
* files

diff --git a/Makefile b/Makefile
index e4e957a..6a12118 100644
--- a/Makefile
+++ b/Makefile
@@ -19,20 +19,23 @@ INCLUDES=-I utils -I parsing -I typing -I bytecomp -I asmcomp -I driver -I tople
 UTILS=utils/misc.cmo utils/tbl.cmo utils/config.cmo \
   utils/clflags.cmo utils/terminfo.cmo
 
-PARSING=parsing/location.cmo parsing/longident.cmo \
+PARSING=parsing/label.cmo parsing/location.cmo parsing/longident.cmo \
   parsing/pstream.cmo parsing/parser.cmo parsing/lexer.cmo parsing/parse.cmo
 
 TYPING=typing/ident.cmo typing/path.cmo \
   typing/primitive.cmo typing/typedtree.cmo \
-  typing/subst.cmo typing/printtyp.cmo \
-  typing/predef.cmo typing/datarepr.cmo typing/env.cmo \
-  typing/ctype.cmo typing/mtype.cmo \
-  typing/includecore.cmo typing/includemod.cmo typing/parmatch.cmo \
+  typing/subst.cmo typing/predef.cmo \
+  typing/datarepr.cmo typing/env.cmo \
+  typing/ctype.cmo typing/printtyp.cmo \
+  typing/mtype.cmo typing/includecore.cmo \
+  typing/includemod.cmo typing/parmatch.cmo \
   typing/typetexp.cmo typing/typecore.cmo \
-  typing/typedecl.cmo typing/typemod.cmo
+  typing/typedecl.cmo typing/typeclass.cmo \
+  typing/typemod.cmo
 
 COMP=bytecomp/lambda.cmo bytecomp/printlambda.cmo \
-  bytecomp/matching.cmo bytecomp/translcore.cmo bytecomp/translmod.cmo \
+  bytecomp/translobj.cmo bytecomp/matching.cmo bytecomp/translcore.cmo \
+  bytecomp/translclass.cmo bytecomp/translmod.cmo \
   bytecomp/simplif.cmo bytecomp/runtimedef.cmo
 



* asmcomp/

diff --git a/asmcomp/clambda.ml b/asmcomp/clambda.ml
index ae5cf62..d640aeb 100644
--- a/asmcomp/clambda.ml
+++ b/asmcomp/clambda.ml
@@ -39,6 +39,7 @@ type ulambda =
   | Uwhile of ulambda * ulambda
   | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
   | Uassign of Ident.t * ulambda
+  | Usend of ulambda * ulambda * ulambda list
 
 and ulambda_switch =
   { us_index_consts: int array;
diff --git a/asmcomp/clambda.mli b/asmcomp/clambda.mli
index ae5cf62..d640aeb 100644
--- a/asmcomp/clambda.mli
+++ b/asmcomp/clambda.mli
@@ -39,6 +39,7 @@ type ulambda =
   | Uwhile of ulambda * ulambda
   | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
   | Uassign of Ident.t * ulambda
+  | Usend of ulambda * ulambda * ulambda list
 
 and ulambda_switch =
   { us_index_consts: int array;
diff --git a/asmcomp/closure.ml b/asmcomp/closure.ml
index f06844e..8dfdad2 100644
--- a/asmcomp/closure.ml
+++ b/asmcomp/closure.ml
@@ -59,6 +59,7 @@ let occurs_var var u =
     | Uwhile(cond, body) -> occurs cond or occurs body
     | Ufor(id, lo, hi, dir, body) -> occurs lo or occurs hi or occurs body
     | Uassign(id, u) -> id = var or occurs u
+    | Usend(met, obj, args) -> List.exists occurs (met::obj::args)
   and occurs_array a =
     try
       for i = 0 to Array.length a - 1 do
@@ -127,6 +128,10 @@ let rec close fenv cenv = function
       | (ufunct, _) ->
           (Ugeneric_apply(ufunct, close_list fenv cenv args), Value_unknown)
       end
+  | Lsend(met, obj, args) ->
+      let (umet, _) = close fenv cenv met in
+      let (uobj, _) = close fenv cenv obj in
+      (Usend(umet, uobj, close_list fenv cenv args), Value_unknown)
   | Llet(str, id, lam, body) ->
       let (ulam, alam) = close_named fenv cenv id lam in
       let (ubody, abody) = close (Tbl.add id alam fenv) cenv body in
@@ -276,6 +276,16 @@ let string_length exp =
               Cop(Cloadchunk Byte_unsigned,
                   [Cop(Cadda, [str; Cvar tmp_var])])])))
 
+(* Message sending *)
+
+let lookup_label obj lab =
+  bind "lab" lab (fun lab ->
+    let table = Cop (Cload typ_addr, [obj]) in
+    let buck_index = Cop(Clsr, [lab; Cconst_int 16]) in
+    let bucket = Cop (Cload typ_addr, [Cop (Cadda, [table; buck_index])]) in
+    let item_index = Cop (Cand, [lab; Cconst_int (255 * size_addr)]) in
+    Cop (Cload typ_addr, [Cop (Cadda, [bucket; item_index])]))
+
 (* To compile "let rec" over values *)
 
 let fundecls_size fundecls =
@@ -397,9 +407,20 @@ let rec transl = function
       Cop(Capply typ_addr,
           Cconst_symbol(apply_function arity) ::
           List.map transl (args @ [clos]))
+  | Usend(met, obj, []) ->
+      bind "obj" (transl obj) (fun obj ->
+      bind "met" (lookup_label obj (transl met)) (fun clos ->
+        Cop(Capply typ_addr, [get_field clos 0; obj; clos])))
+  | Usend(met, obj, args) ->
+      let arity = List.length args + 1 in
+      bind "obj" (transl obj) (fun obj ->
+      bind "met" (lookup_label obj (transl met)) (fun clos ->
+        Cop(Capply typ_addr,
+            Cconst_symbol(apply_function arity) ::
+	    obj :: (List.map transl args) @ [clos])))
   | Ulet(id, exp, body) ->
       if is_unboxed_float exp then begin
-        let unboxed_id = Ident.new (Ident.name id) in
+        let unboxed_id = Ident.create (Ident.name id) in
         let (tr_body, need_boxed, is_assigned) =
           subst_boxed_float id unboxed_id (transl body) in
         if need_boxed & is_assigned then
@@ -817,6 +838,52 @@ let rec transl_all_functions already_translated cont =
   with Queue.Empty ->
     cont
 
+(* Translate a toplevel structure definition *)
+
+let rec transl_structure glob = function
+    Uprim(Pmakeblock(tag, mut), args) ->
+      (* Scan the args, storing those that are not identifiers and
+         returning a hashtable id -> position in block
+         for those that are idents. *)
+      let map = Hashtbl.create 17 in
+      let rec make_stores pos = function
+        [] -> Ctuple []
+      | Uvar v :: rem ->
+          Hashtbl.add map v pos;
+          make_stores (pos+1) rem
+      | ulam :: rem ->
+          Csequence(Cop(Cstore,
+                        [field_address (Cconst_symbol glob) pos; transl ulam]),
+                    make_stores (pos+1) rem) in
+      let c = make_stores 0 args in
+      (c, map, List.length args)
+  | Usequence(e1, e2) ->
+      let (c2, map, size) = transl_structure glob e2 in
+      (Csequence(remove_unit(transl e1), c2), map, size)
+  | Ulet(id, arg, body) ->
+      let (cbody, map, size) = transl_structure glob body in
+      (Clet(id, transl arg, add_store glob id map cbody), map, size)
+  | Uletrec(bindings, body) ->
+      let (cbody, map, size) = transl_structure glob body in
+      (transl_letrec bindings (add_stores glob bindings map cbody), map, size)
+  | Uprim(Psetglobal id, [arg]) ->
+      transl_structure glob arg
+  | _ ->
+      fatal_error "Cmmgen.transl_structure"
+
+and add_store glob id map code =
+  let rec store = function
+    [] -> code
+  | pos :: rem ->
+      Csequence(Cop(Cstore, [field_address (Cconst_symbol glob) pos; Cvar id]),
+                store rem) in
+  store (Hashtbl.find_all map id)
+
+and add_stores glob bindings map code =
+  match bindings with
+    [] -> code
+  | (id, def) :: rem -> add_stores glob rem map (add_store glob id map code) 
+
 (* Emit structured constants *)
 
 let rec emit_constant symb cst cont =


* bytecomp/

diff --git a/bytecomp/bytegen.ml b/bytecomp/bytegen.ml
index cce6e6c..2d84dae 100644
--- a/bytecomp/bytegen.ml
+++ b/bytecomp/bytegen.ml
@@ -169,6 +169,21 @@ let rec comp_expr env exp sz cont =
             (Kpush :: comp_expr env func (sz + 3 + nargs)
                       (Kapply nargs :: cont1))
         end
+  | Lsend(met, obj, args) ->
+      let nargs = List.length args + 1 in
+      if is_tailcall cont then
+        comp_args env (met::obj::args) sz
+          (Kgetmethod :: Kappterm(nargs, sz + nargs) :: discard_dead_code cont)
+      else
+        if nargs < 4 then
+          comp_args env (met::obj::args) sz
+            (Kgetmethod :: Kapply nargs :: cont)
+        else begin
+          let (lbl, cont1) = label_code cont in
+          Kpush_retaddr lbl ::
+          comp_args env (met::obj::args) (sz + 3)
+            (Kgetmethod :: Kapply nargs :: cont1)
+        end
   | Lfunction(params, body) ->
       let lbl = new_label() in
       let fv = IdentSet.elements(free_variables exp) in

 (* Emission of one instruction *)
@@ -234,6 +234,7 @@ let emit_instr = function
   | Kintcomp Cgt -> out opGTINT      | Kintcomp Cge -> out opGEINT
   | Koffsetint n -> out opOFFSETINT; out_int n
   | Koffsetref n -> out opOFFSETREF; out_int n
+  | Kgetmethod -> out opGETMETHOD
   | Kstop -> out opSTOP
 
 (* Emission of a list of instructions. Include some peephole optimization. *)
diff --git a/bytecomp/instruct.ml b/bytecomp/instruct.ml
index 0aad1d0..8c3539a 100644
--- a/bytecomp/instruct.ml
+++ b/bytecomp/instruct.ml
@@ -60,6 +60,7 @@ type instruction =
   | Kintcomp of comparison
   | Koffsetint of int
   | Koffsetref of int
+  | Kgetmethod
   | Kstop
 
 let immed_min = -0x40000000
diff --git a/bytecomp/instruct.mli b/bytecomp/instruct.mli
index 1c122eb..2f1043d 100644
--- a/bytecomp/instruct.mli
+++ b/bytecomp/instruct.mli
@@ -62,6 +62,7 @@ type instruction =
   | Kintcomp of comparison
   | Koffsetint of int
   | Koffsetref of int
+  | Kgetmethod
   | Kstop
 
 val immed_min: int
diff --git a/bytecomp/lambda.ml b/bytecomp/lambda.ml
index 56c3192..1c119ab 100644
--- a/bytecomp/lambda.ml
+++ b/bytecomp/lambda.ml
@@ -69,7 +69,9 @@ type structured_constant =
   | Const_block of int * structured_constant list
   | Const_float_array of string list
 
-type let_kind = Strict | Alias
+type let_kind = Strict | Alias | StrictOpt
+
+type shared_code = (int * int) list
 
 type lambda =
     Lvar of Ident.t
@@ -88,6 +90,7 @@ type lambda =
   | Lwhile of lambda * lambda
   | Lfor of Ident.t * lambda * lambda * direction_flag * lambda
   | Lassign of Ident.t * lambda
+  | Lsend of lambda * lambda * lambda list
 
 and lambda_switch =
   { sw_numconsts: int;
@@ -159,6 +162,8 @@ let free_variables l =
       freevars e1; freevars e2; freevars e3; fv := IdentSet.remove v !fv
   | Lassign(id, e) ->
       fv := IdentSet.add id !fv; freevars e
+  | Lsend (met, obj, args) ->
+      List.iter freevars (met::obj::args)
   in freevars l; !fv
 
 (* Check if an action has a "when" guard *)
diff --git a/bytecomp/lambda.mli b/bytecomp/lambda.mli
index b12ed97..6ea5baf 100644
--- a/bytecomp/lambda.mli
+++ b/bytecomp/lambda.mli
@@ -69,7 +69,9 @@ type structured_constant =
   | Const_block of int * structured_constant list
   | Const_float_array of string list
 
-type let_kind = Strict | Alias
+type let_kind = Strict | Alias | StrictOpt
+
+type shared_code = (int * int) list     (* stack size -> code label *)
 
 type lambda =
     Lvar of Ident.t
@@ -88,6 +90,7 @@ type lambda =
   | Lwhile of lambda * lambda
   | Lfor of Ident.t * lambda * lambda * direction_flag * lambda
   | Lassign of Ident.t * lambda
+  | Lsend of lambda * lambda * lambda list
 
 and lambda_switch =
   { sw_numconsts: int;                  (* Number of integer cases *)
diff --git a/bytecomp/matching.ml b/bytecomp/matching.ml
index c521790..7123e41 100644
--- a/bytecomp/matching.ml
+++ b/bytecomp/matching.ml
@@ -166,7 +166,7 @@ let make_record_matching all_labels = function
           let str =
             match lbl.lbl_mut with
               Immutable -> Alias
-            | Mutable -> Strict in
+            | Mutable -> StrictOpt in
           (Lprim(access, [arg]), str) :: make_args(pos + 1)
         end in
       {cases = []; args = make_args 0}
diff --git a/bytecomp/printinstr.ml b/bytecomp/printinstr.ml
index cb4e48a..eac2b5f 100644
--- a/bytecomp/printinstr.ml
+++ b/bytecomp/printinstr.ml
@@ -93,6 +93,7 @@ let instruction = function
   | Kintcomp Cge -> print_string "\tgeint"
   | Koffsetint n -> print_string "\toffsetint "; print_int n
   | Koffsetref n -> print_string "\toffsetref "; print_int n
+  | Kgetmethod -> print_string "\tgetmethod"
   | Kstop -> print_string "\tstop"
 
 let rec instruction_list = function
diff --git a/bytecomp/printlambda.ml b/bytecomp/printlambda.ml
index d90d8f2..dabc6e3 100644
--- a/bytecomp/printlambda.ml
+++ b/bytecomp/printlambda.ml
@@ -237,6 +237,14 @@ let rec lambda = function
       Ident.print id; print_space();
       lambda expr; print_string ")";
       close_box()
+  | Lsend (met, obj, largs) ->
+      open_hovbox 2;
+      print_string "(send"; print_space();
+      lambda obj; print_space();
+      lambda met;
+      List.iter (fun l -> print_space(); lambda l) largs;
+      print_string ")";
+      close_box()
 
 and sequence = function
     Lsequence(l1, l2) ->
diff --git a/bytecomp/simplif.ml b/bytecomp/simplif.ml
index 8671e3a..177f19b 100644
--- a/bytecomp/simplif.ml
+++ b/bytecomp/simplif.ml
@@ -72,6 +72,9 @@ let rec eliminate_ref id = function
            dir, eliminate_ref id e3)
   | Lassign(v, e) ->
       Lassign(v, eliminate_ref id e)
+  | Lsend(m, o, el) ->
+      Lsend(eliminate_ref id m, eliminate_ref id o,
+            List.map (eliminate_ref id) el)
 
 (* Simplification of lets *)
 
@@ -126,6 +129,7 @@ let simplify_lambda lam =
       (* Lalias-bound variables are never assigned, so don't increase
          v's refcount *)
       count l
+  | Lsend(m, o, ll) -> List.iter count (m::o::ll)
   in
   count lam;
   (* Second pass: remove Lalias bindings of unused variables,
@@ -159,6 +163,11 @@ let simplify_lambda lam =
       | 1 -> Hashtbl.add subst v (simplif l1); simplif l2
       | n -> Llet(Alias, v, simplif l1, simplif l2)
       end
+  | Llet(StrictOpt, v, l1, l2) ->
+      begin match count_var v with
+        0 -> simplif l2
+      | n -> Llet(Alias, v, simplif l1, simplif l2)
+      end
   | Lletrec(bindings, body) ->
       Lletrec(List.map (fun (v, l) -> (v, simplif l)) bindings, simplif body)
   | Lprim(p, ll) -> Lprim(p, List.map simplif ll)
@@ -178,8 +187,6 @@ let simplify_lambda lam =
   | Lfor(v, l1, l2, dir, l3) ->
       Lfor(v, simplif l1, simplif l2, dir, simplif l3)
   | Lassign(v, l) -> Lassign(v, simplif l)
+  | Lsend(m, o, ll) -> Lsend(simplif m, simplif o, List.map simplif ll)
   in
   simplif lam
-
-    
-    
diff --git a/bytecomp/symtable.ml b/bytecomp/symtable.ml
index ef7d0fe..431fd42 100644
diff --git a/bytecomp/translclass.ml b/bytecomp/translclass.ml
new file mode 100644
index 0000000..4b76396
--- /dev/null
+++ b/bytecomp/translclass.ml
@@ -0,0 +1,11 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                         Caml Special Light                          *)
+(*                                                                     *)
+(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  Automatique.  Distributed only by permission.                      *)
+(*                                                                     *)
+(***********************************************************************)
+
...

diff --git a/bytecomp/translcore.ml b/bytecomp/translcore.ml
index d89ec8f..07ad56c 100644
--- a/bytecomp/translcore.ml
+++ b/bytecomp/translcore.ml
@@ -20,11 +20,12 @@ open Primitive
 open Path
 open Typedtree
 open Lambda
-
+open Translobj
 
 type error =
     Illegal_letrec_pat
   | Illegal_letrec_expr
+  | Free_super_var
 
 exception Error of Location.t * error
 
@@ -139,8 +140,8 @@ let primitives_table = create_hashtable 31 [
 ]
 
 let same_base_type ty1 ty2 =
-  match (Ctype.repr ty1, Ctype.repr ty2) with
-    (Tconstr(p1, []), Tconstr(p2, [])) -> Path.same p1 p2
+  match ((Ctype.repr ty1).desc, (Ctype.repr ty2).desc) with
+    (Tconstr(p1, [], _), Tconstr(p2, [], _)) -> Path.same p1 p2
   | (_, _) -> false
 
 let maybe_pointer arg =
@@ -148,11 +149,11 @@ let maybe_pointer arg =
       same_base_type arg.exp_type Predef.type_char)
 
 let array_kind arg =
-  match Ctype.repr arg.exp_type with
-    Tconstr(p, [ty]) when Path.same p Predef.path_array ->
-      begin match Ctype.repr ty with
-        Tvar v -> Pgenarray
-      | Tconstr(p, _) ->
+  match (Ctype.repr arg.exp_type).desc with
+    Tconstr(p, [ty], _) when Path.same p Predef.path_array ->
+      begin match (Ctype.repr ty).desc with
+        Tvar -> Pgenarray
+      | Tconstr(p, _, _) ->
           if Path.same p Predef.path_int or Path.same p Predef.path_char then
             Pintarray
           else if Path.same p Predef.path_float then
@@ -263,8 +264,10 @@ let rec name_pattern default = function
 
 let rec transl_exp e =
   match e.exp_desc with
-    Texp_ident(path, {val_prim = Some p}) ->
+    Texp_ident(path, {val_kind = Val_prim p}) ->
       transl_primitive p
+  | Texp_ident(path, {val_kind = Val_anc _}) ->
+      raise(Error(e.exp_loc, Free_super_var))
   | Texp_ident(path, desc) ->
       transl_path path
   | Texp_constant cst ->
@@ -274,11 +277,18 @@ let rec transl_exp e =
   | Texp_function pat_expr_list ->
       let (params, body) = transl_function e.exp_loc pat_expr_list in
       Lfunction(params, body)
-  | Texp_apply({exp_desc = Texp_ident(path, {val_prim = Some p})}, args)
+  | Texp_apply({exp_desc = Texp_ident(path, {val_kind = Val_prim p})}, args)
     when List.length args = p.prim_arity ->
       Lprim(transl_prim p args, transl_list args)
   | Texp_apply(funct, args) ->
-      Lapply(transl_exp funct, transl_list args)
+      begin match transl_exp funct with
+        Lapply(lfunct, largs) ->
+          Lapply(lfunct, largs @ transl_list args)
+      | Lsend(lmet, lobj, largs) ->
+          Lsend(lmet, lobj, largs @ transl_list args)
+      | lexp ->
+          Lapply(lexp, transl_list args)
+      end
   | Texp_match({exp_desc = Texp_tuple argl} as arg, pat_expr_list) ->
       Matching.for_multiple_match e.exp_loc
         (transl_list argl) (transl_cases pat_expr_list)
@@ -379,6 +389,23 @@ let rec transl_exp e =
       Lfor(param, transl_exp low, transl_exp high, dir, transl_exp body)
   | Texp_when(cond, body) ->
       Lifthenelse(transl_exp cond, transl_exp body, Lstaticfail)
+  | Texp_send(expr, met) ->
+      Lsend(Lvar (meth met), transl_exp expr, [])
+  | Texp_new cl ->
+      Lprim(Pfield 0, [transl_path cl])
+  | Texp_instvar(path_self, path) ->
+      Lprim(Parrayrefu Paddrarray , [transl_path path_self; transl_path path])
+  | Texp_setinstvar(path_self, path, expr) ->
+      transl_setinstvar (transl_path path_self) path expr
+  | Texp_override(path_self, modifs) ->
+      let cpy = Ident.create "copy" in
+      Llet(Strict, cpy, Lapply(oo_prim "copy", [transl_path path_self]),
+      List.fold_right
+      	(fun (path, expr) rem ->
+	   Lsequence(transl_setinstvar (Lvar cpy) path expr,
+	             rem))
+	modifs
+	(Lvar cpy))
   | _ ->
       fatal_error "Translcore.transl"
 
@@ -419,6 +446,10 @@ and transl_let rec_flag pat_expr_list body =
         (id, lam) in
       Lletrec(List.map transl_case pat_expr_list, body)
 
+and transl_setinstvar self var expr =
+  Lprim(Parraysetu (if maybe_pointer expr then Paddrarray else Pintarray),
+                    [self; transl_path var; transl_exp expr])
+
 (* Compile an exception definition *)
 
 let transl_exception id decl =
@@ -436,3 +467,6 @@ let report_error = function
   | Illegal_letrec_expr ->
       print_string
       "This kind of expression is not allowed as right-hand side of `let rec'"
+  | Free_super_var ->
+      print_string
+        "Ancestor names can only be used to select inherited methods"
diff --git a/bytecomp/translcore.mli b/bytecomp/translcore.mli
index fbaa50a..20ffd18 100644
--- a/bytecomp/translcore.mli
+++ b/bytecomp/translcore.mli
@@ -18,6 +18,9 @@ open Asttypes
 open Typedtree
 open Lambda
 
+val name_pattern: string -> (Typedtree.pattern * 'a) list -> Ident.t
+val maybe_pointer: expression -> bool
+
 val transl_exp: expression -> lambda
 val transl_let:
       rec_flag -> (pattern * expression) list -> lambda -> lambda
@@ -27,9 +30,8 @@ val transl_exception: Ident.t -> exception_declaration -> lambda
 type error =
     Illegal_letrec_pat
   | Illegal_letrec_expr
+  | Free_super_var
 
 exception Error of Location.t * error
 
 val report_error: error -> unit
-
-
diff --git a/bytecomp/translmod.ml b/bytecomp/translmod.ml
index 7c20a71..d90e664 100644
--- a/bytecomp/translmod.ml
+++ b/bytecomp/translmod.ml
@@ -18,8 +18,9 @@ open Misc
 open Asttypes
 open Typedtree
 open Lambda
+open Translobj
 open Translcore
-
+open Translclass
 
 (* Compile a coercion *)
 
@@ -119,10 +120,10 @@ and transl_structure fields cc = function
       let ext_fields = rev_let_bound_idents pat_expr_list @ fields in
       transl_let rec_flag pat_expr_list (transl_structure ext_fields cc rem)
   | Tstr_primitive(id, descr) :: rem ->
-      begin match descr.val_prim with
-        None -> ()
-      | Some p -> primitive_declarations :=
-                    p.Primitive.prim_name :: !primitive_declarations
+      begin match descr.val_kind with
+        Val_prim p -> primitive_declarations :=
+                        p.Primitive.prim_name :: !primitive_declarations
+      | _ -> ()
       end;
       transl_structure fields cc rem
   | Tstr_type(decls) :: rem ->
@@ -137,13 +138,20 @@ and transl_structure fields cc = function
       transl_structure fields cc rem
   | Tstr_open path :: rem ->
       transl_structure fields cc rem
+  | Tstr_class cl_list :: rem ->
+      List.fold_right
+      	(fun (id, cl) re ->
+	   Llet(Strict, id, transl_class cl, re))
+	cl_list
+	(transl_structure ((List.map fst cl_list) @ fields) cc rem)
 
 (* Compile an implementation *)
 
 let transl_implementation module_name str cc =
+  reset_labels ();
   primitive_declarations := [];
-  let module_id = Ident.new_persistent module_name in
-  Lprim(Psetglobal module_id, [transl_structure [] cc str])
+  let module_id = Ident.create_persistent module_name in
+  Lprim(Psetglobal module_id, [transl_label_init (transl_structure [] cc str)])
 
 (* A variant of transl_structure used to compile toplevel structure definitions
    for the native-code compiler. Store the defined values in the fields
@@ -163,10 +171,10 @@ let transl_store_structure glob map prims str =
         (store_idents glob map (let_bound_idents pat_expr_list)
           (transl_store rem))
   | Tstr_primitive(id, descr) :: rem ->
-      begin match descr.val_prim with
-        None -> ()
-      | Some p -> primitive_declarations :=
-                    p.Primitive.prim_name :: !primitive_declarations
+      begin match descr.val_kind with
+        Val_prim p -> primitive_declarations :=
+                        p.Primitive.prim_name :: !primitive_declarations
+      | _ -> ()
       end;
       transl_store rem
   | Tstr_type(decls) :: rem ->
@@ -181,6 +189,12 @@ let transl_store_structure glob map prims str =
       transl_store rem
   | Tstr_open path :: rem ->
       transl_store rem
+  | Tstr_class cl_list :: rem ->
+      List.fold_right
+      	(fun (id, cl) re ->
+	   Llet(Strict, id, transl_class cl, re))
+	cl_list
+	(store_idents glob map (List.map fst cl_list) (transl_store rem))
 
   and store_ident glob map id cont =
     try
@@ -215,6 +229,8 @@ let rec defined_idents = function
   | Tstr_module(id, modl) :: rem -> id :: defined_idents rem
   | Tstr_modtype(id, decl) :: rem -> defined_idents rem
   | Tstr_open path :: rem -> defined_idents rem
+  | Tstr_class cl_list :: rem ->
+      List.map fst cl_list @ defined_idents rem
 
 (* Transform a coercion and the list of value identifiers built above
    into a table id -> (pos, coercion), with [pos] being the position
@@ -253,17 +269,19 @@ let build_ident_map restr idlist =
    (for the native-code compiler). *)
 
 let transl_store_implementation module_name str restr =
+  reset_labels ();
   primitive_declarations := [];
-  let module_id = Ident.new_persistent module_name in
+  let module_id = Ident.create_persistent module_name in
   let (map, prims, size) = build_ident_map restr (defined_idents str) in
-  (size, transl_store_structure module_id map prims str)
+  (size, transl_label_init (transl_store_structure module_id map prims str))
 
 (* Compile a sequence of expressions *)
 
 let rec make_sequence fn = function
     [] -> lambda_unit
   | [x] -> fn x
-  | x::rem -> Lsequence(fn x, make_sequence fn rem)
+  | x::rem ->
+      Lsequence(fn x, make_sequence fn rem)
 
 (* Compile a toplevel phrase *)
 
@@ -291,6 +309,12 @@ let transl_toplevel_item = function
       lambda_unit
   | Tstr_open path ->
       lambda_unit
+  | Tstr_class cl_list ->
+      List.iter (fun (id, cl) -> Ident.make_global id) cl_list;
+      make_sequence
+        (fun (id, cl) -> Lprim(Psetglobal id, [transl_class cl]))
+	cl_list
 
 let transl_toplevel_definition str =
-  make_sequence transl_toplevel_item str
+  reset_labels ();
+  transl_label_init (make_sequence transl_toplevel_item str)
diff --git a/bytecomp/translobj.ml b/bytecomp/translobj.ml
new file mode 100644
index 0000000..6827303
--- /dev/null
+++ b/bytecomp/translobj.ml
@@ -0,0 +1,11 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                         Caml Special Light                          *)
+(*                                                                     *)
+(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  Automatique.  Distributed only by permission.                      *)
+(*                                                                     *)
+(***********************************************************************)

* byterun/

diff --git a/byterun/instruct.h b/byterun/instruct.h
index 5f80cd7..98a36f1 100644
--- a/byterun/instruct.h
+++ b/byterun/instruct.h
@@ -42,5 +42,6 @@ enum instructions {
   ANDINT, ORINT, XORINT, LSLINT, LSRINT, ASRINT,
   EQ, NEQ, LTINT, LEINT, GTINT, GEINT,
   OFFSETINT, OFFSETREF,
+  GETMETHOD,
   STOP
 };




diff --git a/byterun/interp.c b/byterun/interp.c
index e8b4418..ba4cde9 100644
--- a/byterun/interp.c
+++ b/byterun/interp.c
@@ -826,6 +826,16 @@ value interprete(prog, prog_size)
       pc++;
       Next;
 
+/* Object-oriented operations */
+
+#define Lookup(obj, lab) \
+  Field (Field (Field (obj, 0), ((lab) >> 16) / sizeof (value)), \
+	 ((lab) / sizeof (value)) & 0xFF)
+
+    Instruct(GETMETHOD):
+      accu = Lookup(sp[0], accu);
+      Next;
+
 /* Machine control */
 
     Instruct(STOP):


* driver/

diff --git a/driver/compile.ml b/driver/compile.ml
index e15022d..1341153 100644
--- a/driver/compile.ml
+++ b/driver/compile.ml
@@ -85,7 +85,7 @@ let implementation sourcefile =
         (Includemod.compunit sourcefile sg intf_file dclsig, crc)
       end else begin
         let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
-        Typemod.check_nongen_schemes str;
+        Typemod.check_nongen_schemes finalenv str;
         (Tcoerce_none, crc)
       end in
     Emitcode.to_file oc modulename crc
diff --git a/driver/errors.ml b/driver/errors.ml
index 28d1846..add586a 100644
--- a/driver/errors.ml
+++ b/driver/errors.ml
@@ -49,6 +49,8 @@ let report_error exn =
       Bytelibrarian.report_error code
   | Sys_error msg ->
       print_string "I/O error: "; print_string msg
+  | Typeclass.Error(loc, err) ->
+      Location.print loc; Typeclass.report_error err
   | x ->
       close_box(); raise x
   end;
diff --git a/driver/optcompile.ml b/driver/optcompile.ml
index f055b53..ef54574 100644
--- a/driver/optcompile.ml
+++ b/driver/optcompile.ml
@@ -82,7 +82,7 @@ let implementation sourcefile =
         (Includemod.compunit sourcefile sg intf_file dclsig, crc)
       end else begin
         let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
-        Typemod.check_nongen_schemes str;
+        Typemod.check_nongen_schemes finalenv str;
         (Tcoerce_none, crc)
       end in
     Compilenv.reset modulename crc;
diff --git a/driver/opterrors.ml b/driver/opterrors.ml
index 23d15ae..bfddf14 100644
--- a/driver/opterrors.ml
+++ b/driver/opterrors.ml
@@ -51,6 +51,8 @@ let report_error exn =
       Asmlibrarian.report_error code
   | Sys_error msg ->
       print_string "I/O error: "; print_string msg
+  | Typeclass.Error(loc, err) ->
+      Location.print loc; Typeclass.report_error err
   | x ->
       close_box(); raise x
   end;


* parsing/

** ast

--- a/parsing/asttypes.mli
+++ b/parsing/asttypes.mli
@@ -23,6 +23,10 @@ type rec_flag = Nonrecursive | Recursive
 
 type direction_flag = Upto | Downto
 
+type private_flag = Private | Public
+
 type mutable_flag = Immutable | Mutable
 
+type virtual_flag = Virtual | Concrete
 
+type closed_flag = Open | Closed
diff --git a/parsing/label.ml b/parsing/label.ml
new file mode 100644
index 0000000..dd9fd30
--- /dev/null
+++ b/parsing/label.ml
@@ -0,0 +1,10 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                         Caml Special Light                          *)
+(*                                                                     *)
+(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  Automatique.  Distributed only by permission.                      *)
+(*                                                                     *)
+(***********************************************************************)


** AST bis

diff --git a/parsing/parsetree.mli b/parsing/parsetree.mli
index bcfdb9f..ea8356a 100644
--- a/parsing/parsetree.mli
+++ b/parsing/parsetree.mli
@@ -25,7 +25,17 @@ and core_type_desc =
     Ptyp_var of string
   | Ptyp_arrow of core_type * core_type
   | Ptyp_tuple of core_type list
-  | Ptyp_constr of Longident.t * core_type list
+  | Ptyp_constr of Longident.t * core_type list * string option
+  | Ptyp_object of core_field_type list * string option
+  | Ptyp_class of Longident.t * core_type list * string option
+
+and core_field_type =
+  { pfield_desc: core_field_desc;
+    pfield_loc: Location.t }
+
+and core_field_desc =
+    Pfield of Label.t * core_type
+  | Pfield_var
 
 (* Value expressions for the core language *)
 
@@ -66,8 +76,12 @@ and expression_desc =
   | Pexp_sequence of expression * expression
   | Pexp_while of expression * expression
   | Pexp_for of string * expression * expression * direction_flag * expression
-  | Pexp_constraint of expression * core_type
+  | Pexp_constraint of expression * core_type option * core_type option
   | Pexp_when of expression * expression
+  | Pexp_send of expression * Label.t
+  | Pexp_new of Longident.t
+  | Pexp_setinstvar of Label.t * expression
+  | Pexp_override of (Label.t * expression) list
 
 (* Value descriptions *)
 
@@ -90,6 +104,46 @@ and type_kind =
 
 type exception_declaration = core_type list
 
+(* Type expressions for the class language *)
+
+type class_type_field =
+    Pctf_inher of (Longident.t * core_type list * Location.t)
+  | Pctf_val of
+      (Label.t * private_flag * mutable_flag * core_type option * Location.t)
+  | Pctf_virt of (Label.t * core_type * Location.t)
+  | Pctf_meth of (Label.t * core_type * Location.t)
+
+type class_type =
+  { pcty_name: string;
+    pcty_param: string list;
+    pcty_args: core_type list;
+    pcty_self: string option;
+    pcty_cstr: (string * core_type * Location.t) list;
+    pcty_field: class_type_field list;
+    pcty_kind: virtual_flag;
+    pcty_closed: closed_flag;
+    pcty_loc: Location.t }
+
+type class_field =
+    Pcf_inher of (Longident.t * core_type list * expression list *
+      	       	  string option * Location.t)
+  | Pcf_val of
+      (Label.t * private_flag * mutable_flag * expression option * Location.t)
+  | Pcf_virt of (Label.t * core_type * Location.t)
+  | Pcf_meth of (Label.t * expression * Location.t)
+
+type class_def =
+  { pcl_name: string;
+    pcl_param: string list;
+    pcl_args: pattern list;
+    pcl_self: string option;
+    pcl_self_ty: string option;
+    pcl_cstr: (string * core_type * Location.t) list;
+    pcl_field: class_field list;
+    pcl_kind: virtual_flag;
+    pcl_closed: closed_flag;
+    pcl_loc: Location.t }
+
 (* Type expressions for the module language *)
 
 type module_type =
@@ -116,6 +170,7 @@ and signature_item_desc =
   | Psig_modtype of string * modtype_declaration
   | Psig_open of Longident.t
   | Psig_include of module_type
+  | Psig_class of class_type list
 
 and modtype_declaration =
     Pmodtype_abstract
@@ -153,6 +208,7 @@ and structure_item_desc =
   | Pstr_module of string * module_expr
   | Pstr_modtype of string * module_type
   | Pstr_open of Longident.t
+  | Pstr_class of class_def list
 
 (* Toplevel phrases *)


** tools/


diff --git a/tools/cslprof.ml b/tools/cslprof.ml
index df5a283..98dffd3 100644
--- a/tools/cslprof.ml
@@ -203,13 +203,24 @@ and rewrite_exp sexp =
     if !instr_loops then insert_profile sbody.pexp_loc;
     rewrite_exp sbody
 
-  | Pexp_constraint(sarg, _) ->
+  | Pexp_constraint(sarg, _, _) ->
     rewrite_exp sarg
 
   | Pexp_when(scond, sbody) ->
     rewrite_exp scond;
     rewrite_exp sbody
-      
+
+  | Pexp_send (sobj, _) ->
+    rewrite_exp sobj
+
+  | Pexp_new _ -> ()
+
+  | Pexp_setinstvar (_, sarg) ->
+    rewrite_exp sarg
+
+  | Pexp_override l ->
+      List.iter (fun (_, sexp) -> rewrite_exp sexp) l
+
 and rewrite_ifbody sifbody =
   if !instr_if then begin
     insert_open sifbody.pexp_loc;
@@ -243,6 +254,18 @@ and rewrite_funmatching l =
 and rewrite_trymatching l =
   rewrite_annotate_exp_list (List.map snd l)
 
+(* Rewrite a class definition *)
+
+let rewrite_class_field =
+  function
+    Pcf_inher (_, _, l, _, _) -> List.iter rewrite_exp l
+  | Pcf_val (_, _, _, Some exp, _) -> rewrite_exp exp
+  | Pcf_val (_, _, _, None, _) | Pcf_virt _ -> ()
+  | Pcf_meth (_, exp, _) -> rewrite_exp exp
+
+let rewrite_class cl =
+  List.iter rewrite_class_field cl.pcl_field
+
 (* Rewrite a module expression or structure expression *)
 
 let rec rewrite_mod smod =
@@ -258,6 +281,7 @@ and rewrite_str_item item =
     Pstr_eval exp -> rewrite_exp exp
   | Pstr_value(_, exps) -> List.iter (function (_,exp) -> rewrite_exp exp) exps
   | Pstr_module(name, smod) -> rewrite_mod smod
+  | Pstr_class classes -> List.iter rewrite_class classes
   | _ -> ()
 
 (* Rewrite a .ml file *)


** toplevel/

diff --git a/toplevel/printval.ml b/toplevel/printval.ml
index 0048ec5..b6c02b4 100644
--- a/toplevel/printval.ml
+++ b/toplevel/printval.ml
@@ -13,6 +13,7 @@
 
 (* To print values *)
 
+open Misc
 open Obj
 open Format
 open Longident
@@ -100,8 +101,8 @@ let print_qualified lookup_fun env ty_path name =
       print_string name
   | Pdot(p, s, pos) ->
       if try
-           match lookup_fun (Lident name) env with
-             Tconstr(ty_path', _) -> Path.same ty_path ty_path'
+           match (lookup_fun (Lident name) env).desc with
+             Tconstr(ty_path', _, _) -> Path.same ty_path ty_path'
            | _ -> false
          with Not_found -> false
       then print_string name
@@ -132,8 +133,8 @@ let print_value env obj ty =
     try
       find_printer env ty obj; ()
     with Not_found ->
-      match Ctype.repr ty with
-        Tvar _ ->
+      match (Ctype.repr ty).desc with
+        Tvar ->
           print_string "<poly>"
       | Tarrow(ty1, ty2) ->
           print_string "<fun>"
@@ -144,14 +145,14 @@ let print_value env obj ty =
           print_val_list 1 depth obj ty_list;
           if prio > 0 then print_string ")";
           close_box()
-      | Tconstr(path, []) when Path.same path Predef.path_exn ->
+      | Tconstr(path, [], _) when Path.same path Predef.path_exn ->
           if prio > 1
           then begin open_hovbox 2; print_string "(" end
           else open_hovbox 1;
           print_exception obj;
           if prio > 1 then print_string ")";
           close_box()
-      | Tconstr(path, [ty_arg]) when Path.same path Predef.path_list ->
+      | Tconstr(path, [ty_arg], _) when Path.same path Predef.path_list ->
           let rec print_conses depth cons =
             if Obj.is_block cons then begin
               print_val 0 (depth - 1) (Obj.field cons 0) ty_arg;
@@ -166,7 +167,7 @@ let print_value env obj ty =
           cautious (print_conses depth) obj;
           print_string "]";
           close_box()
-      | Tconstr(path, [ty_arg]) when Path.same path Predef.path_array ->
+      | Tconstr(path, [ty_arg], _) when Path.same path Predef.path_array ->
           let rec print_items depth i =
             if i < Obj.size obj then begin
               if i > 0 then begin print_string ";"; print_space() end;
@@ -178,7 +179,7 @@ let print_value env obj ty =
           cautious (print_items depth) 0;
           print_string "|]";
           close_box()
-      | Tconstr(path, ty_list) ->
+      | Tconstr(path, ty_list, _) ->
           begin try
             let decl = Env.find_type path env in
             match decl with
@@ -186,7 +187,7 @@ let print_value env obj ty =
                 print_string "<abstr>"
             | {type_kind = Type_abstract; type_manifest = Some body} ->
                 print_val prio depth obj
-                          (Ctype.substitute decl.type_params ty_list body)
+                          (Ctype.substitute [] decl.type_params ty_list body)
             | {type_kind = Type_variant constr_list} ->
                 let tag =
                   if Obj.is_block obj
@@ -195,7 +196,7 @@ let print_value env obj ty =
                 let (constr_name, constr_args) =
                   find_constr tag 0 0 constr_list in
                 let ty_args =
-                  List.map (Ctype.substitute decl.type_params ty_list)
+                  List.map (Ctype.substitute [] decl.type_params ty_list)
                       constr_args in
                 begin match ty_args with
                   [] ->
@@ -232,7 +233,7 @@ let print_value env obj ty =
                     print_label env path lbl_name;
                     print_string "="; print_cut();
                     let ty_arg =
-                      Ctype.substitute decl.type_params ty_list lbl_arg in
+                      Ctype.substitute [] decl.type_params ty_list lbl_arg in
                     cautious (print_val 0 (depth - 1) (Obj.field obj pos))
                              ty_arg;
                     close_box();
@@ -248,6 +249,10 @@ let print_value env obj ty =
           | Constr_not_found ->         (* raised by find_constr *)
               print_string "<unknown constructor>"
           end
+      | Tobject (_, _) ->
+      	  print_string "<obj>"
+      | Tfield(_, _, _) | Tnil | Tlink _ ->
+      	  fatal_error "Printval.print_value"
 
   and print_val_list prio depth obj ty_list =
     let rec print_list depth i = function
diff --git a/toplevel/topdirs.ml b/toplevel/topdirs.ml
index f72a4da..8b862ca 100644
--- a/toplevel/topdirs.ml
+++ b/toplevel/topdirs.ml
@@ -149,8 +149,8 @@ let find_printer_type lid =
     let (path, desc) = Env.lookup_value lid !toplevel_env in
     Ctype.begin_def();
     let ty_arg = Ctype.newvar() in
-    Ctype.unify !toplevel_env (Tarrow(ty_arg, Predef.type_unit))
-                               (Ctype.instance desc.val_type);
+    Ctype.unify !toplevel_env (Ctype.newty (Tarrow(ty_arg, Predef.type_unit)))
+                              (Ctype.instance desc.val_type);
     Ctype.end_def();
     Ctype.generalize ty_arg;
     (ty_arg, path)
@@ -218,16 +218,16 @@ let dir_trace lid =
         overwrite_closure clos
          (Obj.repr (fun arg -> Trace.print_trace (current_environment()) arg));
         (* Warn if this is a primitive *)
-        match desc.val_prim with
-          None ->
-            Printtyp.longident lid; print_string " is now traced.";
-            print_newline()
-        | Some p ->
+        match desc.val_kind with
+          Val_prim p ->
             open_hovbox 0;
             print_string "Warning: "; Printtyp.longident lid;
             print_string " is an external function."; print_space();
             print_string "Inlined calls will not be traced.";
             close_box(); print_newline()
+        | _ ->
+            Printtyp.longident lid; print_string " is now traced.";
+            print_newline()
       end else begin
         Printtyp.longident lid; print_string " is not a function.";
         print_newline()
diff --git a/toplevel/toploop.ml b/toplevel/toploop.ml
index e019abf..4fdfb54 100644
--- a/toplevel/toploop.ml
+++ b/toplevel/toploop.ml
@@ -61,21 +61,23 @@ let load_lambda lam =
 
 (* Print the outcome of an evaluation *)
 
+let hidden = ref 0
+
 let print_item env = function
     Tsig_value(id, decl) ->
       open_hovbox 2;
-      begin match decl.val_prim with
-        None ->
+      begin match decl.val_kind with
+        Val_prim p ->
+          print_string "external "; Printtyp.ident id;
+          print_string " :"; print_space();
+          Printtyp.type_scheme decl.val_type; print_space();
+          print_string "= "; Primitive.print_description p
+      | _ ->
           print_string "val "; Printtyp.ident id;
           print_string " :"; print_space();
           Printtyp.type_scheme decl.val_type;
           print_string " ="; print_space();
           print_value env (Symtable.get_global_value id) decl.val_type
-      | Some p ->
-          print_string "external "; Printtyp.ident id;
-          print_string " :"; print_space();
-          Printtyp.type_scheme decl.val_type; print_space();
-          print_string "= "; Primitive.print_description p
       end;
       close_box()
   | Tsig_type(id, decl) ->
@@ -87,6 +89,9 @@ let print_item env = function
       print_string " :"; print_space(); Printtyp.modtype mty; close_box()
   | Tsig_modtype(id, decl) ->
       Printtyp.modtype_declaration id decl
+  | Tsig_class(id, decl) ->
+      hidden := 2;
+      Printtyp.class_type id decl
 
 (* Print an exception produced by an evaluation *)
 
@@ -132,7 +137,12 @@ let execute_phrase phr =
               print_newline()
           | _ ->
               open_vbox 0;
-              List.iter (fun item -> print_item newenv item; print_space()) sg;
+	      hidden := 0;
+              List.iter
+                (fun item ->
+		   if !hidden > 0 then decr hidden
+      	       	   else begin print_item newenv item; print_space() end)
+      	        sg;
               close_box();
               print_flush()
           end;
diff --git a/toplevel/trace.ml b/toplevel/trace.ml
index c677b57..f9d9ed1 100644
--- a/toplevel/trace.ml
+++ b/toplevel/trace.ml
@@ -53,7 +53,7 @@ let overwrite_closure dst src =
    traces its execution. *)
 
 let rec instrument_closure name clos_typ =
-  match Ctype.repr clos_typ with
+  match (Ctype.repr clos_typ).desc with
     Tarrow(t1, t2) ->
       let starred_name =
         match name with


** typing (BIG)

diff --git a/typing/ctype.ml b/typing/ctype.ml
index 4870cd0..549e2db 100644
--- a/typing/ctype.ml
+++ b/typing/ctype.ml
@@ -14,85 +14,242 @@
 (* Operations on core types *)
 
 open Misc
-open Path
+open Asttypes
 open Typedtree
 
 exception Unify
 
 let current_level = ref 0
-
+let global_level = ref 1
 let generic_level = (-1)
 
-let reset_def () = current_level := 0
 let begin_def () = incr current_level
 let end_def () = decr current_level
 
-let newvar () =
-  Tvar { tvar_level = !current_level; tvar_link = None }
+let reset_global_level () =
+  global_level := !current_level + 1
 
-let new_global_var () =
-  Tvar { tvar_level = 1; tvar_link = None }
+let newty desc         = { desc = desc; level = !current_level }
+let new_global_ty desc = { desc = desc; level = !global_level }
+let newgenty desc      = { desc = desc; level = generic_level }
+let newvar ()          = { desc = Tvar; level = !current_level }
+let new_global_var ()  = new_global_ty Tvar
+let new_gen_var ()     = newgenty Tvar
+let newobj fields      = newty (Tobject (fields, ref None))
 
 let rec repr = function
-    Tvar({tvar_link = Some ty} as v) ->
-      let r = repr ty in
-      if r != ty then v.tvar_link <- Some r;
+    {desc = Tlink t'} as t ->
+      let r = repr t' in
+      if r != t' then t.desc <- Tlink r;
       r
   | t -> t
 
-let none = Ttuple []                  (* Clearly ill-formed type *)
+let rec repr2 = function                (* No path compression *)
+                                        (* during unification *)
+    {desc = Tlink ty} ->
+      repr2 ty
+  | t -> t
+
+let none = newty (Ttuple [])                (* Clearly ill-formed type *)
+
+(* --- *)
+
+let flatten_fields ty =
+  let rec flatten l ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tfield(s, ty1, ty2) ->
+        flatten ((s, ty1)::l) ty2
+    | Tvar | Tnil ->
+        (l, ty)
+    | _ ->
+      fatal_error "Ctype.flatten_fields"
+  in
+    let (l, r) = flatten [] ty in
+      (List.rev l, r)
+
+let build_fields =
+  List.fold_right
+    (fun (s, ty1) ty2 ->
+       {desc = Tfield(s, ty1, ty2);
+        level = ty2.level})
+
+let associate_fields fields1 fields2 =
+  let rec associate p s s' =
+    function
+      (l, []) ->
+        (List.rev p, (List.rev s) @ l, List.rev s')
+    | ([], l') ->
+        (List.rev p, List.rev s, (List.rev s') @ l')
+    | (((n, t)::r as l), ((n', t')::r' as l')) ->
+        if Label. (=) n n' then
+          associate ((t, t')::p) s s' (r, r')
+        else if Label. (<) n  n' then
+          associate p ((n, t)::s) s' (r, l')
+        else
+          associate p s ((n', t')::s') (l, r')
+  in let sort = Sort.list (fun (n, _) (n', _) -> Label. (<) n n') in
+  associate [] [] [] (sort fields1, sort fields2)
+
+(* Check whether an object is open *)
+
+let rec opened ty =
+  match (repr ty).desc with
+    Tfield(_, _, t) -> opened t
+  | Tvar            -> true
+  | Tnil            -> false
+  | _               -> fatal_error "Ctype.opened"
+
+let opened_object ty =
+  match (repr ty).desc with
+    Tobject (ty', _)  -> opened ty'
+  | Tconstr (_, _, _) -> false
+  | _                 -> fatal_error "Ctype.opened_object"
 
 (* Type generalization *)
 
 let rec generalize ty =
-  match repr ty with
-    Tvar v ->
-      if v.tvar_level > !current_level then v.tvar_level <- generic_level
-  | Tarrow(t1, t2) ->
-      generalize t1; generalize t2
-  | Ttuple tl ->
-      List.iter generalize tl
-  | Tconstr(p, []) ->
-      ()
-  | Tconstr(p, tl) ->
-      List.iter generalize tl
+  let ty = repr ty in
+  if ty.level > !current_level then begin
+    ty.level <- generic_level;
+    match ty.desc with
+      Tvar               -> ()
+    | Tarrow(t1, t2)     -> generalize t1; generalize t2
+    | Ttuple tl          -> List.iter generalize tl
+    | Tconstr(_, tl, ab) -> ab := []; List.iter generalize tl
+    | Tobject(f, {contents = Some (_, p)})
+                         -> generalize f; List.iter generalize p
+    | Tobject(f, _)      -> generalize f
+    | Tfield(_, t1, t2)  -> generalize t1; generalize t2
+    | Tnil               -> ()
+    | Tlink _            -> fatal_error "Ctype.generalize"
+  end
 
 let rec make_nongen ty =
-  match repr ty with
-    Tvar v ->
-      if v.tvar_level > !current_level then v.tvar_level <- !current_level
-  | Tarrow(t1, t2) ->
-      make_nongen t1; make_nongen t2
-  | Ttuple tl ->
-      List.iter make_nongen tl
-  | Tconstr(p, []) ->
-      ()
-  | Tconstr(p, tl) ->
-      List.iter make_nongen tl
+  let ty = repr ty in
+  if ty.level > !current_level then begin
+    ty.level <- !current_level;
+    match ty.desc with
+      Tvar              -> ()
+    | Tarrow(t1, t2)    ->  make_nongen t1; make_nongen t2
+    | Ttuple tl         -> List.iter make_nongen tl
+    | Tconstr(p, tl, _) -> List.iter make_nongen tl
+    | Tobject (f, _)    -> make_nongen f
+    | Tfield(_, t1, t2) -> make_nongen t1; make_nongen t2
+    | Tnil              -> ()
+    | Tlink _           -> fatal_error "Ctype.make_nongen"
+  end
+
+(* Remove abbreviations from generalized types *)
+
+let visited = ref ([] : type_expr list)
+
+let remove_abbrev ty =
+  let rec remove ty =
+    let ty = repr ty in
+    if ty.level = generic_level & not (List.memq ty !visited) then begin
+      visited := ty :: !visited;
+      match ty.desc with
+        Tvar               -> ()
+      | Tarrow(t1, t2)     -> remove t1; remove t2
+      | Ttuple tl          -> List.iter remove tl
+      | Tconstr(_, tl, ab) -> ab := []; List.iter remove tl
+      | Tobject(f, {contents = Some (_, p)})
+                           -> remove f; List.iter remove p
+      | Tobject(f, _)      -> remove f
+      | Tfield(_, t1, t2)  -> remove t1; remove t2
+      | Tnil               -> ()
+      | Tlink _            -> fatal_error "Ctype.remove_abbrev"
+      end
+  in
+    visited := []; remove ty; visited := []
+
 
 (* Taking instances of type schemes *)
 
+type 'a visited = Zero | One | Many of 'a
+
 let inst_subst = ref ([] : (type_expr * type_expr) list)
 
-let rec copy ty =
-  match repr ty with
-    Tvar v as t ->
-      if v.tvar_level = generic_level then begin
+let rec copy_rec abbrev visited ty =
+  let ty = repr ty in
+  if ty.level <> generic_level then ty else
+  try
+    match List.assq ty visited with
+      {contents = Zero} as v ->
+      	let t = newvar () in
+	v := Many t;
+	let ty' = copy_rec_2 abbrev visited ty v in
+	t.desc <- ty'.desc;
+	t
+    | {contents = One} as v ->
+        let t = newvar () in
+        v := Many t;
+        t
+    | {contents = Many t} ->
+        t
+  with Not_found ->
+    let v = ref One in
+    let ty' = copy_rec_2 abbrev ((ty, v)::visited) ty v in
+    match v with
+      {contents = Many t} ->
+      	t.desc <- ty'.desc;
+	t
+    | _ ->
+      	ty'
+
+and copy_rec_2 abbrev visited ty v =
+  match ty.desc with
+    Tvar ->
+      begin try List.assq ty !inst_subst with Not_found ->
+        let ty' = newvar () in
+        inst_subst := (ty, ty') :: !inst_subst;
+        ty'
+      end
+  | Tarrow (t1, t2) ->
+      newty (Tarrow (copy_rec abbrev visited t1,
+                     copy_rec abbrev visited t2))
+  | Ttuple tl ->
+      newty (Ttuple (List.map (copy_rec abbrev visited) tl))
+  | Tconstr (p, [], _) ->
+      newty (Tconstr (p, [], ref abbrev))
+  | Tconstr (p, tl, _) ->
+      newty (Tconstr (p, List.map (copy_rec abbrev visited) tl,
+                      ref abbrev))
+  | Tobject (t1, {contents = name}) ->
+      let ty' () =
+        let name' =
+          match name with
+            None ->
+              None
+          | Some (p, tl) ->
+              Some (p, List.map (copy_rec abbrev visited) tl)
+        in
+          newty (Tobject (copy_rec abbrev visited t1, ref name'))
+      in
+      if opened_object ty then
         try
-          List.assq t !inst_subst
+          List.assq ty !inst_subst
         with Not_found ->
-          let t' = newvar() in
-          inst_subst := (t, t') :: !inst_subst;
-          t'
-      end else t
-  | Tarrow(t1, t2) ->
-      Tarrow(copy t1, copy t2)
-  | Ttuple tl ->
-      Ttuple(List.map copy tl)
-  | Tconstr(p, []) as t ->
-      t
-  | Tconstr(p, tl) ->
-      Tconstr(p, List.map copy tl)
+          if v = ref One then begin
+            let t = newvar () in
+    	    v := Many t;
+            inst_subst := (ty, t):: !inst_subst
+          end;
+          ty' ()
+      else
+        ty' ()
+  | Tfield (label, t1, t2) ->
+      newty (Tfield (label, copy_rec abbrev visited t1,
+                            copy_rec abbrev visited t2))
+  | Tnil ->
+      newty Tnil
+  | Tlink _ ->
+      fatal_error "Ctype.copy_rec"
+
+let copy ty = copy_rec [] [] ty
+let subst abbrev ty = copy_rec abbrev [] ty
+let copy_parameterized params ty = copy_rec [] params ty
 
 let instance sch =
   inst_subst := [];
@@ -114,100 +271,317 @@ let instance_label lbl =
   inst_subst := [];
   (ty_arg, ty_res)
 
-let substitute params args body =
+let substitute abbrev params args body =
   inst_subst := List.combine params args;
-  let ty = copy body in
+  let ty = subst abbrev body in
   inst_subst := [];
   ty
 
+let instance_parameterized_type sch_args sch =
+  inst_subst := [];
+  let params = List.map (function p -> (repr p, ref Zero)) sch_args in
+  let ty_args = List.map (copy_parameterized params) sch_args in
+  let ty = copy_parameterized params sch in
+  inst_subst := [];
+  (ty_args, ty)
+
+let instance_parameterized_type_2 sch_args sch_lst sch =
+  inst_subst := [];
+  let params = List.map (function p -> (repr p, ref Zero)) sch_args in
+  let ty_args = List.map (copy_parameterized params) sch_args in
+  let ty_lst = List.map (copy_parameterized params) sch_lst in
+  let ty = copy_parameterized params sch in
+  inst_subst := [];
+  (ty_args, ty_lst, ty)
+
+let instance_class cl =
+  inst_subst := [];
+  let params0 = List.map (function p -> (repr p, ref Zero)) cl.cty_params in
+  let params = List.map (copy_parameterized params0) cl.cty_params in
+  let args = List.map (copy_parameterized params0) cl.cty_args in
+  let vars =
+    Vars.fold
+      (fun lab (mut, ty) ->
+         Vars.add lab (mut, copy_parameterized params0 ty))
+      cl.cty_vars
+      Vars.empty in
+  let self = copy_parameterized params0 cl.cty_self in
+  inst_subst := [];
+  (params, args, vars, self)
+
 (* Unification *)
 
+let rec update_level level ty =
+  let ty = repr2 ty in
+  if ty.level > level then begin
+    ty.level <- level;
+    match ty.desc with
+      Tvar               -> ()
+    | Tarrow(t1,t2)      -> update_level level t1; update_level level t2
+    | Ttuple(ty_list)    -> List.iter (update_level level) ty_list
+    | Tconstr(_, tl, _)  -> List.iter (update_level level) tl
+    | Tobject (f, _)     -> update_level level f
+    | Tfield(_, t1, t2)  -> update_level level t1; update_level level t2
+    | Tnil               -> ()
+    | Tlink _            -> fatal_error "Ctype.update_level"
+  end
+
 exception Cannot_expand
 
-let expand_abbrev env path args =
+let rec find_expans p1 =
+  function
+    [] ->
+      None
+  | (p2, ty)::l ->
+      if Path.same p1 p2 then
+        Some ty
+      else
+        find_expans p1 l
+
+let expand_abbrev env path args abbrev level =
+  match find_expans path !abbrev with
+    Some ty ->
+      update_level level ty;
+      ty
+  | None ->
+      try
+        let decl = Env.find_type path env in
+        match decl.type_manifest with
+          Some body ->
+            let v = newvar () in
+            abbrev := (path, v)::!abbrev;
+            let old_level = !current_level in
+            current_level := level;
+            let ty = substitute !abbrev decl.type_params args body in
+            current_level := old_level;
+            v.desc <- Tlink ty;
+            ty
+        | _ ->
+            raise Cannot_expand
+      with Not_found ->
+        raise Cannot_expand
+
+let generic_abbrev env path =
   try
     let decl = Env.find_type path env in
     match decl.type_manifest with
-      Some body -> substitute decl.type_params args body
-    | None -> raise Cannot_expand
-  with Not_found ->
-    raise Cannot_expand
-
-let rec occur tvar ty =
-  match repr ty with
-    Tvar v ->
-      if v == tvar then raise Unify;
-      if v.tvar_level > tvar.tvar_level then v.tvar_level <- tvar.tvar_level
-  | Tarrow(t1, t2) ->
-      occur tvar t1; occur tvar t2
-  | Ttuple tl ->
-      List.iter (occur tvar) tl
-  | Tconstr(p, []) ->
-      ()
-  | Tconstr(p, tl) ->
-      List.iter (occur tvar) tl
+      Some body ->
+        body.level = generic_level
+    | _ ->
+        false
+  with
+    Not_found ->
+      false
 
-let rec unify env t1 t2 =
-  if t1 == t2 then () else begin
-    let t1 = repr t1 in
-    let t2 = repr t2 in
-    if t1 == t2 then () else begin
-      match (t1, t2) with
-        (Tvar v, _) ->
-          occur v t2; v.tvar_link <- Some t2
-      | (_, Tvar v) ->
-          occur v t1; v.tvar_link <- Some t1
-      | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
-          unify env t1 t2; unify env u1 u2
-      | (Ttuple tl1, Ttuple tl2) ->
-          unify_list env tl1 tl2
-      | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
-          if Path.same p1 p2 then
-            unify_list env tl1 tl2
-          else begin
-            try
-              unify env (expand_abbrev env p1 tl1) t2
-            with Cannot_expand ->
-            try
-              unify env t1 (expand_abbrev env p2 tl2)
-            with Cannot_expand ->
-              raise Unify
-          end
-      | (Tconstr(p1, tl1), _) ->
-          begin try
-            unify env (expand_abbrev env p1 tl1) t2
+let occur env ty0 ty =
+  let visited = ref ([] : type_expr list) in
+  let rec occur_rec ty =
+    match ty.desc with
+      Tlink ty' ->
+        occur_rec ty'
+    | Tvar ->
+        if ty == ty0 then raise Unify else
+        ()
+    | Tarrow(t1, t2) ->
+        occur_rec t1; occur_rec t2
+    | Ttuple tl ->
+        List.iter occur_rec tl
+    | Tconstr(p, [], _) ->
+        ()
+    | Tconstr(p, tl, abbrev) ->
+        if not (List.memq ty !visited) then begin
+          visited := ty :: !visited;
+          try List.iter occur_rec tl with Unify ->
+          try occur_rec (expand_abbrev env p tl abbrev ty.level)
           with Cannot_expand ->
-            raise Unify
-          end
-      | (_, Tconstr(p2, tl2)) ->
-          begin try
-            unify env t1 (expand_abbrev env p2 tl2)
-          with Cannot_expand ->
-            raise Unify
-          end
-      | (_, _) ->
+          ()
+        end
+    | Tobject (_, _) ->
+        ()
+    | Tfield (_, _, _) | Tnil ->
+        fatal_error "Ctype.occur"
+  in
+    occur_rec ty
+
+let rec unify_rec env a1 a2 t1 t2 =     (* Variables and abbreviations *)
+  if t1 == t2 then () else
+  let t1 = repr2 t1 in
+  let t2 = repr2 t2 in
+  if t1 == t2 then () else
+  match (t1.desc, t2.desc) with
+    (Tvar, _) ->
+       update_level t1.level t2;
+       begin match a2 with
+         None    -> occur env t1 t2; t1.desc <- Tlink t2
+       | Some l2 -> occur env t1 l2; t1.desc <- Tlink l2
+       end
+  | (_, Tvar) ->
+       update_level t2.level t1;
+       begin match a1 with
+         None    -> occur env t2 t1; t2.desc <- Tlink t1
+       | Some l1 -> occur env t2 l1; t2.desc <- Tlink l1
+       end
+  | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) when Path.same p1 p2 ->
+       unify_core env a1 a2 t1 t2
+  | (Tconstr (p1, tl1, abbrev1), Tconstr (p2, tl2, abbrev2)) ->
+      begin
+        try
+          let t3 = expand_abbrev env p1 tl1 abbrev1 t1.level in
+          update_level t2.level t1;
+          unify_rec env (Some t1) a2 t3 t2
+        with Cannot_expand ->
+        try
+          let t3 = expand_abbrev env p2 tl2 abbrev2 t2.level in
+          update_level t1.level t2;
+          unify_rec env a1 (Some t2) t1 t3
+        with Cannot_expand ->
           raise Unify
-    end
-  end
+      end
+  | (Tconstr (p1, tl1, abbrev1), _) ->
+      begin try
+        let t3 = expand_abbrev env p1 tl1 abbrev1 t1.level in
+        update_level t2.level t1;
+        unify_rec env (Some t1) a2 t3 t2
+      with Cannot_expand ->
+        unify_core env a1 a2 t1 t2
+      end
+  | (_, Tconstr (p2, tl2, abbrev2)) ->
+      begin try
+        let t3 = expand_abbrev env p2 tl2 abbrev2 t2.level in
+        update_level t1.level t2;
+        unify_rec env a1 (Some t2) t1 t3
+      with Cannot_expand ->
+        unify_core env a1 a2 t1 t2
+      end
+  | (_, _) ->
+      unify_core env a1 a2 t1 t2
+
+and unify_core env a1 a2 t1 t2 =        (* Other cases *)
+  let d1 = t1.desc and d2 = t2.desc in
+  begin match (a1, a2) with
+    (None,    Some l2) ->
+      update_level t1.level t2; t1.desc <- Tlink l2
+  | (Some l1, None) ->
+      update_level t2.level t1; t2.desc <- Tlink l1
+  | (_, _) ->
+      update_level t1.level t2; t1.desc <- Tlink t2
+  end;
+  try
+    match (d1, d2) with
+      (Tarrow (t1, u1), Tarrow (t2, u2)) ->
+        unify_rec env None None t1 t2; unify_rec env None None u1 u2
+    | (Ttuple tl1, Ttuple tl2) ->
+        unify_list env tl1 tl2
+    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) (*when Path.same p1 p2*) ->
+        ()
+    | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) (*when Path.same p1 p2*) ->
+        unify_list env tl1 tl2
+    | (Tobject (fi1, nm1), Tobject (fi2, nm2)) ->
+        let old_nm = !nm2 in
+        begin match old_nm with
+          Some (_, va::_) when (repr va).desc = Tvar -> ()
+        | _                                          -> nm2 := !nm1
+        end;
+        begin try unify_fields env fi1 fi2 with exn ->
+          nm2 := old_nm;
+          raise exn
+        end
+    | (_, _) ->
+        raise Unify
+  with exn ->
+    t1.desc <- d1;
+    t2.desc <- d2;
+    raise exn
 
 and unify_list env tl1 tl2 =
-  match (tl1, tl2) with
-    ([], []) -> ()
-  | (t1::r1, t2::r2) -> unify env t1 t2; unify_list env r1 r2
-  | (_, _) -> raise Unify
+  try
+    List.iter2 (unify_rec env None None) tl1 tl2
+  with Invalid_argument _ ->
+    raise Unify
+
+and unify_fields env ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1
+  and (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  let va = newvar () in
+    begin match rest1.desc with
+      Tvar ->
+        let nr = build_fields miss2 va in
+        update_level rest1.level nr;
+        rest1.desc <- Tlink nr
+    | Tnil ->
+        if miss2 <> [] then raise Unify;
+        va.desc <- Tlink {desc = Tnil; level = va.level}
+    | _ ->
+        fatal_error "Ctype.unify_fields (1)"
+    end;
+    begin match rest2.desc with
+      Tvar ->
+        let nr = build_fields miss1 va in
+        update_level rest2.level nr;
+        rest2.desc <- Tlink nr
+    | Tnil ->
+        if miss1 <> [] then raise Unify;
+        va.desc <- Tlink {desc = Tnil; level = va.level}
+    | _ ->
+        fatal_error "Ctype.unify_fields (2)"
+    end;
+    List.iter (fun (t1, t2) -> unify_rec env None None t1 t2) pairs
+
+let unify env ty1 ty2 =
+  unify_rec env None None ty1 ty2
 
 let rec filter_arrow env t =
-  match repr t with
-    Tvar v ->
-      let t1 = Tvar { tvar_level = v.tvar_level; tvar_link = None }
-      and t2 = Tvar { tvar_level = v.tvar_level; tvar_link = None } in
-      v.tvar_link <- Some(Tarrow(t1, t2));
+  let t = repr t in
+  match t.desc with
+    Tvar ->
+      let t1 = newvar () and t2 = newvar () in
+      let t' = newty (Tarrow (t1, t2)) in
+      update_level t.level t';
+      t.desc <- Tlink t';
       (t1, t2)
   | Tarrow(t1, t2) ->
       (t1, t2)
-  | Tconstr(p, tl) ->
+  | Tconstr(p, tl, abbrev) ->
+      begin try
+        filter_arrow env (expand_abbrev env p tl abbrev t.level)
+      with Cannot_expand ->
+        raise Unify
+      end
+  | _ ->
+      raise Unify
+
+let rec filter_method_field name ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      let ty1 = newvar () and ty2 = newvar () in
+      let ty' = newty (Tfield (name, ty1, ty2)) in
+      update_level ty.level ty';
+      ty.desc <- Tlink ty';
+      ty1
+  | Tfield(n, ty1, ty2) ->
+      if Label. (=) n name then
+        ty1
+      else
+        filter_method_field name ty2
+  | _ ->
+      raise Unify
+
+let rec filter_method env name ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      let ty1 = newvar ()in
+      let ty' = newobj ty1 in
+      update_level ty.level ty';
+      ty.desc <- Tlink ty';
+      filter_method_field name ty1
+  | Tobject(f, _) ->
+      filter_method_field name f
+  | Tconstr(p, tl, abbrev) ->
       begin try
-        filter_arrow env (expand_abbrev env p tl)
+        filter_method env name (expand_abbrev env p tl abbrev ty.level)
       with Cannot_expand ->
         raise Unify
       end
@@ -216,127 +590,188 @@ let rec filter_arrow env t =
 
 (* Matching between type schemes *)
 
-let rec moregen_occur tvar ty =
-  match repr ty with
-    Tvar v ->
-      if v == tvar then raise Unify;
-      (* tvar has level = !current_level iff it is generic
+let rec moregen_occur ty0 ty =
+  let visited = ref [] in
+  let rec occur_rec ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      (* ty0 has level = !current_level iff it is generic
          in the original type scheme. In this case, it can be freely
-         instantiated. Otherwise, tvar is not generic
+         instantiated. Otherwise, ty0 is not generic
          and cannot be instantiated by a type that contains
          generic variables. *)
-      if v.tvar_level = generic_level & tvar.tvar_level < !current_level
+      if ty.level = generic_level & ty0.level < !current_level
       then raise Unify
   | Tarrow(t1, t2) ->
-      moregen_occur tvar t1; moregen_occur tvar t2
+      occur_rec t1; occur_rec t2
   | Ttuple tl ->
-      List.iter (moregen_occur tvar) tl
-  | Tconstr(p, []) ->
+      List.iter occur_rec tl
+  | Tconstr(p, tl, _) ->
+      if not (List.memq ty !visited) then begin
+        visited := ty::!visited;
+        List.iter occur_rec tl
+      end
+  | Tobject(f, _) ->
+      if not (List.memq ty !visited) then begin
+        visited := ty::!visited;
+        occur_rec f
+      end
+  | Tfield(_, t1, t2) ->
+      occur_rec t1; occur_rec t2
+  | Tnil ->
       ()
-  | Tconstr(p, tl) ->
-      List.iter (moregen_occur tvar) tl
+  | Tlink _ ->
+      fatal_error "Ctype.moregen_occur"
+  in
+    occur_rec ty
 
 let rec moregen env t1 t2 =
-  if t1 == t2 then () else begin
-    let t1 = repr t1 in
-    let t2 = repr t2 in
-    if t1 == t2 then () else begin
-      match (t1, t2) with
-        (Tvar v, _) ->
-          if v.tvar_level = generic_level then raise Unify;
-          moregen_occur v t2;
-          v.tvar_link <- Some t2
-      | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
-          moregen env t1 t2; moregen env u1 u2
-      | (Ttuple tl1, Ttuple tl2) ->
-          moregen_list env tl1 tl2
-      | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
-          if Path.same p1 p2 then
-            moregen_list env tl1 tl2
-          else begin
-            try
-              moregen env (expand_abbrev env p1 tl1) t2
-            with Cannot_expand ->
-            try
-              moregen env t1 (expand_abbrev env p2 tl2)
-            with Cannot_expand ->
-              raise Unify
-          end
-      | (Tconstr(p1, tl1), _) ->
-          begin try
-            moregen env (expand_abbrev env p1 tl1) t2
+  if t1 == t2 then () else
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if t1 == t2 then () else
+  let d1 = t1.desc in
+  try
+    begin match (t1.desc, t2.desc) with
+      (Tvar, _) ->
+        if t1.level = generic_level then raise Unify;
+        occur env t1 t2;
+        moregen_occur t1 t2;
+        t1.desc <- Tlink t2
+    | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
+        moregen env t1 t2; moregen env u1 u2
+    | (Ttuple tl1, Ttuple tl2) ->
+        moregen_list env tl1 tl2
+    | (Tconstr(p1, tl1, abbrev1), Tconstr(p2, tl2, abbrev2)) ->
+        if Path.same p1 p2 then begin
+          t1.desc <- Tlink t2;
+          moregen_list env tl1 tl2;
+          t1.desc <- d1
+        end else begin
+          try
+            moregen env (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
           with Cannot_expand ->
-            raise Unify
-          end
-      | (_, Tconstr(p2, tl2)) ->
-          begin try
-            moregen env t1 (expand_abbrev env p2 tl2)
+          try
+            moregen env t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
           with Cannot_expand ->
             raise Unify
-          end
-      | (_, _) ->
+        end
+    | (Tobject(f1, _), Tobject(f2, _)) ->
+        t1.desc <- Tlink t2;
+        moregen_fields env f1 f2;
+        t1.desc <- d1
+    | (Tconstr(p1, tl1, abbrev1), _) ->
+        begin try
+          moregen env (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+        with Cannot_expand ->
           raise Unify
+        end
+    | (_, Tconstr(p2, tl2, abbrev2)) ->
+        begin try
+          moregen env t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+        with Cannot_expand ->
+          raise Unify
+        end
+    | (_, _) ->
+        raise Unify
     end
-  end
+  with exn ->
+    t1.desc <- d1;
+    raise exn
 
 and moregen_list env tl1 tl2 =
-  match (tl1, tl2) with
-    ([], []) -> ()
-  | (t1::r1, t2::r2) -> moregen env t1 t2; moregen_list env r1 r2
-  | (_, _) -> raise Unify
-  
+  try
+    List.iter2 (moregen env) tl1 tl2
+  with Invalid_argument _ ->
+    raise Unify
+
+and moregen_fields env ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1
+  and (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  if miss1 <> [] then raise Unify;
+  begin match rest1.desc with
+    Tvar ->
+      if rest1.level = generic_level then raise Unify;
+      let fi = build_fields miss2 rest2 in
+      moregen_occur rest1 fi
+  | Tnil ->
+      if miss2 <> [] then raise Unify;
+      if rest2.desc <> Tnil then raise Unify
+  | _ ->
+      fatal_error "moregen_fields"
+  end;
+  List.iter (fun (t1, t2) -> moregen env t1 t2) pairs
+
 let moregeneral env sch1 sch2 =
   begin_def();
   try
     moregen env (instance sch1) sch2;
+    remove_abbrev sch2;
     end_def();
     true
   with Unify ->
+    remove_abbrev sch2;
     end_def();
     false
 
 (* Equivalence between parameterized types *)
 
 let equal env params1 ty1 params2 ty2 =
-  let subst = List.combine params1 params2 in
+  let subst = ref (List.combine params1 params2) in
+  let type_pairs = ref [] in
   let rec eqtype t1 t2 =
     let t1 = repr t1 in
     let t2 = repr t2 in
-    match (t1, t2) with
-      (Tvar _, Tvar _) ->
+    match (t1.desc, t2.desc) with
+      (Tvar, Tvar) ->
         begin try
-          List.assq t1 subst == t2
+          List.assq t1 !subst == t2
         with Not_found ->
-          fatal_error "Ctype.equal"
+          subst := (t1, t2) :: !subst;
+          true
         end
     | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
         eqtype t1 t2 & eqtype u1 u2
     | (Ttuple tl1, Ttuple tl2) ->
         eqtype_list tl1 tl2
-    | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
-        if Path.same p1 p2 then
-          eqtype_list tl1 tl2
-        else begin
-          try
-            eqtype (expand_abbrev env p1 tl1) t2
-          with Cannot_expand ->
-          try
-            eqtype t1 (expand_abbrev env p2 tl2)
-          with Cannot_expand ->
-            false
+    | (Tconstr(p1, tl1, abbrev1), Tconstr(p2, tl2, abbrev2)) ->
+        List.exists (function (t1', t2') -> t1 == t1' & t2 == t2') !type_pairs
+        or begin
+          type_pairs := (t1, t2) :: !type_pairs;
+          if Path.same p1 p2 then
+            eqtype_list tl1 tl2
+          else begin
+            try
+              eqtype (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+            with Cannot_expand ->
+            try
+              eqtype t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+            with Cannot_expand ->
+              false
+          end
+        end
+    | (Tobject (f1, _), Tobject (f2, _)) ->
+        List.exists (function (t1', t2') -> t1 == t1' & t2 == t2') !type_pairs
+        or begin
+          type_pairs := (t1, t2) :: !type_pairs;
+          eqtype_fields f1 f2
         end
-    | (Tconstr(p1, tl1), _) ->
+    | (Tconstr(p1, tl1, abbrev1), _) ->
         begin try
-          eqtype (expand_abbrev env p1 tl1) t2
+          eqtype (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
         with Cannot_expand ->
           false
         end
-    | (_, Tconstr(p2, tl2)) ->
+    | (_, Tconstr(p2, tl2, abbrev2)) ->
         begin try
-          eqtype t1 (expand_abbrev env p2 tl2)
+          eqtype t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
         with Cannot_expand ->
           false
         end
+    | (Tnil, Tnil) ->
+        true
     | (_, _) ->
         false
   and eqtype_list tl1 tl2 =
@@ -344,65 +779,546 @@ let equal env params1 ty1 params2 ty2 =
       ([], []) -> true
     | (t1::r1, t2::r2) -> eqtype t1 t2 & eqtype_list r1 r2
     | (_, _) -> false
+  and eqtype_fields ty1 ty2 =
+    let (fields1, rest1) = flatten_fields ty1
+    and (fields2, rest2) = flatten_fields ty2 in
+    List.length fields1 = List.length fields2
+      &
+    eqtype rest1 rest2
+      &
+    List.for_all
+      (function (label, t) ->
+         List.exists
+           (function (label', t') ->
+              (Label. (=) label label') & (eqtype t t'))
+           fields2)
+      fields1
   in
-    eqtype ty1 ty2
+    let eq = eqtype ty1 ty2 in
+    remove_abbrev ty1; remove_abbrev ty2;
+    eq
 
-(* Remove dependencies *)
+(* Subtyping *)
+
+let visited = ref ([] : type_expr list)
 
-let rec nondep_type env id ty =
-  match repr ty with
-    Tvar v as tvar -> tvar
+let rec build_subtype env vars t =
+  if List.memq t vars then (t, false) else
+  match t.desc with
+    Tlink t' ->
+      build_subtype env vars t'
+  | Tvar ->
+      (t, false)
   | Tarrow(t1, t2) ->
-      Tarrow(nondep_type env id t1, nondep_type env id t2)
-  | Ttuple tl ->
-      Ttuple(List.map (nondep_type env id) tl)
-  | Tconstr(p, tl) ->
-      if Path.isfree id p then begin
-        let ty' =
-          try
-            expand_abbrev env p tl
-          with Cannot_expand ->
-            raise Not_found in
-        nondep_type env id ty'
+      let (t1', c1) = build_supertype env vars t1 in
+      let (t2', c2) = build_subtype env vars t2 in
+      if c1 or c2 then (new_global_ty (Tarrow(t1', t2')), true)
+      else (t, false)
+  | Ttuple tlist ->
+      let (tlist', clist) =
+        List.split (List.map (build_subtype env vars) tlist)
+      in
+      if List.exists (function c -> c) clist then
+        (new_global_ty (Ttuple tlist'), true)
+      else (t, false)
+  | Tconstr(p, tl, abbrev) ->
+      if generic_abbrev env p then begin
+        let t' = expand_abbrev env p tl abbrev t.level in
+        let (t'', c) = build_subtype env vars t' in
+        if c then (t'', true)
+        else (t, false)
       end else
-        Tconstr(p, List.map (nondep_type env id) tl)
+        (t, false)
+  | Tobject (t1, _) ->
+      if opened t1 then
+        (t, false)
+      else if List.memq t !visited then
+        (t, false)
+      else begin
+        let old_visited = !visited in
+        visited := t :: old_visited;
+        let (t1', _) = build_subtype env vars t1 in
+        visited := old_visited;
+        (new_global_ty (Tobject (t1', ref None)), true)
+      end
+  | Tfield(s, t1, t2) ->
+      let (t1', _) = build_subtype env vars t1 in
+      let (t2', _) = build_subtype env vars t2 in
+      (new_global_ty (Tfield(s, t1', t2')), true)
+  | Tnil ->
+      let v = new_global_var () in
+      (v, true)
 
-let rec free_type_ident env ids ty =
-  match repr ty with
-    Tvar _ -> false
+and build_supertype env vars t =
+  if List.memq t vars then (t, false) else
+  match t.desc with
+    Tlink t' ->
+      build_supertype env vars t'
+  | Tvar ->
+      (t, false)
   | Tarrow(t1, t2) ->
-      free_type_ident env ids t1 or free_type_ident env ids t2
+      let (t1', c1) = build_subtype env vars t1 in
+      let (t2', c2) = build_supertype env vars t2 in
+      if c1 or c2 then (new_global_ty (Tarrow(t1', t2')), true)
+      else (t, false)
+  | Ttuple tlist ->
+      let (tlist', clist) =
+        List.split (List.map (build_supertype env vars) tlist)
+      in
+      if List.exists (function c -> c) clist then
+        (new_global_ty (Ttuple tlist'), true)
+      else
+        (t, false)
+  | Tconstr(p, tl, abbrev) ->
+      if generic_abbrev env p then begin
+        let t' = expand_abbrev env p tl abbrev t.level in
+        let (t'', c) = build_supertype env vars t' in
+        if c then (t'', c)
+        else (t, false)
+      end else
+        (t, false)
+  | Tobject (t1, _) ->
+      if opened t1 then
+        (t, false)
+      else if List.memq t !visited then
+        (t, false)
+      else begin
+        let old_visited = !visited in
+        visited := t :: old_visited;
+        let (t1', c) = build_supertype env vars t1 in
+        visited := old_visited;
+        if c then (new_global_ty (Tobject (t1', ref None)), true)
+        else (t, false)
+      end
+  | Tfield(s, t1, t2) ->
+      let (t1', c1) = build_supertype env vars t1 in
+      let (t2', c2) = build_supertype env vars t2 in
+      if c1 or c2 then (new_global_ty (Tfield(s, t1', t2')), true)
+      else (t, false)
+  | Tnil ->
+      (t, false)
+
+let enlarge_type env vars ty =
+  visited := [];
+  let (ty', _) = build_subtype env vars ty in
+    visited := [];
+    ty'
+
+let subtypes = ref [];;
+let known_subtype t1 t2 =
+  List.exists (fun (t1', t2') -> t1 == t1' & t2 == t2') !subtypes
+
+let rec subtype_rec env vars t1 t2 =
+  if t1 == t2 then () else
+  if List.memq t1 vars or List.memq t2 vars then unify env t1 t2 else
+    match (t1.desc, t2.desc) with
+      (Tlink t1', _) ->
+        subtype_rec env vars t1' t2
+    | (_, Tlink t2') ->
+        subtype_rec env vars t1 t2'
+    | (Tvar, _) | (_, Tvar) ->
+        unify env t1 t2
+    | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
+        subtype_rec env vars t2 t1; subtype_rec env vars u1 u2
+    | (Ttuple tl1, Ttuple tl2) ->
+        subtype_list env vars tl1 tl2
+    | (Tconstr(p1, tl1, abbrev1), Tconstr(p2, tl2, abbrev2)) ->
+        if generic_abbrev env p1 then
+          subtype_rec env vars (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+        else if generic_abbrev env p2 then
+          subtype_rec env vars t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+        else
+          unify env t1 t2
+    | (Tobject (f1, _), Tobject (f2, _)) ->
+        if not (known_subtype t1 t2) then begin
+          if opened f1 & opened f2 then
+            unify env t1 t2
+          else begin
+            subtypes := (t1, t2) :: !subtypes;
+            subtype_fields env vars f1 f2
+          end
+        end
+    | (Tconstr(p1, tl1, abbrev1), _) ->
+        if generic_abbrev env p1 then
+          subtype_rec env vars (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+        else
+          unify env t1 t2
+    | (_, Tconstr(p2, tl2, abbrev2)) ->
+        if generic_abbrev env p2 then
+          subtype_rec env vars t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+        else
+          unify env t1 t2
+    | (_, _) ->
+        raise Unify
+
+and subtype_list env vars tl1 tl2 =
+  try
+    List.iter2 (subtype_rec env vars) tl1 tl2
+  with Invalid_argument _ ->
+    raise Unify
+
+and subtype_fields env vars ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1 in
+  let (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  begin match rest1.desc with
+    Tvar ->
+      let nr = build_fields miss2 (newvar ()) in
+      update_level rest1.level nr;
+      rest1.desc <- Tlink nr
+  | Tnil   -> if miss2 <> [] then raise Unify
+  | _      -> fatal_error "Ctype.subtype_fields (1)"
+  end;
+  begin match rest2.desc with
+    Tvar ->
+      let nr = build_fields miss1 (newvar ()) in
+      update_level rest2.level nr;
+      rest2.desc <- Tlink nr
+  | Tnil   -> ()
+  | _      -> fatal_error "Ctype.subtype_fields (2)"
+  end;
+  List.iter (fun (t1, t2) -> subtype_rec env vars t1 t2) pairs
+
+let subtype env vars ty1 ty2 =
+  subtypes := [];
+  subtype_rec env vars ty1 ty2;
+  subtypes := []
+
+(* Remove dependencies *)
+
+let inst_subst = ref ([] : (type_expr * type_expr) list)
+
+let rec nondep_type_rec env id ty =
+  let ty = repr ty in
+  if ty.desc = Tvar then ty else
+  try List.assq ty !inst_subst with Not_found ->
+    let ty' = new_gen_var () in
+    inst_subst := (ty, ty') :: !inst_subst;
+    ty'.desc <-
+      begin match ty.desc with
+        Tvar ->
+          Tvar
+      | Tarrow(t1, t2) ->
+          Tarrow(nondep_type_rec env id t1, nondep_type_rec env id t2)
+      | Ttuple tl ->
+          Ttuple(List.map (nondep_type_rec env id) tl)
+      | Tconstr(p, tl, abbrev) ->
+          if Path.isfree id p then
+            begin try
+              (nondep_type_rec env id
+                 (expand_abbrev env p tl (ref !abbrev) ty.level)).desc
+            with Cannot_expand ->
+              raise Not_found
+            end
+          else
+            Tconstr(p, List.map (nondep_type_rec env id) tl, ref [])
+      | Tobject (t1, name) ->
+          Tobject (nondep_type_rec env id t1,
+                 ref (match !name with
+                        None -> None
+                      | Some (p, tl) ->
+                          if Path.isfree id p then None
+                          else Some (p, List.map (nondep_type_rec env id) tl)))
+       | Tfield(label, t1, t2) ->
+           Tfield(label, nondep_type_rec env id t1, nondep_type_rec env id t2)
+       | Tnil ->
+           Tnil
+       | Tlink _ ->
+           fatal_error "Ctype.nondep_type"
+       end;
+     ty'
+
+let nondep_type env id ty =
+  inst_subst := [];
+  let ty' = nondep_type_rec env id ty in
+  inst_subst := [];
+  ty'
+
+let nondep_class_type env id decl =
+  inst_subst := [];
+  let decl =
+    { cty_params = List.map (nondep_type_rec env id) decl.cty_params;
+      cty_args = List.map (nondep_type_rec env id) decl.cty_args;
+      cty_vars =
+        Vars.fold (fun l (m, t) -> Vars.add l (m, nondep_type_rec env id t))
+          decl.cty_vars Vars.empty;
+      cty_self = nondep_type_rec env id decl.cty_self;
+      cty_concr = decl.cty_concr;
+      cty_new =
+        begin match decl.cty_new with
+          None    -> None
+        | Some ty -> Some (nondep_type_rec env id ty)
+        end }
+  in
+  inst_subst := [];
+  decl
+
+(* Type pruning *)
+
+let inst_subst = ref ([] : (type_expr * type_expr) list)
+
+let rec prune_rec top cstr ty =
+  let ty = repr ty in
+  try List.assq ty (if top then [] else cstr) with Not_found ->
+  match ty.desc with
+    Tvar ->
+      if ty.level = generic_level then
+        begin try
+          List.assq ty !inst_subst
+        with Not_found ->
+          let ty' = newvar() in
+          inst_subst := (ty, ty') :: !inst_subst;
+          ty'
+        end
+      else
+        ty
+  | Tarrow(t1, t2) ->
+      newty (Tarrow(prune_rec false cstr t1, prune_rec false cstr t2))
   | Ttuple tl ->
-      List.exists (free_type_ident env ids) tl
-  | Tconstr((Pident id as p), tl) ->
-      List.exists (Ident.same id) ids or begin
-        try
-          free_type_ident env (id::ids) (expand_abbrev env p tl)
-        with Cannot_expand ->
-          List.exists (free_type_ident env ids) tl
+      newty (Ttuple(List.map (prune_rec false cstr) tl))
+  | Tconstr(p, tl, _) ->
+      begin try
+        List.assq ty !inst_subst
+      with Not_found ->
+        let ty' = newvar() in
+        inst_subst := (ty, ty') :: !inst_subst;
+        let ty'' = 
+          newty (Tconstr(p, List.map (prune_rec false cstr) tl, ref []))
+        in
+          ty'.desc <- Tlink ty'';
+          ty''
       end
-  | Tconstr(p, tl) ->
+  | Tobject (t1, name) ->
       begin try
-        free_type_ident env ids (expand_abbrev env p tl)
+        List.assq ty !inst_subst
+      with Not_found ->
+        let ty' = newvar() in
+        inst_subst := (ty, ty') :: !inst_subst;
+        let ty'' = newty
+          (Tobject (prune_rec false cstr t1,
+                    ref (match !name with
+                           None -> None
+                         | Some (p, tl) ->
+                             Some (p, List.map (prune_rec false cstr) tl))))
+        in
+          ty'.desc <- Tlink ty'';
+          ty''
+      end
+  | Tfield(label, t1, t2) ->
+      newty (Tfield(label, prune_rec false cstr t1, prune_rec false cstr t2))
+  | Tnil ->
+      newty Tnil
+  | Tlink _             ->
+      fatal_error "Ctype.prune_rec"
+
+let prune_cstr cstr (old_cstr, new_cstr) ((ty, v) as c) =
+  let c' =
+    try (v, List.assq ty old_cstr) with Not_found ->
+    match ty.desc with
+      Tvar ->
+        (v, v)
+    | _ ->
+        (v, prune_rec true cstr ty)
+  in
+    (c :: old_cstr, c' :: new_cstr)
+
+let prune ty leaves =
+  inst_subst := [];
+  let cstr = List.map (fun leaf -> (repr leaf, newvar ())) leaves in
+  let new_ty = prune_rec true cstr ty in
+  inst_subst := [];
+  (new_ty, List.map (fun (ty, v) -> (v, ty)) cstr)
+
+let prune_class_type cl =
+  inst_subst := [];
+  let cstr = List.map (fun leaf -> (repr leaf, newvar ())) cl.cty_params in
+  let args = List.map (prune_rec false cstr) cl.cty_args in
+  let vars =
+    Vars.fold
+      (fun lab (mut, ty) -> Vars.add lab (mut, prune_rec false cstr ty))
+      cl.cty_vars Vars.empty in
+  let self = prune_rec true cstr cl.cty_self in
+  let (_, cstr) = List.fold_left (prune_cstr cstr) ([], []) cstr in
+  inst_subst := [];
+  (List.rev cstr, args, vars, self)
+
+(* --- *)
+
+let rec row_variable ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tfield (_, _, ty) -> row_variable ty
+  | Tvar              -> ty
+  | Tnil              -> raise Not_found
+  | _                 -> fatal_error "Ctype.row_variable"
+
+let close_object ty =
+  let rec close ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tvar              ->
+        ty.desc <- Tlink {desc = Tnil; level = ty.level}
+    | Tfield(_, _, ty') -> close ty'
+    | Tnil              -> ()
+    | _                 -> fatal_error "Ctype.close_object (1)"
+  in
+  match (repr ty).desc with
+    Tobject (ty, _)   -> close ty
+  | Tconstr (_, _, _) -> ()             (* Already closed *)
+  | _                 -> fatal_error "Ctype.close_object (2)"
+
+
+let set_object_name ty params id =
+  match (repr ty).desc with
+    Tobject (fi, nm) ->
+      begin try
+        nm := Some (Path.Pident id, (row_variable fi)::params)
+      with Not_found ->
+        ()
+      end
+  | Tconstr (_, _, _) ->
+      ()
+  | _ ->
+      fatal_error "Ctype.set_object_name"
+
+let remove_object_name ty =
+  match (repr ty).desc with
+    Tobject (_, nm)   -> nm := None
+  | Tconstr (_, _, _) -> ()
+  | _                 -> fatal_error "Ctype.remove_object_name"
+
+let rec expand_root env ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tconstr(p, tl, abbrev) ->
+      begin try
+        expand_root env (expand_abbrev env p tl (ref !abbrev) ty.level)
       with Cannot_expand ->
-        List.exists (free_type_ident env ids) tl
+        ty
       end
+  | _ ->
+      ty
+
+(* Abbreviation correctness *)
+
+exception Nonlinear_abbrev
+exception Recursive_abbrev
+
+let rec correct_abbrev_rec env path params constrs visited ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      []
+  | Tarrow (ty1, ty2) ->
+      let c1 = correct_abbrev_rec env path params constrs visited ty1 in
+      let c2 = correct_abbrev_rec env path params constrs visited ty2 in
+      c1 @ c2
+  | Ttuple tl ->
+      List.flatten
+        (List.map (correct_abbrev_rec env path params constrs visited) tl)
+  | Tconstr(p, args, abbrev) ->
+      if Path.same p path then begin
+        if
+          List.exists (fun (ty1, ty2) -> repr ty1 != repr ty2)
+            (List.combine params args)
+        then
+          raise Nonlinear_abbrev
+        else
+          [p]
+      end else begin
+          try
+            let ty' = expand_abbrev env p args abbrev ty.level in
+            if List.memq ty' constrs then [] else
+            let loops =
+              correct_abbrev_rec env path params (ty'::constrs) visited ty'
+            in
+            if List.exists (Path.same p) loops
+            then raise Recursive_abbrev
+            else loops
+          with Cannot_expand ->
+          if not (List.memq ty visited) then begin
+            List.iter
+              (correct_abbrev_rec env path params constrs (ty::visited))
+              args;
+            ()
+          end;
+          []
+      end
+  | Tobject (ty', _) ->
+      if not (List.memq ty visited) then begin
+        correct_abbrev_rec env path params constrs (ty::visited) ty';
+        ()
+      end;
+      []
+  | Tfield(_, ty1, ty2) ->
+      correct_abbrev_rec env path params constrs visited ty1;
+      correct_abbrev_rec env path params constrs visited ty2;
+      []
+  | Tnil ->
+      []
+  | Tlink _ -> fatal_error "Ctype.correct_abbrev_rec"
+
+let correct_abbrev env ident params ty =
+  let path = Path.Pident ident in
+  let incorrect =
+    List.exists (Path.same path) (correct_abbrev_rec env path params [] [] ty)
+  in
+  remove_abbrev ty;
+  if incorrect then
+    raise Recursive_abbrev
 
 (* Miscellaneous *)
 
-let rec closed_schema ty =
-  match repr ty with
-    Tvar v -> v.tvar_level = generic_level
-  | Tarrow(t1, t2) -> closed_schema t1 & closed_schema t2
-  | Ttuple tl -> List.for_all closed_schema tl
-  | Tconstr(p, tl) -> List.for_all closed_schema tl
+let unroll_abbrev id tl ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tobject (fi, nm) ->
+      ty.desc <-
+        Tlink {desc = Tconstr (Path.Pident id, tl, ref []);
+               level = generic_level};
+      {desc = Tobject (fi, nm); level = ty.level}
+  | _ ->
+      ty
+
+let visited = ref []
+
+let closed_schema ty =
+  let rec closed_schema_rec ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tvar -> ty.level = generic_level
+    | Tarrow(t1, t2) -> closed_schema_rec t1 & closed_schema_rec t2
+    | Ttuple tl -> List.for_all closed_schema_rec tl
+    | Tconstr(p, tl, _) ->
+        if not (List.memq ty !visited) then begin
+          visited := ty::!visited;
+          List.for_all closed_schema_rec tl
+        end else
+          true
+    | Tobject(f, _) ->
+        if not (List.memq ty !visited) then begin
+          visited := ty::!visited;
+          closed_schema_rec f
+        end else
+          true
+    | Tfield(_, t1, t2) ->
+        closed_schema_rec t1 & closed_schema_rec t2
+    | Tnil ->
+        true
+    | Tlink _           -> fatal_error "Ctype.closed_schema"
+  in
+    visited := [];
+    let res = closed_schema_rec ty in
+    visited := [];
+    res
 
 let is_generic ty =
-  match repr ty with
-    Tvar v -> v.tvar_level = generic_level
+  let ty = repr ty in
+  match ty.desc with
+    Tvar -> ty.level = generic_level
   | _ -> fatal_error "Ctype.is_generic"
 
 let rec arity ty =
-  match repr ty with
+  match (repr ty).desc with
     Tarrow(t1, t2) -> 1 + arity t2
   | _ -> 0
diff --git a/typing/ctype.mli b/typing/ctype.mli
index 038271d..87f9d81 100644
--- a/typing/ctype.mli
+++ b/typing/ctype.mli
@@ -13,36 +13,60 @@
 
 (* Operations on core types *)
 
+open Asttypes
 open Typedtree
 
+val generic_level: int
 val begin_def: unit -> unit
         (* Raise the variable level by one at the beginning of a definition. *)
 val end_def: unit -> unit
         (* Lower the variable level by one at the end of a definition *)
-val reset_def: unit -> unit
-        (* Reset (to 0) the variable level *)
+val reset_global_level: unit -> unit
+val newty: type_desc -> type_expr
+val newgenty: type_desc -> type_expr
 val newvar: unit -> type_expr
         (* Return a fresh variable *)
 val new_global_var: unit -> type_expr
         (* Return a fresh variable, bound at toplevel
            (as type variables ['a] in type constraints). *)
+val newobj: type_expr -> type_expr
 val repr: type_expr -> type_expr
         (* Return the canonical representative of a type. *)
+val flatten_fields : type_expr -> (Label.t * type_expr) list * type_expr
+      	(* Transform a field type into a list of pairs label-type *)
 val generalize: type_expr -> unit
         (* Generalize in-place the given type *)
 val make_nongen: type_expr -> unit
         (* Make non-generalizable the given type *)
 val instance: type_expr -> type_expr
         (* Take an instance of a type scheme *)
+val instance_parameterized_type:
+      	type_expr list -> type_expr -> type_expr list * type_expr
+val instance_parameterized_type_2:
+      	type_expr list -> type_expr list -> type_expr ->
+        type_expr list * type_expr list * type_expr
 val instance_constructor:
         constructor_description -> type_expr list * type_expr
         (* Same, for a constructor *)
 val instance_label: label_description -> type_expr * type_expr
         (* Same, for a label *)
+val instance_class:
+      	class_type ->
+        type_expr list * type_expr list *
+        (mutable_flag * type_expr) Vars.t * type_expr
+val expand_abbrev :
+        Env.t -> Path.t -> type_expr list -> (Path.t * type_expr) list ref ->
+	int -> type_expr
+	(* Expand an abbreviation *)
+val occur : Env.t -> type_expr -> type_expr -> unit
+        (* [occur env var ty] Raise [Unify] if [var] occurs in [ty] *)
 val unify: Env.t -> type_expr -> type_expr -> unit
         (* Unify the two types given. Raise [Unify] if not possible. *)
 val filter_arrow: Env.t -> type_expr -> type_expr * type_expr
         (* A special case of unification (with 'a -> 'b). *)
+val filter_method:
+  Env.t -> Label.t -> Typedtree.type_expr -> Typedtree.type_expr
+      	(* A special case of unification (with {m : 'a; 'b}). *)
 val moregeneral: Env.t -> type_expr -> type_expr -> bool
         (* Check if the first type scheme is more general than the second. *)
 val equal: Env.t -> type_expr list -> type_expr ->
@@ -50,6 +74,10 @@ val equal: Env.t -> type_expr list -> type_expr ->
         (* [equal env [x1...xn] tau [y1...yn] sigma]
            checks whether the parameterized types
            [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
+val opened_object: type_expr -> bool
+val enlarge_type: Env.t -> type_expr list -> type_expr -> type_expr
+      	(* Make a type larger *)
+val subtype : Env.t -> type_expr list -> type_expr -> type_expr -> unit
 val closed_schema: type_expr -> bool
         (* Check whether the given type scheme contains no non-generic
            type variables *)
@@ -57,20 +85,35 @@ val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
         (* Return a type equivalent to the given type but without
            references to the given module identifier. Raise [Not_found]
            if no such type exists. *)
-val free_type_ident: Env.t -> Ident.t list -> type_expr -> bool
-        (* Test whether one of the given type identifiers occur free
-           in the given type expression. *)
+val nondep_class_type: Env.t -> Ident.t -> class_type -> class_type
+        (* Same for class types. *)
+val substitute:
+        (Path.t * Typedtree.type_expr) list -> type_expr list ->
+        type_expr list -> type_expr -> type_expr
+        (* [substitute [v1...vN] [t1...tN] t]
+           returns a copy of [t] where the [vi] are replaced
+           by the [ti]. *)
+val prune:
+      	type_expr -> type_expr list -> type_expr * (type_expr * type_expr) list
+val prune_class_type:
+        class_type ->
+        (type_expr * type_expr) list * type_expr list *
+      	(mutable_flag * type_expr) Vars.t * type_expr
+val close_object: type_expr -> unit
+val set_object_name:
+      	type_expr -> type_expr list -> Ident.t -> unit
+val remove_object_name: type_expr -> unit
+val expand_root: Env.t -> type_expr -> type_expr
+val correct_abbrev: Env.t -> Ident.t -> type_expr list -> type_expr -> unit
+val unroll_abbrev: Ident.t -> type_expr list -> type_expr -> type_expr
 val is_generic: type_expr -> bool
         (* Test whether the given type variable is generic *)
 val arity: type_expr -> int
         (* Return the arity (as for curried functions) of the given type. *)
 val none: type_expr
         (* A dummy type expression *)
-val substitute:
-        type_expr list -> type_expr list -> type_expr -> type_expr
-        (* [substitute [v1...vN] [t1...tN] t]
-           returns a copy of [t] where the [vi] are replaced
-           by the [ti]. *)
 
 exception Unify
-
+exception Cannot_expand
+exception Nonlinear_abbrev
+exception Recursive_abbrev
diff --git a/typing/datarepr.ml b/typing/datarepr.ml
index 0afa11e..03a3b4f 100644
--- a/typing/datarepr.ml
+++ b/typing/datarepr.ml
@@ -51,19 +51,22 @@ let exception_descr path_exc decl =
     cstr_consts = -1;
     cstr_nonconsts = -1 }
 
+let none = {desc = Ttuple []; level = -1}
+					(* Clearly ill-formed type *)
 let dummy_label =
-  { lbl_res = Ttuple []; lbl_arg = Ttuple []; lbl_mut = Immutable;
+  { lbl_res = none; lbl_arg = none; lbl_mut = Immutable;
     lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular }
 
 (* Cannot call ctype.repres here *)
 
-let rec is_float = function
-    Tvar{tvar_link = Some ty} -> is_float ty
-  | Tconstr(p, _) -> Path.same p Predef.path_float
+let rec is_float = 
+  function
+    {desc = Tlink ty} -> is_float ty
+  | {desc = Tconstr(p, _, _)} -> Path.same p Predef.path_float
   | _ -> false
 
 let label_descrs ty_res lbls =
-  let all_labels = Array.new (List.length lbls) dummy_label in
+  let all_labels = Array.create (List.length lbls) dummy_label in
   let repres =
     if List.for_all (fun (name, flag, ty) -> is_float ty) lbls
     then Record_float
diff --git a/typing/env.ml b/typing/env.ml
index 0b9f173..c42b417 100644
--- a/typing/env.ml
+++ b/typing/env.ml
@@ -36,7 +36,8 @@ type t = {
   types: (Path.t * type_declaration) Ident.tbl;
   modules: (Path.t * module_type) Ident.tbl;
   modtypes: (Path.t * modtype_declaration) Ident.tbl;
-  components: (Path.t * module_components) Ident.tbl
+  components: (Path.t * module_components) Ident.tbl;
+  classes: (Path.t * class_type) Ident.tbl
 }
 
 and module_components =
@@ -50,7 +51,8 @@ and structure_components = {
   mutable comp_types: (string, (type_declaration * int)) Tbl.t;
   mutable comp_modules: (string, (module_type * int)) Tbl.t;
   mutable comp_modtypes: (string, (modtype_declaration * int)) Tbl.t;
-  mutable comp_components: (string, (module_components * int)) Tbl.t
+  mutable comp_components: (string, (module_components * int)) Tbl.t;
+  mutable comp_classes: (string, (class_type * int)) Tbl.t
 }
 
 and functor_components = {
@@ -64,8 +66,8 @@ let empty = {
   values = Ident.empty; constrs = Ident.empty;
   labels = Ident.empty; types = Ident.empty;
   modules = Ident.empty; modtypes = Ident.empty;
-  components = Ident.empty }
+  components = Ident.empty; classes = Ident.empty }
 
 (* Persistent structure descriptions *)
 
 
@@ -170,6 +172,7 @@ let find proj1 proj2 path env =
 let find_value = find (fun env -> env.values) (fun sc -> sc.comp_values)
 and find_type = find (fun env -> env.types) (fun sc -> sc.comp_types)
 and find_modtype = find (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
+and find_class = find (fun env -> env.classes) (fun sc -> sc.comp_classes)
 
 (* Lookup by name *)
 
@@ -179,7 +182,7 @@ let rec lookup_module_descr lid env =
       begin try
         Ident.find_name s env.components
       with Not_found ->
-        (Pident(Ident.new_persistent s), (find_pers_struct s).ps_comps)
+        (Pident(Ident.create_persistent s), (find_pers_struct s).ps_comps)
       end
   | Ldot(l, s) ->
       let (p, descr) = lookup_module_descr l env in
@@ -207,7 +210,7 @@ and lookup_module lid env =
       begin try
         Ident.find_name s env.modules
       with Not_found ->
-        (Pident(Ident.new_persistent s), 
+        (Pident(Ident.create_persistent s), 
          Tmty_signature(find_pers_struct s).ps_sig)
       end
   | Ldot(l, s) ->
@@ -272,6 +275,8 @@ and lookup_type =
   lookup (fun env -> env.types) (fun sc -> sc.comp_types)
 and lookup_modtype =
   lookup (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
+and lookup_class =
+  lookup (fun env -> env.classes) (fun sc -> sc.comp_classes)
 
 (* Scrape a module type *)
 
@@ -289,7 +294,10 @@ let rec scrape_modtype mty env =
 let constructors_of_type ty_path decl =
   match decl.type_kind with
     Type_variant cstrs ->
-      Datarepr.constructor_descrs (Tconstr(ty_path, decl.type_params)) cstrs
+      Datarepr.constructor_descrs
+        {desc = Tconstr(ty_path, decl.type_params, ref []);
+      	 level = -1 (* generic_level *)}
+        cstrs
   | _ -> []
 
 (* Compute label descriptions *)
@@ -297,7 +305,10 @@ let constructors_of_type ty_path decl =
 let labels_of_type ty_path decl =
   match decl.type_kind with
     Type_record labels ->
-      Datarepr.label_descrs (Tconstr(ty_path, decl.type_params)) labels
+      Datarepr.label_descrs
+        {desc = Tconstr(ty_path, decl.type_params, ref []);
+         level = -1 (* generic_level *)}
+        labels
   | _ -> []
 
 (* Given a signature and a root path, prefix all idents in the signature
@@ -307,7 +318,7 @@ let rec prefix_idents root pos sub = function
     [] -> ([], sub)
   | Tsig_value(id, decl) :: rem ->
       let p = Pdot(root, Ident.name id, pos) in
-      let nextpos = match decl.val_prim with None -> pos+1 | Some _ -> pos in
+      let nextpos = match decl.val_kind with Val_prim _ -> pos | _ -> pos+1 in
       let (pl, final_sub) = prefix_idents root nextpos sub rem in
       (p::pl, final_sub)
   | Tsig_type(id, decl) :: rem ->
@@ -330,6 +341,12 @@ let rec prefix_idents root pos sub = function
         prefix_idents root pos
                       (Subst.add_modtype id (Tmty_ident p) sub) rem in
       (p::pl, final_sub)
+  | Tsig_class(id, decl) :: rem ->
+      let p = Pdot(root, Ident.name id, pos) in
+      let (pl, final_sub) =
+        prefix_idents root (pos + 1) sub rem
+      in
+      (p::pl, final_sub)
 
 (* Compute structure descriptions *)
 
@@ -340,7 +357,7 @@ let rec components_of_module env sub path mty =
         { comp_values = Tbl.empty; comp_constrs = Tbl.empty;
           comp_labels = Tbl.empty; comp_types = Tbl.empty;
           comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
-          comp_components = Tbl.empty } in
+          comp_components = Tbl.empty; comp_classes = Tbl.empty } in
       let (pl, sub) = prefix_idents path 0 sub sg in
       let env = ref env in
       let pos = ref 0 in
@@ -350,8 +367,8 @@ let rec components_of_module env sub path mty =
             let decl' = Subst.value_description sub decl in
             c.comp_values <-
               Tbl.add (Ident.name id) (decl', !pos) c.comp_values;
-            begin match decl.val_prim with
-              None -> incr pos | Some _ -> ()
+            begin match decl.val_kind with
+              Val_prim _ -> () | _ -> incr pos
             end
         | Tsig_type(id, decl) ->
             let decl' = Subst.type_declaration sub decl in
@@ -384,7 +401,12 @@ let rec components_of_module env sub path mty =
             let decl' = Subst.modtype_declaration sub decl in
             c.comp_modtypes <-
               Tbl.add (Ident.name id) (decl', nopos) c.comp_modtypes;
-            env := store_modtype id path decl' !env)
+            env := store_modtype id path decl' !env
+	| Tsig_class(id, decl) ->
+	    let decl' = Subst.class_type sub decl in
+            c.comp_classes <-
+              Tbl.add (Ident.name id) (decl', !pos) c.comp_classes;
+	    incr pos)
         sg pl;
 	Structure_comps c
   | Tmty_functor(param, ty_arg, ty_res) ->
@@ -398,7 +420,7 @@ let rec components_of_module env sub path mty =
       	  comp_values = Tbl.empty; comp_constrs = Tbl.empty;
           comp_labels = Tbl.empty; comp_types = Tbl.empty;
           comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
-          comp_components = Tbl.empty }
+          comp_components = Tbl.empty; comp_classes = Tbl.empty }
 
 (* Insertion of bindings by identifier + path *)
 
@@ -409,26 +431,28 @@ and store_value id path decl env =
     types = env.types;
     modules = env.modules;
     modtypes = env.modtypes;
-    components = env.components }
+    components = env.components;
+    classes = env.classes }
 
 and store_type id path info env =
   { values = env.values;
     constrs =
       List.fold_right
         (fun (name, descr) constrs ->
-          Ident.add (Ident.new name) descr constrs)
+          Ident.add (Ident.create name) descr constrs)
         (constructors_of_type path info)
         env.constrs;
     labels =
       List.fold_right
         (fun (name, descr) labels ->
-          Ident.add (Ident.new name) descr labels)
+          Ident.add (Ident.create name) descr labels)
         (labels_of_type path info)
         env.labels;
     types = Ident.add id (path, info) env.types;
     modules = env.modules;
     modtypes = env.modtypes;
-    components = env.components }
+    components = env.components;
+    classes = env.classes }
 
 and store_exception id path decl env =
   { values = env.values;
@@ -437,7 +461,8 @@ and store_exception id path decl env =
     types = env.types;
     modules = env.modules;
     modtypes = env.modtypes;
-    components = env.components }
+    components = env.components;
+    classes = env.classes }
 
 and store_module id path mty env =
   { values = env.values;
@@ -448,7 +473,8 @@ and store_module id path mty env =
     modtypes = env.modtypes;
     components =
       Ident.add id (path, components_of_module env Subst.identity path mty)
-                   env.components }
+                   env.components;
+    classes = env.classes }
 
 and store_modtype id path info env =
   { values = env.values;
@@ -457,7 +483,8 @@ and store_modtype id path info env =
     types = env.types;
     modules = env.modules;
     modtypes = Ident.add id (path, info) env.modtypes;
-    components = env.components }
+    components = env.components;
+    classes = env.classes }
 
 and store_components id path comps env =
   { values = env.values;
@@ -466,9 +493,20 @@ and store_components id path comps env =
     types = env.types;
     modules = env.modules;
     modtypes = env.modtypes;
-    components = Ident.add id (path, comps) env.components }
+    components = Ident.add id (path, comps) env.components;
+    classes = env.classes }
+
+and store_class id path desc env =
+  { values = env.values;
+    constrs = env.constrs;
+    labels = env.labels;
+    types = env.types;
+    modules = env.modules;
+    modtypes = env.modtypes;
+    components = env.components;
+    classes = Ident.add id (path, desc) env.classes }
 
 (* Memoized function to compute the components of a functor application
    in a path. *)
 let _ =
   components_of_functor_appl :=
@@ -505,11 +543,15 @@ and add_module id mty env =
 and add_modtype id info env =
   store_modtype id (Pident id) info env
 
+and add_class id ty env =
+  store_class id (Pident id) ty env
+
 (* Insertion of bindings by name *)
 
 and enter_exception = enter store_exception
 and enter_module = enter store_module
 and enter_modtype = enter store_modtype
+and enter_class = enter store_class
 
 (* Insertion of all components of a signature *)
 
@@ -525,6 +567,7 @@ let add_signature_component env comp =
   | Tsig_exception(id, decl) -> add_exception id decl env
   | Tsig_module(id, mty) -> add_module id mty env
   | Tsig_modtype(id, decl) -> add_modtype id decl env
+  | Tsig_class(id, decl) -> add_class id decl env
 
 let add_signature sg env =
   List.fold_left add_signature_component env sg
@@ -551,14 +594,17 @@ let open_signature root sg env =
           store_module (Ident.hide id) p (Subst.modtype sub mty) env
       | Tsig_modtype(id, decl) ->
           store_modtype (Ident.hide id) p
-                        (Subst.modtype_declaration sub decl) env)
+                        (Subst.modtype_declaration sub decl) env
+      | Tsig_class(id, decl) ->
+      	  store_class (Ident.hide id) p
+                      (Subst.class_type sub decl) env)
     env sg pl
 
 (* Open a signature from a file *)
 
 let open_pers_signature name env =
   let ps = find_pers_struct name in
-  open_signature (Pident(Ident.new_persistent name)) ps.ps_sig env
+  open_signature (Pident(Ident.create_persistent name)) ps.ps_sig env
 
 (* Read a signature from a file *)
 
@@ -573,7 +619,7 @@ let save_signature sg modname filename =
       ps_sig = sg;
       ps_comps =
         components_of_module empty Subst.identity
-            (Pident(Ident.new_persistent modname)) (Tmty_signature sg) } in
+	    (Pident(Ident.create_persistent modname)) (Tmty_signature sg) } in
   let oc = open_out_bin filename in
   output_string oc cmi_magic_number;
   output_value oc ps;
diff --git a/typing/env.mli b/typing/env.mli
index 8f4040c..9ebe0b3 100644
--- a/typing/env.mli
+++ b/typing/env.mli
@@ -25,6 +25,7 @@ val initial: t
 val find_value: Path.t -> t -> value_description
 val find_type: Path.t -> t -> type_declaration
 val find_modtype: Path.t -> t -> modtype_declaration
+val find_class: Path.t -> t -> class_type
 
 (* Lookup by long identifiers *)
 
@@ -34,6 +35,7 @@ val lookup_label: Longident.t -> t -> label_description
 val lookup_type: Longident.t -> t -> Path.t * type_declaration
 val lookup_module: Longident.t -> t -> Path.t * module_type
 val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
+val lookup_class: Longident.t -> t -> Path.t * class_type
 
 (* Insertion by identifier *)
 
@@ -42,6 +44,7 @@ val add_type: Ident.t -> type_declaration -> t -> t
 val add_exception: Ident.t -> exception_declaration -> t -> t
 val add_module: Ident.t -> module_type -> t -> t
 val add_modtype: Ident.t -> modtype_declaration -> t -> t
+val add_class: Ident.t -> class_type -> t -> t
 
 (* Insertion of all fields of a signature. *)
 
@@ -60,6 +63,7 @@ val enter_type: string -> type_declaration -> t -> Ident.t * t
 val enter_exception: string -> exception_declaration -> t -> Ident.t * t
 val enter_module: string -> module_type -> t -> Ident.t * t
 val enter_modtype: string -> modtype_declaration -> t -> Ident.t * t
+val enter_class: string -> class_type -> t -> Ident.t * t
 
 (* Reset the cache of in-core module interfaces.
    To be called in particular when load_path changes. *)
diff --git a/typing/ident.ml b/typing/ident.ml
index 759a974..0ecd1cd 100644
diff --git a/typing/includecore.ml b/typing/includecore.ml
index 83c9b3f..d355a60 100644
--- a/typing/includecore.ml
+++ b/typing/includecore.ml
@@ -23,12 +23,12 @@ exception Dont_match
 
 let value_descriptions env vd1 vd2 =
   if Ctype.moregeneral env vd1.val_type vd2.val_type then begin
-    match (vd1.val_prim, vd2.val_prim) with
-        (Some p1, Some p2) ->
+    match (vd1.val_kind, vd2.val_kind) with
+        (Val_prim p1, Val_prim p2) ->
           if p1 = p2 then Tcoerce_none else raise Dont_match
-      | (Some p, None) -> Tcoerce_primitive p
-      | (None, Some p) -> raise Dont_match
-      | (None, None) -> Tcoerce_none
+      | (Val_prim p, _) -> Tcoerce_primitive p
+      | (_, Val_prim p) -> raise Dont_match
+      | (_, _) -> Tcoerce_none
   end else
     raise Dont_match
 
@@ -60,8 +60,11 @@ let type_declarations env id decl1 decl2 =
     | (Some ty1, Some ty2) ->
         Ctype.equal env decl1.type_params ty1 decl2.type_params ty2
     | (None, Some ty2) ->
-        let ty1 = Tconstr(Pident id, decl2.type_params) in
-        Ctype.equal env [] ty1 [] ty2
+        let ty1 =
+	  {desc = Tconstr(Pident id, decl2.type_params, ref []);
+	   level = Ctype.generic_level }
+	in
+          Ctype.equal env [] ty1 [] ty2
   end
 
 (* Inclusion between exception declarations *)
@@ -69,3 +72,34 @@ let type_declarations env id decl1 decl2 =
 let exception_declarations env ed1 ed2 =
   for_all2 (fun ty1 ty2 -> Ctype.equal env [] ty1 [] ty2) ed1 ed2
 
+(* Inclusion between class types *)
+let vars desc =
+  Ctype.newgenty (Tobject (
+    Vars.fold
+      (fun lab (mut, ty) rem ->
+      	 let ty' = Ctype.newgenty
+	   (Ttuple [if mut = Asttypes.Mutable then Predef.type_mutable
+      	            else Ctype.newgenty Tvar;
+		    ty])
+	 in
+      	   Ctype.newgenty (Tfield (lab, ty', rem)))
+      desc.cty_vars (Ctype.newgenty Tnil),
+    ref None))
+
+let class_type env d1 d2 =
+  (* Same abbreviations *)
+  let (cstr1, _, _, self1) = Ctype.prune_class_type d1 in
+  let (cstr2, _, _, self2) = Ctype.prune_class_type d2 in
+  Ctype.equal env (List.map fst cstr1) self1 (List.map fst cstr2) self2
+      &
+  (* Same concretes methods *)
+  for_all2 Label. (=) (Sort.list Label. (=) d1.cty_concr)
+      	       	      (Sort.list Label. (=) d2.cty_concr)
+      &
+  (* If virtual, stays virtual *)
+  (d1.cty_new <> None or d2.cty_new = None)
+      &
+  (* Less general *)
+  let t1 = Ctype.newgenty (Ttuple (d1.cty_self::vars d1::d1.cty_args)) in
+  let t2 = Ctype.newgenty (Ttuple (d2.cty_self::vars d2::d2.cty_args)) in
+  Ctype.moregeneral env t1 t2
diff --git a/typing/includecore.mli b/typing/includecore.mli
index c8aa337..98680a4 100644
--- a/typing/includecore.mli
+++ b/typing/includecore.mli
@@ -23,5 +23,5 @@ val type_declarations:
         Env.t -> Ident.t -> type_declaration -> type_declaration -> bool
 val exception_declarations:
         Env.t -> exception_declaration -> exception_declaration -> bool
-
-
+val class_type:
+      	Env.t -> class_type -> class_type -> bool
diff --git a/typing/includemod.ml b/typing/includemod.ml
index e78b1d3..a5835f9 100644
--- a/typing/includemod.ml
+++ b/typing/includemod.ml
@@ -28,6 +28,7 @@ type error =
   | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
   | Modtype_permutation
   | Interface_mismatch of string * string
+  | Class_type of Ident.t * class_type * class_type
 
 exception Error of error list
 
@@ -57,6 +58,13 @@ let exception_declarations env id decl1 decl2 =
   then ()
   else raise(Error[Exception_declarations(id, decl1, decl2)])
 
+(* Inclusion between class types *)
+
+let class_type env id decl1 decl2 =
+  if Includecore.class_type env decl1 decl2
+  then ()
+  else raise(Error[Class_type(id, decl1, decl2)])
+
 (* Expand a module type identifier when possible *)
 
 exception Dont_match
@@ -77,6 +85,7 @@ type field_desc =
   | Field_exception of string
   | Field_module of string
   | Field_modtype of string
+  | Field_classtype of string
 
 let item_ident_name = function
     Tsig_value(id, _) -> (id, Field_value(Ident.name id))
@@ -84,6 +93,7 @@ let item_ident_name = function
   | Tsig_exception(id, _) -> (id, Field_exception(Ident.name id))
   | Tsig_module(id, _) -> (id, Field_module(Ident.name id))
   | Tsig_modtype(id, _) -> (id, Field_modtype(Ident.name id))
+  | Tsig_class(id, _) -> (id, Field_classtype(Ident.name id))
 
 (* Simplify a structure coercion *)
 
@@ -149,12 +159,13 @@ and signatures env sig1 sig2 =
         let (id, name) = item_ident_name item in
         let nextpos =
           match item with
-            Tsig_value(_,{val_prim = None})
-          | Tsig_exception(_,_)
-          | Tsig_module(_,_) -> pos+1
-          | Tsig_value(_,{val_prim = Some _})
+            Tsig_value(_,{val_kind = Val_prim _})
           | Tsig_type(_,_)
-          | Tsig_modtype(_,_) -> pos in
+          | Tsig_modtype(_,_) -> pos
+          | Tsig_value(_,_)
+          | Tsig_exception(_,_)
+          | Tsig_module(_,_)
+	  | Tsig_class(_, _) -> pos+1 in
         build_component_table nextpos
                               (Tbl.add name (id, item, pos) tbl) rem in
   let comps1 =
@@ -189,9 +200,9 @@ and signature_components env = function
     [] -> []
   | (Tsig_value(id1, valdecl1), Tsig_value(id2, valdecl2), pos) :: rem ->
       let cc = value_descriptions env id1 valdecl1 valdecl2 in
-      begin match valdecl2.val_prim with
-        None -> (pos, cc) :: signature_components env rem
-      | Some p -> signature_components env rem
+      begin match valdecl2.val_kind with
+        Val_prim p -> signature_components env rem
+      | _ -> (pos, cc) :: signature_components env rem
       end
   | (Tsig_type(id1, tydecl1), Tsig_type(id2, tydecl2), pos) :: rem ->
       type_declarations env id1 tydecl1 tydecl2;
@@ -206,6 +217,9 @@ and signature_components env = function
   | (Tsig_modtype(id1, info1), Tsig_modtype(id2, info2), pos) :: rem ->
       modtype_infos env id1 info1 info2;
       signature_components env rem
+  | (Tsig_class(id1, decl1), Tsig_class(id2, decl2), pos) :: rem ->
+      class_type env id1 decl1 decl2;
+      (pos, Tcoerce_none) :: signature_components env rem
   | _ ->
       fatal_error "Includemod.signature_components"
 
@@ -305,6 +319,14 @@ let include_err = function
       print_string intf_name;
       print_string ":";
       close_box()
+  | Class_type(id, d1, d2) ->
+      open_hvbox 2;
+      print_string "Class types do not match:"; print_space();
+      Printtyp.class_type id d1; 
+      print_break 1 (-2);
+      print_string "is not included in"; print_space();
+      Printtyp.class_type id d2;
+      close_box()
 
 let report_error errlist =
   match errlist with
diff --git a/typing/includemod.mli b/typing/includemod.mli
index c582c2e..e0c739e 100644
--- a/typing/includemod.mli
+++ b/typing/includemod.mli
@@ -29,6 +29,7 @@ type error =
   | Modtype_infos of Ident.t * modtype_declaration * modtype_declaration
   | Modtype_permutation
   | Interface_mismatch of string * string
+  | Class_type of Ident.t * class_type * class_type
 
 exception Error of error list
 
diff --git a/typing/mtype.ml b/typing/mtype.ml
index 691fc04..6cfea5b 100644
--- a/typing/mtype.ml
+++ b/typing/mtype.ml
@@ -50,8 +50,10 @@ and strengthen_sig env sg p =
             { type_params = decl.type_params;
               type_arity = decl.type_arity;
               type_kind = decl.type_kind;
-              type_manifest = Some(Tconstr(Pdot(p, Ident.name id, nopos),
-                                                decl.type_params)) }
+              type_manifest = Some(Ctype.newgenty(
+	       		           Tconstr(Pdot(p, Ident.name id, nopos),
+                                           decl.type_params,
+					   ref []))) }
         | _ -> decl in
       Tsig_type(id, newdecl) :: strengthen_sig env rem p
   | (Tsig_exception(id, d) as sigelt) :: rem ->
@@ -70,6 +72,8 @@ and strengthen_sig env sg p =
       Tsig_modtype(id, newdecl) ::
       strengthen_sig (Env.add_modtype id decl env) rem p
       (* Need to add the module type in case it is manifest *)
+  | (Tsig_class(id, decl) as sigelt) :: rem ->
+      sigelt :: strengthen_sig env rem p
 
 (* In nondep_supertype, env is only used for the type it assigns to id.
    Hence there is no need to keep env up-to-date by adding the bindings
@@ -79,45 +83,47 @@ type variance = Co | Contra | Strict
 
 let nondep_supertype env mid mty =
 
-  let rec nondep_mty var mty =
+  let rec nondep_mty va mty =
     match mty with
       Tmty_ident p ->
         if Path.isfree mid p then begin
           match Env.find_modtype p env with
             Tmodtype_abstract -> raise Not_found
-          | Tmodtype_manifest mty -> nondep_mty var mty      
+          | Tmodtype_manifest mty -> nondep_mty va mty      
         end else mty
     | Tmty_signature sg ->
-        Tmty_signature(nondep_sig var sg)
+        Tmty_signature(nondep_sig va sg)
     | Tmty_functor(param, arg, res) ->
         let var_inv =
-          match var with Co -> Contra | Contra -> Co | Strict -> Strict in
-        Tmty_functor(param, nondep_mty var_inv arg, nondep_mty var res)
+          match va with Co -> Contra | Contra -> Co | Strict -> Strict in
+        Tmty_functor(param, nondep_mty var_inv arg, nondep_mty va res)
 
-  and nondep_sig var = function
+  and nondep_sig va = function
     [] -> []
   | item :: rem ->
-      let rem' = nondep_sig var rem in
+      let rem' = nondep_sig va rem in
       match item with
         Tsig_value(id, d) ->
           Tsig_value(id, {val_type = Ctype.nondep_type env mid d.val_type;
-                          val_prim = d.val_prim}) :: rem'
+                          val_kind = d.val_kind}) :: rem'
       | Tsig_type(id, d) ->
-          Tsig_type(id, nondep_type_decl var d) :: rem'
+          Tsig_type(id, nondep_type_decl va d) :: rem'
       | Tsig_exception(id, d) ->
           Tsig_exception(id, List.map (Ctype.nondep_type env mid) d) :: rem'
       | Tsig_module(id, mty) ->
-          Tsig_module(id, nondep_mty var mty) :: rem'
+          Tsig_module(id, nondep_mty va mty) :: rem'
       | Tsig_modtype(id, d) ->
           begin try
             Tsig_modtype(id, nondep_modtype_decl d) :: rem'
           with Not_found ->
-            match var with
+            match va with
               Co -> Tsig_modtype(id, Tmodtype_abstract) :: rem'
             | _  -> raise Not_found
           end
+      | Tsig_class(id, d) ->
+          Tsig_class(id, Ctype.nondep_class_type env mid d) :: rem'
 
-  and nondep_type_decl var d =
+  and nondep_type_decl va d =
     {type_params = d.type_params;
      type_arity = d.type_arity;
      type_kind =
@@ -134,7 +140,7 @@ let nondep_supertype env mid mty =
                (fun (c, mut, t) -> (c, mut, Ctype.nondep_type env mid t))
                lbls)
        with Not_found ->
-         match var with Co -> Type_abstract | _ -> raise Not_found
+         match va with Co -> Type_abstract | _ -> raise Not_found
        end;
      type_manifest =
        begin try
@@ -142,7 +148,7 @@ let nondep_supertype env mid mty =
            None -> None
          | Some ty -> Some(Ctype.nondep_type env mid ty)
        with Not_found ->
-         match var with Co -> None | _ -> raise Not_found
+         match va with Co -> None | _ -> raise Not_found
        end}
 
   and nondep_modtype_decl = function
diff --git a/typing/parmatch.ml b/typing/parmatch.ml
index 2d18939..0ac7a54 100644
diff --git a/typing/predef.ml b/typing/predef.ml
index 8da5734..742ea89 100644
--- a/typing/predef.ml
+++ b/typing/predef.ml
@@ -17,16 +17,21 @@ open Path
 open Typedtree
 
 
-let ident_int = Ident.new "int"
-and ident_char = Ident.new "char"
-and ident_string = Ident.new "string"
-and ident_float = Ident.new "float"
-and ident_bool = Ident.new "bool"
-and ident_unit = Ident.new "unit"
-and ident_exn = Ident.new "exn"
-and ident_array = Ident.new "array"
-and ident_list = Ident.new "list"
-and ident_format = Ident.new "format"
+let newgenty desc =
+  {desc = desc; level = -1 (* generic_level *)}
+
+let ident_int = Ident.create "int"
+and ident_char = Ident.create "char"
+and ident_string = Ident.create "string"
+and ident_float = Ident.create "float"
+and ident_bool = Ident.create "bool"
+and ident_unit = Ident.create "unit"
+and ident_exn = Ident.create "exn"
+and ident_array = Ident.create "array"
+and ident_list = Ident.create "list"
+and ident_format = Ident.create "format"
+and ident_mutable = Ident.create "(mutable)"
+and ident_immutable = Ident.create "(immutable)"
 
 let path_int = Pident ident_int
 and path_char = Pident ident_char
@@ -38,25 +43,29 @@ and path_exn = Pident ident_exn
 and path_array = Pident ident_array
 and path_list = Pident ident_list
 and path_format = Pident ident_format
+and path_mutable = Pident ident_mutable
+and path_immutable = Pident ident_immutable
 
-let type_int = Tconstr(path_int, [])
-and type_char = Tconstr(path_char, [])
-and type_string = Tconstr(path_string, [])
-and type_float = Tconstr(path_float, [])
-and type_bool = Tconstr(path_bool, [])
-and type_unit = Tconstr(path_unit, [])
-and type_exn = Tconstr(path_exn, [])
-and type_array t = Tconstr(path_array, [t])
-and type_list t = Tconstr(path_list, [t])
+let type_int = newgenty (Tconstr(path_int, [], ref []))
+and type_char = newgenty (Tconstr(path_char, [], ref []))
+and type_string = newgenty (Tconstr(path_string, [], ref []))
+and type_float = newgenty (Tconstr(path_float, [], ref []))
+and type_bool = newgenty (Tconstr(path_bool, [], ref []))
+and type_unit = newgenty (Tconstr(path_unit, [], ref []))
+and type_exn = newgenty (Tconstr(path_exn, [], ref []))
+and type_array t = newgenty (Tconstr(path_array, [t], ref []))
+and type_list t = newgenty (Tconstr(path_list, [t], ref []))
+and type_mutable = newgenty (Tconstr(path_mutable, [], ref []))
+and type_immutable = newgenty (Tconstr(path_immutable, [], ref []))
 
-let ident_match_failure = Ident.new "Match_failure"
-and ident_out_of_memory = Ident.new "Out_of_memory"
-and ident_invalid_argument = Ident.new "Invalid_argument"
-and ident_failure = Ident.new "Failure"
-and ident_not_found = Ident.new "Not_found"
-and ident_sys_error = Ident.new "Sys_error"
-and ident_end_of_file = Ident.new "End_of_file"
-and ident_division_by_zero = Ident.new "Division_by_zero"
+let ident_match_failure = Ident.create "Match_failure"
+and ident_out_of_memory = Ident.create "Out_of_memory"
+and ident_invalid_argument = Ident.create "Invalid_argument"
+and ident_failure = Ident.create "Failure"
+and ident_not_found = Ident.create "Not_found"
+and ident_sys_error = Ident.create "Sys_error"
+and ident_end_of_file = Ident.create "End_of_file"
+and ident_division_by_zero = Ident.create "Division_by_zero"
 
 let path_match_failure = Pident ident_match_failure
 
@@ -64,7 +73,7 @@ let build_initial_env add_type add_exception empty_env =
   let newvar() =
     (* Cannot call the real newvar from ctype here
        because ctype imports predef via env *)
-    Tvar{tvar_level = -1 (*generic_level*); tvar_link = None} in
+    {desc = Tvar; level = -1 (*generic_level*)} in
   let decl_abstr =
     {type_params = [];
      type_arity = 0;
@@ -103,7 +112,7 @@ let build_initial_env add_type add_exception empty_env =
      type_kind = Type_abstract;
      type_manifest = None} in
 
-  add_exception ident_match_failure [Ttuple[type_string; type_int; type_int]] (
+  add_exception ident_match_failure [newgenty (Ttuple[type_string; type_int; type_int])] (
   add_exception ident_out_of_memory [] (
   add_exception ident_invalid_argument [type_string] (
   add_exception ident_failure [type_string] (
@@ -111,6 +120,8 @@ let build_initial_env add_type add_exception empty_env =
   add_exception ident_sys_error [type_string] (
   add_exception ident_end_of_file [] (
   add_exception ident_division_by_zero [] (
+  add_type ident_immutable decl_abstr (
+  add_type ident_mutable decl_abstr (
   add_type ident_format decl_format (
   add_type ident_list decl_list (
   add_type ident_array decl_array (
@@ -121,7 +132,7 @@ let build_initial_env add_type add_exception empty_env =
   add_type ident_string decl_abstr (
   add_type ident_char decl_abstr (
   add_type ident_int decl_abstr (
-    empty_env))))))))))))))))))
+    empty_env))))))))))))))))))))
 
 let builtin_values =
   List.map (fun id -> Ident.make_global id; (Ident.name id, id))
diff --git a/typing/predef.mli b/typing/predef.mli
index f35f7d8..18a5c8c 100644
--- a/typing/predef.mli
+++ b/typing/predef.mli
@@ -24,6 +24,8 @@ val type_unit: type_expr
 val type_exn: type_expr
 val type_array: type_expr -> type_expr
 val type_list: type_expr -> type_expr
+val type_mutable: type_expr
+val type_immutable: type_expr
 
 val path_int: Path.t
 val path_char: Path.t
diff --git a/typing/printtyp.ml b/typing/printtyp.ml
index caf233c..8879a67 100644
--- a/typing/printtyp.ml
+++ b/typing/printtyp.ml
@@ -13,6 +13,8 @@
 
 (* Printing functions *)
 
+open Misc
+open Ctype
 open Format
 open Longident
 open Path
@@ -49,32 +51,101 @@ let rec path = function
 
 (* Print a type expression *)
 
-let var_names = ref ([] : (type_expr * string) list)
-let var_counter = ref 0
+let names = ref ([] : (type_expr * string) list)
+let name_counter = ref 0
 
-let reset_var_names () = var_names := []; var_counter := 0
+let reset_names () = names := []; name_counter := 0
 
-let name_of_var v =
-  try
-    List.assq v !var_names
-  with Not_found ->
-    let name = 
-      if !var_counter < 26
-      then String.make 1 (Char.chr(97 + !var_counter)) 
-      else String.make 1 (Char.chr(97 + !var_counter mod 26)) ^
-           string_of_int(!var_counter / 26) in
-    var_names := (v, name) :: !var_names;
-    incr var_counter;
+let new_name () =
+  let name =
+    if !name_counter < 26
+    then String.make 1 (Char.chr(97 + !name_counter)) 
+    else String.make 1 (Char.chr(97 + !name_counter mod 26)) ^
+           string_of_int(!name_counter / 26)
+  in
+    incr name_counter;
     name
 
-let rec typexp sch prio = function
-    Tvar {tvar_link = Some ty} ->
-      typexp sch prio ty
-  | Tvar {tvar_link = None; tvar_level = lvl} as v ->
-      if (not sch) or lvl = -1 (* generic *)
+let name_of_type t =
+  try List.assq t !names with Not_found ->
+    let name = new_name () in
+    names := (t, name) :: !names;
+    name
+
+let rec list_removeq a =
+  function
+    [] ->
+      []
+  | (b, _) as e::l ->
+      if a == b then l else e::list_removeq a l
+
+let remove_name_of_type t =
+  names := list_removeq t !names
+
+let visited_objects = ref ([] : type_expr list)
+let aliased = ref ([] : type_expr list)
+
+let rec mark_loops_rec visited ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar			  -> ()
+  | Tarrow(ty1, ty2)              ->
+      mark_loops_rec visited ty1; mark_loops_rec visited ty2
+  | Ttuple tyl		          -> List.iter (mark_loops_rec visited) tyl
+  | Tconstr(_, tyl, _)		  ->
+      if List.memq ty visited then begin
+      	if not (List.memq ty !aliased) then
+	  aliased := ty :: !aliased
+      end else
+        List.iter (mark_loops_rec (ty::visited)) tyl
+  | Tobject (fi, nm) ->
+      if List.memq ty !visited_objects or List.memq ty visited then begin
+      	if not (List.memq ty !aliased) then
+	  aliased := ty :: !aliased
+      end else begin
+      	if opened_object ty then
+	  visited_objects := ty :: !visited_objects;
+        let name =
+          match !nm with
+            None -> None
+          | Some (n, v::l) ->
+	      let v' = repr v in
+      	      begin match v'.desc with
+	        Tvar -> Some (n, v'::l)
+	      | _    -> None
+	      end
+          | _ ->
+      	      fatal_error "Printtyp.mark_loops_rec"
+        in
+	nm := name;
+	begin match !nm with
+	  None ->
+	    mark_loops_rec (ty::visited) fi
+	| Some (_, l) ->
+	    List.iter (mark_loops_rec (ty::visited)) l
+	end
+      end
+  | Tfield(_, ty1, ty2)		  ->
+      mark_loops_rec visited ty1; mark_loops_rec visited ty2
+  | Tnil			  -> ()
+  | Tlink _			  -> fatal_error "Printtyp.mark_loops_rec (2)"
+
+let mark_loops ty = mark_loops_rec [] ty
+
+let reset_loop_marks () =
+  visited_objects := []; aliased := []
+
+let reset () =
+  reset_names (); reset_loop_marks ()
+
+let rec typexp sch prio ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      if (not sch) or ty.level = generic_level
       then print_string "'"
       else print_string "'_";
-      print_string(name_of_var v)
+      print_string(name_of_type ty)
   | Tarrow(ty1, ty2) ->
       if prio >= 1 then begin open_hovbox 1; print_string "(" end
                    else open_hovbox 0;
@@ -89,18 +160,41 @@ let rec typexp sch prio = function
       typlist sch 2 " *" tyl;
       if prio >= 2 then print_string ")";
       close_box()
-  | Tconstr(p, tyl) ->
+  | Tconstr(p, tyl, _) ->
       open_hovbox 0;
-      begin match tyl with
-        [] -> ()
-      | [ty1] ->
-          typexp sch 2 ty1; print_space()
-      | tyl ->
-          open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
-          print_string ")"; close_box(); print_space()
+      begin try
+        List.assq ty !names;
+        print_string "'";
+        print_string (name_of_type ty)
+      with Not_found ->
+        if List.memq ty !aliased then begin
+          name_of_type ty;
+          if prio >= 1 then begin open_hovbox 1; print_string "(" end
+	end;
+        open_hovbox 0;
+        begin match tyl with
+          [] -> ()
+        | [ty1] ->
+            typexp sch 2 ty1; print_space()
+        | tyl ->
+            open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
+            print_string ")"; close_box(); print_space()
+        end;
+        path p;
+        close_box();
+        if List.memq ty !aliased then begin
+          print_string " as ";
+          print_string "'";
+          print_string (name_of_type ty);
+	  remove_name_of_type ty;
+          if prio >= 1 then begin print_string ")"; close_box () end
+        end
       end;
-      path p;
       close_box()
+  | Tobject (fi, nm) ->
+      typobject sch prio ty fi nm
+  | _ ->
+      fatal_error "Printtyp.typexp"
 
 and typlist sch prio sep = function
     [] -> ()
@@ -109,19 +203,99 @@ and typlist sch prio sep = function
       typexp sch prio ty; print_string sep; print_space();
       typlist sch prio sep tyl
 
-let type_expr ty = typexp false 0 ty
-and type_scheme ty = reset_var_names(); typexp true 0 ty
+and typobject sch prio ty fi nm =
+  try
+    List.assq ty !names;
+    print_string "'";
+    print_string (name_of_type ty)
+  with Not_found ->
+    if List.memq ty !aliased then begin
+      name_of_type ty;
+      if prio >= 1 then begin open_hovbox 1; print_string "(" end
+    end;
+    begin match !nm with
+      None ->
+        open_hovbox 2;
+        print_string "< ";
+        (let (fields, rest) = flatten_fields fi in
+           typfields sch rest fields);
+        print_string " >";
+        close_box ()
+    | Some (p, {desc = Tvar}::tyl) ->
+        open_hovbox 0;
+        begin match tyl with
+          [] -> ()
+        | [ty1] ->
+            typexp sch 2 ty1; print_space()
+        | tyl ->
+            open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
+            print_string ")"; close_box(); print_space()
+        end;
+	if sch & ty.level <> generic_level then
+	  print_string "_";
+	print_string "#";
+        path p;
+        close_box()
+    | _ ->
+      	fatal_error "Printtyp.typobject"
+    end;
+    if List.memq ty !aliased then begin
+      print_string " as ";
+      print_string "'";
+      print_string (name_of_type ty);
+      if not (opened_object ty) then
+      	remove_name_of_type ty;
+      if prio >= 1 then begin print_string ")"; close_box () end
+    end
+
+and typfields sch rest =
+  function
+    [] ->
+      begin match rest.desc with
+      	Tvar -> if sch & rest.level <> generic_level then
+      	       	  print_string "_";
+      	       	print_string ".."
+      | Tnil -> ()
+      | _    -> fatal_error "typfields (1)"
+      end
+  | [(s, t)] ->
+      print_string s.Label.lab_name;
+      print_string " : ";
+      typexp sch 0 t;
+      begin match rest.desc with
+      	Tvar -> print_string ";"; print_space ()
+      | Tnil -> ()
+      | _    -> fatal_error "typfields (2)"
+      end;
+      typfields sch rest []
+  | (s, t)::l ->
+      print_string s.Label.lab_name;
+      print_string " : ";
+      typexp sch 0 t;
+      print_string ";"; print_space ();
+      typfields sch rest l
+
+let type_expr ty =
+  typexp false 0 ty
+
+and type_sch ty =
+  typexp true 0 ty
+
+and type_scheme ty =
+  reset(); mark_loops ty; typexp true 0 ty
 
 (* Print one type declaration *)
 
 let rec type_declaration id decl =
-  reset_var_names();
+  reset();
   open_hvbox 2;
   print_string "type ";
-  type_expr (Tconstr(Pident id, decl.type_params));
+  type_expr {desc = Tconstr(Pident id, decl.type_params, ref []);
+  	     level = generic_level};
   begin match decl.type_manifest with
     None -> ()
-  | Some ty -> print_string " ="; print_space(); type_expr ty
+  | Some ty ->
+      print_string " ="; print_space(); mark_loops ty; type_expr ty
   end;
   begin match decl.type_kind with
     Type_abstract -> ()
@@ -130,10 +304,10 @@ let rec type_declaration id decl =
   | Type_variant (cstr1 :: cstrs) ->
       print_string " ="; print_break 1 2;
       constructor cstr1;
-      List.iter
-        (fun cstr -> print_space(); print_string "| "; constructor cstr)
-        cstrs
-  | Type_record (lbl1 :: lbls) ->
+      List.iter (fun cstr -> print_space(); print_string "| "; constructor cstr)
+              cstrs
+  | Type_record (lbl1 :: lbls as l) ->
+      List.iter (fun (_, _, ty) -> mark_loops ty) l;
       print_string " ="; print_space();
       print_string "{ "; label lbl1;
       List.iter
@@ -170,14 +344,185 @@ let value_description id decl =
   open_hovbox 2;
   print_string "val "; ident id; print_string " :"; print_space();
   type_scheme decl.val_type;
-  begin match decl.val_prim with
-    None -> ()
-  | Some p -> print_space(); print_string "= "; Primitive.print_description p
+  begin match decl.val_kind with
+    Val_prim p ->
+      print_space(); print_string "= "; Primitive.print_description p
+  | _ -> ()
   end;
   close_box()
 
+(* Print a class type *)
+
+let list_state = ref []
+let start_list sp =
+  list_state := false::!list_state;
+  if sp then print_space ()
+let list_item () =
+  match !list_state with
+    false::l -> list_state := true::l
+  | _        -> print_space ()
+let end_list sp =
+  if sp & (List.hd !list_state) then print_break 1 (-2);
+  list_state := List.tl !list_state
+
+let class_arg arg =
+  print_space ();
+  open_hovbox 1; print_string "(";
+  type_sch arg;
+  print_string ")"; close_box ()
+
+let constrain (v, ty) =
+  open_hovbox 2;
+  type_sch v;
+  print_string " =";
+  print_space();
+  type_sch ty;
+  close_box()
+
+let class_var l (m, t) =
+  list_item ();
+  open_hovbox 2;
+  print_string "val ";
+  begin match m with
+    Immutable -> ()
+  | Mutable -> print_string "mutable "
+  end;
+  print_string l.Label.lab_name;
+  print_string " :";
+  print_space();
+  type_sch t;
+  close_box()
+
+let metho kind (l, t) =
+  list_item ();
+  open_hovbox 2;
+  print_string kind;
+  print_string l.Label.lab_name;
+  print_string " :";
+  print_space();
+  type_sch t;
+  close_box()
+
+let rec and_sep_list pr =
+  function
+    [] ->
+      ()
+  | [e] ->
+      pr e
+  | e::l ->
+      pr e;
+      print_break 1 (-2);
+      print_string "and ";
+      and_sep_list pr l
+
+let methods_of_type ty =
+  match (repr ty).desc with
+    Tobject (m, _) -> m
+  | _              -> fatal_error "Printtyp.methods_of_type"
+
+let rec list_meths ty =
+  match (repr ty).desc with
+    Tfield(lab, ty, ty') -> (lab, ty) :: (list_meths ty')
+  | _ 			 -> []
+
+let class_type id cl_ty =
+  begin_def ();
+  let (cstr, args, vars, self) = Ctype.prune_class_type cl_ty in
+  end_def ();
+  List.iter (fun (v, c) -> generalize v; generalize c) cstr;
+  List.iter generalize args;
+  Vars.iter (fun l (m, t) -> generalize t) vars;
+  generalize self;
+
+  let self = repr self in
+  let params = List.map fst cstr in
+  let cstr =
+    List.fold_right
+      (fun ((v, ty) as c) l -> if v == ty then l else c::l) cstr []
+  in
+  reset ();
+					(* Self may have a name *)
+  visited_objects := self :: !visited_objects;
+  begin match self.desc with
+    Tobject (fi, _) -> mark_loops fi
+  | _               -> fatal_error "Printtyp.class_type"
+  end;
+  List.iter mark_loops args;
+  List.iter (fun (_, ty) -> mark_loops ty) cstr;
+  Vars.iter (fun _ (_, ty) -> mark_loops ty) vars;
+  open_hvbox 2;
+  open_hovbox 0;
+  print_string "class ";
+  if cl_ty.cty_new = None then
+    print_string "virtual ";
+  if not (opened_object self) then
+    print_string "closed ";
+  type_sch
+    {desc = Tconstr(Pident id, params, ref []); level = 0};
+  if List.memq self !aliased then
+    (name_of_type self; ());
+  List.iter class_arg args;
+  if List.memq self !aliased then begin
+    print_string " : ";
+    print_string "'";
+    print_string (name_of_type self)
+  end;
+  print_space ();
+  print_string "=";
+  close_box ();
+  start_list true;
+  open_hvbox 0;
+  if cstr <> [] then begin
+    list_item ();
+    open_hvbox 2;
+    print_string "constraint ";
+    and_sep_list constrain cstr;
+    close_box()
+  end;
+  if vars <> Vars.empty then begin
+    list_item ();
+    open_hvbox 0;
+    start_list false;
+    Vars.iter class_var vars;
+    end_list false;
+    close_box ()
+  end;
+  let meths = list_meths (methods_of_type self) in
+  let (meths, virt) =
+    List.fold_right
+      (fun ((lab, ty) as m) (ml, vl) ->
+      	 if List.exists (fun lab' -> Label. (=) lab lab') cl_ty.cty_concr then
+	   (m::ml, vl)
+	 else
+	   (ml, m::vl))
+      meths
+      ([], [])
+  in
+  if meths <> [] then begin
+    list_item ();
+    open_hvbox 0;
+    start_list false;
+    List.iter (metho "method ") meths;
+    close_box ();
+    end_list false
+  end;
+  if virt <> [] then begin
+    list_item ();
+    open_hvbox 0;
+    start_list false;
+    List.iter (metho "virtual ") virt;
+    close_box ();
+    end_list false
+  end;
+  close_box();
+  end_list true;
+  print_string "end";
+  close_box()
+
 (* Print a module type *)
 
+let hidden = ref 0
+
 let rec modtype = function
     Tmty_ident p ->
       path p
@@ -186,10 +531,13 @@ let rec modtype = function
   | Tmty_signature(item :: rem) ->
       open_hvbox 2;
       print_string "sig"; print_space(); 
+      hidden := 0;
       signature_item item;
       List.iter
-        (fun item -> print_space(); signature_item item)
-      rem;
+        (fun item ->
+           if !hidden > 0 then decr hidden
+           else begin print_space(); signature_item item end)
+        rem;
       print_break 1 (-2); print_string "end";
       close_box()
   | Tmty_functor(param, ty_arg, ty_res) ->
@@ -213,6 +561,9 @@ and signature_item = function
       print_space(); modtype mty; close_box()
   | Tsig_modtype(id, decl) ->
       modtype_declaration id decl
+  | Tsig_class(id, decl) ->
+      hidden := 2;
+      class_type id decl
 
 and modtype_declaration id decl =
   open_hovbox 2; print_string "module type "; ident id;
@@ -228,5 +579,10 @@ and modtype_declaration id decl =
 
 let signature sg =
   open_vbox 0;
-  List.iter (fun item -> signature_item item; print_space()) sg;
+  hidden := 0;
+  List.iter
+    (fun item ->
+       if !hidden > 0 then decr hidden
+       else begin signature_item item; print_space() end)
+    sg;
   close_box()
diff --git a/typing/printtyp.mli b/typing/printtyp.mli
index 6bad01b..96cc876 100644
--- a/typing/printtyp.mli
+++ b/typing/printtyp.mli
@@ -18,7 +18,8 @@ open Typedtree
 val longident: Longident.t -> unit
 val ident: Ident.t -> unit
 val path: Path.t -> unit
-val reset_var_names: unit -> unit
+val reset: unit -> unit
+val mark_loops: type_expr -> unit
 val type_expr: type_expr -> unit
 val type_scheme: type_expr -> unit
 val value_description: Ident.t -> value_description -> unit
@@ -28,3 +29,4 @@ val modtype: module_type -> unit
 val signature: signature -> unit
 val signature_item: signature_item -> unit
 val modtype_declaration: Ident.t -> modtype_declaration -> unit
+val class_type: Ident.t -> class_type -> unit
diff --git a/typing/subst.ml b/typing/subst.ml
index 5f14a94..2a73ea9 100644
--- a/typing/subst.ml
+++ b/typing/subst.ml
@@ -57,17 +57,108 @@ let type_path s = function
   | Papply(p1, p2) ->
       fatal_error "Subst.type_path"
 
-let rec type_expr s = function
-    Tvar{tvar_link = None} as ty -> ty
-  | Tvar{tvar_link = Some ty} -> type_expr s ty
-  | Tarrow(t1, t2) -> Tarrow(type_expr s t1, type_expr s t2)
-  | Ttuple tl -> Ttuple(List.map (type_expr s) tl)
-  | Tconstr(p, []) -> Tconstr(type_path s p, [])
-  | Tconstr(p, tl) -> Tconstr(type_path s p, List.map (type_expr s) tl)
+(* From Ctype *)
+let rec repr = function
+    {desc = Tlink ty} as t ->
+      let r = repr ty in
+      if r != ty then t.desc <- Tlink r;
+      r
+  | t -> t
+
+(* From Ctype *)
+let rec opened ty =
+  match (repr ty).desc with
+    Tfield(_, _, t) -> opened t
+  | Tvar            -> true
+  | Tnil            -> false
+  | _               -> fatal_error "Subst.opened"
+
+let generic_level = -1
+
+let newgenty desc =
+  {desc = desc; level = generic_level}
+
+let new_val = ref []
+
+type 'a visited = Zero | One | Many of 'a
+
+let rec typexp visited s ty =
+  let ty = repr ty in
+  if ty.desc = Tvar then ty else
+  try
+    match List.assq ty visited with
+      {contents = Zero} as v ->
+      	let t = newgenty Tvar in
+	v := Many t;
+	let ty' = typexp_2 visited s ty v in
+	t.desc <- ty'.desc;
+	t
+    | {contents = One} as v ->
+        let t = newgenty Tvar in
+        v := Many t;
+        t
+    | {contents = Many t} ->
+        t
+  with Not_found ->
+    let v = ref One in
+    let ty' = typexp_2 ((ty, v)::visited) s ty v in
+    match v with
+      {contents = Many t} ->
+      	t.desc <- ty'.desc;
+	t
+    | _ ->
+      	ty'
+
+and typexp_2 visited s ty v =
+  match ty.desc with
+    Tvar ->
+      ty
+  | Tarrow(t1, t2) ->
+      newgenty(Tarrow(typexp visited s t1, typexp visited s t2))
+  | Ttuple tl ->
+      newgenty(Ttuple(List.map (typexp visited s) tl))
+  | Tconstr(p, [], _) ->
+      newgenty(Tconstr(type_path s p, [], ref []))
+  | Tconstr(p, tl, _) ->
+      newgenty(Tconstr(type_path s p, List.map (typexp visited s) tl, ref []))
+  | Tobject (t1, name) ->
+      let ty' () =
+      	let name' =
+          match !name with
+            None -> None
+          | Some (p, tl) ->
+              Some (type_path s p, List.map (typexp visited s) tl)
+	in
+        newgenty(Tobject (typexp visited s t1, ref name'))
+      in
+      if opened t1 then
+        try
+          List.assq ty !new_val
+        with Not_found ->
+          if v = ref One then begin
+            let t = newgenty Tvar in
+    	    v := Many t;
+            new_val := (ty, t):: !new_val
+          end;
+          ty' ()
+      else
+        ty' ()
+  | Tfield(n, t1, t2) ->
+      newgenty(Tfield(n, typexp visited s t1, typexp visited s t2))
+  | Tnil ->
+      newgenty Tnil
+  | Tlink _ ->
+      fatal_error "Subst.typexp"
+
+let type_expr s ty =
+  new_val := [];
+  let ty = typexp [] s ty in
+  new_val := [];
+  ty
 
 let value_description s descr =
   { val_type = type_expr s descr.val_type;
-    val_prim = descr.val_prim }
+    val_kind = descr.val_kind }
 
 let type_declaration s decl =
   { type_params = decl.type_params;
@@ -92,6 +183,26 @@ let type_declaration s decl =
 let exception_declaration s tyl =
   List.map (type_expr s) tyl
 
+let class_type s decl =
+  new_val := [];
+  let params = List.map (function p -> (repr p, ref Zero)) decl.cty_params in
+  let decl =
+    { cty_params = List.map (typexp params s) decl.cty_params;
+      cty_args = List.map (typexp params s) decl.cty_args;
+      cty_vars =
+        Vars.fold (fun l (m, t) -> Vars.add l (m, typexp params s t))
+          decl.cty_vars Vars.empty;
+      cty_self = typexp params s decl.cty_self;
+      cty_concr = decl.cty_concr;
+      cty_new =
+        begin match decl.cty_new with
+      	  None    -> None
+        | Some ty -> Some (typexp params s ty)
+      	end }
+  in
+    new_val := [];
+    decl
+
 let rec modtype s = function
     Tmty_ident p as mty ->
       begin match p with
@@ -115,6 +226,7 @@ and signature_item s = function
   | Tsig_exception(id, d) -> Tsig_exception(id, exception_declaration s d)
   | Tsig_module(id, mty) -> Tsig_module(id, modtype s mty)
   | Tsig_modtype(id, d) -> Tsig_modtype(id, modtype_declaration s d)
+  | Tsig_class(id, d) -> Tsig_class(id, class_type s d)
 
 and modtype_declaration s = function
     Tmodtype_abstract -> Tmodtype_abstract
diff --git a/typing/subst.mli b/typing/subst.mli
index 9bb374a..98cbe27 100644
--- a/typing/subst.mli
+++ b/typing/subst.mli
@@ -28,7 +28,7 @@ val value_description: t -> value_description -> value_description
 val type_declaration: t -> type_declaration -> type_declaration
 val exception_declaration:
         t -> exception_declaration -> exception_declaration
+val class_type: t -> class_type -> class_type
 val modtype: t -> module_type -> module_type
 val signature: t -> signature -> signature
 val modtype_declaration: t -> modtype_declaration -> modtype_declaration
-
diff --git a/typing/typeclass.ml b/typing/typeclass.ml
new file mode 100644
index 0000000..f0cb0e2
--- /dev/null
+++ b/typing/typeclass.ml
@@ -0,0 +1,10 @@
+(***********************************************************************)
+(*                                                                     *)
+(*                         Caml Special Light                          *)
+(*                                                                     *)
+(*         Jerome Vouillon, projet Cristal, INRIA Rocquencourt         *)
+(*                                                                     *)
+(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
+(*  Automatique.  Distributed only by permission.                      *)
+(*                                                                     *)
+(***********************************************************************)
diff --git a/typing/typecore.ml b/typing/typecore.ml
index 89937df..ea77828 100644
--- a/typing/typecore.ml
+++ b/typing/typecore.ml
@@ -35,6 +35,14 @@ type error =
   | Label_missing
   | Label_not_mutable of Longident.t
   | Bad_format of string
+  | Undefined_method_err of Label.t
+  | Unbound_class of Longident.t
+  | Virtual_class of Longident.t
+  | Unbound_instance_variable of string
+  | Instance_variable_not_mutable of string
+  | Not_subtype of type_expr * type_expr
+  | Outside_class
+  | Value_multiply_overridden of string
 
 exception Error of Location.t * error
 
@@ -59,7 +67,7 @@ let pattern_variables = ref ([]: (Ident.t * type_expr) list)
 let enter_variable loc name ty =
   if List.exists (fun (id, ty) -> Ident.name id = name) !pattern_variables
   then raise(Error(loc, Multiply_bound_variable));
-  let id = Ident.new name in
+  let id = Ident.create name in
   pattern_variables := (id, ty) :: !pattern_variables;
   id
 
@@ -89,7 +97,7 @@ let rec type_pat env sp =
       let pl = List.map (type_pat env) spl in
       { pat_desc = Tpat_tuple pl;
         pat_loc = sp.ppat_loc;
-        pat_type = Ttuple(List.map (fun p -> p.pat_type) pl) }
+        pat_type = newty (Ttuple(List.map (fun p -> p.pat_type) pl)) }
   | Ppat_construct(lid, sarg) ->
       let constr =
         try
@@ -154,7 +162,7 @@ let add_pattern_variables env =
   pattern_variables := [];
   List.fold_right
     (fun (id, ty) env ->
-      Env.add_value id {val_type = ty; val_prim = None} env)
+      Env.add_value id {val_type = ty; val_kind = Val_reg} env)
     pv env
 
 let type_pattern env spat =
@@ -188,6 +196,7 @@ let rec is_nonexpansive exp =
               lbl_exp_list
   | Texp_field(exp, lbl) -> is_nonexpansive exp
   | Texp_array [] -> true
+  | Texp_new _ -> true
   | _ -> false
 
 (* Typing of printf formats *)
@@ -212,26 +221,29 @@ let type_format loc fmt =
           '%' ->
             scan_format (j+1)
         | 's' ->
-            Tarrow(Predef.type_string, scan_format (j+1))
+            newty (Tarrow(Predef.type_string, scan_format (j+1)))
         | 'c' ->
-            Tarrow(Predef.type_char, scan_format (j+1))
+            newty (Tarrow(Predef.type_char, scan_format (j+1)))
         | 'd' | 'o' | 'x' | 'X' | 'u' ->
-            Tarrow(Predef.type_int, scan_format (j+1))
+            newty (Tarrow(Predef.type_int, scan_format (j+1)))
         | 'f' | 'e' | 'E' | 'g' | 'G' ->
-            Tarrow(Predef.type_float, scan_format (j+1))
+            newty (Tarrow(Predef.type_float, scan_format (j+1)))
         | 'b' ->
-            Tarrow(Predef.type_bool, scan_format (j+1))
+            newty (Tarrow(Predef.type_bool, scan_format (j+1)))
         | 'a' ->
             let ty_arg = newvar() in
-            Tarrow (Tarrow(ty_input, Tarrow (ty_arg, ty_result)),
-                    Tarrow (ty_arg, scan_format (j+1)))
+            newty (Tarrow (newty (Tarrow(ty_input,
+      	       	       	       	       	 newty (Tarrow (ty_arg, ty_result)))),
+                           newty (Tarrow (ty_arg, scan_format (j+1)))))
         | 't' ->
-            Tarrow(Tarrow(ty_input, ty_result), scan_format (j+1))
+            newty (Tarrow(newty (Tarrow(ty_input, ty_result)),
+      	       	       	  scan_format (j+1)))
         | c ->
             raise(Error(loc, Bad_format(String.sub fmt i (j-i))))
         end
     | _ -> scan_format (i+1) in
-  Tconstr(Predef.path_format, [scan_format 0; ty_input; ty_result])
+  newty
+    (Tconstr(Predef.path_format, [scan_format 0; ty_input; ty_result], ref []))
 
 (* Typing of expressions *)
 
@@ -246,7 +258,16 @@ let rec type_exp env sexp =
     Pexp_ident lid ->
       begin try
         let (path, desc) = Env.lookup_value lid env in
-        { exp_desc = Texp_ident(path, desc);
+        { exp_desc =
+            begin match (desc.val_kind, lid) with
+	      (Val_ivar _, Longident.Lident lab) ->
+      	        let (path_self, _) =
+                  Env.lookup_value (Longident.Lident "*self*") env
+                in
+                Texp_instvar (path_self, path)
+	    | _ ->
+	        Texp_ident(path, desc)
+      	    end;
           exp_loc = sexp.pexp_loc;
           exp_type = instance desc.val_type }
       with Not_found ->
@@ -269,7 +290,7 @@ let rec type_exp env sexp =
       Parmatch.check_partial sexp.pexp_loc cases;
       { exp_desc = Texp_function cases;
         exp_loc = sexp.pexp_loc;
-        exp_type = Tarrow(ty_arg, ty_res) }
+        exp_type = newty (Tarrow(ty_arg, ty_res)) }
   | Pexp_apply(sfunct, sargs) ->
       let funct = type_exp env sfunct in
       let rec type_args ty_fun = function
@@ -309,7 +330,7 @@ let rec type_exp env sexp =
       let expl = List.map (type_exp env) sexpl in
       { exp_desc = Texp_tuple expl;
         exp_loc = sexp.pexp_loc;
-        exp_type = Ttuple(List.map (fun exp -> exp.exp_type) expl) }
+        exp_type = newty (Ttuple(List.map (fun exp -> exp.exp_type) expl)) }
   | Pexp_construct(lid, sarg) ->
       let constr =
         try
@@ -425,24 +446,140 @@ let rec type_exp env sexp =
       let high = type_expect env shigh Predef.type_int in
       let (id, new_env) =
         Env.enter_value param {val_type = Predef.type_int;
-                                val_prim = None} env in
+                                val_kind = Val_reg} env in
       let body = type_statement new_env sbody in
       { exp_desc = Texp_for(id, low, high, dir, body);
         exp_loc = sexp.pexp_loc;
         exp_type = Predef.type_unit }
-  | Pexp_constraint(sarg, sty) ->
-      let ty = Typetexp.transl_simple_type env false sty in
-      let arg = type_expect env sarg ty in
+  | Pexp_constraint(sarg, sty, sty') ->
+      let (ty, ty') =
+        match (sty, sty') with
+      	  (None, None) ->
+	    none, none
+	| (Some sty, None) ->
+            let ty = Typetexp.transl_simple_type env false sty in
+	    (ty, ty)
+	| (None, Some sty') ->
+            let ty' = Typetexp.transl_simple_type env false sty' in
+            (enlarge_type env (Typetexp.type_variable_list ()) ty', ty')
+	| (Some sty, Some sty') ->
+            let ty = Typetexp.transl_simple_type env false sty in
+            let ty' = Typetexp.transl_simple_type env false sty' in
+	    begin try subtype env (Typetexp.type_variable_list ()) ty ty' with
+	      Unify ->
+	        raise(Error(sexp.pexp_loc, Not_subtype(ty, ty')))
+	    end;
+	    (ty, ty')
+      in let arg = type_expect env sarg ty in
       { exp_desc = arg.exp_desc;
         exp_loc = arg.exp_loc;
-        exp_type = ty }
+        exp_type = ty' }
   | Pexp_when(scond, sbody) ->
       let cond = type_expect env scond Predef.type_bool in
       let body = type_exp env sbody in
       { exp_desc = Texp_when(cond, body);
         exp_loc = sexp.pexp_loc;
         exp_type = body.exp_type }
-      
+  | Pexp_send (e, met) ->
+      let object = type_exp env e in
+      begin try
+        let typ = filter_method env met object.exp_type in
+        let exp =
+      	  match object.exp_desc with
+	    Texp_ident(path, {val_kind = Val_anc methods}) ->
+      	      let (path, desc) =
+                Env.lookup_value (Longident.Lident "*self*") env
+              in
+              let method_id = List.assoc met methods in
+	      let method_type = newvar () in
+	      let (obj_ty, res_ty) = filter_arrow env method_type in
+	      unify env obj_ty desc.val_type;
+	      unify env res_ty typ;
+	      Texp_apply({exp_desc = Texp_ident(Path.Pident method_id,
+      	       	       	       	                {val_type = method_type;
+      	       	       	       	                 val_kind = Val_reg});
+      	       	          exp_loc = sexp.pexp_loc;
+      	       	          exp_type = method_type},
+                         [{exp_desc = Texp_ident(path, desc);
+      	       	       	   exp_loc = object.exp_loc;
+      	       	       	   exp_type = desc.val_type}])
+          | _ ->
+	      Texp_send(object, met)
+        in
+          { exp_desc = exp; exp_loc = sexp.pexp_loc; exp_type = typ}
+      with Unify ->
+      	raise(Error(e.pexp_loc,	Undefined_method_err met))
+      end
+  | Pexp_new cl ->
+      let (cl_path, cl_typ) =
+        try Env.lookup_class cl env with Not_found ->
+          raise(Error(sexp.pexp_loc, Unbound_class cl))
+      in
+      	begin match cl_typ.cty_new with
+	  None ->
+	    raise(Error(sexp.pexp_loc, Virtual_class cl))
+        | Some ty ->
+            { exp_desc = Texp_new cl_path;
+      	      exp_loc = sexp.pexp_loc;
+	      exp_type = instance ty }
+        end
+  | Pexp_setinstvar (lab, snewval) ->
+      let name = lab.Label.lab_name in
+      begin try
+        let (path, desc) = Env.lookup_value (Longident.Lident name) env in
+        match desc.val_kind with
+	  Val_ivar Mutable ->
+	    let newval = type_expect env snewval desc.val_type in
+      	    let (path_self, _) =
+              Env.lookup_value (Longident.Lident "*self*") env
+            in
+            { exp_desc = Texp_setinstvar(path_self, path, newval);
+              exp_loc = sexp.pexp_loc;
+              exp_type = Predef.type_unit }
+	| Val_ivar _ ->
+      	    raise(Error(sexp.pexp_loc, Instance_variable_not_mutable name))
+	| _ ->
+            raise(Error(sexp.pexp_loc, Unbound_instance_variable name))
+      with
+	Not_found ->
+          raise(Error(sexp.pexp_loc, Unbound_instance_variable name))
+      end        
+  | Pexp_override lst ->
+      List.fold_right
+      	(fun (lab, _) l ->
+	   if List.exists (Label. (=) lab) l then
+	     raise(Error(sexp.pexp_loc,
+      	       	       	 Value_multiply_overridden lab.Label.lab_name));
+      	   lab::l)
+	lst
+	[];
+      let (path_self, {val_type = self_ty}) =
+      	try
+          Env.lookup_value (Longident.Lident "*self*") env
+	with Not_found ->
+	  raise(Error(sexp.pexp_loc, Outside_class))
+      in
+      let type_override (lab, snewval) =
+        let name = lab.Label.lab_name in
+        begin try
+          let (path, desc) = Env.lookup_value (Longident.Lident name) env in
+          match desc.val_kind with
+	    Val_ivar _ ->
+              (path, type_expect env snewval desc.val_type)
+	  | _ ->
+              raise(Error(sexp.pexp_loc, Unbound_instance_variable name))
+        with
+	  Not_found ->
+            raise(Error(sexp.pexp_loc, Unbound_instance_variable name))
+        end
+      in
+      let modifs = List.map type_override lst in
+      { exp_desc = Texp_override(path_self, modifs);
+      	exp_loc = sexp.pexp_loc;
+	exp_type = self_ty }
+
+      (* let obj = Oo.copy self in obj.x <- e; obj *)
+
 (* Typing of an expression with an expected type.
    Some constructs are treated specially to provide better error messages. *)
 
@@ -454,8 +591,8 @@ and type_expect env sexp ty_expected =
           exp_loc = sexp.pexp_loc;
           exp_type =
             (* Terrible hack for format strings *)
-            match Ctype.repr ty_expected with
-              Tconstr(path, _) when Path.same path Predef.path_format ->
+            match (repr ty_expected).desc with
+              Tconstr(path, _, _) when Path.same path Predef.path_format ->
                 type_format sexp.pexp_loc s
             | _ -> Predef.type_string } in
       unify_exp env exp ty_expected;
@@ -481,7 +618,7 @@ and type_expect env sexp ty_expected =
 
 and type_statement env sexp =
     let exp = type_exp env sexp in
-    match Ctype.repr exp.exp_type with
+    match (repr exp.exp_type).desc with
       Tarrow(_, _) ->
         Location.print_warning sexp.pexp_loc
           "this function application is partial,\n\
@@ -505,7 +642,8 @@ and type_cases env ty_arg ty_res caselist =
 and type_let env rec_flag spat_sexp_list =
   begin_def();
   let (pat_list, new_env) =
-    type_pattern_list env (List.map (fun (spat, sexp) -> spat) spat_sexp_list) in
+    type_pattern_list env (List.map (fun (spat, sexp) -> spat) spat_sexp_list)
+  in
   let exp_env =
     match rec_flag with Nonrecursive -> env | Recursive -> new_env in
   let exp_list =
@@ -527,14 +665,12 @@ and type_let env rec_flag spat_sexp_list =
 (* Typing of toplevel bindings *)
 
 let type_binding env rec_flag spat_sexp_list =
-  reset_def();
   Typetexp.reset_type_variables();
   type_let env rec_flag spat_sexp_list
 
 (* Typing of toplevel expressions *)
 
 let type_expression env sexp =
-  reset_def();
   Typetexp.reset_type_variables();
   begin_def();
   let exp = type_exp env sexp in
@@ -542,6 +678,36 @@ let type_expression env sexp =
   if is_nonexpansive exp then generalize exp.exp_type;
   exp
 
+(* Typing of methods *)
+
+let type_method env self self_name sexp =
+  let (obj, env) =
+    Env.enter_value "*self*" {val_type = self; val_kind = Val_reg} env
+  in
+  let pattern =
+    { pat_desc = Tpat_var obj;
+      pat_loc = Location.none;
+      pat_type = self }
+  in
+  let (pattern, env) =
+    match self_name with
+      None      ->
+        (pattern, env)
+    | Some name ->
+        let (self_name, env) =
+          Env.enter_value name {val_type = self; val_kind = Val_reg} env
+        in
+        ({ pat_desc = Tpat_alias (pattern, self_name);
+	   pat_loc = Location.none;
+	   pat_type = self },
+	 env)
+  in
+  let exp = type_exp env sexp in
+  ({ exp_desc = Texp_function [(pattern, exp)];
+     exp_loc = sexp.pexp_loc;
+     exp_type = newty (Tarrow(pattern.pat_type, exp.exp_type)) },
+   exp.exp_type)
+
 (* Error report *)
 
 open Format
@@ -563,6 +729,8 @@ let report_error = function
       print_string " argument(s)";
       close_box()
   | Label_mismatch(lid, actual, expected) ->
+      reset ();
+      mark_loops actual; mark_loops expected;
       open_hovbox 0;
       print_string "The label "; longident lid;
       print_space(); print_string "belongs to the type"; print_space();
@@ -571,6 +739,8 @@ let report_error = function
       type_expr expected;
       close_box()
   | Pattern_type_clash(inferred, expected) ->
+      reset ();
+      mark_loops inferred; mark_loops expected;
       open_hovbox 0;
       print_string "This pattern matches values of type"; print_space();
       type_expr inferred; print_space();
@@ -582,6 +752,8 @@ let report_error = function
   | Orpat_not_closed ->
       print_string "A pattern with | must not bind variables"
   | Expr_type_clash(inferred, expected) ->
+      reset ();
+      mark_loops inferred; mark_loops expected;
       open_hovbox 0;
       print_string "This expression has type"; print_space();
       type_expr inferred; print_space();
@@ -589,7 +761,7 @@ let report_error = function
       type_expr expected;
       close_box()
   | Apply_non_function typ ->
-      begin match Ctype.repr typ with
+      begin match (repr typ).desc with
         Tarrow(_, _) ->
           print_string "This function is applied to too many arguments"
       | _ ->
@@ -605,3 +777,30 @@ let report_error = function
       print_string " is not mutable"
   | Bad_format s ->
       print_string "Bad format `"; print_string s; print_string "'"
+  | Undefined_method_err me ->
+      print_string "This expression has no method ";
+      print_string me.Label.lab_name
+  | Unbound_class cl ->
+      print_string "Unbound class "; longident cl
+  | Virtual_class cl ->
+      print_string "One cannot create instances of the virtual class ";
+      longident cl
+  | Unbound_instance_variable v ->
+      print_string "Unbound instance variable ";
+      print_string v
+  | Instance_variable_not_mutable v ->
+      print_string " The instance variable "; print_string v;
+      print_string " is not mutable"
+  | Not_subtype(ty, ty') ->
+      reset ();
+      mark_loops ty; mark_loops ty';
+      open_hovbox 0;
+      type_expr ty; print_space();
+      print_string "is not a subtype of"; print_space ();
+      type_expr ty';
+      close_box()
+  | Outside_class ->
+      print_string "Object duplication outside a class definition."
+  | Value_multiply_overridden v ->
+      print_string "The instance variable "; print_string v;
+      print_string " is overridden several times"
diff --git a/typing/typecore.mli b/typing/typecore.mli
index 54d31ad..d527ae4 100644
--- a/typing/typecore.mli
+++ b/typing/typecore.mli
@@ -19,10 +19,20 @@ open Typedtree
 val type_binding:
         Env.t -> rec_flag ->
           (Parsetree.pattern * Parsetree.expression) list -> 
-            (Typedtree.pattern * Typedtree.expression) list * Env.t
+            (pattern * expression) list * Env.t
 val type_expression:
-        Env.t -> Parsetree.expression -> Typedtree.expression
-        
+        Env.t -> Parsetree.expression -> expression
+val type_method:
+        Env.t -> Typedtree.type_expr -> string option ->
+        Parsetree.expression -> expression * type_expr
+val type_pattern_list:
+        Env.t -> Parsetree.pattern list -> Typedtree.pattern list * Env.t
+val type_expect:
+        Env.t -> Parsetree.expression -> Typedtree.type_expr ->
+        Typedtree.expression
+val type_exp:
+      	Env.t -> Parsetree.expression -> Typedtree.expression
+
 type error =
     Unbound_value of Longident.t
   | Unbound_constructor of Longident.t
@@ -38,6 +48,14 @@ type error =
   | Label_missing
   | Label_not_mutable of Longident.t
   | Bad_format of string
+  | Undefined_method_err of Label.t
+  | Unbound_class of Longident.t
+  | Virtual_class of Longident.t
+  | Unbound_instance_variable of string
+  | Instance_variable_not_mutable of string
+  | Not_subtype of type_expr * type_expr
+  | Outside_class
+  | Value_multiply_overridden of string
 
 exception Error of Location.t * error
 
diff --git a/typing/typedecl.ml b/typing/typedecl.ml
index e8e7091..f7cca50 100644
--- a/typing/typedecl.ml
+++ b/typing/typedecl.ml
@@ -25,6 +25,7 @@ type error =
   | Duplicate_label of string
   | Recursive_abbrev of string
   | Definition_mismatch of type_expr
+  | Illdefined_abbrev of string
 
 exception Error of Location.t * error
 
@@ -52,8 +53,8 @@ module StringSet =
   end)
 
 let transl_declaration env (name, sdecl) id =
-  Ctype.begin_def();
   reset_type_variables();
+  Ctype.begin_def();
   let params =
     try
       List.map enter_type_variable sdecl.ptype_params
@@ -96,17 +97,31 @@ let transl_declaration env (name, sdecl) id =
       type_manifest =
         begin match sdecl.ptype_manifest with
           None -> None
-        | Some sty -> Some(transl_simple_type env true sty)
+        | Some sty ->
+            Some (Ctype.unroll_abbrev id params
+                    (transl_simple_type env true sty))
         end } in
   Ctype.end_def();
   List.iter Ctype.generalize params;
+  begin match decl.type_kind with
+    Type_abstract ->
+      ()
+  | Type_variant v ->
+      List.iter (fun (_, tyl) -> List.iter Ctype.generalize tyl) v
+  | Type_record r ->
+      List.iter (fun (_, _, ty) -> Ctype.generalize ty) r
+  end;
+  begin match decl.type_manifest with
+    None    -> ()
+  | Some ty -> Ctype.generalize ty
+  end;
   (* If both a variant/record definition and a type equation are given,
      need to check that the equation refers to a type of the same kind
      with the same constructors and labels *)
   begin match decl with
     {type_kind = (Type_variant _ | Type_record _); type_manifest = Some ty} ->
-      begin match ty with
-        Tconstr(path, args) ->
+      begin match ty.desc with
+        Tconstr(path, args, _) ->
           begin try
             let decl' = Env.find_type path env in
             if args = params & Includecore.type_declarations env id decl decl'
@@ -121,30 +136,28 @@ let transl_declaration env (name, sdecl) id =
   end;
   (id, decl)
 
-(* Check for recursive abbrevs *)
+(* Check for ill-defined abbrevs *)
 
 let check_recursive_abbrev env (name, sdecl) (id, decl) =
   match decl.type_manifest with
     Some ty ->
-      if Ctype.free_type_ident env [id] ty
-      then raise(Error(sdecl.ptype_loc, Recursive_abbrev name))
-  | _ -> ()
+      begin try Ctype.correct_abbrev env id decl.type_params ty with
+        Ctype.Recursive_abbrev ->
+          raise(Error(sdecl.ptype_loc, Recursive_abbrev name))
+      | Ctype.Nonlinear_abbrev ->
+          raise(Error(sdecl.ptype_loc, Illdefined_abbrev name))
+      end
+  | _ ->
+      ()
 
 (* Translate a set of mutually recursive type declarations *)
 
 let transl_type_decl env name_sdecl_list =
-  Ctype.reset_def();
+  (* Enter the types as abstract *)
+  let (id_list, temp_env) = enter_types env name_sdecl_list in
+  (* Translate each declaration *)
   let decls =
-    match name_sdecl_list with
-      [(name, {ptype_kind = Ptype_abstract}) as name_sdecl] ->
-        (* No recursion involved, use original env for translation *)
-        let id = Ident.new name in
-        [transl_declaration env name_sdecl id]
-    | _ ->
-        (* Enter the types as abstract *)
-        let (id_list, temp_env) = enter_types env name_sdecl_list in
-        (* Translate each declaration *)
-        List.map2 (transl_declaration temp_env) name_sdecl_list id_list in
+    List.map2 (transl_declaration temp_env) name_sdecl_list id_list in
   (* Build the final env *)
   let newenv =
     List.fold_right
@@ -158,25 +171,23 @@ let transl_type_decl env name_sdecl_list =
 (* Translate an exception declaration *)
 
 let transl_exception env excdecl =
-  Ctype.reset_def();
   reset_type_variables();
   List.map (transl_simple_type env true) excdecl
 
 (* Translate a value declaration *)
 
 let transl_value_decl env valdecl =
-  Ctype.reset_def();
   let ty = Typetexp.transl_type_scheme env valdecl.pval_type in
+  let prim = Primitive.parse_declaration (Ctype.arity ty) valdecl.pval_prim in
   { val_type = ty;
-    val_prim = Primitive.parse_declaration (Ctype.arity ty) valdecl.pval_prim }
+    val_kind = match prim with Some p -> Val_prim p | None -> Val_reg }
 
 (* Translate a "with" constraint -- much simplified version of
     transl_type_decl. *)
 
 let transl_with_constraint env sdecl =
-  Ctype.reset_def();
-  Ctype.begin_def();
   reset_type_variables();
+  Ctype.begin_def();
   let params =
     try
       List.map enter_type_variable sdecl.ptype_params
@@ -214,4 +225,7 @@ let report_error = function
       print_string
         "The variant or record definition does not match that of type";
       print_space(); Printtyp.type_expr ty
+  | Illdefined_abbrev s ->
+      print_string "The type abbreviation "; print_string s;
+      print_string " is ill-defined"
 
diff --git a/typing/typedecl.mli b/typing/typedecl.mli
index 8ce3edb..1a01015 100644
--- a/typing/typedecl.mli
+++ b/typing/typedecl.mli
@@ -34,6 +34,7 @@ type error =
   | Duplicate_label of string
   | Recursive_abbrev of string
   | Definition_mismatch of type_expr
+  | Illdefined_abbrev of string
 
 exception Error of Location.t * error
 
diff --git a/typing/typedtree.ml b/typing/typedtree.ml
index b2e41f5..6f137d5 100644
--- a/typing/typedtree.ml
+++ b/typing/typedtree.ml
@@ -19,20 +19,30 @@ open Asttypes
 (* Type expressions for the core language *)
 
 type type_expr =
-    Tvar of type_variable
+  { mutable desc: type_desc; 
+    mutable level: int }
+
+and type_desc =
+    Tvar
   | Tarrow of type_expr * type_expr
   | Ttuple of type_expr list
-  | Tconstr of Path.t * type_expr list
-
-and type_variable =
-    { mutable tvar_level: int;
-      mutable tvar_link: type_expr option }
+  | Tconstr of Path.t * type_expr list * (Path.t * type_expr) list ref
+  | Tobject of type_expr * (Path.t * type_expr list) option ref
+  | Tfield of Label.t * type_expr * type_expr
+  | Tnil
+  | Tlink of type_expr
 
 (* Value descriptions *)
 
 type value_description =
   { val_type: type_expr;                       (* Type of the val *)
-    val_prim: Primitive.description option }   (* Is this a primitive? *)
+    val_kind: value_kind }
+
+and value_kind =
+    Val_reg				(* Regular value *)
+  | Val_prim of Primitive.description	(* Primitive *)
+  | Val_ivar of mutable_flag		(* Instance variable (mutable ?) *)
+  | Val_anc of (Label.t * Ident.t) list (* Ancestor *)
 
 (* Constructor descriptions *)
 
@@ -63,6 +73,18 @@ and record_representation =
     Record_regular                      (* All fields are boxed / tagged *)
   | Record_float                        (* All fields are floats *)
 
+(* Type expressions for classes *)
+
+module Vars = Map.Make(Label)
+
+type class_type =
+  { cty_params: type_expr list;
+    cty_args: type_expr list;
+    cty_vars: (Asttypes.mutable_flag * type_expr) Vars.t;
+    cty_self: type_expr;
+    cty_concr: Label.t list;
+    mutable cty_new: type_expr option }
+
 (* Value expressions for the core language *)
 
 type pattern =
@@ -105,6 +127,11 @@ and expression_desc =
   | Texp_for of
       Ident.t * expression * expression * direction_flag * expression
   | Texp_when of expression * expression
+  | Texp_send of expression * Label.t
+  | Texp_new of Path.t
+  | Texp_instvar of Path.t * Path.t
+  | Texp_setinstvar of Path.t * Path.t * expression
+  | Texp_override of Path.t * (Path.t * expression) list
 
 (* Type definitions *)
 
@@ -136,11 +163,26 @@ and signature_item =
   | Tsig_exception of Ident.t * exception_declaration
   | Tsig_module of Ident.t * module_type
   | Tsig_modtype of Ident.t * modtype_declaration
+  | Tsig_class of Ident.t * class_type
 
 and modtype_declaration =
     Tmodtype_abstract
   | Tmodtype_manifest of module_type
 
+(* Value expressions for classes *)
+
+type class_field =
+    Cf_inher of
+      Path.t * expression list * (Label.t * Ident.t) list *
+      (Label.t * Ident.t) list
+  | Cf_val of Label.t * Ident.t * private_flag * expression option
+  | Cf_meth of Label.t * expression
+
+type class_def =
+  { cl_args: pattern list;
+    cl_field: class_field list;
+    cl_loc: Location.t }
+
 (* Value expressions for the module language *)
 
 type module_expr =
@@ -166,6 +208,7 @@ and structure_item =
   | Tstr_module of Ident.t * module_expr
   | Tstr_modtype of Ident.t * module_type
   | Tstr_open of Path.t
+  | Tstr_class of (Ident.t * class_def) list
 
 and module_coercion =
     Tcoerce_none
diff --git a/typing/typedtree.mli b/typing/typedtree.mli
index 01592ff..fe0e72a 100644
--- a/typing/typedtree.mli
+++ b/typing/typedtree.mli
@@ -13,21 +13,31 @@
 
 (* Type expressions for the core language *)
 
 type type_expr =
-    Tvar of type_variable
+  { mutable desc: type_desc; 
+    mutable level: int }
+
+and type_desc =
+    Tvar
   | Tarrow of type_expr * type_expr
   | Ttuple of type_expr list
-  | Tconstr of Path.t * type_expr list
-
-and type_variable =
-    { mutable tvar_level: int;
-      mutable tvar_link: type_expr option }
+  | Tconstr of Path.t * type_expr list * (Path.t * type_expr) list ref
+  | Tobject of type_expr * (Path.t * type_expr list) option ref
+  | Tfield of Label.t * type_expr * type_expr
+  | Tnil
+  | Tlink of type_expr
 
 (* Value descriptions *)
 
 type value_description =
   { val_type: type_expr;                       (* Type of the val *)
-    val_prim: Primitive.description option }   (* Is this a primitive? *)
+    val_kind: value_kind }
+
+and value_kind =
+    Val_reg				(* Regular value *)
+  | Val_prim of Primitive.description	(* Primitive *)
+  | Val_ivar of mutable_flag		(* Instance variable (mutable ?) *)
+  | Val_anc of (Label.t * Ident.t) list (* Ancestor *)
 
 (* Constructor descriptions *)
 
@@ -62,6 +73,18 @@ and record_representation =
     Record_regular                      (* All fields are boxed / tagged *)
   | Record_float                        (* All fields are floats *)
 
+(* Type expressions for classes *)
+
+module Vars : Map.S with type key = Label.t
+
+type class_type =
+  { cty_params: type_expr list;
+    cty_args: type_expr list;
+    cty_vars: (mutable_flag * type_expr) Vars.t;
+    cty_self: type_expr;
+    cty_concr: Label.t list;
+    mutable cty_new: type_expr option }
+
 (* Value expressions for the core language *)
 
 type pattern =
@@ -104,6 +127,11 @@ and expression_desc =
   | Texp_for of
       Ident.t * expression * expression * direction_flag * expression
   | Texp_when of expression * expression
+  | Texp_send of expression * Label.t
+  | Texp_new of Path.t
+  | Texp_instvar of Path.t * Path.t
+  | Texp_setinstvar of Path.t * Path.t * expression
+  | Texp_override of Path.t * (Path.t * expression) list
 
 (* Type definitions *)
 
@@ -135,11 +163,26 @@ and signature_item =
   | Tsig_exception of Ident.t * exception_declaration
   | Tsig_module of Ident.t * module_type
   | Tsig_modtype of Ident.t * modtype_declaration
+  | Tsig_class of Ident.t * class_type
 
 and modtype_declaration =
     Tmodtype_abstract
   | Tmodtype_manifest of module_type
 
+(* Value expressions for classes *)
+
+type class_field =
+    Cf_inher of
+      Path.t * expression list * (Label.t * Ident.t) list *
+      (Label.t * Ident.t) list
+  | Cf_val of Label.t * Ident.t * private_flag * expression option
+  | Cf_meth of Label.t * expression
+
+type class_def =
+  { cl_args: pattern list;
+    cl_field: class_field list;
+    cl_loc: Location.t }
+
 (* Value expressions for the module language *)
 
 type module_expr =
@@ -165,6 +208,7 @@ and structure_item =
   | Tstr_module of Ident.t * module_expr
   | Tstr_modtype of Ident.t * module_type
   | Tstr_open of Path.t
+  | Tstr_class of (Ident.t * class_def) list
 
 and module_coercion =
     Tcoerce_none
diff --git a/typing/typemod.ml b/typing/typemod.ml
index 6f963a0..bd76c03 100644
--- a/typing/typemod.ml
+++ b/typing/typemod.ml
@@ -31,6 +31,7 @@ type error =
   | With_no_component of Longident.t
   | Repeated_name of string * string
   | Non_generalizable of type_expr
+  | Non_generalizable_class of Ident.t * class_type
 
 exception Error of Location.t * error
 
@@ -142,6 +143,14 @@ and transl_signature env sg =
       let newenv = Env.add_signature sg env in
       let rem = transl_signature newenv srem in
       sg @ rem
+  | {psig_desc = Psig_class cl} :: srem ->
+      let (classes, newenv) = Typeclass.transl_class_types env cl in
+      let rem = transl_signature newenv srem in
+      List.flatten
+        (map_end
+           (fun (i, d, i', d', i'', d'') ->
+              [Tsig_class(i, d); Tsig_type(i', d'); Tsig_type(i'', d'')])
+           classes [rem])
 
 and transl_modtype_info env sinfo =
   match sinfo with
@@ -188,12 +197,14 @@ let check_unique_names sg =
         check "module" item.pstr_loc module_names name
     | Pstr_modtype(name, decl) ->
         check "module type" item.pstr_loc modtype_names name
-    | Pstr_open lid -> () in
-  List.iter check_item sg
+    | Pstr_open lid -> ()
+    | Pstr_class decl -> ()
+  in
+    List.iter check_item sg
 
 (* Check that all core type schemes in a structure are closed *)
 
-let check_nongen_schemes str =
+let check_nongen_schemes env str =
   List.iter 
     (function
         Tstr_value(rec_flag, pat_exp_list) ->
@@ -202,8 +213,24 @@ let check_nongen_schemes str =
               if not (Ctype.closed_schema exp.exp_type) then
                 raise(Error(exp.exp_loc, Non_generalizable exp.exp_type)))
             pat_exp_list
+      | Tstr_class cl ->
+          List.iter
+	    (fun (id, imp) ->
+	       let desc = Env.find_class (Pident id) env in
+	       if not
+	         (List.for_all Ctype.closed_schema desc.cty_params
+	             &
+	          List.for_all Ctype.closed_schema desc.cty_args
+	             &
+	          Vars.fold (fun _ (_, ty) -> (or) (Ctype.closed_schema ty))
+                    desc.cty_vars
+      	       	    true)
+	       then
+	         raise(Error(imp.cl_loc,
+      	       	       Non_generalizable_class (id, desc))))
+	    cl
       | _ -> ())  (* Sub-structures have been checked before *)
-  str
+    str
 
 (* Type a module value expression *)
 
@@ -215,8 +242,8 @@ let rec type_module env smod =
         mod_type = Mtype.strengthen env mty path;
         mod_loc = smod.pmod_loc }
   | Pmod_structure sstr ->
-      let (str, sg, _) = type_structure env sstr in
-      check_nongen_schemes str;
+      let (str, sg, finalenv) = type_structure env sstr in
+      check_nongen_schemes finalenv str;
       { mod_desc = Tmod_structure str;
         mod_type = Tmty_signature sg;
         mod_loc = smod.pmod_loc }
@@ -326,6 +353,19 @@ and type_struct env = function
       let (path, mty) = type_module_path env loc lid in
       let sg = extract_sig_open env loc mty in
       type_struct (Env.open_signature path sg env) srem
+  | {pstr_desc = Pstr_class cl; pstr_loc = loc} :: srem ->
+      let (classes, new_env) = Typeclass.transl_classes env cl in
+      let (str_rem, sig_rem, final_env) = type_struct new_env srem in
+      (Tstr_class (List.map (fun (i, _, _, _, _, _, c) -> (i, c)) classes)
+       :: Tstr_type (List.map (fun (_, _, i, d, _, _, _) -> (i, d)) classes)
+       :: Tstr_type (List.map (fun (_, _, _, _, i, d, _) -> (i, d)) classes)
+       :: str_rem,
+       List.flatten
+         (map_end
+      	    (fun (i, d, i', d', i'', d'', _) ->
+               [Tsig_class(i, d); Tsig_type(i', d'); Tsig_type(i'', d'')])
+            classes [sig_rem]),
+       final_env)
 
 (* Error report *)
 
@@ -376,4 +416,11 @@ let report_error = function
       open_hovbox 0;
       print_string "The type of this expression,"; print_space();
       type_scheme typ; print_string ","; print_space();
-      print_string "contains type variables that cannot be generalized"
+      print_string "contains type variables that cannot be generalized";
+      close_box()
+  | Non_generalizable_class (id, desc) ->
+      open_hovbox 0;
+      print_string "The type of this class,"; print_space();
+      class_type id desc; print_string ","; print_space();
+      print_string "contains type variables that cannot be generalized";
+      close_box()
diff --git a/typing/typemod.mli b/typing/typemod.mli
index b917199..58abc68 100644
--- a/typing/typemod.mli
+++ b/typing/typemod.mli
@@ -20,7 +20,7 @@ val type_structure:
 val transl_signature:
         Env.t -> Parsetree.signature -> signature
 val check_nongen_schemes:
-        structure -> unit
+        Env.t -> structure -> unit
 
 type error =
     Unbound_module of Longident.t
@@ -33,6 +33,7 @@ type error =
   | With_no_component of Longident.t
   | Repeated_name of string * string
   | Non_generalizable of type_expr
+  | Non_generalizable_class of Ident.t * class_type
 
 exception Error of Location.t * error
 
diff --git a/typing/typetexp.ml b/typing/typetexp.ml
index 08e99a7..ec83c77 100644
--- a/typing/typetexp.ml
+++ b/typing/typetexp.ml
@@ -13,6 +13,7 @@
 
 (* Typechecking of type expressions for the core language *)
 
+open Misc
 open Parsetree
 open Typedtree
 open Ctype
@@ -23,6 +24,11 @@ type error =
     Unbound_type_variable of string
   | Unbound_type_constructor of Longident.t
   | Type_arity_mismatch of Longident.t * int * int
+  | Bound_type_variable of string
+  | Recursive_type
+  | Unbound_class of Longident.t
+  | Unbound_row_variable of Longident.t
+  | Type_mismatch of type_expr * type_expr
 
 exception Error of Location.t * error
 
@@ -31,6 +37,7 @@ exception Error of Location.t * error
 let type_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
 
 let reset_type_variables () =
+  reset_global_level ();
   type_variables := Tbl.empty
 
 let enter_type_variable name =
@@ -41,6 +48,17 @@ let enter_type_variable name =
     type_variables := Tbl.add name v !type_variables;
     v
 
+let type_variable loc name =
+  try
+    Tbl.find name !type_variables
+  with Not_found ->
+    raise(Error(loc, Unbound_type_variable name))
+
+let type_variable_list () =
+  let l = ref [] in
+  Tbl.iter (fun _ v -> l := v::!l) !type_variables;
+  !l
+
 let rec transl_simple_type env fixed styp =
   match styp.ptyp_desc with
     Ptyp_var name ->
@@ -56,11 +74,12 @@ let rec transl_simple_type env fixed styp =
         end
       end
   | Ptyp_arrow(st1, st2) ->
-      Tarrow(transl_simple_type env fixed st1,
-             transl_simple_type env fixed st2)
+      let ty1 = transl_simple_type env fixed st1 in
+      let ty2 = transl_simple_type env fixed st2 in
+        Ctype.newty (Tarrow(ty1, ty2))
   | Ptyp_tuple stl ->
-      Ttuple(List.map (transl_simple_type env fixed) stl)
-  | Ptyp_constr(lid, stl) ->
+      Ctype.newty (Ttuple(List.map (transl_simple_type env fixed) stl))
+  | Ptyp_constr(lid, stl, alias) ->
       let (path, decl) =
         try
           Env.lookup_type lid env
@@ -69,7 +88,116 @@ let rec transl_simple_type env fixed styp =
       if List.length stl <> decl.type_arity then
         raise(Error(styp.ptyp_loc, Type_arity_mismatch(lid, decl.type_arity,
                                                            List.length stl)));
-      Tconstr(path, List.map (transl_simple_type env fixed) stl)
+      let (cstr, params) =
+        begin match alias with
+      	  None ->
+	    let tl = List.map (transl_simple_type env fixed) stl in
+              (newty (Tconstr(path, tl, ref [])), tl)
+        | Some alias ->
+            let cstr = newvar () in
+      	    begin try
+              Tbl.find alias !type_variables;
+	      raise(Error(styp.ptyp_loc, Bound_type_variable alias))
+            with Not_found ->
+      	      type_variables := Tbl.add alias cstr !type_variables
+	    end;
+	    let tl = List.map (transl_simple_type env fixed) stl in
+	    begin try
+              occur env cstr
+      	       	(Ctype.expand_abbrev env path tl (ref []) cstr.level)
+            with
+	      Unify         -> raise(Error(styp.ptyp_loc, Recursive_type))
+	    | Cannot_expand -> ()
+	    end;
+	    cstr.desc <- Tconstr(path, tl, ref []);
+	    (cstr, tl)
+        end
+      in
+      begin match decl.type_manifest with
+      	Some _ ->
+	  List.iter2
+           (fun ty (sty, ty') ->
+	      try Ctype.unify env (Ctype.instance ty) ty' with
+		Unify ->
+		  raise (Error(sty.ptyp_loc, Type_mismatch(ty, ty'))))
+           decl.type_params (List.combine stl params)
+      | _ ->
+      	  ()
+      end;
+      cstr
+  | Ptyp_object(fields, None) ->
+      newobj (transl_fields env fixed fields)
+  | Ptyp_object(fields, Some alias) ->
+      begin try
+        Tbl.find alias !type_variables;
+	raise(Error(styp.ptyp_loc, Bound_type_variable alias))
+      with Not_found ->
+        let obj = newvar () in
+      	  type_variables := Tbl.add alias obj !type_variables;
+	  obj.desc <- Tobject (transl_fields env fixed fields, ref None);
+	  obj
+      end
+  | Ptyp_class(lid, stl, alias) ->
+      if fixed then
+        raise(Error(styp.ptyp_loc, Unbound_row_variable lid));
+      let lid2 =
+        match lid with
+          Longident.Lident s     -> Longident.Lident ("#" ^ s)
+	| Longident.Ldot(r, s)   -> Longident.Ldot (r, "#" ^ s)
+	| Longident.Lapply(_, _) -> fatal_error "Typetexp.transl_simple_type"
+      in
+      let (path, decl) =
+        try
+          Env.lookup_type lid2 env
+        with Not_found ->
+          raise(Error(styp.ptyp_loc, Unbound_class lid)) in
+      if List.length stl <> decl.type_arity then
+        raise(Error(styp.ptyp_loc, Type_arity_mismatch(lid, decl.type_arity,
+                                                           List.length stl)));
+      let v = new_global_var () in
+      let (ty, params) =
+        begin match alias with
+      	  None ->
+	    let tl = List.map (transl_simple_type env fixed) stl in
+	    (expand_abbrev env path tl (ref []) v.level, tl)
+        | Some alias ->
+      	    begin try
+              Tbl.find alias !type_variables;
+	      raise(Error(styp.ptyp_loc, Bound_type_variable alias))
+            with Not_found ->
+      	      type_variables := Tbl.add alias v !type_variables
+	    end;
+	    let tl = List.map (transl_simple_type env fixed) stl in
+	    let cstr = expand_abbrev env path tl (ref []) v.level in
+	    v.desc <- cstr.desc;
+	    (v, tl)
+        end
+      in
+      begin match decl.type_manifest with
+      	Some _ ->
+	  List.iter2
+           (fun ty (sty, ty') ->
+	      try Ctype.unify env (Ctype.instance ty) ty' with
+		Unify ->
+		  raise (Error(sty.ptyp_loc, Type_mismatch(ty, ty'))))
+           decl.type_params (List.combine stl params)
+      | _ ->
+      	  ()
+      end;
+      ty
+
+and transl_fields env fixed =
+  function
+    [] ->
+      newty Tnil
+  | {pfield_desc = Pfield_var} as field::_ ->
+      if fixed then
+        raise(Error(field.pfield_loc, Unbound_type_variable ".."));
+      newvar ()
+  | {pfield_desc = Pfield(s, e)}::l ->
+      let ty1 = transl_simple_type env fixed e in
+      let ty2 = transl_fields env fixed l in
+	newty (Tfield (s, ty1, ty2))
 
 let transl_type_scheme env styp =
   reset_type_variables();
@@ -97,3 +225,19 @@ let report_error = function
       print_string "but is here applied to "; print_int provided;
       print_string " argument(s)";
       close_box()
+  | Bound_type_variable name ->
+      print_string "Already bound type parameter "; print_string name
+  | Recursive_type ->
+      print_string "This type is recursive"
+  | Unbound_class lid ->
+      print_string "Unbound class "; longident lid
+  | Unbound_row_variable lid ->
+      print_string "Unbound row variable in #"; longident lid
+  | Type_mismatch (ty, ty') ->
+      Printtyp.reset ();
+      Printtyp.mark_loops ty; Printtyp.mark_loops ty';
+      open_hovbox 0;
+      print_string "This parameter ";
+      Printtyp.type_expr ty';
+      print_string " should be an instance of ";
+      Printtyp.type_expr ty
diff --git a/typing/typetexp.mli b/typing/typetexp.mli
index 14505b6..c1dd2d0 100644
--- a/typing/typetexp.mli
+++ b/typing/typetexp.mli
@@ -19,6 +19,8 @@ val transl_type_scheme:
         Env.t -> Parsetree.core_type -> Typedtree.type_expr
 val reset_type_variables: unit -> unit
 val enter_type_variable: string -> Typedtree.type_expr
+val type_variable : Location.t -> string -> Typedtree.type_expr
+val type_variable_list : unit -> Typedtree.type_expr list
 
 exception Already_bound
 
@@ -26,4 +28,9 @@ type error =
     Unbound_type_variable of string
   | Unbound_type_constructor of Longident.t
   | Type_arity_mismatch of Longident.t * int * int
+  | Bound_type_variable of string
+  | Recursive_type
+  | Unbound_class of Longident.t
+  | Unbound_row_variable of Longident.t
+  | Type_mismatch of Typedtree.type_expr * Typedtree.type_expr
 
 exception Error of Location.t * error
