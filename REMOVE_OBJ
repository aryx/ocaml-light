* bytecomp/

 val immed_min: int
diff --git a/bytecomp/lambda.ml b/bytecomp/lambda.ml
index 56c3192..1c119ab 100644
--- a/bytecomp/lambda.ml
+++ b/bytecomp/lambda.ml
@@ -69,7 +69,9 @@ type structured_constant =
   | Const_block of int * structured_constant list
   | Const_float_array of string list
 
-type let_kind = Strict | Alias
+type let_kind = Strict | Alias | StrictOpt
+
+type shared_code = (int * int) list
 
 type lambda =
     Lvar of Ident.t
 
 (* Check if an action has a "when" guard *)
diff --git a/bytecomp/lambda.mli b/bytecomp/lambda.mli
index b12ed97..6ea5baf 100644
--- a/bytecomp/lambda.mli
+++ b/bytecomp/lambda.mli
@@ -69,7 +69,9 @@ type structured_constant =
   | Const_block of int * structured_constant list
   | Const_float_array of string list
 
-type let_kind = Strict | Alias
+type let_kind = Strict | Alias | StrictOpt
+
+type shared_code = (int * int) list     (* stack size -> code label *)
 
 type lambda =
     Lvar of Ident.t
diff --git a/bytecomp/matching.ml b/bytecomp/matching.ml
index c521790..7123e41 100644
--- a/bytecomp/matching.ml
+++ b/bytecomp/matching.ml
@@ -166,7 +166,7 @@ let make_record_matching all_labels = function
           let str =
             match lbl.lbl_mut with
               Immutable -> Alias
-            | Mutable -> Strict in
+            | Mutable -> StrictOpt in
           (Lprim(access, [arg]), str) :: make_args(pos + 1)
         end in
       {cases = []; args = make_args 0}
   (* Second pass: remove Lalias bindings of unused variables,
@@ -159,6 +163,11 @@ let simplify_lambda lam =
       | 1 -> Hashtbl.add subst v (simplif l1); simplif l2
       | n -> Llet(Alias, v, simplif l1, simplif l2)
       end
+  | Llet(StrictOpt, v, l1, l2) ->
+      begin match count_var v with
+        0 -> simplif l2
+      | n -> Llet(Alias, v, simplif l1, simplif l2)
+      end
   | Lletrec(bindings, body) ->
       Lletrec(List.map (fun (v, l) -> (v, simplif l)) bindings, simplif body)
   | Lprim(p, ll) -> Lprim(p, List.map simplif ll)
@@ -178,8 +187,6 @@ let simplify_lambda lam =
   | Lfor(v, l1, l2, dir, l3) ->
       Lfor(v, simplif l1, simplif l2, dir, simplif l3)
   | Lassign(v, l) -> Lassign(v, simplif l)
   in
   simplif lam
diff --git a/bytecomp/translcore.ml b/bytecomp/translcore.ml
index d89ec8f..07ad56c 100644
--- a/bytecomp/translcore.ml
+++ b/bytecomp/translcore.ml
@@ -20,11 +20,12 @@ open Primitive
@@ -139,8 +140,8 @@ let primitives_table = create_hashtable 31 [
 ]
 
 let same_base_type ty1 ty2 =
-  match (Ctype.repr ty1, Ctype.repr ty2) with
-    (Tconstr(p1, []), Tconstr(p2, [])) -> Path.same p1 p2
+  match ((Ctype.repr ty1).desc, (Ctype.repr ty2).desc) with
+    (Tconstr(p1, [], _), Tconstr(p2, [], _)) -> Path.same p1 p2
   | (_, _) -> false
 
 let maybe_pointer arg =
@@ -148,11 +149,11 @@ let maybe_pointer arg =
       same_base_type arg.exp_type Predef.type_char)
 
 let array_kind arg =
-  match Ctype.repr arg.exp_type with
-    Tconstr(p, [ty]) when Path.same p Predef.path_array ->
-      begin match Ctype.repr ty with
-        Tvar v -> Pgenarray
-      | Tconstr(p, _) ->
+  match (Ctype.repr arg.exp_type).desc with
+    Tconstr(p, [ty], _) when Path.same p Predef.path_array ->
+      begin match (Ctype.repr ty).desc with
+        Tvar -> Pgenarray
+      | Tconstr(p, _, _) ->
           if Path.same p Predef.path_int or Path.same p Predef.path_char then
             Pintarray
           else if Path.same p Predef.path_float then
@@ -263,8 +264,10 @@ let rec name_pattern default = function
 
 let rec transl_exp e =
   match e.exp_desc with
-    Texp_ident(path, {val_prim = Some p}) ->
+    Texp_ident(path, {val_kind = Val_prim p}) ->
       transl_primitive p
   | Texp_ident(path, desc) ->
       transl_path path
   | Texp_constant cst ->
@@ -274,11 +277,18 @@ let rec transl_exp e =
   | Texp_function pat_expr_list ->
       let (params, body) = transl_function e.exp_loc pat_expr_list in
       Lfunction(params, body)
-  | Texp_apply({exp_desc = Texp_ident(path, {val_prim = Some p})}, args)
+  | Texp_apply({exp_desc = Texp_ident(path, {val_kind = Val_prim p})}, args)
     when List.length args = p.prim_arity ->
       Lprim(transl_prim p args, transl_list args)
   | Texp_apply(funct, args) ->
-      Lapply(transl_exp funct, transl_list args)
+      begin match transl_exp funct with
+        Lapply(lfunct, largs) ->
+          Lapply(lfunct, largs @ transl_list args)
+      | Lsend(lmet, lobj, largs) ->
+          Lsend(lmet, lobj, largs @ transl_list args)
+      | lexp ->
+          Lapply(lexp, transl_list args)
+      end
   | Texp_match({exp_desc = Texp_tuple argl} as arg, pat_expr_list) ->
       Matching.for_multiple_match e.exp_loc
         (transl_list argl) (transl_cases pat_expr_list)
@@ -379,6 +389,23 @@ let rec transl_exp e =
       Lfor(param, transl_exp low, transl_exp high, dir, transl_exp body)
   | Texp_when(cond, body) ->
       Lifthenelse(transl_exp cond, transl_exp body, Lstaticfail)
   | _ ->
       fatal_error "Translcore.transl"
 
@@ -419,6 +446,10 @@ and transl_let rec_flag pat_expr_list body =
         (id, lam) in
       Lletrec(List.map transl_case pat_expr_list, body)
 

 let transl_exception id decl =
diff --git a/bytecomp/translcore.mli b/bytecomp/translcore.mli
index fbaa50a..20ffd18 100644
--- a/bytecomp/translcore.mli
+++ b/bytecomp/translcore.mli
@@ -18,6 +18,9 @@ open Asttypes
 open Typedtree
 open Lambda
 
+val name_pattern: string -> (Typedtree.pattern * 'a) list -> Ident.t
+val maybe_pointer: expression -> bool
+
 val transl_exp: expression -> lambda
 val transl_let:
       rec_flag -> (pattern * expression) list -> lambda -> lambda
 exception Error of Location.t * error
 
diff --git a/bytecomp/translmod.ml b/bytecomp/translmod.ml
index 7c20a71..d90e664 100644
--- a/bytecomp/translmod.ml
+++ b/bytecomp/translmod.ml
@@ -18,8 +18,9 @@ open Misc
 open Asttypes
 open Typedtree
 open Lambda
 (* Compile a coercion *)
 
@@ -119,10 +120,10 @@ and transl_structure fields cc = function
       let ext_fields = rev_let_bound_idents pat_expr_list @ fields in
       transl_let rec_flag pat_expr_list (transl_structure ext_fields cc rem)
   | Tstr_primitive(id, descr) :: rem ->
-      begin match descr.val_prim with
-        None -> ()
-      | Some p -> primitive_declarations :=
-                    p.Primitive.prim_name :: !primitive_declarations
+      begin match descr.val_kind with
+        Val_prim p -> primitive_declarations :=
+                        p.Primitive.prim_name :: !primitive_declarations
+      | _ -> ()
       end;
       transl_structure fields cc rem
   | Tstr_type(decls) :: rem ->
@@ -137,13 +138,20 @@ and transl_structure fields cc = function
       transl_structure fields cc rem
   | Tstr_open path :: rem ->
       transl_structure fields cc rem
 
 (* Compile an implementation *)
 
 let transl_implementation module_name str cc =
+  reset_labels ();
   primitive_declarations := [];
-  let module_id = Ident.new_persistent module_name in
-  Lprim(Psetglobal module_id, [transl_structure [] cc str])
+  let module_id = Ident.create_persistent module_name in
+  Lprim(Psetglobal module_id, [transl_label_init (transl_structure [] cc str)])
 
 (* A variant of transl_structure used to compile toplevel structure definitions
    for the native-code compiler. Store the defined values in the fields
@@ -163,10 +171,10 @@ let transl_store_structure glob map prims str =
         (store_idents glob map (let_bound_idents pat_expr_list)
           (transl_store rem))
   | Tstr_primitive(id, descr) :: rem ->
-      begin match descr.val_prim with
-        None -> ()
-      | Some p -> primitive_declarations :=
-                    p.Primitive.prim_name :: !primitive_declarations
+      begin match descr.val_kind with
+        Val_prim p -> primitive_declarations :=
+                        p.Primitive.prim_name :: !primitive_declarations
+      | _ -> ()
       end;
       transl_store rem
   | Tstr_type(decls) :: rem ->
 
 (* Transform a coercion and the list of value identifiers built above
    into a table id -> (pos, coercion), with [pos] being the position
@@ -253,17 +269,19 @@ let build_ident_map restr idlist =
    (for the native-code compiler). *)
 
 let transl_store_implementation module_name str restr =
+  reset_labels ();
   primitive_declarations := [];
-  let module_id = Ident.new_persistent module_name in
+  let module_id = Ident.create_persistent module_name in
   let (map, prims, size) = build_ident_map restr (defined_idents str) in
-  (size, transl_store_structure module_id map prims str)
+  (size, transl_label_init (transl_store_structure module_id map prims str))
 
 (* Compile a toplevel phrase *)
 
@@ -291,6 +309,12 @@ let transl_toplevel_item = function
       lambda_unit
   | Tstr_open path ->
       lambda_unit
 let transl_toplevel_definition str =
-  make_sequence transl_toplevel_item str
+  reset_labels ();
+  transl_label_init (make_sequence transl_toplevel_item str)

* byterun/

diff --git a/byterun/instruct.h b/byterun/instruct.h
index 5f80cd7..98a36f1 100644
--- a/byterun/instruct.h
+++ b/byterun/instruct.h
@@ -42,5 +42,6 @@ enum instructions {
   ANDINT, ORINT, XORINT, LSLINT, LSRINT, ASRINT,
   EQ, NEQ, LTINT, LEINT, GTINT, GEINT,
   OFFSETINT, OFFSETREF,
+  GETMETHOD,
   STOP
 };




diff --git a/byterun/interp.c b/byterun/interp.c
index e8b4418..ba4cde9 100644
--- a/byterun/interp.c
+++ b/byterun/interp.c
@@ -826,6 +826,16 @@ value interprete(prog, prog_size)
       pc++;
       Next;
 
+/* Object-oriented operations */
+
+#define Lookup(obj, lab) \
+  Field (Field (Field (obj, 0), ((lab) >> 16) / sizeof (value)), \
+	 ((lab) / sizeof (value)) & 0xFF)
+
+    Instruct(GETMETHOD):
+      accu = Lookup(sp[0], accu);
+      Next;
+
 /* Machine control */
 
     Instruct(STOP):


* driver/

diff --git a/driver/compile.ml b/driver/compile.ml
index e15022d..1341153 100644
--- a/driver/compile.ml
+++ b/driver/compile.ml
@@ -85,7 +85,7 @@ let implementation sourcefile =
         (Includemod.compunit sourcefile sg intf_file dclsig, crc)
       end else begin
         let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
-        Typemod.check_nongen_schemes str;
+        Typemod.check_nongen_schemes finalenv str;
         (Tcoerce_none, crc)
       end in
     Emitcode.to_file oc modulename crc
diff --git a/driver/optcompile.ml b/driver/optcompile.ml
index f055b53..ef54574 100644
--- a/driver/optcompile.ml
+++ b/driver/optcompile.ml
@@ -82,7 +82,7 @@ let implementation sourcefile =
         (Includemod.compunit sourcefile sg intf_file dclsig, crc)
       end else begin
         let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
-        Typemod.check_nongen_schemes str;
+        Typemod.check_nongen_schemes finalenv str;
         (Tcoerce_none, crc)
       end in
     Compilenv.reset modulename crc;

* parsing/

** ast


diff --git a/parsing/parsetree.mli b/parsing/parsetree.mli
index bcfdb9f..ea8356a 100644
--- a/parsing/parsetree.mli
+++ b/parsing/parsetree.mli
@@ -25,7 +25,17 @@ and core_type_desc =
     Ptyp_var of string
   | Ptyp_arrow of core_type * core_type
   | Ptyp_tuple of core_type list
-  | Ptyp_constr of Longident.t * core_type list
+  | Ptyp_constr of Longident.t * core_type list * string option
+
+and core_field_type =
+  { pfield_desc: core_field_desc;
+    pfield_loc: Location.t }
+
+and core_field_desc =
+    Pfield of Label.t * core_type
+  | Pfield_var
 
 (* Value expressions for the core language *)
 
@@ -66,8 +76,12 @@ and expression_desc =
   | Pexp_sequence of expression * expression
   | Pexp_while of expression * expression
   | Pexp_for of string * expression * expression * direction_flag * expression
-  | Pexp_constraint of expression * core_type
+  | Pexp_constraint of expression * core_type option * core_type option
   | Pexp_when of expression * expression
 (* Value descriptions *)
 
@@ -90,6 +104,46 @@ and type_kind =
 

** Typed AST

diff --git a/typing/typedtree.mli b/typing/typedtree.mli
index 01592ff..fe0e72a 100644
--- a/typing/typedtree.mli
+++ b/typing/typedtree.mli
@@ -13,21 +13,31 @@
 
 (* Type expressions for the core language *)
 
 type type_expr =
-    Tvar of type_variable
+  { mutable desc: type_desc; 
+    mutable level: int }
+
+and type_desc =
+    Tvar
   | Tarrow of type_expr * type_expr
   | Ttuple of type_expr list
-  | Tconstr of Path.t * type_expr list
-
-and type_variable =
-    { mutable tvar_level: int;
-      mutable tvar_link: type_expr option }
+  | Tconstr of Path.t * type_expr list * (Path.t * type_expr) list ref
+  | Tnil
+  | Tlink of type_expr
 
 (* Value descriptions *)
 
 type value_description =
   { val_type: type_expr;                       (* Type of the val *)
-    val_prim: Primitive.description option }   (* Is this a primitive? *)
+    val_kind: value_kind }
+
+and value_kind =
+    Val_reg				(* Regular value *)
+  | Val_prim of Primitive.description	(* Primitive *)
 
 (* Constructor descriptions *)

 
** toplevel/

diff --git a/toplevel/printval.ml b/toplevel/printval.ml
index 0048ec5..b6c02b4 100644
--- a/toplevel/printval.ml
+++ b/toplevel/printval.ml
@@ -13,6 +13,7 @@
 
 (* To print values *)
 
+open Misc
 open Obj
 open Format
 open Longident
@@ -100,8 +101,8 @@ let print_qualified lookup_fun env ty_path name =
       print_string name
   | Pdot(p, s, pos) ->
       if try
-           match lookup_fun (Lident name) env with
-             Tconstr(ty_path', _) -> Path.same ty_path ty_path'
+           match (lookup_fun (Lident name) env).desc with
+             Tconstr(ty_path', _, _) -> Path.same ty_path ty_path'
            | _ -> false
          with Not_found -> false
       then print_string name
@@ -132,8 +133,8 @@ let print_value env obj ty =
     try
       find_printer env ty obj; ()
     with Not_found ->
-      match Ctype.repr ty with
-        Tvar _ ->
+      match (Ctype.repr ty).desc with
+        Tvar ->
           print_string "<poly>"
       | Tarrow(ty1, ty2) ->
           print_string "<fun>"
@@ -144,14 +145,14 @@ let print_value env obj ty =
           print_val_list 1 depth obj ty_list;
           if prio > 0 then print_string ")";
           close_box()
-      | Tconstr(path, []) when Path.same path Predef.path_exn ->
+      | Tconstr(path, [], _) when Path.same path Predef.path_exn ->
           if prio > 1
           then begin open_hovbox 2; print_string "(" end
           else open_hovbox 1;
           print_exception obj;
           if prio > 1 then print_string ")";
           close_box()
-      | Tconstr(path, [ty_arg]) when Path.same path Predef.path_list ->
+      | Tconstr(path, [ty_arg], _) when Path.same path Predef.path_list ->
           let rec print_conses depth cons =
             if Obj.is_block cons then begin
               print_val 0 (depth - 1) (Obj.field cons 0) ty_arg;
@@ -166,7 +167,7 @@ let print_value env obj ty =
           cautious (print_conses depth) obj;
           print_string "]";
           close_box()
-      | Tconstr(path, [ty_arg]) when Path.same path Predef.path_array ->
+      | Tconstr(path, [ty_arg], _) when Path.same path Predef.path_array ->
           let rec print_items depth i =
             if i < Obj.size obj then begin
               if i > 0 then begin print_string ";"; print_space() end;
@@ -178,7 +179,7 @@ let print_value env obj ty =
           cautious (print_items depth) 0;
           print_string "|]";
           close_box()
-      | Tconstr(path, ty_list) ->
+      | Tconstr(path, ty_list, _) ->
           begin try
             let decl = Env.find_type path env in
             match decl with
@@ -186,7 +187,7 @@ let print_value env obj ty =
                 print_string "<abstr>"
             | {type_kind = Type_abstract; type_manifest = Some body} ->
                 print_val prio depth obj
-                          (Ctype.substitute decl.type_params ty_list body)
+                          (Ctype.substitute [] decl.type_params ty_list body)
             | {type_kind = Type_variant constr_list} ->
                 let tag =
                   if Obj.is_block obj
@@ -195,7 +196,7 @@ let print_value env obj ty =
                 let (constr_name, constr_args) =
                   find_constr tag 0 0 constr_list in
                 let ty_args =
-                  List.map (Ctype.substitute decl.type_params ty_list)
+                  List.map (Ctype.substitute [] decl.type_params ty_list)
                       constr_args in
                 begin match ty_args with
                   [] ->
@@ -232,7 +233,7 @@ let print_value env obj ty =
                     print_label env path lbl_name;
                     print_string "="; print_cut();
                     let ty_arg =
-                      Ctype.substitute decl.type_params ty_list lbl_arg in
+                      Ctype.substitute [] decl.type_params ty_list lbl_arg in
                     cautious (print_val 0 (depth - 1) (Obj.field obj pos))
                              ty_arg;
                     close_box();
@@ -248,6 +249,10 @@ let print_value env obj ty =
           | Constr_not_found ->         (* raised by find_constr *)
               print_string "<unknown constructor>"
           end
+      | Tnil | Tlink _ ->
+      	  fatal_error "Printval.print_value"
 
   and print_val_list prio depth obj ty_list =
     let rec print_list depth i = function
diff --git a/toplevel/topdirs.ml b/toplevel/topdirs.ml
index f72a4da..8b862ca 100644
--- a/toplevel/topdirs.ml
+++ b/toplevel/topdirs.ml
@@ -149,8 +149,8 @@ let find_printer_type lid =
     let (path, desc) = Env.lookup_value lid !toplevel_env in
     Ctype.begin_def();
     let ty_arg = Ctype.newvar() in
-    Ctype.unify !toplevel_env (Tarrow(ty_arg, Predef.type_unit))
-                               (Ctype.instance desc.val_type);
+    Ctype.unify !toplevel_env (Ctype.newty (Tarrow(ty_arg, Predef.type_unit)))
+                              (Ctype.instance desc.val_type);
     Ctype.end_def();
     Ctype.generalize ty_arg;
     (ty_arg, path)
@@ -218,16 +218,16 @@ let dir_trace lid =
         overwrite_closure clos
          (Obj.repr (fun arg -> Trace.print_trace (current_environment()) arg));
         (* Warn if this is a primitive *)
-        match desc.val_prim with
-          None ->
-            Printtyp.longident lid; print_string " is now traced.";
-            print_newline()
-        | Some p ->
+        match desc.val_kind with
+          Val_prim p ->
             open_hovbox 0;
             print_string "Warning: "; Printtyp.longident lid;
             print_string " is an external function."; print_space();
             print_string "Inlined calls will not be traced.";
             close_box(); print_newline()
+        | _ ->
+            Printtyp.longident lid; print_string " is now traced.";
+            print_newline()
       end else begin
         Printtyp.longident lid; print_string " is not a function.";
         print_newline()
diff --git a/toplevel/toploop.ml b/toplevel/toploop.ml
index e019abf..4fdfb54 100644
--- a/toplevel/toploop.ml
+++ b/toplevel/toploop.ml
@@ -61,21 +61,23 @@ let load_lambda lam =
 
 (* Print the outcome of an evaluation *)
 
+let hidden = ref 0
+
 let print_item env = function
     Tsig_value(id, decl) ->
       open_hovbox 2;
-      begin match decl.val_prim with
-        None ->
+      begin match decl.val_kind with
+        Val_prim p ->
+          print_string "external "; Printtyp.ident id;
+          print_string " :"; print_space();
+          Printtyp.type_scheme decl.val_type; print_space();
+          print_string "= "; Primitive.print_description p
+      | _ ->
           print_string "val "; Printtyp.ident id;
           print_string " :"; print_space();
           Printtyp.type_scheme decl.val_type;
           print_string " ="; print_space();
           print_value env (Symtable.get_global_value id) decl.val_type
-      | Some p ->
-          print_string "external "; Printtyp.ident id;
-          print_string " :"; print_space();
-          Printtyp.type_scheme decl.val_type; print_space();
-          print_string "= "; Primitive.print_description p
       end;
       close_box()
   | Tsig_type(id, decl) ->
@@ -87,6 +89,9 @@ let print_item env = function
       print_string " :"; print_space(); Printtyp.modtype mty; close_box()
   | Tsig_modtype(id, decl) ->
       Printtyp.modtype_declaration id decl
 
 (* Print an exception produced by an evaluation *)
 
@@ -132,7 +137,12 @@ let execute_phrase phr =
               print_newline()
           | _ ->
               open_vbox 0;
-              List.iter (fun item -> print_item newenv item; print_space()) sg;
+	      hidden := 0;
+              List.iter
+                (fun item ->
+		   if !hidden > 0 then decr hidden
+      	       	   else begin print_item newenv item; print_space() end)
+      	        sg;
               close_box();
               print_flush()
           end;
diff --git a/toplevel/trace.ml b/toplevel/trace.ml
index c677b57..f9d9ed1 100644
--- a/toplevel/trace.ml
+++ b/toplevel/trace.ml
@@ -53,7 +53,7 @@ let overwrite_closure dst src =
    traces its execution. *)
 
 let rec instrument_closure name clos_typ =
-  match Ctype.repr clos_typ with
+  match (Ctype.repr clos_typ).desc with
     Tarrow(t1, t2) ->
       let starred_name =
         match name with


** typing (BIG)

diff --git a/typing/ctype.ml b/typing/ctype.ml
index 4870cd0..549e2db 100644
--- a/typing/ctype.ml
+++ b/typing/ctype.ml
@@ -14,85 +14,242 @@
 (* Operations on core types *)
 
 open Misc
-open Path
+open Asttypes
 open Typedtree
 
 exception Unify
 
 let current_level = ref 0
-
+let global_level = ref 1
 let generic_level = (-1)
 
-let reset_def () = current_level := 0
 let begin_def () = incr current_level
 let end_def () = decr current_level
 
-let newvar () =
-  Tvar { tvar_level = !current_level; tvar_link = None }
+let reset_global_level () =
+  global_level := !current_level + 1
 
-let new_global_var () =
-  Tvar { tvar_level = 1; tvar_link = None }
+let newty desc         = { desc = desc; level = !current_level }
+let new_global_ty desc = { desc = desc; level = !global_level }
+let newgenty desc      = { desc = desc; level = generic_level }
+let newvar ()          = { desc = Tvar; level = !current_level }
+let new_global_var ()  = new_global_ty Tvar
+let new_gen_var ()     = newgenty Tvar
 
 let rec repr = function
-    Tvar({tvar_link = Some ty} as v) ->
-      let r = repr ty in
-      if r != ty then v.tvar_link <- Some r;
+    {desc = Tlink t'} as t ->
+      let r = repr t' in
+      if r != t' then t.desc <- Tlink r;
       r
   | t -> t
 
-let none = Ttuple []                  (* Clearly ill-formed type *)
+let rec repr2 = function                (* No path compression *)
+                                        (* during unification *)
+    {desc = Tlink ty} ->
+      repr2 ty
+  | t -> t
+
+let none = newty (Ttuple [])                (* Clearly ill-formed type *)
+
+(* --- *)
+
+
 
 (* Type generalization *)
 
 let rec generalize ty =
-  match repr ty with
-    Tvar v ->
-      if v.tvar_level > !current_level then v.tvar_level <- generic_level
-  | Tarrow(t1, t2) ->
-      generalize t1; generalize t2
-  | Ttuple tl ->
-      List.iter generalize tl
-  | Tconstr(p, []) ->
-      ()
-  | Tconstr(p, tl) ->
-      List.iter generalize tl
+  let ty = repr ty in
+  if ty.level > !current_level then begin
+    ty.level <- generic_level;
+    match ty.desc with
+      Tvar               -> ()
+    | Tarrow(t1, t2)     -> generalize t1; generalize t2
+    | Ttuple tl          -> List.iter generalize tl
+    | Tconstr(_, tl, ab) -> ab := []; List.iter generalize tl
+    | Tnil               -> ()
+    | Tlink _            -> fatal_error "Ctype.generalize"
+  end
 
 let rec make_nongen ty =
-  match repr ty with
-    Tvar v ->
-      if v.tvar_level > !current_level then v.tvar_level <- !current_level
-  | Tarrow(t1, t2) ->
-      make_nongen t1; make_nongen t2
-  | Ttuple tl ->
-      List.iter make_nongen tl
-  | Tconstr(p, []) ->
-      ()
-  | Tconstr(p, tl) ->
-      List.iter make_nongen tl
+  let ty = repr ty in
+  if ty.level > !current_level then begin
+    ty.level <- !current_level;
+    match ty.desc with
+      Tvar              -> ()
+    | Tarrow(t1, t2)    ->  make_nongen t1; make_nongen t2
+    | Ttuple tl         -> List.iter make_nongen tl
+    | Tconstr(p, tl, _) -> List.iter make_nongen tl
+    | Tnil              -> ()
+    | Tlink _           -> fatal_error "Ctype.make_nongen"
+  end
+
+(* Remove abbreviations from generalized types *)
+
+let visited = ref ([] : type_expr list)
+
+let remove_abbrev ty =
+  let rec remove ty =
+    let ty = repr ty in
+    if ty.level = generic_level & not (List.memq ty !visited) then begin
+      visited := ty :: !visited;
+      match ty.desc with
+        Tvar               -> ()
+      | Tarrow(t1, t2)     -> remove t1; remove t2
+      | Ttuple tl          -> List.iter remove tl
+      | Tconstr(_, tl, ab) -> ab := []; List.iter remove tl
+      | Tnil               -> ()
+      | Tlink _            -> fatal_error "Ctype.remove_abbrev"
+      end
+  in
+    visited := []; remove ty; visited := []
+
 
 (* Taking instances of type schemes *)
 
+type 'a visited = Zero | One | Many of 'a
+
 let inst_subst = ref ([] : (type_expr * type_expr) list)
 
-let rec copy ty =
-  match repr ty with
-    Tvar v as t ->
-      if v.tvar_level = generic_level then begin
+let rec copy_rec abbrev visited ty =
+  let ty = repr ty in
+  if ty.level <> generic_level then ty else
+  try
+    match List.assq ty visited with
+      {contents = Zero} as v ->
+      	let t = newvar () in
+	v := Many t;
+	let ty' = copy_rec_2 abbrev visited ty v in
+	t.desc <- ty'.desc;
+	t
+    | {contents = One} as v ->
+        let t = newvar () in
+        v := Many t;
+        t
+    | {contents = Many t} ->
+        t
+  with Not_found ->
+    let v = ref One in
+    let ty' = copy_rec_2 abbrev ((ty, v)::visited) ty v in
+    match v with
+      {contents = Many t} ->
+      	t.desc <- ty'.desc;
+	t
+    | _ ->
+      	ty'
+
+and copy_rec_2 abbrev visited ty v =
+  match ty.desc with
+    Tvar ->
+      begin try List.assq ty !inst_subst with Not_found ->
+        let ty' = newvar () in
+        inst_subst := (ty, ty') :: !inst_subst;
+        ty'
+      end
+  | Tarrow (t1, t2) ->
+      newty (Tarrow (copy_rec abbrev visited t1,
+                     copy_rec abbrev visited t2))
+  | Ttuple tl ->
+      newty (Ttuple (List.map (copy_rec abbrev visited) tl))
+  | Tconstr (p, [], _) ->
+      newty (Tconstr (p, [], ref abbrev))
+  | Tconstr (p, tl, _) ->
+      newty (Tconstr (p, List.map (copy_rec abbrev visited) tl,
+                      ref abbrev))
-  | Tarrow(t1, t2) ->
-      Tarrow(copy t1, copy t2)
-  | Ttuple tl ->
-      Ttuple(List.map copy tl)
-  | Tconstr(p, []) as t ->
-      t
-  | Tconstr(p, tl) ->
-      Tconstr(p, List.map copy tl)
+          if v = ref One then begin
+            let t = newvar () in
+    	    v := Many t;
+            inst_subst := (ty, t):: !inst_subst
+          end;
+          ty' ()
+      else
+        ty' ()
+  | Tnil ->
+      newty Tnil
+  | Tlink _ ->
+      fatal_error "Ctype.copy_rec"
+
+let copy ty = copy_rec [] [] ty
+let subst abbrev ty = copy_rec abbrev [] ty
+let copy_parameterized params ty = copy_rec [] params ty
 
 let instance sch =
   inst_subst := [];
@@ -114,100 +271,317 @@ let instance_label lbl =
   inst_subst := [];
   (ty_arg, ty_res)
 
-let substitute params args body =
+let substitute abbrev params args body =
   inst_subst := List.combine params args;
-  let ty = copy body in
+  let ty = subst abbrev body in
   inst_subst := [];
   ty
 
+let instance_parameterized_type sch_args sch =
+  inst_subst := [];
+  let params = List.map (function p -> (repr p, ref Zero)) sch_args in
+  let ty_args = List.map (copy_parameterized params) sch_args in
+  let ty = copy_parameterized params sch in
+  inst_subst := [];
+  (ty_args, ty)
+
+let instance_parameterized_type_2 sch_args sch_lst sch =
+  inst_subst := [];
+  let params = List.map (function p -> (repr p, ref Zero)) sch_args in
+  let ty_args = List.map (copy_parameterized params) sch_args in
+  let ty_lst = List.map (copy_parameterized params) sch_lst in
+  let ty = copy_parameterized params sch in
+  inst_subst := [];
+  (ty_args, ty_lst, ty)
+
 (* Unification *)
 
+let rec update_level level ty =
+  let ty = repr2 ty in
+  if ty.level > level then begin
+    ty.level <- level;
+    match ty.desc with
+      Tvar               -> ()
+    | Tarrow(t1,t2)      -> update_level level t1; update_level level t2
+    | Ttuple(ty_list)    -> List.iter (update_level level) ty_list
+    | Tconstr(_, tl, _)  -> List.iter (update_level level) tl
+    | Tnil               -> ()
+    | Tlink _            -> fatal_error "Ctype.update_level"
+  end
+
 exception Cannot_expand
 
-let expand_abbrev env path args =
+let rec find_expans p1 =
+  function
+    [] ->
+      None
+  | (p2, ty)::l ->
+      if Path.same p1 p2 then
+        Some ty
+      else
+        find_expans p1 l
+
+let expand_abbrev env path args abbrev level =
+  match find_expans path !abbrev with
+    Some ty ->
+      update_level level ty;
+      ty
+  | None ->
+      try
+        let decl = Env.find_type path env in
+        match decl.type_manifest with
+          Some body ->
+            let v = newvar () in
+            abbrev := (path, v)::!abbrev;
+            let old_level = !current_level in
+            current_level := level;
+            let ty = substitute !abbrev decl.type_params args body in
+            current_level := old_level;
+            v.desc <- Tlink ty;
+            ty
+        | _ ->
+            raise Cannot_expand
+      with Not_found ->
+        raise Cannot_expand
+
+let generic_abbrev env path =
   try
     let decl = Env.find_type path env in
     match decl.type_manifest with
-      Some body -> substitute decl.type_params args body
-    | None -> raise Cannot_expand
-  with Not_found ->
-    raise Cannot_expand
-
-let rec occur tvar ty =
-  match repr ty with
-    Tvar v ->
-      if v == tvar then raise Unify;
-      if v.tvar_level > tvar.tvar_level then v.tvar_level <- tvar.tvar_level
-  | Tarrow(t1, t2) ->
-      occur tvar t1; occur tvar t2
-  | Ttuple tl ->
-      List.iter (occur tvar) tl
-  | Tconstr(p, []) ->
-      ()
-  | Tconstr(p, tl) ->
-      List.iter (occur tvar) tl
+      Some body ->
+        body.level = generic_level
+    | _ ->
+        false
+  with
+    Not_found ->
+      false
 
-let rec unify env t1 t2 =
-  if t1 == t2 then () else begin
-    let t1 = repr t1 in
-    let t2 = repr t2 in
-    if t1 == t2 then () else begin
-      match (t1, t2) with
-        (Tvar v, _) ->
-          occur v t2; v.tvar_link <- Some t2
-      | (_, Tvar v) ->
-          occur v t1; v.tvar_link <- Some t1
-      | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
-          unify env t1 t2; unify env u1 u2
-      | (Ttuple tl1, Ttuple tl2) ->
-          unify_list env tl1 tl2
-      | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
-          if Path.same p1 p2 then
-            unify_list env tl1 tl2
-          else begin
-            try
-              unify env (expand_abbrev env p1 tl1) t2
-            with Cannot_expand ->
-            try
-              unify env t1 (expand_abbrev env p2 tl2)
-            with Cannot_expand ->
-              raise Unify
-          end
-      | (Tconstr(p1, tl1), _) ->
-          begin try
-            unify env (expand_abbrev env p1 tl1) t2
+let occur env ty0 ty =
+  let visited = ref ([] : type_expr list) in
+  let rec occur_rec ty =
+    match ty.desc with
+      Tlink ty' ->
+        occur_rec ty'
+    | Tvar ->
+        if ty == ty0 then raise Unify else
+        ()
+    | Tarrow(t1, t2) ->
+        occur_rec t1; occur_rec t2
+    | Ttuple tl ->
+        List.iter occur_rec tl
+    | Tconstr(p, [], _) ->
+        ()
+    | Tconstr(p, tl, abbrev) ->
+        if not (List.memq ty !visited) then begin
+          visited := ty :: !visited;
+          try List.iter occur_rec tl with Unify ->
+          try occur_rec (expand_abbrev env p tl abbrev ty.level)
           with Cannot_expand ->
-            raise Unify
-          end
-      | (_, Tconstr(p2, tl2)) ->
-          begin try
-            unify env t1 (expand_abbrev env p2 tl2)
-          with Cannot_expand ->
-            raise Unify
-          end
-      | (_, _) ->
+          ()
+        end
+    | Tnil ->
+        fatal_error "Ctype.occur"
+  in
+    occur_rec ty
+
+let rec unify_rec env a1 a2 t1 t2 =     (* Variables and abbreviations *)
+  if t1 == t2 then () else
+  let t1 = repr2 t1 in
+  let t2 = repr2 t2 in
+  if t1 == t2 then () else
+  match (t1.desc, t2.desc) with
+    (Tvar, _) ->
+       update_level t1.level t2;
+       begin match a2 with
+         None    -> occur env t1 t2; t1.desc <- Tlink t2
+       | Some l2 -> occur env t1 l2; t1.desc <- Tlink l2
+       end
+  | (_, Tvar) ->
+       update_level t2.level t1;
+       begin match a1 with
+         None    -> occur env t2 t1; t2.desc <- Tlink t1
+       | Some l1 -> occur env t2 l1; t2.desc <- Tlink l1
+       end
+  | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) when Path.same p1 p2 ->
+       unify_core env a1 a2 t1 t2
+  | (Tconstr (p1, tl1, abbrev1), Tconstr (p2, tl2, abbrev2)) ->
+      begin
+        try
+          let t3 = expand_abbrev env p1 tl1 abbrev1 t1.level in
+          update_level t2.level t1;
+          unify_rec env (Some t1) a2 t3 t2
+        with Cannot_expand ->
+        try
+          let t3 = expand_abbrev env p2 tl2 abbrev2 t2.level in
+          update_level t1.level t2;
+          unify_rec env a1 (Some t2) t1 t3
+        with Cannot_expand ->
           raise Unify
-    end
-  end
+      end
+  | (Tconstr (p1, tl1, abbrev1), _) ->
+      begin try
+        let t3 = expand_abbrev env p1 tl1 abbrev1 t1.level in
+        update_level t2.level t1;
+        unify_rec env (Some t1) a2 t3 t2
+      with Cannot_expand ->
+        unify_core env a1 a2 t1 t2
+      end
+  | (_, Tconstr (p2, tl2, abbrev2)) ->
+      begin try
+        let t3 = expand_abbrev env p2 tl2 abbrev2 t2.level in
+        update_level t1.level t2;
+        unify_rec env a1 (Some t2) t1 t3
+      with Cannot_expand ->
+        unify_core env a1 a2 t1 t2
+      end
+  | (_, _) ->
+      unify_core env a1 a2 t1 t2
+
+and unify_core env a1 a2 t1 t2 =        (* Other cases *)
+  let d1 = t1.desc and d2 = t2.desc in
+  begin match (a1, a2) with
+    (None,    Some l2) ->
+      update_level t1.level t2; t1.desc <- Tlink l2
+  | (Some l1, None) ->
+      update_level t2.level t1; t2.desc <- Tlink l1
+  | (_, _) ->
+      update_level t1.level t2; t1.desc <- Tlink t2
+  end;
+  try
+    match (d1, d2) with
+      (Tarrow (t1, u1), Tarrow (t2, u2)) ->
+        unify_rec env None None t1 t2; unify_rec env None None u1 u2
+    | (Ttuple tl1, Ttuple tl2) ->
+        unify_list env tl1 tl2
+    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) (*when Path.same p1 p2*) ->
+        ()
+    | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) (*when Path.same p1 p2*) ->
+        unify_list env tl1 tl2
+    | (_, _) ->
+        raise Unify
+  with exn ->
+    t1.desc <- d1;
+    t2.desc <- d2;
+    raise exn
 
 and unify_list env tl1 tl2 =
-  match (tl1, tl2) with
-    ([], []) -> ()
-  | (t1::r1, t2::r2) -> unify env t1 t2; unify_list env r1 r2
-  | (_, _) -> raise Unify
+  try
+    List.iter2 (unify_rec env None None) tl1 tl2
+  with Invalid_argument _ ->
+    raise Unify
+
+and unify_fields env ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1
+  and (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  let va = newvar () in
+    begin match rest1.desc with
+      Tvar ->
+        let nr = build_fields miss2 va in
+        update_level rest1.level nr;
+        rest1.desc <- Tlink nr
+    | Tnil ->
+        if miss2 <> [] then raise Unify;
+        va.desc <- Tlink {desc = Tnil; level = va.level}
+    | _ ->
+        fatal_error "Ctype.unify_fields (1)"
+    end;
+    begin match rest2.desc with
+      Tvar ->
+        let nr = build_fields miss1 va in
+        update_level rest2.level nr;
+        rest2.desc <- Tlink nr
+    | Tnil ->
+        if miss1 <> [] then raise Unify;
+        va.desc <- Tlink {desc = Tnil; level = va.level}
+    | _ ->
+        fatal_error "Ctype.unify_fields (2)"
+    end;
+    List.iter (fun (t1, t2) -> unify_rec env None None t1 t2) pairs
+
+let unify env ty1 ty2 =
+  unify_rec env None None ty1 ty2
 
 let rec filter_arrow env t =
-  match repr t with
-    Tvar v ->
-      let t1 = Tvar { tvar_level = v.tvar_level; tvar_link = None }
-      and t2 = Tvar { tvar_level = v.tvar_level; tvar_link = None } in
-      v.tvar_link <- Some(Tarrow(t1, t2));
+  let t = repr t in
+  match t.desc with
+    Tvar ->
+      let t1 = newvar () and t2 = newvar () in
+      let t' = newty (Tarrow (t1, t2)) in
+      update_level t.level t';
+      t.desc <- Tlink t';
       (t1, t2)
   | Tarrow(t1, t2) ->
       (t1, t2)
-  | Tconstr(p, tl) ->
+  | Tconstr(p, tl, abbrev) ->
+      begin try
+        filter_arrow env (expand_abbrev env p tl abbrev t.level)
+      with Cannot_expand ->
+        raise Unify
+      end
+  | _ ->
+      raise Unify
+
@@ -216,127 +590,188 @@ let rec filter_arrow env t =
 
 (* Matching between type schemes *)
 
-let rec moregen_occur tvar ty =
-  match repr ty with
-    Tvar v ->
-      if v == tvar then raise Unify;
-      (* tvar has level = !current_level iff it is generic
+let rec moregen_occur ty0 ty =
+  let visited = ref [] in
+  let rec occur_rec ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      (* ty0 has level = !current_level iff it is generic
          in the original type scheme. In this case, it can be freely
-         instantiated. Otherwise, tvar is not generic
+         instantiated. Otherwise, ty0 is not generic
          and cannot be instantiated by a type that contains
          generic variables. *)
-      if v.tvar_level = generic_level & tvar.tvar_level < !current_level
+      if ty.level = generic_level & ty0.level < !current_level
       then raise Unify
   | Tarrow(t1, t2) ->
-      moregen_occur tvar t1; moregen_occur tvar t2
+      occur_rec t1; occur_rec t2
   | Ttuple tl ->
-      List.iter (moregen_occur tvar) tl
-  | Tconstr(p, []) ->
+      List.iter occur_rec tl
+  | Tconstr(p, tl, _) ->
+      if not (List.memq ty !visited) then begin
+        visited := ty::!visited;
+        List.iter occur_rec tl
+      end
+  | Tnil ->
       ()
-  | Tconstr(p, tl) ->
-      List.iter (moregen_occur tvar) tl
+  | Tlink _ ->
+      fatal_error "Ctype.moregen_occur"
+  in
+    occur_rec ty
 
 let rec moregen env t1 t2 =
-  if t1 == t2 then () else begin
-    let t1 = repr t1 in
-    let t2 = repr t2 in
-    if t1 == t2 then () else begin
-      match (t1, t2) with
-        (Tvar v, _) ->
-          if v.tvar_level = generic_level then raise Unify;
-          moregen_occur v t2;
-          v.tvar_link <- Some t2
-      | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
-          moregen env t1 t2; moregen env u1 u2
-      | (Ttuple tl1, Ttuple tl2) ->
-          moregen_list env tl1 tl2
-      | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
-          if Path.same p1 p2 then
-            moregen_list env tl1 tl2
-          else begin
-            try
-              moregen env (expand_abbrev env p1 tl1) t2
-            with Cannot_expand ->
-            try
-              moregen env t1 (expand_abbrev env p2 tl2)
-            with Cannot_expand ->
-              raise Unify
-          end
-      | (Tconstr(p1, tl1), _) ->
-          begin try
-            moregen env (expand_abbrev env p1 tl1) t2
+  if t1 == t2 then () else
+  let t1 = repr t1 in
+  let t2 = repr t2 in
+  if t1 == t2 then () else
+  let d1 = t1.desc in
+  try
+    begin match (t1.desc, t2.desc) with
+      (Tvar, _) ->
+        if t1.level = generic_level then raise Unify;
+        occur env t1 t2;
+        moregen_occur t1 t2;
+        t1.desc <- Tlink t2
+    | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
+        moregen env t1 t2; moregen env u1 u2
+    | (Ttuple tl1, Ttuple tl2) ->
+        moregen_list env tl1 tl2
+    | (Tconstr(p1, tl1, abbrev1), Tconstr(p2, tl2, abbrev2)) ->
+        if Path.same p1 p2 then begin
+          t1.desc <- Tlink t2;
+          moregen_list env tl1 tl2;
+          t1.desc <- d1
+        end else begin
+          try
+            moregen env (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
           with Cannot_expand ->
-            raise Unify
-          end
-      | (_, Tconstr(p2, tl2)) ->
-          begin try
-            moregen env t1 (expand_abbrev env p2 tl2)
+          try
+            moregen env t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
           with Cannot_expand ->
             raise Unify
-          end
-      | (_, _) ->
+        end
+    | (Tconstr(p1, tl1, abbrev1), _) ->
+        begin try
+          moregen env (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+        with Cannot_expand ->
           raise Unify
+        end
+    | (_, Tconstr(p2, tl2, abbrev2)) ->
+        begin try
+          moregen env t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+        with Cannot_expand ->
+          raise Unify
+        end
+    | (_, _) ->
+        raise Unify
     end
-  end
+  with exn ->
+    t1.desc <- d1;
+    raise exn
 
 and moregen_list env tl1 tl2 =
-  match (tl1, tl2) with
-    ([], []) -> ()
-  | (t1::r1, t2::r2) -> moregen env t1 t2; moregen_list env r1 r2
-  | (_, _) -> raise Unify
-  
+  try
+    List.iter2 (moregen env) tl1 tl2
+  with Invalid_argument _ ->
+    raise Unify
+
+and moregen_fields env ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1
+  and (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  if miss1 <> [] then raise Unify;
+  begin match rest1.desc with
+    Tvar ->
+      if rest1.level = generic_level then raise Unify;
+      let fi = build_fields miss2 rest2 in
+      moregen_occur rest1 fi
+  | Tnil ->
+      if miss2 <> [] then raise Unify;
+      if rest2.desc <> Tnil then raise Unify
+  | _ ->
+      fatal_error "moregen_fields"
+  end;
+  List.iter (fun (t1, t2) -> moregen env t1 t2) pairs
+
 let moregeneral env sch1 sch2 =
   begin_def();
   try
     moregen env (instance sch1) sch2;
+    remove_abbrev sch2;
     end_def();
     true
   with Unify ->
+    remove_abbrev sch2;
     end_def();
     false
 
 (* Equivalence between parameterized types *)
 
 let equal env params1 ty1 params2 ty2 =
-  let subst = List.combine params1 params2 in
+  let subst = ref (List.combine params1 params2) in
+  let type_pairs = ref [] in
   let rec eqtype t1 t2 =
     let t1 = repr t1 in
     let t2 = repr t2 in
-    match (t1, t2) with
-      (Tvar _, Tvar _) ->
+    match (t1.desc, t2.desc) with
+      (Tvar, Tvar) ->
         begin try
-          List.assq t1 subst == t2
+          List.assq t1 !subst == t2
         with Not_found ->
-          fatal_error "Ctype.equal"
+          subst := (t1, t2) :: !subst;
+          true
         end
     | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
         eqtype t1 t2 & eqtype u1 u2
     | (Ttuple tl1, Ttuple tl2) ->
         eqtype_list tl1 tl2
-    | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
-        if Path.same p1 p2 then
-          eqtype_list tl1 tl2
-        else begin
-          try
-            eqtype (expand_abbrev env p1 tl1) t2
-          with Cannot_expand ->
-          try
-            eqtype t1 (expand_abbrev env p2 tl2)
-          with Cannot_expand ->
-            false
+    | (Tconstr(p1, tl1, abbrev1), Tconstr(p2, tl2, abbrev2)) ->
+        List.exists (function (t1', t2') -> t1 == t1' & t2 == t2') !type_pairs
+        or begin
+          type_pairs := (t1, t2) :: !type_pairs;
+          if Path.same p1 p2 then
+            eqtype_list tl1 tl2
+          else begin
+            try
+              eqtype (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+            with Cannot_expand ->
+            try
+              eqtype t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+            with Cannot_expand ->
+              false
+          end
+        end
-    | (Tconstr(p1, tl1), _) ->
+    | (Tconstr(p1, tl1, abbrev1), _) ->
         begin try
-          eqtype (expand_abbrev env p1 tl1) t2
+          eqtype (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
         with Cannot_expand ->
           false
         end
-    | (_, Tconstr(p2, tl2)) ->
+    | (_, Tconstr(p2, tl2, abbrev2)) ->
         begin try
-          eqtype t1 (expand_abbrev env p2 tl2)
+          eqtype t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
         with Cannot_expand ->
           false
         end
+    | (Tnil, Tnil) ->
+        true
     | (_, _) ->
         false
   and eqtype_list tl1 tl2 =
@@ -344,65 +779,546 @@ let equal env params1 ty1 params2 ty2 =
       ([], []) -> true
     | (t1::r1, t2::r2) -> eqtype t1 t2 & eqtype_list r1 r2
     | (_, _) -> false
+  and eqtype_fields ty1 ty2 =
+    let (fields1, rest1) = flatten_fields ty1
+    and (fields2, rest2) = flatten_fields ty2 in
+    List.length fields1 = List.length fields2
+      &
+    eqtype rest1 rest2
+      &
+    List.for_all
+      (function (label, t) ->
+         List.exists
+           (function (label', t') ->
+              (Label. (=) label label') & (eqtype t t'))
+           fields2)
+      fields1
   in
-    eqtype ty1 ty2
+    let eq = eqtype ty1 ty2 in
+    remove_abbrev ty1; remove_abbrev ty2;
+    eq
 
-(* Remove dependencies *)
+(* Subtyping *)
+
+let visited = ref ([] : type_expr list)
 
-let rec nondep_type env id ty =
-  match repr ty with
-    Tvar v as tvar -> tvar
+let rec build_subtype env vars t =
+  if List.memq t vars then (t, false) else
+  match t.desc with
+    Tlink t' ->
+      build_subtype env vars t'
+  | Tvar ->
+      (t, false)
   | Tarrow(t1, t2) ->
-      Tarrow(nondep_type env id t1, nondep_type env id t2)
-  | Ttuple tl ->
-      Ttuple(List.map (nondep_type env id) tl)
-  | Tconstr(p, tl) ->
-      if Path.isfree id p then begin
-        let ty' =
-          try
-            expand_abbrev env p tl
-          with Cannot_expand ->
-            raise Not_found in
-        nondep_type env id ty'
+      let (t1', c1) = build_supertype env vars t1 in
+      let (t2', c2) = build_subtype env vars t2 in
+      if c1 or c2 then (new_global_ty (Tarrow(t1', t2')), true)
+      else (t, false)
+  | Ttuple tlist ->
+      let (tlist', clist) =
+        List.split (List.map (build_subtype env vars) tlist)
+      in
+      if List.exists (function c -> c) clist then
+        (new_global_ty (Ttuple tlist'), true)
+      else (t, false)
+  | Tconstr(p, tl, abbrev) ->
+      if generic_abbrev env p then begin
+        let t' = expand_abbrev env p tl abbrev t.level in
+        let (t'', c) = build_subtype env vars t' in
+        if c then (t'', true)
+        else (t, false)
       end else
-        Tconstr(p, List.map (nondep_type env id) tl)
+        (t, false)
+  | Tnil ->
+      let v = new_global_var () in
+      (v, true)
 
-let rec free_type_ident env ids ty =
-  match repr ty with
-    Tvar _ -> false
+and build_supertype env vars t =
+  if List.memq t vars then (t, false) else
+  match t.desc with
+    Tlink t' ->
+      build_supertype env vars t'
+  | Tvar ->
+      (t, false)
   | Tarrow(t1, t2) ->
-      free_type_ident env ids t1 or free_type_ident env ids t2
+      let (t1', c1) = build_subtype env vars t1 in
+      let (t2', c2) = build_supertype env vars t2 in
+      if c1 or c2 then (new_global_ty (Tarrow(t1', t2')), true)
+      else (t, false)
+  | Ttuple tlist ->
+      let (tlist', clist) =
+        List.split (List.map (build_supertype env vars) tlist)
+      in
+      if List.exists (function c -> c) clist then
+        (new_global_ty (Ttuple tlist'), true)
+      else
+        (t, false)
+  | Tconstr(p, tl, abbrev) ->
+      if generic_abbrev env p then begin
+        let t' = expand_abbrev env p tl abbrev t.level in
+        let (t'', c) = build_supertype env vars t' in
+        if c then (t'', c)
+        else (t, false)
+      end else
+        (t, false)
+  | Tnil ->
+      (t, false)
+
+let enlarge_type env vars ty =
+  visited := [];
+  let (ty', _) = build_subtype env vars ty in
+    visited := [];
+    ty'
+
+let subtypes = ref [];;
+let known_subtype t1 t2 =
+  List.exists (fun (t1', t2') -> t1 == t1' & t2 == t2') !subtypes
+
+let rec subtype_rec env vars t1 t2 =
+  if t1 == t2 then () else
+  if List.memq t1 vars or List.memq t2 vars then unify env t1 t2 else
+    match (t1.desc, t2.desc) with
+      (Tlink t1', _) ->
+        subtype_rec env vars t1' t2
+    | (_, Tlink t2') ->
+        subtype_rec env vars t1 t2'
+    | (Tvar, _) | (_, Tvar) ->
+        unify env t1 t2
+    | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
+        subtype_rec env vars t2 t1; subtype_rec env vars u1 u2
+    | (Ttuple tl1, Ttuple tl2) ->
+        subtype_list env vars tl1 tl2
+    | (Tconstr(p1, tl1, abbrev1), Tconstr(p2, tl2, abbrev2)) ->
+        if generic_abbrev env p1 then
+          subtype_rec env vars (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+        else if generic_abbrev env p2 then
+          subtype_rec env vars t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+        else
+          unify env t1 t2
+    | (Tconstr(p1, tl1, abbrev1), _) ->
+        if generic_abbrev env p1 then
+          subtype_rec env vars (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
+        else
+          unify env t1 t2
+    | (_, Tconstr(p2, tl2, abbrev2)) ->
+        if generic_abbrev env p2 then
+          subtype_rec env vars t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
+        else
+          unify env t1 t2
+    | (_, _) ->
+        raise Unify
+
+and subtype_list env vars tl1 tl2 =
+  try
+    List.iter2 (subtype_rec env vars) tl1 tl2
+  with Invalid_argument _ ->
+    raise Unify
+
+and subtype_fields env vars ty1 ty2 =
+  let (fields1, rest1) = flatten_fields ty1 in
+  let (fields2, rest2) = flatten_fields ty2 in
+  let (pairs, miss1, miss2) = associate_fields fields1 fields2 in
+  begin match rest1.desc with
+    Tvar ->
+      let nr = build_fields miss2 (newvar ()) in
+      update_level rest1.level nr;
+      rest1.desc <- Tlink nr
+  | Tnil   -> if miss2 <> [] then raise Unify
+  | _      -> fatal_error "Ctype.subtype_fields (1)"
+  end;
+  begin match rest2.desc with
+    Tvar ->
+      let nr = build_fields miss1 (newvar ()) in
+      update_level rest2.level nr;
+      rest2.desc <- Tlink nr
+  | Tnil   -> ()
+  | _      -> fatal_error "Ctype.subtype_fields (2)"
+  end;
+  List.iter (fun (t1, t2) -> subtype_rec env vars t1 t2) pairs
+
+let subtype env vars ty1 ty2 =
+  subtypes := [];
+  subtype_rec env vars ty1 ty2;
+  subtypes := []
+
+(* Remove dependencies *)
+
+let inst_subst = ref ([] : (type_expr * type_expr) list)
+
+let rec nondep_type_rec env id ty =
+  let ty = repr ty in
+  if ty.desc = Tvar then ty else
+  try List.assq ty !inst_subst with Not_found ->
+    let ty' = new_gen_var () in
+    inst_subst := (ty, ty') :: !inst_subst;
+    ty'.desc <-
+      begin match ty.desc with
+        Tvar ->
+          Tvar
+      | Tarrow(t1, t2) ->
+          Tarrow(nondep_type_rec env id t1, nondep_type_rec env id t2)
+      | Ttuple tl ->
+          Ttuple(List.map (nondep_type_rec env id) tl)
+      | Tconstr(p, tl, abbrev) ->
+          if Path.isfree id p then
+            begin try
+              (nondep_type_rec env id
+                 (expand_abbrev env p tl (ref !abbrev) ty.level)).desc
+            with Cannot_expand ->
+              raise Not_found
+            end
+          else
+            Tconstr(p, List.map (nondep_type_rec env id) tl, ref [])
+       | Tnil ->
+           Tnil
+       | Tlink _ ->
+           fatal_error "Ctype.nondep_type"
+       end;
+     ty'
+
+let nondep_type env id ty =
+  inst_subst := [];
+  let ty' = nondep_type_rec env id ty in
+  inst_subst := [];
+  ty'
+
+
+(* Type pruning *)
+
+let inst_subst = ref ([] : (type_expr * type_expr) list)
+
+let rec prune_rec top cstr ty =
+  let ty = repr ty in
+  try List.assq ty (if top then [] else cstr) with Not_found ->
+  match ty.desc with
+    Tvar ->
+      if ty.level = generic_level then
+        begin try
+          List.assq ty !inst_subst
+        with Not_found ->
+          let ty' = newvar() in
+          inst_subst := (ty, ty') :: !inst_subst;
+          ty'
+        end
+      else
+        ty
+  | Tarrow(t1, t2) ->
+      newty (Tarrow(prune_rec false cstr t1, prune_rec false cstr t2))
   | Ttuple tl ->
-      List.exists (free_type_ident env ids) tl
-  | Tconstr((Pident id as p), tl) ->
-      List.exists (Ident.same id) ids or begin
-        try
-          free_type_ident env (id::ids) (expand_abbrev env p tl)
-        with Cannot_expand ->
-          List.exists (free_type_ident env ids) tl
+      newty (Ttuple(List.map (prune_rec false cstr) tl))
+  | Tconstr(p, tl, _) ->
+      begin try
+        List.assq ty !inst_subst
+      with Not_found ->
+        let ty' = newvar() in
+        inst_subst := (ty, ty') :: !inst_subst;
+        let ty'' = 
+          newty (Tconstr(p, List.map (prune_rec false cstr) tl, ref []))
+        in
+          ty'.desc <- Tlink ty'';
+          ty''
       end
-  | Tconstr(p, tl) ->
+  | Tobject (t1, name) ->
       begin try
-        free_type_ident env ids (expand_abbrev env p tl)
+        List.assq ty !inst_subst
+      with Not_found ->
+        let ty' = newvar() in
+        inst_subst := (ty, ty') :: !inst_subst;
+        let ty'' = newty
+          (Tobject (prune_rec false cstr t1,
+                    ref (match !name with
+                           None -> None
+                         | Some (p, tl) ->
+                             Some (p, List.map (prune_rec false cstr) tl))))
+        in
+          ty'.desc <- Tlink ty'';
+          ty''
+      end
+  | Tnil ->
+      newty Tnil
+  | Tlink _             ->
+      fatal_error "Ctype.prune_rec"
+
+let prune_cstr cstr (old_cstr, new_cstr) ((ty, v) as c) =
+  let c' =
+    try (v, List.assq ty old_cstr) with Not_found ->
+    match ty.desc with
+      Tvar ->
+        (v, v)
+    | _ ->
+        (v, prune_rec true cstr ty)
+  in
+    (c :: old_cstr, c' :: new_cstr)
+
+let prune ty leaves =
+  inst_subst := [];
+  let cstr = List.map (fun leaf -> (repr leaf, newvar ())) leaves in
+  let new_ty = prune_rec true cstr ty in
+  inst_subst := [];
+  (new_ty, List.map (fun (ty, v) -> (v, ty)) cstr)
+
+
+(* --- *)
+
+
+let rec expand_root env ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tconstr(p, tl, abbrev) ->
+      begin try
+        expand_root env (expand_abbrev env p tl (ref !abbrev) ty.level)
       with Cannot_expand ->
-        List.exists (free_type_ident env ids) tl
+        ty
       end
+  | _ ->
+      ty
+
+(* Abbreviation correctness *)
+
+exception Nonlinear_abbrev
+exception Recursive_abbrev
+
+let rec correct_abbrev_rec env path params constrs visited ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      []
+  | Tarrow (ty1, ty2) ->
+      let c1 = correct_abbrev_rec env path params constrs visited ty1 in
+      let c2 = correct_abbrev_rec env path params constrs visited ty2 in
+      c1 @ c2
+  | Ttuple tl ->
+      List.flatten
+        (List.map (correct_abbrev_rec env path params constrs visited) tl)
+  | Tconstr(p, args, abbrev) ->
+      if Path.same p path then begin
+        if
+          List.exists (fun (ty1, ty2) -> repr ty1 != repr ty2)
+            (List.combine params args)
+        then
+          raise Nonlinear_abbrev
+        else
+          [p]
+      end else begin
+          try
+            let ty' = expand_abbrev env p args abbrev ty.level in
+            if List.memq ty' constrs then [] else
+            let loops =
+              correct_abbrev_rec env path params (ty'::constrs) visited ty'
+            in
+            if List.exists (Path.same p) loops
+            then raise Recursive_abbrev
+            else loops
+          with Cannot_expand ->
+          if not (List.memq ty visited) then begin
+            List.iter
+              (correct_abbrev_rec env path params constrs (ty::visited))
+              args;
+            ()
+          end;
+          []
+      end
+  | Tnil ->
+      []
+  | Tlink _ -> fatal_error "Ctype.correct_abbrev_rec"
+
+let correct_abbrev env ident params ty =
+  let path = Path.Pident ident in
+  let incorrect =
+    List.exists (Path.same path) (correct_abbrev_rec env path params [] [] ty)
+  in
+  remove_abbrev ty;
+  if incorrect then
+    raise Recursive_abbrev
 
 (* Miscellaneous *)
 
-let rec closed_schema ty =
-  match repr ty with
-    Tvar v -> v.tvar_level = generic_level
-  | Tarrow(t1, t2) -> closed_schema t1 & closed_schema t2
-  | Ttuple tl -> List.for_all closed_schema tl
-  | Tconstr(p, tl) -> List.for_all closed_schema tl
+let unroll_abbrev id tl ty =
+  let ty = repr ty in
+  match ty.desc with
+  | _ ->
+      ty
+
+let visited = ref []
+
+let closed_schema ty =
+  let rec closed_schema_rec ty =
+    let ty = repr ty in
+    match ty.desc with
+      Tvar -> ty.level = generic_level
+    | Tarrow(t1, t2) -> closed_schema_rec t1 & closed_schema_rec t2
+    | Ttuple tl -> List.for_all closed_schema_rec tl
+    | Tconstr(p, tl, _) ->
+        if not (List.memq ty !visited) then begin
+          visited := ty::!visited;
+          List.for_all closed_schema_rec tl
+        end else
+          true
+    | Tnil ->
+        true
+    | Tlink _           -> fatal_error "Ctype.closed_schema"
+  in
+    visited := [];
+    let res = closed_schema_rec ty in
+    visited := [];
+    res
 
 let is_generic ty =
-  match repr ty with
-    Tvar v -> v.tvar_level = generic_level
+  let ty = repr ty in
+  match ty.desc with
+    Tvar -> ty.level = generic_level
   | _ -> fatal_error "Ctype.is_generic"
 
 let rec arity ty =
-  match repr ty with
+  match (repr ty).desc with
     Tarrow(t1, t2) -> 1 + arity t2
   | _ -> 0
diff --git a/typing/ctype.mli b/typing/ctype.mli
index 038271d..87f9d81 100644
--- a/typing/ctype.mli
+++ b/typing/ctype.mli
@@ -13,36 +13,60 @@
 
 (* Operations on core types *)
 
+open Asttypes
 open Typedtree
 
+val generic_level: int
 val begin_def: unit -> unit
         (* Raise the variable level by one at the beginning of a definition. *)
 val end_def: unit -> unit
         (* Lower the variable level by one at the end of a definition *)
-val reset_def: unit -> unit
-        (* Reset (to 0) the variable level *)
+val reset_global_level: unit -> unit
+val newty: type_desc -> type_expr
+val newgenty: type_desc -> type_expr
 val newvar: unit -> type_expr
         (* Return a fresh variable *)
 val new_global_var: unit -> type_expr
         (* Return a fresh variable, bound at toplevel
            (as type variables ['a] in type constraints). *)
 val repr: type_expr -> type_expr
         (* Return the canonical representative of a type. *)
 val generalize: type_expr -> unit
         (* Generalize in-place the given type *)
 val make_nongen: type_expr -> unit
         (* Make non-generalizable the given type *)
 val instance: type_expr -> type_expr
         (* Take an instance of a type scheme *)
+val instance_parameterized_type:
+      	type_expr list -> type_expr -> type_expr list * type_expr
+val instance_parameterized_type_2:
+      	type_expr list -> type_expr list -> type_expr ->
+        type_expr list * type_expr list * type_expr
 val instance_constructor:
         constructor_description -> type_expr list * type_expr
         (* Same, for a constructor *)
 val instance_label: label_description -> type_expr * type_expr
         (* Same, for a label *)
+val expand_abbrev :
+        Env.t -> Path.t -> type_expr list -> (Path.t * type_expr) list ref ->
+	int -> type_expr
+	(* Expand an abbreviation *)
+val occur : Env.t -> type_expr -> type_expr -> unit
+        (* [occur env var ty] Raise [Unify] if [var] occurs in [ty] *)
 val unify: Env.t -> type_expr -> type_expr -> unit
         (* Unify the two types given. Raise [Unify] if not possible. *)
 val filter_arrow: Env.t -> type_expr -> type_expr * type_expr
         (* A special case of unification (with 'a -> 'b). *)
+val filter_method:
+  Env.t -> Label.t -> Typedtree.type_expr -> Typedtree.type_expr
+      	(* A special case of unification (with {m : 'a; 'b}). *)
 val moregeneral: Env.t -> type_expr -> type_expr -> bool
         (* Check if the first type scheme is more general than the second. *)
 val equal: Env.t -> type_expr list -> type_expr ->
@@ -50,6 +74,10 @@ val equal: Env.t -> type_expr list -> type_expr ->
         (* [equal env [x1...xn] tau [y1...yn] sigma]
            checks whether the parameterized types
            [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
+val opened_object: type_expr -> bool
+val enlarge_type: Env.t -> type_expr list -> type_expr -> type_expr
+      	(* Make a type larger *)
+val subtype : Env.t -> type_expr list -> type_expr -> type_expr -> unit
 val closed_schema: type_expr -> bool
         (* Check whether the given type scheme contains no non-generic
            type variables *)
@@ -57,20 +85,35 @@ val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
         (* Return a type equivalent to the given type but without
            references to the given module identifier. Raise [Not_found]
            if no such type exists. *)
-val free_type_ident: Env.t -> Ident.t list -> type_expr -> bool
-        (* Test whether one of the given type identifiers occur free
-           in the given type expression. *)
+val substitute:
+        (Path.t * Typedtree.type_expr) list -> type_expr list ->
+        type_expr list -> type_expr -> type_expr
+        (* [substitute [v1...vN] [t1...tN] t]
+           returns a copy of [t] where the [vi] are replaced
+           by the [ti]. *)
+val prune:
+      	type_expr -> type_expr list -> type_expr * (type_expr * type_expr) list
+val expand_root: Env.t -> type_expr -> type_expr
+val correct_abbrev: Env.t -> Ident.t -> type_expr list -> type_expr -> unit
+val unroll_abbrev: Ident.t -> type_expr list -> type_expr -> type_expr
 val is_generic: type_expr -> bool
         (* Test whether the given type variable is generic *)
 val arity: type_expr -> int
         (* Return the arity (as for curried functions) of the given type. *)
 val none: type_expr
         (* A dummy type expression *)
-val substitute:
-        type_expr list -> type_expr list -> type_expr -> type_expr
-        (* [substitute [v1...vN] [t1...tN] t]
-           returns a copy of [t] where the [vi] are replaced
-           by the [ti]. *)
 
 exception Unify
-
+exception Cannot_expand
+exception Nonlinear_abbrev
+exception Recursive_abbrev
diff --git a/typing/datarepr.ml b/typing/datarepr.ml
index 0afa11e..03a3b4f 100644
--- a/typing/datarepr.ml
+++ b/typing/datarepr.ml
@@ -51,19 +51,22 @@ let exception_descr path_exc decl =
     cstr_consts = -1;
     cstr_nonconsts = -1 }
 
+let none = {desc = Ttuple []; level = -1}
+					(* Clearly ill-formed type *)
 let dummy_label =
-  { lbl_res = Ttuple []; lbl_arg = Ttuple []; lbl_mut = Immutable;
+  { lbl_res = none; lbl_arg = none; lbl_mut = Immutable;
     lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular }
 
 (* Cannot call ctype.repres here *)
 
-let rec is_float = function
-    Tvar{tvar_link = Some ty} -> is_float ty
-  | Tconstr(p, _) -> Path.same p Predef.path_float
+let rec is_float = 
+  function
+    {desc = Tlink ty} -> is_float ty
+  | {desc = Tconstr(p, _, _)} -> Path.same p Predef.path_float
   | _ -> false
 
 
 (* Lookup by name *)
 
 
 (* Scrape a module type *)
 
@@ -289,7 +294,10 @@ let rec scrape_modtype mty env =
 let constructors_of_type ty_path decl =
   match decl.type_kind with
     Type_variant cstrs ->
-      Datarepr.constructor_descrs (Tconstr(ty_path, decl.type_params)) cstrs
+      Datarepr.constructor_descrs
+        {desc = Tconstr(ty_path, decl.type_params, ref []);
+      	 level = -1 (* generic_level *)}
+        cstrs
   | _ -> []
 
 (* Compute label descriptions *)
@@ -297,7 +305,10 @@ let constructors_of_type ty_path decl =
 let labels_of_type ty_path decl =
   match decl.type_kind with
     Type_record labels ->
-      Datarepr.label_descrs (Tconstr(ty_path, decl.type_params)) labels
+      Datarepr.label_descrs
+        {desc = Tconstr(ty_path, decl.type_params, ref []);
+         level = -1 (* generic_level *)}
+        labels
   | _ -> []
 
 (* Given a signature and a root path, prefix all idents in the signature
@@ -307,7 +318,7 @@ let rec prefix_idents root pos sub = function
     [] -> ([], sub)
   | Tsig_value(id, decl) :: rem ->
       let p = Pdot(root, Ident.name id, pos) in
-      let nextpos = match decl.val_prim with None -> pos+1 | Some _ -> pos in
+      let nextpos = match decl.val_kind with Val_prim _ -> pos | _ -> pos+1 in
       let (pl, final_sub) = prefix_idents root nextpos sub rem in
       (p::pl, final_sub)
   | Tsig_type(id, decl) :: rem ->
@@ -330,6 +341,12 @@ let rec prefix_idents root pos sub = function
         prefix_idents root pos
                       (Subst.add_modtype id (Tmty_ident p) sub) rem in
       (p::pl, final_sub)
 
@@ -350,8 +367,8 @@ let rec components_of_module env sub path mty =
             let decl' = Subst.value_description sub decl in
             c.comp_values <-
               Tbl.add (Ident.name id) (decl', !pos) c.comp_values;
-            begin match decl.val_prim with
-              None -> incr pos | Some _ -> ()
+            begin match decl.val_kind with
+              Val_prim _ -> () | _ -> incr pos
             end
         | Tsig_type(id, decl) ->
             let decl' = Subst.type_declaration sub decl in
@@ -384,7 +401,12 @@ let rec components_of_module env sub path mty =
             let decl' = Subst.modtype_declaration sub decl in
             c.comp_modtypes <-
               Tbl.add (Ident.name id) (decl', nopos) c.comp_modtypes;
-            env := store_modtype id path decl' !env)
+            env := store_modtype id path decl' !env
         sg pl;
 	Structure_comps c
 let add_signature sg env =
   List.fold_left add_signature_component env sg
@@ -551,14 +594,17 @@ let open_signature root sg env =
           store_module (Ident.hide id) p (Subst.modtype sub mty) env
       | Tsig_modtype(id, decl) ->
           store_modtype (Ident.hide id) p
-                        (Subst.modtype_declaration sub decl) env)
+                        (Subst.modtype_declaration sub decl) env
     env sg pl
 
 (* Open a signature from a file *)
 
 let open_pers_signature name env =
   let ps = find_pers_struct name in
-  open_signature (Pident(Ident.new_persistent name)) ps.ps_sig env
+  open_signature (Pident(Ident.create_persistent name)) ps.ps_sig env
 
 (* Read a signature from a file *)
 
@@ -573,7 +619,7 @@ let save_signature sg modname filename =
       ps_sig = sg;
       ps_comps =
         components_of_module empty Subst.identity
-            (Pident(Ident.new_persistent modname)) (Tmty_signature sg) } in
+	    (Pident(Ident.create_persistent modname)) (Tmty_signature sg) } in
   let oc = open_out_bin filename in
   output_string oc cmi_magic_number;
   output_value oc ps;
diff --git a/typing/ident.ml b/typing/ident.ml
index 759a974..0ecd1cd 100644
diff --git a/typing/includecore.ml b/typing/includecore.ml
index 83c9b3f..d355a60 100644
--- a/typing/includecore.ml
+++ b/typing/includecore.ml
@@ -23,12 +23,12 @@ exception Dont_match
 
 let value_descriptions env vd1 vd2 =
   if Ctype.moregeneral env vd1.val_type vd2.val_type then begin
-    match (vd1.val_prim, vd2.val_prim) with
-        (Some p1, Some p2) ->
+    match (vd1.val_kind, vd2.val_kind) with
+        (Val_prim p1, Val_prim p2) ->
           if p1 = p2 then Tcoerce_none else raise Dont_match
-      | (Some p, None) -> Tcoerce_primitive p
-      | (None, Some p) -> raise Dont_match
-      | (None, None) -> Tcoerce_none
+      | (Val_prim p, _) -> Tcoerce_primitive p
+      | (_, Val_prim p) -> raise Dont_match
+      | (_, _) -> Tcoerce_none
   end else
     raise Dont_match
 
@@ -60,8 +60,11 @@ let type_declarations env id decl1 decl2 =
     | (Some ty1, Some ty2) ->
         Ctype.equal env decl1.type_params ty1 decl2.type_params ty2
     | (None, Some ty2) ->
-        let ty1 = Tconstr(Pident id, decl2.type_params) in
-        Ctype.equal env [] ty1 [] ty2
+        let ty1 =
+	  {desc = Tconstr(Pident id, decl2.type_params, ref []);
+	   level = Ctype.generic_level }
+	in
+          Ctype.equal env [] ty1 [] ty2
   end
 
 (* Inclusion between exception declarations *)
@@ -69,3 +72,34 @@ let type_declarations env id decl1 decl2 =
 let exception_declarations env ed1 ed2 =
   for_all2 (fun ty1 ty2 -> Ctype.equal env [] ty1 [] ty2) ed1 ed2
 
 let item_ident_name = function
     Tsig_value(id, _) -> (id, Field_value(Ident.name id))
@@ -84,6 +93,7 @@ let item_ident_name = function
   | Tsig_exception(id, _) -> (id, Field_exception(Ident.name id))
   | Tsig_module(id, _) -> (id, Field_module(Ident.name id))
   | Tsig_modtype(id, _) -> (id, Field_modtype(Ident.name id))
 
 (* Simplify a structure coercion *)
 
@@ -149,12 +159,13 @@ and signatures env sig1 sig2 =
         let (id, name) = item_ident_name item in
         let nextpos =
           match item with
-            Tsig_value(_,{val_prim = None})
-          | Tsig_exception(_,_)
-          | Tsig_module(_,_) -> pos+1
-          | Tsig_value(_,{val_prim = Some _})
+            Tsig_value(_,{val_kind = Val_prim _})
           | Tsig_type(_,_)
-          | Tsig_modtype(_,_) -> pos in
+          | Tsig_modtype(_,_) -> pos
+          | Tsig_value(_,_)
+          | Tsig_exception(_,_)
+          | Tsig_module(_,_)
  in
         build_component_table nextpos
                               (Tbl.add name (id, item, pos) tbl) rem in
   let comps1 =
@@ -189,9 +200,9 @@ and signature_components env = function
     [] -> []
   | (Tsig_value(id1, valdecl1), Tsig_value(id2, valdecl2), pos) :: rem ->
       let cc = value_descriptions env id1 valdecl1 valdecl2 in
-      begin match valdecl2.val_prim with
-        None -> (pos, cc) :: signature_components env rem
-      | Some p -> signature_components env rem
+      begin match valdecl2.val_kind with
+        Val_prim p -> signature_components env rem
+      | _ -> (pos, cc) :: signature_components env rem
       end
   | (Tsig_type(id1, tydecl1), Tsig_type(id2, tydecl2), pos) :: rem ->
       type_declarations env id1 tydecl1 tydecl2;
diff --git a/typing/mtype.ml b/typing/mtype.ml
index 691fc04..6cfea5b 100644
--- a/typing/mtype.ml
+++ b/typing/mtype.ml
@@ -50,8 +50,10 @@ and strengthen_sig env sg p =
             { type_params = decl.type_params;
               type_arity = decl.type_arity;
               type_kind = decl.type_kind;
-              type_manifest = Some(Tconstr(Pdot(p, Ident.name id, nopos),
-                                                decl.type_params)) }
+              type_manifest = Some(Ctype.newgenty(
+	       		           Tconstr(Pdot(p, Ident.name id, nopos),
+                                           decl.type_params,
+					   ref []))) }
         | _ -> decl in
       Tsig_type(id, newdecl) :: strengthen_sig env rem p
   | (Tsig_exception(id, d) as sigelt) :: rem ->
@@ -70,6 +72,8 @@ and strengthen_sig env sg p =
       Tsig_modtype(id, newdecl) ::
       strengthen_sig (Env.add_modtype id decl env) rem p
       (* Need to add the module type in case it is manifest *)
 
 (* In nondep_supertype, env is only used for the type it assigns to id.
    Hence there is no need to keep env up-to-date by adding the bindings
@@ -79,45 +83,47 @@ type variance = Co | Contra | Strict
 
 let nondep_supertype env mid mty =
       match item with
         Tsig_value(id, d) ->
           Tsig_value(id, {val_type = Ctype.nondep_type env mid d.val_type;
-                          val_prim = d.val_prim}) :: rem'
+                          val_kind = d.val_kind}) :: rem'
       | Tsig_type(id, d) ->
-          Tsig_type(id, nondep_type_decl var d) :: rem'
+          Tsig_type(id, nondep_type_decl va d) :: rem'
       | Tsig_exception(id, d) ->
           Tsig_exception(id, List.map (Ctype.nondep_type env mid) d) :: rem'
       | Tsig_module(id, mty) ->
-          Tsig_module(id, nondep_mty var mty) :: rem'
+          Tsig_module(id, nondep_mty va mty) :: rem'
       | Tsig_modtype(id, d) ->
           begin try
             Tsig_modtype(id, nondep_modtype_decl d) :: rem'
 
   and nondep_modtype_decl = function
diff --git a/typing/parmatch.ml b/typing/parmatch.ml
index 2d18939..0ac7a54 100644
diff --git a/typing/predef.ml b/typing/predef.ml
index 8da5734..742ea89 100644
--- a/typing/predef.ml
+++ b/typing/predef.ml
@@ -17,16 +17,21 @@ open Path
 open Typedtree
 
 
+let newgenty desc =
+  {desc = desc; level = -1 (* generic_level *)}
+
 
 let path_int = Pident ident_int
 and path_char = Pident ident_char
@@ -38,25 +43,29 @@ and path_exn = Pident ident_exn
 and path_array = Pident ident_array
 and path_list = Pident ident_list
 and path_format = Pident ident_format
+and path_mutable = Pident ident_mutable
+and path_immutable = Pident ident_immutable
 
-let type_int = Tconstr(path_int, [])
-and type_char = Tconstr(path_char, [])
-and type_string = Tconstr(path_string, [])
-and type_float = Tconstr(path_float, [])
-and type_bool = Tconstr(path_bool, [])
-and type_unit = Tconstr(path_unit, [])
-and type_exn = Tconstr(path_exn, [])
-and type_array t = Tconstr(path_array, [t])
-and type_list t = Tconstr(path_list, [t])
+let type_int = newgenty (Tconstr(path_int, [], ref []))
+and type_char = newgenty (Tconstr(path_char, [], ref []))
+and type_string = newgenty (Tconstr(path_string, [], ref []))
+and type_float = newgenty (Tconstr(path_float, [], ref []))
+and type_bool = newgenty (Tconstr(path_bool, [], ref []))
+and type_unit = newgenty (Tconstr(path_unit, [], ref []))
+and type_exn = newgenty (Tconstr(path_exn, [], ref []))
+and type_array t = newgenty (Tconstr(path_array, [t], ref []))
+and type_list t = newgenty (Tconstr(path_list, [t], ref []))
+and type_mutable = newgenty (Tconstr(path_mutable, [], ref []))
+and type_immutable = newgenty (Tconstr(path_immutable, [], ref []))
 
 
@@ -64,7 +73,7 @@ let build_initial_env add_type add_exception empty_env =
   let newvar() =
     (* Cannot call the real newvar from ctype here
        because ctype imports predef via env *)
-    Tvar{tvar_level = -1 (*generic_level*); tvar_link = None} in
+    {desc = Tvar; level = -1 (*generic_level*)} in
   let decl_abstr =
     {type_params = [];
      type_arity = 0;
@@ -103,7 +112,7 @@ let build_initial_env add_type add_exception empty_env =
      type_kind = Type_abstract;
      type_manifest = None} in
 
-  add_exception ident_match_failure [Ttuple[type_string; type_int; type_int]] (
+  add_exception ident_match_failure [newgenty (Ttuple[type_string; type_int; type_int])] (
   add_exception ident_out_of_memory [] (
   add_exception ident_invalid_argument [type_string] (
   add_exception ident_failure [type_string] (
@@ -111,6 +120,8 @@ let build_initial_env add_type add_exception empty_env =
   add_exception ident_sys_error [type_string] (
   add_exception ident_end_of_file [] (
   add_exception ident_division_by_zero [] (
+  add_type ident_immutable decl_abstr (
+  add_type ident_mutable decl_abstr (
   add_type ident_format decl_format (
   add_type ident_list decl_list (
   add_type ident_array decl_array (
@@ -121,7 +132,7 @@ let build_initial_env add_type add_exception empty_env =
   add_type ident_string decl_abstr (
   add_type ident_char decl_abstr (
   add_type ident_int decl_abstr (
-    empty_env))))))))))))))))))
+    empty_env))))))))))))))))))))
 
 let builtin_values =
   List.map (fun id -> Ident.make_global id; (Ident.name id, id))
diff --git a/typing/predef.mli b/typing/predef.mli
index f35f7d8..18a5c8c 100644
--- a/typing/predef.mli
+++ b/typing/predef.mli
@@ -24,6 +24,8 @@ val type_unit: type_expr
 val type_exn: type_expr
 val type_array: type_expr -> type_expr
 val type_list: type_expr -> type_expr
+val type_mutable: type_expr
+val type_immutable: type_expr
 
 val path_int: Path.t
 val path_char: Path.t
diff --git a/typing/printtyp.ml b/typing/printtyp.ml
index caf233c..8879a67 100644
--- a/typing/printtyp.ml
+++ b/typing/printtyp.ml
@@ -13,6 +13,8 @@
 
 (* Printing functions *)
 
+open Misc
+open Ctype
 open Format
 open Longident
 open Path
@@ -49,32 +51,101 @@ let rec path = function
 
 (* Print a type expression *)
 
-let var_names = ref ([] : (type_expr * string) list)
-let var_counter = ref 0
+let names = ref ([] : (type_expr * string) list)
+let name_counter = ref 0
 
-let reset_var_names () = var_names := []; var_counter := 0
+let reset_names () = names := []; name_counter := 0
 
-let name_of_var v =
-  try
-    List.assq v !var_names
-  with Not_found ->
-    let name = 
-      if !var_counter < 26
-      then String.make 1 (Char.chr(97 + !var_counter)) 
-      else String.make 1 (Char.chr(97 + !var_counter mod 26)) ^
-           string_of_int(!var_counter / 26) in
-    var_names := (v, name) :: !var_names;
-    incr var_counter;
+let new_name () =
+  let name =
+    if !name_counter < 26
+    then String.make 1 (Char.chr(97 + !name_counter)) 
+    else String.make 1 (Char.chr(97 + !name_counter mod 26)) ^
+           string_of_int(!name_counter / 26)
+  in
+    incr name_counter;
     name
 
-let rec typexp sch prio = function
-    Tvar {tvar_link = Some ty} ->
-      typexp sch prio ty
-  | Tvar {tvar_link = None; tvar_level = lvl} as v ->
-      if (not sch) or lvl = -1 (* generic *)
+let name_of_type t =
+  try List.assq t !names with Not_found ->
+    let name = new_name () in
+    names := (t, name) :: !names;
+    name
+
+let rec list_removeq a =
+  function
+    [] ->
+      []
+  | (b, _) as e::l ->
+      if a == b then l else e::list_removeq a l
+
+let remove_name_of_type t =
+  names := list_removeq t !names
+
+let visited_objects = ref ([] : type_expr list)
+let aliased = ref ([] : type_expr list)
+
+let rec mark_loops_rec visited ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar			  -> ()
+  | Tarrow(ty1, ty2)              ->
+      mark_loops_rec visited ty1; mark_loops_rec visited ty2
+  | Ttuple tyl		          -> List.iter (mark_loops_rec visited) tyl
+  | Tconstr(_, tyl, _)		  ->
+      if List.memq ty visited then begin
+      	if not (List.memq ty !aliased) then
+	  aliased := ty :: !aliased
+      end else
+        List.iter (mark_loops_rec (ty::visited)) tyl
+  | Tnil			  -> ()
+  | Tlink _			  -> fatal_error "Printtyp.mark_loops_rec (2)"
+
+let mark_loops ty = mark_loops_rec [] ty
+
+let reset_loop_marks () =
+  visited_objects := []; aliased := []
+
+let reset () =
+  reset_names (); reset_loop_marks ()
+
+let rec typexp sch prio ty =
+  let ty = repr ty in
+  match ty.desc with
+    Tvar ->
+      if (not sch) or ty.level = generic_level
       then print_string "'"
       else print_string "'_";
-      print_string(name_of_var v)
+      print_string(name_of_type ty)
   | Tarrow(ty1, ty2) ->
       if prio >= 1 then begin open_hovbox 1; print_string "(" end
                    else open_hovbox 0;
@@ -89,18 +160,41 @@ let rec typexp sch prio = function
       typlist sch 2 " *" tyl;
       if prio >= 2 then print_string ")";
       close_box()
-  | Tconstr(p, tyl) ->
+  | Tconstr(p, tyl, _) ->
       open_hovbox 0;
-      begin match tyl with
-        [] -> ()
-      | [ty1] ->
-          typexp sch 2 ty1; print_space()
-      | tyl ->
-          open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
-          print_string ")"; close_box(); print_space()
+      begin try
+        List.assq ty !names;
+        print_string "'";
+        print_string (name_of_type ty)
+      with Not_found ->
+        if List.memq ty !aliased then begin
+          name_of_type ty;
+          if prio >= 1 then begin open_hovbox 1; print_string "(" end
+	end;
+        open_hovbox 0;
+        begin match tyl with
+          [] -> ()
+        | [ty1] ->
+            typexp sch 2 ty1; print_space()
+        | tyl ->
+            open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
+            print_string ")"; close_box(); print_space()
+        end;
+        path p;
+        close_box();
+        if List.memq ty !aliased then begin
+          print_string " as ";
+          print_string "'";
+          print_string (name_of_type ty);
+	  remove_name_of_type ty;
+          if prio >= 1 then begin print_string ")"; close_box () end
+        end
       end;
-      path p;
       close_box()
+  | _ ->
+      fatal_error "Printtyp.typexp"
 
 and typlist sch prio sep = function
     [] -> ()
@@ -109,19 +203,99 @@ and typlist sch prio sep = function
       typexp sch prio ty; print_string sep; print_space();
       typlist sch prio sep tyl
 
-let type_expr ty = typexp false 0 ty
-and type_scheme ty = reset_var_names(); typexp true 0 ty
+and typobject sch prio ty fi nm =
+  try
+    List.assq ty !names;
+    print_string "'";
+    print_string (name_of_type ty)
+  with Not_found ->
+    if List.memq ty !aliased then begin
+      name_of_type ty;
+      if prio >= 1 then begin open_hovbox 1; print_string "(" end
+    end;
+    begin match !nm with
+      None ->
+        open_hovbox 2;
+        print_string "< ";
+        (let (fields, rest) = flatten_fields fi in
+           typfields sch rest fields);
+        print_string " >";
+        close_box ()
+    | Some (p, {desc = Tvar}::tyl) ->
+        open_hovbox 0;
+        begin match tyl with
+          [] -> ()
+        | [ty1] ->
+            typexp sch 2 ty1; print_space()
+        | tyl ->
+            open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
+            print_string ")"; close_box(); print_space()
+        end;
+	if sch & ty.level <> generic_level then
+	  print_string "_";
+	print_string "#";
+        path p;
+        close_box()
+    | _ ->
+      	fatal_error "Printtyp.typobject"
+    end;
+    if List.memq ty !aliased then begin
+      print_string " as ";
+      print_string "'";
+      print_string (name_of_type ty);
+      if not (opened_object ty) then
+      	remove_name_of_type ty;
+      if prio >= 1 then begin print_string ")"; close_box () end
+    end
+
+and typfields sch rest =
+  function
+    [] ->
+      begin match rest.desc with
+      	Tvar -> if sch & rest.level <> generic_level then
+      	       	  print_string "_";
+      	       	print_string ".."
+      | Tnil -> ()
+      | _    -> fatal_error "typfields (1)"
+      end
+  | [(s, t)] ->
+      print_string s.Label.lab_name;
+      print_string " : ";
+      typexp sch 0 t;
+      begin match rest.desc with
+      	Tvar -> print_string ";"; print_space ()
+      | Tnil -> ()
+      | _    -> fatal_error "typfields (2)"
+      end;
+      typfields sch rest []
+  | (s, t)::l ->
+      print_string s.Label.lab_name;
+      print_string " : ";
+      typexp sch 0 t;
+      print_string ";"; print_space ();
+      typfields sch rest l
+
+let type_expr ty =
+  typexp false 0 ty
+
+and type_sch ty =
+  typexp true 0 ty
+
+and type_scheme ty =
+  reset(); mark_loops ty; typexp true 0 ty
 
 (* Print one type declaration *)
 
 let rec type_declaration id decl =
-  reset_var_names();
+  reset();
   open_hvbox 2;
   print_string "type ";
-  type_expr (Tconstr(Pident id, decl.type_params));
+  type_expr {desc = Tconstr(Pident id, decl.type_params, ref []);
+  	     level = generic_level};
   begin match decl.type_manifest with
     None -> ()
-  | Some ty -> print_string " ="; print_space(); type_expr ty
+  | Some ty ->
+      print_string " ="; print_space(); mark_loops ty; type_expr ty
   end;
   begin match decl.type_kind with
     Type_abstract -> ()
@@ -130,10 +304,10 @@ let rec type_declaration id decl =
   | Type_variant (cstr1 :: cstrs) ->
       print_string " ="; print_break 1 2;
       constructor cstr1;
-      List.iter
-        (fun cstr -> print_space(); print_string "| "; constructor cstr)
-        cstrs
-  | Type_record (lbl1 :: lbls) ->
+      List.iter (fun cstr -> print_space(); print_string "| "; constructor cstr)
+              cstrs
+  | Type_record (lbl1 :: lbls as l) ->
+      List.iter (fun (_, _, ty) -> mark_loops ty) l;
       print_string " ="; print_space();
       print_string "{ "; label lbl1;
       List.iter
@@ -170,14 +344,185 @@ let value_description id decl =
   open_hovbox 2;
   print_string "val "; ident id; print_string " :"; print_space();
   type_scheme decl.val_type;
-  begin match decl.val_prim with
-    None -> ()
-  | Some p -> print_space(); print_string "= "; Primitive.print_description p
+  begin match decl.val_kind with
+    Val_prim p ->
+      print_space(); print_string "= "; Primitive.print_description p
+  | _ -> ()
   end;
   close_box()
 
+(* Print a class type *)
+
+let list_state = ref []
+let start_list sp =
+  list_state := false::!list_state;
+  if sp then print_space ()
+let list_item () =
+  match !list_state with
+    false::l -> list_state := true::l
+  | _        -> print_space ()
+let end_list sp =
+  if sp & (List.hd !list_state) then print_break 1 (-2);
+  list_state := List.tl !list_state
+
+let constrain (v, ty) =
+  open_hovbox 2;
+  type_sch v;
+  print_string " =";
+  print_space();
+  type_sch ty;
+  close_box()
+let rec and_sep_list pr =
+  function
+    [] ->
+      ()
+  | [e] ->
+      pr e
+  | e::l ->
+      pr e;
+      print_break 1 (-2);
+      print_string "and ";
+      and_sep_list pr l
+
 
+let hidden = ref 0
+
 let rec modtype = function
     Tmty_ident p ->
       path p
@@ -186,10 +531,13 @@ let rec modtype = function
   | Tmty_signature(item :: rem) ->
       open_hvbox 2;
       print_string "sig"; print_space(); 
+      hidden := 0;
       signature_item item;
       List.iter
-        (fun item -> print_space(); signature_item item)
-      rem;
+        (fun item ->
+           if !hidden > 0 then decr hidden
+           else begin print_space(); signature_item item end)
+        rem;
       print_break 1 (-2); print_string "end";
       close_box()
   | Tmty_functor(param, ty_arg, ty_res) ->
@@ -213,6 +561,9 @@ and signature_item = function
       print_space(); modtype mty; close_box()
   | Tsig_modtype(id, decl) ->
       modtype_declaration id decl
 
 and modtype_declaration id decl =
   open_hovbox 2; print_string "module type "; ident id;
@@ -228,5 +579,10 @@ and modtype_declaration id decl =
 
 let signature sg =
   open_vbox 0;
-  List.iter (fun item -> signature_item item; print_space()) sg;
+  hidden := 0;
+  List.iter
+    (fun item ->
+       if !hidden > 0 then decr hidden
+       else begin signature_item item; print_space() end)
+    sg;
   close_box()
diff --git a/typing/printtyp.mli b/typing/printtyp.mli
index 6bad01b..96cc876 100644
--- a/typing/printtyp.mli
+++ b/typing/printtyp.mli
@@ -18,7 +18,8 @@ open Typedtree
 val longident: Longident.t -> unit
 val ident: Ident.t -> unit
 val path: Path.t -> unit
-val reset_var_names: unit -> unit
+val reset: unit -> unit
+val mark_loops: type_expr -> unit
 val type_expr: type_expr -> unit
 val type_scheme: type_expr -> unit
 val value_description: Ident.t -> value_description -> unit
diff --git a/typing/subst.ml b/typing/subst.ml
index 5f14a94..2a73ea9 100644
--- a/typing/subst.ml
+++ b/typing/subst.ml
@@ -57,17 +57,108 @@ let type_path s = function
   | Papply(p1, p2) ->
       fatal_error "Subst.type_path"
 
-let rec type_expr s = function
-    Tvar{tvar_link = None} as ty -> ty
-  | Tvar{tvar_link = Some ty} -> type_expr s ty
-  | Tarrow(t1, t2) -> Tarrow(type_expr s t1, type_expr s t2)
-  | Ttuple tl -> Ttuple(List.map (type_expr s) tl)
-  | Tconstr(p, []) -> Tconstr(type_path s p, [])
-  | Tconstr(p, tl) -> Tconstr(type_path s p, List.map (type_expr s) tl)
+(* From Ctype *)
+let rec repr = function
+    {desc = Tlink ty} as t ->
+      let r = repr ty in
+      if r != ty then t.desc <- Tlink r;
+      r
+  | t -> t
+
+let generic_level = -1
+
+let newgenty desc =
+  {desc = desc; level = generic_level}
+
+let new_val = ref []
+
+type 'a visited = Zero | One | Many of 'a
+
+let rec typexp visited s ty =
+  let ty = repr ty in
+  if ty.desc = Tvar then ty else
+  try
+    match List.assq ty visited with
+      {contents = Zero} as v ->
+      	let t = newgenty Tvar in
+	v := Many t;
+	let ty' = typexp_2 visited s ty v in
+	t.desc <- ty'.desc;
+	t
+    | {contents = One} as v ->
+        let t = newgenty Tvar in
+        v := Many t;
+        t
+    | {contents = Many t} ->
+        t
+  with Not_found ->
+    let v = ref One in
+    let ty' = typexp_2 ((ty, v)::visited) s ty v in
+    match v with
+      {contents = Many t} ->
+      	t.desc <- ty'.desc;
+	t
+    | _ ->
+      	ty'
+
+and typexp_2 visited s ty v =
+  match ty.desc with
+    Tvar ->
+      ty
+  | Tarrow(t1, t2) ->
+      newgenty(Tarrow(typexp visited s t1, typexp visited s t2))
+  | Ttuple tl ->
+      newgenty(Ttuple(List.map (typexp visited s) tl))
+  | Tconstr(p, [], _) ->
+      newgenty(Tconstr(type_path s p, [], ref []))
+  | Tconstr(p, tl, _) ->
+      newgenty(Tconstr(type_path s p, List.map (typexp visited s) tl, ref []))
+  | Tnil ->
+      newgenty Tnil
+  | Tlink _ ->
+      fatal_error "Subst.typexp"
+
+let type_expr s ty =
+  new_val := [];
+  let ty = typexp [] s ty in
+  new_val := [];
+  ty
 
 let value_description s descr =
   { val_type = type_expr s descr.val_type;
-    val_prim = descr.val_prim }
+    val_kind = descr.val_kind }
 
 let type_declaration s decl =
   { type_params = decl.type_params;
@@ -92,6 +183,26 @@ let type_declaration s decl =
 let exception_declaration s tyl =
   List.map (type_expr s) tyl
 
 let rec modtype s = function
     Tmty_ident p as mty ->
       begin match p with
@@ -115,6 +226,7 @@ and signature_item s = function
   | Tsig_exception(id, d) -> Tsig_exception(id, exception_declaration s d)
   | Tsig_module(id, mty) -> Tsig_module(id, modtype s mty)
   | Tsig_modtype(id, d) -> Tsig_modtype(id, modtype_declaration s d)
 
 and modtype_declaration s = function
     Tmodtype_abstract -> Tmodtype_abstract
diff --git a/typing/typecore.ml b/typing/typecore.ml
index 89937df..ea77828 100644
--- a/typing/typecore.ml
+++ b/typing/typecore.ml
@@ -35,6 +35,14 @@ type error =
   | Label_missing
   | Label_not_mutable of Longident.t
   | Bad_format of string
+  | Undefined_method_err of Label.t
+  | Unbound_class of Longident.t
+  | Virtual_class of Longident.t
+  | Unbound_instance_variable of string
+  | Instance_variable_not_mutable of string
+  | Not_subtype of type_expr * type_expr
+  | Outside_class
+  | Value_multiply_overridden of string
 
 exception Error of Location.t * error
 
 
@@ -89,7 +97,7 @@ let rec type_pat env sp =
       let pl = List.map (type_pat env) spl in
       { pat_desc = Tpat_tuple pl;
         pat_loc = sp.ppat_loc;
-        pat_type = Ttuple(List.map (fun p -> p.pat_type) pl) }
+        pat_type = newty (Ttuple(List.map (fun p -> p.pat_type) pl)) }
   | Ppat_construct(lid, sarg) ->
       let constr =
         try
@@ -154,7 +162,7 @@ let add_pattern_variables env =
   pattern_variables := [];
   List.fold_right
     (fun (id, ty) env ->
-      Env.add_value id {val_type = ty; val_prim = None} env)
+      Env.add_value id {val_type = ty; val_kind = Val_reg} env)
     pv env
 
 let type_pattern env spat =
@@ -188,6 +196,7 @@ let rec is_nonexpansive exp =
               lbl_exp_list
   | Texp_field(exp, lbl) -> is_nonexpansive exp
   | Texp_array [] -> true
+  | Texp_new _ -> true
   | _ -> false
 
 (* Typing of printf formats *)
@@ -212,26 +221,29 @@ let type_format loc fmt =
           '%' ->
             scan_format (j+1)
         | 's' ->
-            Tarrow(Predef.type_string, scan_format (j+1))
+            newty (Tarrow(Predef.type_string, scan_format (j+1)))
         | 'c' ->
-            Tarrow(Predef.type_char, scan_format (j+1))
+            newty (Tarrow(Predef.type_char, scan_format (j+1)))
         | 'd' | 'o' | 'x' | 'X' | 'u' ->
-            Tarrow(Predef.type_int, scan_format (j+1))
+            newty (Tarrow(Predef.type_int, scan_format (j+1)))
         | 'f' | 'e' | 'E' | 'g' | 'G' ->
-            Tarrow(Predef.type_float, scan_format (j+1))
+            newty (Tarrow(Predef.type_float, scan_format (j+1)))
         | 'b' ->
-            Tarrow(Predef.type_bool, scan_format (j+1))
+            newty (Tarrow(Predef.type_bool, scan_format (j+1)))
         | 'a' ->
             let ty_arg = newvar() in
-            Tarrow (Tarrow(ty_input, Tarrow (ty_arg, ty_result)),
-                    Tarrow (ty_arg, scan_format (j+1)))
+            newty (Tarrow (newty (Tarrow(ty_input,
+      	       	       	       	       	 newty (Tarrow (ty_arg, ty_result)))),
+                           newty (Tarrow (ty_arg, scan_format (j+1)))))
         | 't' ->
-            Tarrow(Tarrow(ty_input, ty_result), scan_format (j+1))
+            newty (Tarrow(newty (Tarrow(ty_input, ty_result)),
+      	       	       	  scan_format (j+1)))
         | c ->
             raise(Error(loc, Bad_format(String.sub fmt i (j-i))))
         end
     | _ -> scan_format (i+1) in
-  Tconstr(Predef.path_format, [scan_format 0; ty_input; ty_result])
+  newty
+    (Tconstr(Predef.path_format, [scan_format 0; ty_input; ty_result], ref []))
 
 (* Typing of expressions *)
 
@@ -246,7 +258,16 @@ let rec type_exp env sexp =
     Pexp_ident lid ->
       begin try
         let (path, desc) = Env.lookup_value lid env in
-        { exp_desc = Texp_ident(path, desc);
+        { exp_desc =
+            begin match (desc.val_kind, lid) with
+	    | _ ->
+	        Texp_ident(path, desc)
+      	    end;
           exp_loc = sexp.pexp_loc;
           exp_type = instance desc.val_type }
       with Not_found ->
@@ -269,7 +290,7 @@ let rec type_exp env sexp =
       Parmatch.check_partial sexp.pexp_loc cases;
       { exp_desc = Texp_function cases;
         exp_loc = sexp.pexp_loc;
-        exp_type = Tarrow(ty_arg, ty_res) }
+        exp_type = newty (Tarrow(ty_arg, ty_res)) }
   | Pexp_apply(sfunct, sargs) ->
       let funct = type_exp env sfunct in
       let rec type_args ty_fun = function
@@ -309,7 +330,7 @@ let rec type_exp env sexp =
       let expl = List.map (type_exp env) sexpl in
       { exp_desc = Texp_tuple expl;
         exp_loc = sexp.pexp_loc;
-        exp_type = Ttuple(List.map (fun exp -> exp.exp_type) expl) }
+        exp_type = newty (Ttuple(List.map (fun exp -> exp.exp_type) expl)) }
   | Pexp_construct(lid, sarg) ->
       let constr =
         try
@@ -425,24 +446,140 @@ let rec type_exp env sexp =
       let high = type_expect env shigh Predef.type_int in
       let (id, new_env) =
         Env.enter_value param {val_type = Predef.type_int;
-                                val_prim = None} env in
+                                val_kind = Val_reg} env in
       let body = type_statement new_env sbody in
       { exp_desc = Texp_for(id, low, high, dir, body);
         exp_loc = sexp.pexp_loc;
         exp_type = Predef.type_unit }
-  | Pexp_constraint(sarg, sty) ->
-      let ty = Typetexp.transl_simple_type env false sty in
-      let arg = type_expect env sarg ty in
+  | Pexp_constraint(sarg, sty, sty') ->
+      let (ty, ty') =
+        match (sty, sty') with
+      	  (None, None) ->
+	    none, none
+	| (Some sty, None) ->
+            let ty = Typetexp.transl_simple_type env false sty in
+	    (ty, ty)
+	| (None, Some sty') ->
+            let ty' = Typetexp.transl_simple_type env false sty' in
+            (enlarge_type env (Typetexp.type_variable_list ()) ty', ty')
+	| (Some sty, Some sty') ->
+            let ty = Typetexp.transl_simple_type env false sty in
+            let ty' = Typetexp.transl_simple_type env false sty' in
+	    begin try subtype env (Typetexp.type_variable_list ()) ty ty' with
+	      Unify ->
+	        raise(Error(sexp.pexp_loc, Not_subtype(ty, ty')))
+	    end;
+	    (ty, ty')
+      in let arg = type_expect env sarg ty in
       { exp_desc = arg.exp_desc;
         exp_loc = arg.exp_loc;
-        exp_type = ty }
+        exp_type = ty' }
   | Pexp_when(scond, sbody) ->
       let cond = type_expect env scond Predef.type_bool in
       let body = type_exp env sbody in
       { exp_desc = Texp_when(cond, body);
         exp_loc = sexp.pexp_loc;
         exp_type = body.exp_type }
 (* Typing of an expression with an expected type.
    Some constructs are treated specially to provide better error messages. *)
 
@@ -454,8 +591,8 @@ and type_expect env sexp ty_expected =
           exp_loc = sexp.pexp_loc;
           exp_type =
             (* Terrible hack for format strings *)
-            match Ctype.repr ty_expected with
-              Tconstr(path, _) when Path.same path Predef.path_format ->
+            match (repr ty_expected).desc with
+              Tconstr(path, _, _) when Path.same path Predef.path_format ->
                 type_format sexp.pexp_loc s
             | _ -> Predef.type_string } in
       unify_exp env exp ty_expected;
@@ -481,7 +618,7 @@ and type_expect env sexp ty_expected =
 
 and type_statement env sexp =
     let exp = type_exp env sexp in
-    match Ctype.repr exp.exp_type with
+    match (repr exp.exp_type).desc with
       Tarrow(_, _) ->
         Location.print_warning sexp.pexp_loc
           "this function application is partial,\n\
@@ -505,7 +642,8 @@ and type_cases env ty_arg ty_res caselist =
 and type_let env rec_flag spat_sexp_list =
   begin_def();
   let (pat_list, new_env) =
-    type_pattern_list env (List.map (fun (spat, sexp) -> spat) spat_sexp_list) in
+    type_pattern_list env (List.map (fun (spat, sexp) -> spat) spat_sexp_list)
+  in
   let exp_env =
     match rec_flag with Nonrecursive -> env | Recursive -> new_env in
   let exp_list =
@@ -527,14 +665,12 @@ and type_let env rec_flag spat_sexp_list =
 (* Typing of toplevel bindings *)
 
 let type_binding env rec_flag spat_sexp_list =
-  reset_def();
   Typetexp.reset_type_variables();
   type_let env rec_flag spat_sexp_list
 
 (* Typing of toplevel expressions *)
 
 let type_expression env sexp =
-  reset_def();
   Typetexp.reset_type_variables();
   begin_def();
   let exp = type_exp env sexp in
@@ -542,6 +678,36 @@ let type_expression env sexp =
   if is_nonexpansive exp then generalize exp.exp_type;
   exp
 
+(* Typing of methods *)
+
+let type_method env self self_name sexp =
+  let (obj, env) =
+    Env.enter_value "*self*" {val_type = self; val_kind = Val_reg} env
+  in
+  let pattern =
+    { pat_desc = Tpat_var obj;
+      pat_loc = Location.none;
+      pat_type = self }
+  in
+  let (pattern, env) =
+    match self_name with
+      None      ->
+        (pattern, env)
+    | Some name ->
+        let (self_name, env) =
+          Env.enter_value name {val_type = self; val_kind = Val_reg} env
+        in
+        ({ pat_desc = Tpat_alias (pattern, self_name);
+	   pat_loc = Location.none;
+	   pat_type = self },
+	 env)
+  in
+  let exp = type_exp env sexp in
+  ({ exp_desc = Texp_function [(pattern, exp)];
+     exp_loc = sexp.pexp_loc;
+     exp_type = newty (Tarrow(pattern.pat_type, exp.exp_type)) },
+   exp.exp_type)
+
 (* Error report *)
 
 open Format
@@ -563,6 +729,8 @@ let report_error = function
       print_string " argument(s)";
       close_box()
   | Label_mismatch(lid, actual, expected) ->
+      reset ();
+      mark_loops actual; mark_loops expected;
       open_hovbox 0;
       print_string "The label "; longident lid;
       print_space(); print_string "belongs to the type"; print_space();
@@ -571,6 +739,8 @@ let report_error = function
       type_expr expected;
       close_box()
   | Pattern_type_clash(inferred, expected) ->
+      reset ();
+      mark_loops inferred; mark_loops expected;
       open_hovbox 0;
       print_string "This pattern matches values of type"; print_space();
       type_expr inferred; print_space();
@@ -582,6 +752,8 @@ let report_error = function
   | Orpat_not_closed ->
       print_string "A pattern with | must not bind variables"
   | Expr_type_clash(inferred, expected) ->
+      reset ();
+      mark_loops inferred; mark_loops expected;
       open_hovbox 0;
       print_string "This expression has type"; print_space();
       type_expr inferred; print_space();
@@ -589,7 +761,7 @@ let report_error = function
       type_expr expected;
       close_box()
   | Apply_non_function typ ->
-      begin match Ctype.repr typ with
+      begin match (repr typ).desc with
         Tarrow(_, _) ->
           print_string "This function is applied to too many arguments"
       | _ ->
@@ -605,3 +777,30 @@ let report_error = function
       print_string " is not mutable"
   | Bad_format s ->
       print_string "Bad format `"; print_string s; print_string "'"
+  | Undefined_method_err me ->
+      print_string "This expression has no method ";
+      print_string me.Label.lab_name
+  | Unbound_class cl ->
+      print_string "Unbound class "; longident cl
+  | Virtual_class cl ->
+      print_string "One cannot create instances of the virtual class ";
+      longident cl
+  | Unbound_instance_variable v ->
+      print_string "Unbound instance variable ";
+      print_string v
+  | Instance_variable_not_mutable v ->
+      print_string " The instance variable "; print_string v;
+      print_string " is not mutable"
+  | Not_subtype(ty, ty') ->
+      reset ();
+      mark_loops ty; mark_loops ty';
+      open_hovbox 0;
+      type_expr ty; print_space();
+      print_string "is not a subtype of"; print_space ();
+      type_expr ty';
+      close_box()
+  | Outside_class ->
+      print_string "Object duplication outside a class definition."
+  | Value_multiply_overridden v ->
+      print_string "The instance variable "; print_string v;
+      print_string " is overridden several times"
diff --git a/typing/typecore.mli b/typing/typecore.mli
index 54d31ad..d527ae4 100644
--- a/typing/typecore.mli
+++ b/typing/typecore.mli
@@ -19,10 +19,20 @@ open Typedtree
 val type_binding:
         Env.t -> rec_flag ->
           (Parsetree.pattern * Parsetree.expression) list -> 
-            (Typedtree.pattern * Typedtree.expression) list * Env.t
+            (pattern * expression) list * Env.t
 val type_expression:
-        Env.t -> Parsetree.expression -> Typedtree.expression
-        
+        Env.t -> Parsetree.expression -> expression
+val type_method:
+        Env.t -> Typedtree.type_expr -> string option ->
+        Parsetree.expression -> expression * type_expr
+val type_pattern_list:
+        Env.t -> Parsetree.pattern list -> Typedtree.pattern list * Env.t
+val type_expect:
+        Env.t -> Parsetree.expression -> Typedtree.type_expr ->
+        Typedtree.expression
+val type_exp:
+      	Env.t -> Parsetree.expression -> Typedtree.expression
+
 type error =
     Unbound_value of Longident.t
   | Unbound_constructor of Longident.t
@@ -38,6 +48,14 @@ type error =
   | Label_missing
   | Label_not_mutable of Longident.t
   | Bad_format of string
+  | Undefined_method_err of Label.t
+  | Unbound_class of Longident.t
+  | Virtual_class of Longident.t
+  | Unbound_instance_variable of string
+  | Instance_variable_not_mutable of string
+  | Not_subtype of type_expr * type_expr
+  | Outside_class
+  | Value_multiply_overridden of string
 
 exception Error of Location.t * error
 
diff --git a/typing/typedecl.ml b/typing/typedecl.ml
index e8e7091..f7cca50 100644
--- a/typing/typedecl.ml
+++ b/typing/typedecl.ml
@@ -25,6 +25,7 @@ type error =
   | Duplicate_label of string
   | Recursive_abbrev of string
   | Definition_mismatch of type_expr
+  | Illdefined_abbrev of string
 
 exception Error of Location.t * error
 
@@ -52,8 +53,8 @@ module StringSet =
   end)
 
 let transl_declaration env (name, sdecl) id =
-  Ctype.begin_def();
   reset_type_variables();
+  Ctype.begin_def();
   let params =
     try
       List.map enter_type_variable sdecl.ptype_params
@@ -96,17 +97,31 @@ let transl_declaration env (name, sdecl) id =
       type_manifest =
         begin match sdecl.ptype_manifest with
           None -> None
-        | Some sty -> Some(transl_simple_type env true sty)
+        | Some sty ->
+            Some (Ctype.unroll_abbrev id params
+                    (transl_simple_type env true sty))
         end } in
   Ctype.end_def();
   List.iter Ctype.generalize params;
+  begin match decl.type_kind with
+    Type_abstract ->
+      ()
+  | Type_variant v ->
+      List.iter (fun (_, tyl) -> List.iter Ctype.generalize tyl) v
+  | Type_record r ->
+      List.iter (fun (_, _, ty) -> Ctype.generalize ty) r
+  end;
+  begin match decl.type_manifest with
+    None    -> ()
+  | Some ty -> Ctype.generalize ty
+  end;
   (* If both a variant/record definition and a type equation are given,
      need to check that the equation refers to a type of the same kind
      with the same constructors and labels *)
   begin match decl with
     {type_kind = (Type_variant _ | Type_record _); type_manifest = Some ty} ->
-      begin match ty with
-        Tconstr(path, args) ->
+      begin match ty.desc with
+        Tconstr(path, args, _) ->
           begin try
             let decl' = Env.find_type path env in
             if args = params & Includecore.type_declarations env id decl decl'
@@ -121,30 +136,28 @@ let transl_declaration env (name, sdecl) id =
   end;
   (id, decl)
 
-(* Check for recursive abbrevs *)
+(* Check for ill-defined abbrevs *)
 
 let check_recursive_abbrev env (name, sdecl) (id, decl) =
   match decl.type_manifest with
     Some ty ->
-      if Ctype.free_type_ident env [id] ty
-      then raise(Error(sdecl.ptype_loc, Recursive_abbrev name))
-  | _ -> ()
+      begin try Ctype.correct_abbrev env id decl.type_params ty with
+        Ctype.Recursive_abbrev ->
+          raise(Error(sdecl.ptype_loc, Recursive_abbrev name))
+      | Ctype.Nonlinear_abbrev ->
+          raise(Error(sdecl.ptype_loc, Illdefined_abbrev name))
+      end
+  | _ ->
+      ()
 
 (* Translate a set of mutually recursive type declarations *)
 
 let transl_type_decl env name_sdecl_list =
-  Ctype.reset_def();
+  (* Enter the types as abstract *)
+  let (id_list, temp_env) = enter_types env name_sdecl_list in
+  (* Translate each declaration *)
   let decls =
-    match name_sdecl_list with
-      [(name, {ptype_kind = Ptype_abstract}) as name_sdecl] ->
-        (* No recursion involved, use original env for translation *)
-        let id = Ident.new name in
-        [transl_declaration env name_sdecl id]
-    | _ ->
-        (* Enter the types as abstract *)
-        let (id_list, temp_env) = enter_types env name_sdecl_list in
-        (* Translate each declaration *)
-        List.map2 (transl_declaration temp_env) name_sdecl_list id_list in
+    List.map2 (transl_declaration temp_env) name_sdecl_list id_list in
   (* Build the final env *)
   let newenv =
     List.fold_right
@@ -158,25 +171,23 @@ let transl_type_decl env name_sdecl_list =
 (* Translate an exception declaration *)
 
 let transl_exception env excdecl =
-  Ctype.reset_def();
   reset_type_variables();
   List.map (transl_simple_type env true) excdecl
 
 (* Translate a value declaration *)
 
 let transl_value_decl env valdecl =
-  Ctype.reset_def();
   let ty = Typetexp.transl_type_scheme env valdecl.pval_type in
+  let prim = Primitive.parse_declaration (Ctype.arity ty) valdecl.pval_prim in
   { val_type = ty;
-    val_prim = Primitive.parse_declaration (Ctype.arity ty) valdecl.pval_prim }
+    val_kind = match prim with Some p -> Val_prim p | None -> Val_reg }
 
 (* Translate a "with" constraint -- much simplified version of
     transl_type_decl. *)
 
 let transl_with_constraint env sdecl =
-  Ctype.reset_def();
-  Ctype.begin_def();
   reset_type_variables();
+  Ctype.begin_def();
   let params =
     try
       List.map enter_type_variable sdecl.ptype_params
@@ -214,4 +225,7 @@ let report_error = function
       print_string
         "The variant or record definition does not match that of type";
       print_space(); Printtyp.type_expr ty
+  | Illdefined_abbrev s ->
+      print_string "The type abbreviation "; print_string s;
+      print_string " is ill-defined"
 
diff --git a/typing/typedecl.mli b/typing/typedecl.mli
index 8ce3edb..1a01015 100644
--- a/typing/typedecl.mli
+++ b/typing/typedecl.mli
@@ -34,6 +34,7 @@ type error =
   | Duplicate_label of string
   | Recursive_abbrev of string
   | Definition_mismatch of type_expr
+  | Illdefined_abbrev of string
 
 exception Error of Location.t * error
 

diff --git a/typing/typemod.ml b/typing/typemod.ml
index 6f963a0..bd76c03 100644
--- a/typing/typemod.ml
+++ b/typing/typemod.ml
@@ -31,6 +31,7 @@ type error =
   | With_no_component of Longident.t
   | Repeated_name of string * string
   | Non_generalizable of type_expr
 
 exception Error of Location.t * error
 
 and transl_modtype_info env sinfo =
   match sinfo with
@@ -188,12 +197,14 @@ let check_unique_names sg =
         check "module" item.pstr_loc module_names name
     | Pstr_modtype(name, decl) ->
         check "module type" item.pstr_loc modtype_names name
-    | Pstr_open lid -> () in
-  List.iter check_item sg
+    | Pstr_open lid -> ()
+    | Pstr_class decl -> ()
+  in
+    List.iter check_item sg
 
 (* Check that all core type schemes in a structure are closed *)
 
-let check_nongen_schemes str =
+let check_nongen_schemes env str =
   List.iter 
     (function
         Tstr_value(rec_flag, pat_exp_list) ->
@@ -202,8 +213,24 @@ let check_nongen_schemes str =
               if not (Ctype.closed_schema exp.exp_type) then
                 raise(Error(exp.exp_loc, Non_generalizable exp.exp_type)))
             pat_exp_list
 
 (* Type a module value expression *)
 
@@ -215,8 +242,8 @@ let rec type_module env smod =
         mod_type = Mtype.strengthen env mty path;
         mod_loc = smod.pmod_loc }
   | Pmod_structure sstr ->
-      let (str, sg, _) = type_structure env sstr in
-      check_nongen_schemes str;
+      let (str, sg, finalenv) = type_structure env sstr in
+      check_nongen_schemes finalenv str;
       { mod_desc = Tmod_structure str;
         mod_type = Tmty_signature sg;
         mod_loc = smod.pmod_loc }
@@ -326,6 +353,19 @@ and type_struct env = function
       let (path, mty) = type_module_path env loc lid in
       let sg = extract_sig_open env loc mty in
       type_struct (Env.open_signature path sg env) srem
 
 (* Error report *)
 
@@ -376,4 +416,11 @@ let report_error = function
       open_hovbox 0;
       print_string "The type of this expression,"; print_space();
       type_scheme typ; print_string ","; print_space();
-      print_string "contains type variables that cannot be generalized"
+      print_string "contains type variables that cannot be generalized";
+      close_box()
diff --git a/typing/typemod.mli b/typing/typemod.mli
index b917199..58abc68 100644
--- a/typing/typemod.mli
+++ b/typing/typemod.mli
@@ -20,7 +20,7 @@ val type_structure:
 val transl_signature:
         Env.t -> Parsetree.signature -> signature
 val check_nongen_schemes:
-        structure -> unit
+        Env.t -> structure -> unit
 
 type error =
     Unbound_module of Longident.t
diff --git a/typing/typetexp.ml b/typing/typetexp.ml
index 08e99a7..ec83c77 100644
--- a/typing/typetexp.ml
+++ b/typing/typetexp.ml
@@ -13,6 +13,7 @@
 
 (* Typechecking of type expressions for the core language *)
 
+open Misc
 open Parsetree
 open Typedtree
 open Ctype
@@ -23,6 +24,11 @@ type error =
     Unbound_type_variable of string
   | Unbound_type_constructor of Longident.t
   | Type_arity_mismatch of Longident.t * int * int
+  | Bound_type_variable of string
+  | Recursive_type
+  | Unbound_class of Longident.t
+  | Unbound_row_variable of Longident.t
+  | Type_mismatch of type_expr * type_expr
 
 exception Error of Location.t * error
 
@@ -31,6 +37,7 @@ exception Error of Location.t * error
 let type_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
 
 let reset_type_variables () =
+  reset_global_level ();
   type_variables := Tbl.empty
 
 let enter_type_variable name =
@@ -41,6 +48,17 @@ let enter_type_variable name =
     type_variables := Tbl.add name v !type_variables;
     v
 
+let type_variable loc name =
+  try
+    Tbl.find name !type_variables
+  with Not_found ->
+    raise(Error(loc, Unbound_type_variable name))
+
+let type_variable_list () =
+  let l = ref [] in
+  Tbl.iter (fun _ v -> l := v::!l) !type_variables;
+  !l
+
 let rec transl_simple_type env fixed styp =
   match styp.ptyp_desc with
     Ptyp_var name ->
@@ -56,11 +74,12 @@ let rec transl_simple_type env fixed styp =
         end
       end
   | Ptyp_arrow(st1, st2) ->
-      Tarrow(transl_simple_type env fixed st1,
-             transl_simple_type env fixed st2)
+      let ty1 = transl_simple_type env fixed st1 in
+      let ty2 = transl_simple_type env fixed st2 in
+        Ctype.newty (Tarrow(ty1, ty2))
   | Ptyp_tuple stl ->
-      Ttuple(List.map (transl_simple_type env fixed) stl)
-  | Ptyp_constr(lid, stl) ->
+      Ctype.newty (Ttuple(List.map (transl_simple_type env fixed) stl))
+  | Ptyp_constr(lid, stl, alias) ->
       let (path, decl) =
         try
           Env.lookup_type lid env
@@ -69,7 +88,116 @@ let rec transl_simple_type env fixed styp =
       if List.length stl <> decl.type_arity then
         raise(Error(styp.ptyp_loc, Type_arity_mismatch(lid, decl.type_arity,
                                                            List.length stl)));
-      Tconstr(path, List.map (transl_simple_type env fixed) stl)
+      let (cstr, params) =
+        begin match alias with
+      	  None ->
+	    let tl = List.map (transl_simple_type env fixed) stl in
+              (newty (Tconstr(path, tl, ref [])), tl)
+        | Some alias ->
+            let cstr = newvar () in
+      	    begin try
+              Tbl.find alias !type_variables;
+	      raise(Error(styp.ptyp_loc, Bound_type_variable alias))
+            with Not_found ->
+      	      type_variables := Tbl.add alias cstr !type_variables
+	    end;
+	    let tl = List.map (transl_simple_type env fixed) stl in
+	    begin try
+              occur env cstr
+      	       	(Ctype.expand_abbrev env path tl (ref []) cstr.level)
+            with
+	      Unify         -> raise(Error(styp.ptyp_loc, Recursive_type))
+	    | Cannot_expand -> ()
+	    end;
+	    cstr.desc <- Tconstr(path, tl, ref []);
+	    (cstr, tl)
+        end
+      in
+      begin match decl.type_manifest with
+      	Some _ ->
+	  List.iter2
+           (fun ty (sty, ty') ->
+	      try Ctype.unify env (Ctype.instance ty) ty' with
+		Unify ->
+		  raise (Error(sty.ptyp_loc, Type_mismatch(ty, ty'))))
+           decl.type_params (List.combine stl params)
+      | _ ->
+      	  ()
+      end;
+      cstr

 let transl_type_scheme env styp =
   reset_type_variables();
@@ -97,3 +225,19 @@ let report_error = function
       print_string "but is here applied to "; print_int provided;
       print_string " argument(s)";
       close_box()
+  | Bound_type_variable name ->
+      print_string "Already bound type parameter "; print_string name
+  | Recursive_type ->
+      print_string "This type is recursive"
+  | Unbound_class lid ->
+      print_string "Unbound class "; longident lid
+  | Unbound_row_variable lid ->
+      print_string "Unbound row variable in #"; longident lid
+  | Type_mismatch (ty, ty') ->
+      Printtyp.reset ();
+      Printtyp.mark_loops ty; Printtyp.mark_loops ty';
+      open_hovbox 0;
+      print_string "This parameter ";
+      Printtyp.type_expr ty';
+      print_string " should be an instance of ";
+      Printtyp.type_expr ty
diff --git a/typing/typetexp.mli b/typing/typetexp.mli
index 14505b6..c1dd2d0 100644
--- a/typing/typetexp.mli
+++ b/typing/typetexp.mli
@@ -19,6 +19,8 @@ val transl_type_scheme:
         Env.t -> Parsetree.core_type -> Typedtree.type_expr
 val reset_type_variables: unit -> unit
 val enter_type_variable: string -> Typedtree.type_expr
+val type_variable : Location.t -> string -> Typedtree.type_expr
+val type_variable_list : unit -> Typedtree.type_expr list
 
 exception Already_bound
 
@@ -26,4 +28,9 @@ type error =
     Unbound_type_variable of string
   | Unbound_type_constructor of Longident.t
   | Type_arity_mismatch of Longident.t * int * int
+  | Bound_type_variable of string
+  | Recursive_type
+  | Unbound_class of Longident.t
+  | Unbound_row_variable of Longident.t
+  | Type_mismatch of Typedtree.type_expr * Typedtree.type_expr
 
 exception Error of Location.t * error


* asmcomp/

diff --git a/asmcomp/clambda.ml b/asmcomp/clambda.ml
index ae5cf62..d640aeb 100644
--- a/asmcomp/clambda.ml
+++ b/asmcomp/clambda.ml
@@ -39,6 +39,7 @@ type ulambda =
   | Uwhile of ulambda * ulambda
   | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
   | Uassign of Ident.t * ulambda
+  | Usend of ulambda * ulambda * ulambda list
 
 and ulambda_switch =
   { us_index_consts: int array;
diff --git a/asmcomp/clambda.mli b/asmcomp/clambda.mli
index ae5cf62..d640aeb 100644
--- a/asmcomp/clambda.mli
+++ b/asmcomp/clambda.mli
@@ -39,6 +39,7 @@ type ulambda =
   | Uwhile of ulambda * ulambda
   | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
   | Uassign of Ident.t * ulambda
+  | Usend of ulambda * ulambda * ulambda list
 
 and ulambda_switch =
   { us_index_consts: int array;
diff --git a/asmcomp/closure.ml b/asmcomp/closure.ml
index f06844e..8dfdad2 100644
--- a/asmcomp/closure.ml
+++ b/asmcomp/closure.ml
@@ -59,6 +59,7 @@ let occurs_var var u =
     | Uwhile(cond, body) -> occurs cond or occurs body
     | Ufor(id, lo, hi, dir, body) -> occurs lo or occurs hi or occurs body
     | Uassign(id, u) -> id = var or occurs u
+    | Usend(met, obj, args) -> List.exists occurs (met::obj::args)
   and occurs_array a =
     try
       for i = 0 to Array.length a - 1 do
@@ -127,6 +128,10 @@ let rec close fenv cenv = function
       | (ufunct, _) ->
           (Ugeneric_apply(ufunct, close_list fenv cenv args), Value_unknown)
       end
+  | Lsend(met, obj, args) ->
+      let (umet, _) = close fenv cenv met in
+      let (uobj, _) = close fenv cenv obj in
+      (Usend(umet, uobj, close_list fenv cenv args), Value_unknown)
   | Llet(str, id, lam, body) ->
       let (ulam, alam) = close_named fenv cenv id lam in
       let (ubody, abody) = close (Tbl.add id alam fenv) cenv body in
@@ -276,6 +276,16 @@ let string_length exp =
               Cop(Cloadchunk Byte_unsigned,
                   [Cop(Cadda, [str; Cvar tmp_var])])])))
 
+(* Message sending *)
+
+let lookup_label obj lab =
+  bind "lab" lab (fun lab ->
+    let table = Cop (Cload typ_addr, [obj]) in
+    let buck_index = Cop(Clsr, [lab; Cconst_int 16]) in
+    let bucket = Cop (Cload typ_addr, [Cop (Cadda, [table; buck_index])]) in
+    let item_index = Cop (Cand, [lab; Cconst_int (255 * size_addr)]) in
+    Cop (Cload typ_addr, [Cop (Cadda, [bucket; item_index])]))
+
 (* To compile "let rec" over values *)
 
 let fundecls_size fundecls =
@@ -397,9 +407,20 @@ let rec transl = function
       Cop(Capply typ_addr,
           Cconst_symbol(apply_function arity) ::
           List.map transl (args @ [clos]))
+  | Usend(met, obj, []) ->
+      bind "obj" (transl obj) (fun obj ->
+      bind "met" (lookup_label obj (transl met)) (fun clos ->
+        Cop(Capply typ_addr, [get_field clos 0; obj; clos])))
+  | Usend(met, obj, args) ->
+      let arity = List.length args + 1 in
+      bind "obj" (transl obj) (fun obj ->
+      bind "met" (lookup_label obj (transl met)) (fun clos ->
+        Cop(Capply typ_addr,
+            Cconst_symbol(apply_function arity) ::
+	    obj :: (List.map transl args) @ [clos])))
   | Ulet(id, exp, body) ->
       if is_unboxed_float exp then begin
-        let unboxed_id = Ident.new (Ident.name id) in
+        let unboxed_id = Ident.create (Ident.name id) in
         let (tr_body, need_boxed, is_assigned) =
           subst_boxed_float id unboxed_id (transl body) in
         if need_boxed & is_assigned then
@@ -817,6 +838,52 @@ let rec transl_all_functions already_translated cont =
   with Queue.Empty ->
     cont
 
+(* Translate a toplevel structure definition *)
+
+let rec transl_structure glob = function
+    Uprim(Pmakeblock(tag, mut), args) ->
+      (* Scan the args, storing those that are not identifiers and
+         returning a hashtable id -> position in block
+         for those that are idents. *)
+      let map = Hashtbl.create 17 in
+      let rec make_stores pos = function
+        [] -> Ctuple []
+      | Uvar v :: rem ->
+          Hashtbl.add map v pos;
+          make_stores (pos+1) rem
+      | ulam :: rem ->
+          Csequence(Cop(Cstore,
+                        [field_address (Cconst_symbol glob) pos; transl ulam]),
+                    make_stores (pos+1) rem) in
+      let c = make_stores 0 args in
+      (c, map, List.length args)
+  | Usequence(e1, e2) ->
+      let (c2, map, size) = transl_structure glob e2 in
+      (Csequence(remove_unit(transl e1), c2), map, size)
+  | Ulet(id, arg, body) ->
+      let (cbody, map, size) = transl_structure glob body in
+      (Clet(id, transl arg, add_store glob id map cbody), map, size)
+  | Uletrec(bindings, body) ->
+      let (cbody, map, size) = transl_structure glob body in
+      (transl_letrec bindings (add_stores glob bindings map cbody), map, size)
+  | Uprim(Psetglobal id, [arg]) ->
+      transl_structure glob arg
+  | _ ->
+      fatal_error "Cmmgen.transl_structure"
+
+and add_store glob id map code =
+  let rec store = function
+    [] -> code
+  | pos :: rem ->
+      Csequence(Cop(Cstore, [field_address (Cconst_symbol glob) pos; Cvar id]),
+                store rem) in
+  store (Hashtbl.find_all map id)
+
+and add_stores glob bindings map code =
+  match bindings with
+    [] -> code
+  | (id, def) :: rem -> add_stores glob rem map (add_store glob id map code) 
+
 (* Emit structured constants *)
 
 let rec emit_constant symb cst cont =


