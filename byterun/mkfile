</$objtype/mkfile

# If you want to cross compile ocamlrun, you just need
# to add this to config.h
#   #undef __GNUC__
#   #undef ARCH_SIXTYFOUR
#   #undef HAS_TERMCAP
# and then run mk

OFILES1=interp.$O misc.$O stacks.$O fix_code.$O startup.$O main.$O \
  freelist.$O major_gc.$O minor_gc.$O memory.$O alloc.$O roots.$O \
  fail.$O signals.$O printexc.$O \
  compare.$O ints.$O floats.$O str.$O array.$O io.$O extern.$O intern.$O \
  hash.$O sys.$O meta.$O parsing.$O gc_ctrl.$O terminfo.$O md5.$O obj.$O \
  lexing.$O callback.$O debugger.$O weak.$O compact.$O 

BIN=/$objtype/bin

OFILES=$OFILES1 prims.$O

</sys/src/cmd/mkone

#old: I was adding -p to use the ANSI preprocessor, because the builtin
# cpp in 8c does not support complex conditions in #idef such as
# #if defined(X) && !defined(Y).
# But it was not enough. So I switched to pcc and ape.
#CFLAGS= -p $CFLAGS 

CC=pcc
LD=pcc
# I removed -T because prims.c (a generated file) has wrong signatures 
# but it's ok
# I added here some -D_xxx instead of config.h because some files 
# don't include config.h, so simpler to do it here once and for all.
CFLAGS=-FV -c -D_POSIX_SOURCE -D_BSD_EXTENSION
# add this if you want better trace
# -DDEBUG
LDFLAGS=

default:V: 8.out libcamlrun.a

lib:V: libcamlrun.a

libcamlrun.a: $OFILES1
	rm -f $target
	ar vu $target $OFILES1              

ROOT=/home/pad/plan9/ROOT

# do not use ../boot/..., use the latest compiled stuff
install:V: 8.out libcamlrun.a
	cp -f 8.out $ROOT/usr/local/bin/ocamlrun
    cp libcamlrun.a $ROOT/usr/local/lib/ocaml/
    mk install2

install2:V:
    cp ../ocamlc $ROOT/usr/local/bin/
    cp ../ocaml $ROOT/usr/local/bin/
    cp ../lex/ocamllex $ROOT/usr/local/bin/
    cp ../stdlib/*.cm* $ROOT/usr/local/lib/ocaml
    cp ../otherlibs/unix/*.cm* $ROOT/usr/local/lib/ocaml
    cp ../otherlibs/str/*.cm* $ROOT/usr/local/lib/ocaml
    cp ../otherlibs/threads/*.cm* $ROOT/usr/local/lib/ocaml/threads

clean:V:
	rm -f *.[58] [58].out y.tab.? lex.yy.c y.debug y.output  $CLEANFILES
	rm -f libcamlrun.a
