%\part{NATIVE CODE START}

\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/arch.ml]]}

<<type [[Arch.addressing_mode]]>>=
(* Addressing modes *)

type addressing_mode =
    Iindexed of int                     (* reg + displ *)
@

<<type [[Arch.specific_operation]]>>=
type specific_operation =
    Ishiftarith of arith_operation * int
  | Ishiftcheckbound of int
  | Irevsubimm of int
@

<<type [[Arch.arith_operation]]>>=
and arith_operation =
    Ishiftadd
  | Ishiftsub
  | Ishiftsubrev
@

<<type [[Arch.float_operation]]>>=
type float_operation = unit
@

<<constant [[Arch.big_endian]]>>=
(* Sizes, endianness *)

let big_endian = false
@

<<constant [[Arch.size_addr]]>>=
let size_addr = 4
@

<<constant [[Arch.size_int]]>>=
let size_int = 4
@

<<constant [[Arch.size_float]]>>=
let size_float = 8
@

<<constant [[Arch.identity_addressing]]>>=
(* Operations on addressing modes *)

let identity_addressing = Iindexed 0
@

<<function [[Arch.offset_addressing]]>>=
let offset_addressing (Iindexed n) delta = Iindexed(n + delta)
@

<<function [[Arch.num_args_addressing]]>>=
let num_args_addressing (Iindexed n) = 1
@

<<function [[Arch.print_addressing]]>>=
(* Printing operations and addressing modes *)

let print_addressing printreg addr arg =
  match addr with
    Iindexed n ->
      printreg arg.(0);
      if n <> 0 then begin print_string " + "; print_int n end
@

<<function [[Arch.print_specific_operation]]>>=
let print_specific_operation printreg op arg =
  match op with
    Ishiftarith(op, shift) ->
      printreg arg.(0);
      begin match op with
        Ishiftadd -> print_string " + "
      | Ishiftsub -> print_string " - "
      | Ishiftsubrev -> print_string " -rev "
      end;
      printreg arg.(1);
      if shift >= 0
      then begin print_string " << "; print_int shift end
      else begin print_string " >> "; print_int (-shift) end
  | Ishiftcheckbound n ->
      print_string "check ";
      printreg arg.(0);
      print_string " >> "; print_int n; print_string " > ";
      printreg arg.(1)
  | Irevsubimm n ->
      print_int n; print_string " - "; printreg arg.(0)
@


%-------------------------------------------------------------

<<asmcomp/arm/arch.ml>>=
<<copyright header 1998>>

(* Specific operations for the ARM processor *)

open Misc
open Format

<<type [[Arch.addressing_mode]]>>

(* We do not support the reg + shifted reg addressing mode, because
   what we really need is reg + shifted reg + displ,
   and this is decomposed in two instructions (reg + shifted reg -> tmp,
   then addressing tmp + displ). *)

(* Specific operations *)

<<type [[Arch.specific_operation]]>>

<<type [[Arch.arith_operation]]>>

<<type [[Arch.float_operation]]>>

<<constant [[Arch.big_endian]]>>

<<constant [[Arch.size_addr]]>>
<<constant [[Arch.size_int]]>>
<<constant [[Arch.size_float]]>>

<<constant [[Arch.identity_addressing]]>>

<<function [[Arch.offset_addressing]]>>

<<function [[Arch.num_args_addressing]]>>

<<function [[Arch.print_addressing]]>>

<<function [[Arch.print_specific_operation]]>>
@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/clambda.mli]]}

<<type [[Clambda.function_label]]>>=
type function_label = string
@

<<type [[Clambda.ulambda]]>>=
type ulambda =
    Uvar of Ident.t
  | Uconst of structured_constant
  | Udirect_apply of function_label * ulambda list
  | Ugeneric_apply of ulambda * ulambda list
  | Uclosure of (function_label * int * Ident.t list * ulambda) list
              * ulambda list
  | Uoffset of ulambda * int
  | Ulet of Ident.t * ulambda * ulambda
  | Uletrec of (Ident.t * ulambda) list * ulambda
  | Uprim of primitive * ulambda list
  | Uswitch of ulambda * ulambda_switch
  | Ustaticfail
  | Ucatch of ulambda * ulambda
  | Utrywith of ulambda * Ident.t * ulambda
  | Uifthenelse of ulambda * ulambda * ulambda
  | Usequence of ulambda * ulambda
  | Uwhile of ulambda * ulambda
  | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
  | Uassign of Ident.t * ulambda
@

<<type [[Clambda.ulambda_switch]]>>=
and ulambda_switch =
  { us_index_consts: int array;
    us_cases_consts: ulambda array;
    us_index_blocks: int array;
    us_cases_blocks: ulambda array;
    us_checked: bool }
@

<<type [[Clambda.function_description]]>>=
(* Description of known functions *)

type function_description =
  { fun_label: function_label;          (* Label of direct entry point *)
    fun_arity: int;                     (* Number of arguments *)
    mutable fun_closed: bool;           (* True if environment not used *)
    mutable fun_inline: (Ident.t list * ulambda) option }
@

<<type [[Clambda.value_approximation]]>>=
(* Approximation of values *)

type value_approximation =
    Value_closure of function_description * value_approximation
  | Value_tuple of value_approximation array
  | Value_unknown
@


%-------------------------------------------------------------

<<asmcomp/clambda.mli>>=
<<copyright header>>

(* A variant of the "lambda" code with direct / indirect calls explicit
   and closures explicit too *)

open Asttypes
open Lambda

<<type [[Clambda.function_label]]>>

<<type [[Clambda.ulambda]]>>

<<type [[Clambda.ulambda_switch]]>>

<<type [[Clambda.function_description]]>>

<<type [[Clambda.value_approximation]]>>
@


\subsection*{[[asmcomp/clambda.ml]]}

<<type [[Clambda.function_label]]([[(asmcomp/clambda.ml)]])>>=
type function_label = string
@

<<type [[Clambda.ulambda]]([[(asmcomp/clambda.ml)]])>>=
type ulambda =
    Uvar of Ident.t
  | Uconst of structured_constant
  | Udirect_apply of function_label * ulambda list
  | Ugeneric_apply of ulambda * ulambda list
  | Uclosure of (function_label * int * Ident.t list * ulambda) list
              * ulambda list
  | Uoffset of ulambda * int
  | Ulet of Ident.t * ulambda * ulambda
  | Uletrec of (Ident.t * ulambda) list * ulambda
  | Uprim of primitive * ulambda list
  | Uswitch of ulambda * ulambda_switch
  | Ustaticfail
  | Ucatch of ulambda * ulambda
  | Utrywith of ulambda * Ident.t * ulambda
  | Uifthenelse of ulambda * ulambda * ulambda
  | Usequence of ulambda * ulambda
  | Uwhile of ulambda * ulambda
  | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
  | Uassign of Ident.t * ulambda
@

<<type [[Clambda.ulambda_switch]]([[(asmcomp/clambda.ml)]])>>=
and ulambda_switch =
  { us_index_consts: int array;
    us_cases_consts: ulambda array;
    us_index_blocks: int array;
    us_cases_blocks: ulambda array;
    us_checked: bool }
@

<<type [[Clambda.function_description]]([[(asmcomp/clambda.ml)]])>>=
(* Description of known functions *)

type function_description =
  { fun_label: function_label;          (* Label of direct entry point *)
    fun_arity: int;                     (* Number of arguments *)
    mutable fun_closed: bool;           (* True if environment not used *)
    mutable fun_inline: (Ident.t list * ulambda) option }
@

<<type [[Clambda.value_approximation]]([[(asmcomp/clambda.ml)]])>>=
(* Approximation of values *)

type value_approximation =
    Value_closure of function_description * value_approximation
  | Value_tuple of value_approximation array
  | Value_unknown
@


%-------------------------------------------------------------

<<asmcomp/clambda.ml>>=
<<copyright header>>

(* A variant of the "lambda" code with direct / indirect calls explicit
   and closures explicit too *)

open Asttypes
open Lambda

<<type [[Clambda.function_label]]([[(asmcomp/clambda.ml)]])>>

<<type [[Clambda.ulambda]]([[(asmcomp/clambda.ml)]])>>

<<type [[Clambda.ulambda_switch]]([[(asmcomp/clambda.ml)]])>>

<<type [[Clambda.function_description]]([[(asmcomp/clambda.ml)]])>>

<<type [[Clambda.value_approximation]]([[(asmcomp/clambda.ml)]])>>
@


\subsection*{[[asmcomp/emitaux.mli]]}

<<signature [[Emitaux.output_channel]]>>=
(* Common functions for emitting assembly code *)

val output_channel: out_channel ref
@

<<signature [[Emitaux.emit_string]]>>=
val emit_string: string -> unit
@

<<signature [[Emitaux.emit_int]]>>=
val emit_int: int -> unit
@

<<signature [[Emitaux.emit_nativeint]]>>=
val emit_nativeint: Nativeint.t -> unit
@

<<signature [[Emitaux.emit_symbol]]>>=
val emit_symbol: char -> string -> unit
@

<<signature [[Emitaux.emit_printf]]>>=
val emit_printf: ('a, out_channel, unit) format -> 'a
@

<<signature [[Emitaux.emit_char]]>>=
val emit_char: char -> unit
@

<<signature [[Emitaux.emit_string_literal]]>>=
val emit_string_literal: string -> unit
@

<<signature [[Emitaux.emit_string_directive]]>>=
val emit_string_directive: string -> string -> unit
@

<<signature [[Emitaux.emit_bytes_directive]]>>=
val emit_bytes_directive: string -> string -> unit
@


%-------------------------------------------------------------

<<asmcomp/emitaux.mli>>=
<<copyright header>>

<<signature [[Emitaux.output_channel]]>>
<<signature [[Emitaux.emit_string]]>>
<<signature [[Emitaux.emit_int]]>>
<<signature [[Emitaux.emit_nativeint]]>>
<<signature [[Emitaux.emit_symbol]]>>
<<signature [[Emitaux.emit_printf]]>>
<<signature [[Emitaux.emit_char]]>>
<<signature [[Emitaux.emit_string_literal]]>>
<<signature [[Emitaux.emit_string_directive]]>>
<<signature [[Emitaux.emit_bytes_directive]]>>
@


\subsection*{[[asmcomp/emitaux.ml]]}

<<constant [[Emitaux.output_channel]]>>=
(* Common functions for emitting assembly code *)

let output_channel = ref stdout
@

<<function [[Emitaux.emit_string]]>>=
let emit_string s = output_string !output_channel s
@

<<function [[Emitaux.emit_int]]>>=
let emit_int n = output_string !output_channel (string_of_int n)
@

<<function [[Emitaux.emit_char]]>>=
let emit_char c = output_char !output_channel c
@

<<function [[Emitaux.emit_nativeint]]>>=
let emit_nativeint n = output_string !output_channel (Nativeint.to_string n)
@

<<function [[Emitaux.emit_printf]]>>=
(* @Scheck: used by mips backend *)
let emit_printf fmt =
  Printf.fprintf !output_channel fmt
@

<<function [[Emitaux.emit_symbol]]>>=
let emit_symbol esc s =
  for i = 0 to String.length s - 1 do
    let c = s.[i] in
    match c with
      'A'..'Z' | 'a'..'z' | '0'..'9' | '_' ->
        output_char !output_channel c
    | _ ->
        Printf.fprintf !output_channel "%c%02x" esc (Char.code c)
  done
@

<<function [[Emitaux.emit_string_literal]]>>=
let emit_string_literal s =
  let last_was_escape = ref false in
  emit_string "\"";
  for i = 0 to String.length s - 1 do
    let c = s.[i] in
    if c >= '0' && c <= '9' then
      if !last_was_escape
      then Printf.fprintf !output_channel "\\%o" (Char.code c)
      else output_char !output_channel c
    else if c >= ' ' && c <= '~' && c <> '"' (* '"' *) && c <> '\\' then begin
      output_char !output_channel c;
      last_was_escape := false
    end else begin
      Printf.fprintf !output_channel "\\%o" (Char.code c);
      last_was_escape := true
    end
  done;
  emit_string "\""
@

<<function [[Emitaux.emit_string_directive]]>>=
let emit_string_directive directive s =
  let l = String.length s in
  if l = 0 then ()
  else if l < 80 then begin
    emit_string directive;
    emit_string_literal s;
    emit_char '\n'
  end else begin
    let i = ref 0 in
    while !i < l do
      let n = min (l - !i) 80 in
      emit_string directive;
      emit_string_literal (String.sub s !i n);
      emit_char '\n';
      i := !i + n
    done
  end
@

<<function [[Emitaux.emit_bytes_directive]]>>=
let emit_bytes_directive directive s =
   let pos = ref 0 in
   for i = 0 to String.length s - 1 do
     if !pos = 0
     then emit_string directive
     else emit_char ',';
     emit_int(Char.code s.[i]);
     incr pos;
     if !pos >= 16 then begin emit_char '\n'; pos := 0 end
   done;
   if !pos > 0 then emit_char '\n'
@


%-------------------------------------------------------------

<<asmcomp/emitaux.ml>>=
<<copyright header>>

<<constant [[Emitaux.output_channel]]>>

<<function [[Emitaux.emit_string]]>>

<<function [[Emitaux.emit_int]]>>

<<function [[Emitaux.emit_char]]>>

<<function [[Emitaux.emit_nativeint]]>>

<<function [[Emitaux.emit_printf]]>>

<<function [[Emitaux.emit_symbol]]>>

<<function [[Emitaux.emit_string_literal]]>>

<<function [[Emitaux.emit_string_directive]]>>

<<function [[Emitaux.emit_bytes_directive]]>>

@


\subsection*{[[asmcomp/scheduling.mli]]}

<<signature [[Scheduling.fundecl]]>>=
(* Instruction scheduling *)

val fundecl: Linearize.fundecl -> Linearize.fundecl
@


%-------------------------------------------------------------

<<asmcomp/scheduling.mli>>=
<<copyright header>>

<<signature [[Scheduling.fundecl]]>>
@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/scheduling.ml]]}

<<function [[Scheduling.scheduler]]>>=
(* Instruction scheduling for the Sparc *)

let scheduler () = 

  let super = Schedgen.scheduler_generic () in
  {

  oper_in_basic_block = super.oper_in_basic_block;
  schedule_fundecl = super.schedule_fundecl;
  instr_in_basic_block = super.instr_in_basic_block;
  instr_latency = super.instr_latency;
  instr_issue_cycles = super.instr_issue_cycles;
  add_instruction = super.add_instruction;
  ready_instruction = super.ready_instruction;
  reschedule = super.reschedule;

(* Scheduling -- based roughly on the Strong ARM *)

 oper_latency = (function
    Ireload -> 2
  | Iload(_, _) -> 2
  | Iconst_symbol _ -> 2                (* turned into a load *)
  | Iconst_float _ -> 2                 (* turned into a load *)
  | Iintop(Imul) -> 3
  | Iintop_imm(Imul, _) -> 3
  (* No data available for floatops, let's make educated guesses *)
  | Iaddf -> 3
  | Isubf -> 3
  | Imulf -> 5
  | Idivf -> 15
  | _ -> 1
 );

(* Issue cycles.  Rough approximations *)

 oper_issue_cycles = (function
    Ialloc _ -> 4
  | Iintop(Icomp _) -> 3
  | Iintop(Icheckbound) -> 2
  | Iintop_imm(Idiv, _) -> 4
  | Iintop_imm(Imod, _) -> 6
  | Iintop_imm(Icomp _, _) -> 3
  | Iintop_imm(Icheckbound, _) -> 2
  | _ -> 1
 );
  }
@

<<function [[Scheduling.fundecl]]>>=
let fundecl f = 
  let s = scheduler () in
  s.schedule_fundecl s f
@


%-------------------------------------------------------------

<<asmcomp/arm/scheduling.ml>>=
<<copyright header>>
open Mach

open Schedgen

<<function [[Scheduling.scheduler]]>>

<<function [[Scheduling.fundecl]]>>
@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/cmm.mli]]}

<<type [[Cmm.machtype_component]]>>=
(* Second intermediate language (machine independent) *)

type machtype_component =
    Addr
  | Int
  | Float
@

<<type [[Cmm.machtype]]>>=
type machtype = machtype_component array
@

<<signature [[Cmm.typ_void]]>>=
val typ_void: machtype
@

<<signature [[Cmm.typ_addr]]>>=
val typ_addr: machtype
@

<<signature [[Cmm.typ_int]]>>=
val typ_int: machtype
@

<<signature [[Cmm.typ_float]]>>=
val typ_float: machtype
@

<<signature [[Cmm.size_component]]>>=
val size_component: machtype_component -> int
@

<<signature [[Cmm.size_machtype]]>>=
val size_machtype: machtype -> int
@

<<type [[Cmm.comparison]]>>=
type comparison =
    Ceq
  | Cne
  | Clt
  | Cle
  | Cgt
  | Cge
@

<<signature [[Cmm.negate_comparison]]>>=
val negate_comparison: comparison -> comparison
@

<<signature [[Cmm.swap_comparison]]>>=
val swap_comparison: comparison -> comparison
@

<<type [[Cmm.memory_chunk]]>>=
type memory_chunk =
    Byte_unsigned
  | Byte_signed
  | Sixteen_unsigned
  | Sixteen_signed
  | Word
@

<<type [[Cmm.operation]]>>=
type operation =
    Capply of machtype
  | Cextcall of string * machtype * bool
  | Cproj of int * int
  | Cload of machtype
  | Cloadchunk of memory_chunk
  | Calloc
  | Cstore
  | Cstorechunk of memory_chunk
  | Caddi | Csubi | Cmuli | Cdivi | Cmodi
  | Cand | Cor | Cxor | Clsl | Clsr | Casr
  | Ccmpi of comparison
  | Cadda | Csuba
  | Ccmpa of comparison
  | Cnegf | Cabsf
  | Caddf | Csubf | Cmulf | Cdivf
  | Cfloatofint | Cintoffloat
  | Ccmpf of comparison
  | Craise
  | Ccheckbound
@

<<type [[Cmm.expression]]>>=
type expression =
    Cconst_int of int
  | Cconst_natint of Nativeint.t
  | Cconst_float of string
  | Cconst_symbol of string
  | Cconst_pointer of int
  | Cvar of Ident.t
  | Clet of Ident.t * expression * expression
  | Cassign of Ident.t * expression
  | Ctuple of expression list
  | Cop of operation * expression list
  | Csequence of expression * expression
  | Cifthenelse of expression * expression * expression
  | Cswitch of expression * int array * expression array
  | Cloop of expression
  | Ccatch of expression * expression
  | Cexit
  | Ctrywith of expression * Ident.t * expression
@

<<type [[Cmm.fundecl]]>>=
type fundecl =
  { fun_name: string;
    fun_args: (Ident.t * machtype) list;
    fun_body: expression;
    fun_fast: bool }
@

<<type [[Cmm.data_item]]>>=
type data_item =
    Cdefine_symbol of string
  | Cdefine_label of int
  | Cint8 of int
  | Cint16 of int
  | Cint of Nativeint.t
  | Cfloat of string
  | Csymbol_address of string
  | Clabel_address of int
  | Cstring of string
  | Cskip of int
  | Calign of int
@

<<type [[Cmm.phrase]]>>=
type phrase =
    Cfunction of fundecl
  | Cdata of data_item list
@


%-------------------------------------------------------------

<<asmcomp/cmm.mli>>=
<<copyright header>>

<<type [[Cmm.machtype_component]]>>

<<type [[Cmm.machtype]]>>

<<signature [[Cmm.typ_void]]>>
<<signature [[Cmm.typ_addr]]>>
<<signature [[Cmm.typ_int]]>>
<<signature [[Cmm.typ_float]]>>

<<signature [[Cmm.size_component]]>>
<<signature [[Cmm.size_machtype]]>>

<<type [[Cmm.comparison]]>>

<<signature [[Cmm.negate_comparison]]>>
<<signature [[Cmm.swap_comparison]]>>

<<type [[Cmm.memory_chunk]]>>

<<type [[Cmm.operation]]>>

<<type [[Cmm.expression]]>>

<<type [[Cmm.fundecl]]>>

<<type [[Cmm.data_item]]>>

<<type [[Cmm.phrase]]>>

@


\subsection*{[[asmcomp/cmm.ml]]}

<<type [[Cmm.machtype_component]]([[(asmcomp/cmm.ml)]])>>=

type machtype_component =
    Addr
  | Int
  | Float
@

<<type [[Cmm.machtype]]([[(asmcomp/cmm.ml)]])>>=
type machtype = machtype_component array
@

<<constant [[Cmm.typ_void]]>>=
let typ_void = ([||] : machtype_component array)
@

<<constant [[Cmm.typ_addr]]>>=
let typ_addr = [|Addr|]
@

<<constant [[Cmm.typ_int]]>>=
let typ_int = [|Int|]
@

<<constant [[Cmm.typ_float]]>>=
let typ_float = [|Float|]
@

<<function [[Cmm.size_component]]>>=
let size_component = function
    Addr -> Arch.size_addr
  | Int -> Arch.size_int
  | Float -> Arch.size_float
@

<<function [[Cmm.size_machtype]]>>=
let size_machtype mty =
  let size = ref 0 in
  for i = 0 to Array.length mty - 1 do
    size := !size + size_component mty.(i)
  done;
  !size
@

<<type [[Cmm.comparison]]([[(asmcomp/cmm.ml)]])>>=
type comparison =
    Ceq
  | Cne
  | Clt
  | Cle
  | Cgt
  | Cge
@

<<function [[Cmm.negate_comparison]]>>=
let negate_comparison = function
    Ceq -> Cne | Cne -> Ceq
  | Clt -> Cge | Cle -> Cgt
  | Cgt -> Cle | Cge -> Clt
@

<<function [[Cmm.swap_comparison]]>>=
let swap_comparison = function
    Ceq -> Ceq | Cne -> Cne
  | Clt -> Cgt | Cle -> Cge
  | Cgt -> Clt | Cge -> Cle
@

<<type [[Cmm.memory_chunk]]([[(asmcomp/cmm.ml)]])>>=
type memory_chunk =
    Byte_unsigned
  | Byte_signed
  | Sixteen_unsigned
  | Sixteen_signed
  | Word
@

<<type [[Cmm.operation]]([[(asmcomp/cmm.ml)]])>>=
type operation =
    Capply of machtype
  | Cextcall of string * machtype * bool
  | Cproj of int * int
  | Cload of machtype
  | Cloadchunk of memory_chunk
  | Calloc
  | Cstore
  | Cstorechunk of memory_chunk
  | Caddi | Csubi | Cmuli | Cdivi | Cmodi
  | Cand | Cor | Cxor | Clsl | Clsr | Casr
  | Ccmpi of comparison
  | Cadda | Csuba
  | Ccmpa of comparison
  | Cnegf | Cabsf
  | Caddf | Csubf | Cmulf | Cdivf
  | Cfloatofint | Cintoffloat
  | Ccmpf of comparison
  | Craise
  | Ccheckbound
@

<<type [[Cmm.expression]]([[(asmcomp/cmm.ml)]])>>=
type expression =
    Cconst_int of int
  | Cconst_natint of Nativeint.t
  | Cconst_float of string
  | Cconst_symbol of string
  | Cconst_pointer of int
  | Cvar of Ident.t
  | Clet of Ident.t * expression * expression
  | Cassign of Ident.t * expression
  | Ctuple of expression list
  | Cop of operation * expression list
  | Csequence of expression * expression
  | Cifthenelse of expression * expression * expression
  | Cswitch of expression * int array * expression array
  | Cloop of expression
  | Ccatch of expression * expression
  | Cexit
  | Ctrywith of expression * Ident.t * expression
@

<<type [[Cmm.fundecl]]([[(asmcomp/cmm.ml)]])>>=
type fundecl =
  { fun_name: string;
    fun_args: (Ident.t * machtype) list;
    fun_body: expression;
    fun_fast: bool }
@

<<type [[Cmm.data_item]]([[(asmcomp/cmm.ml)]])>>=
type data_item =
    Cdefine_symbol of string
  | Cdefine_label of int
  | Cint8 of int
  | Cint16 of int
  | Cint of Nativeint.t
  | Cfloat of string
  | Csymbol_address of string
  | Clabel_address of int
  | Cstring of string
  | Cskip of int
  | Calign of int
@

<<type [[Cmm.phrase]]([[(asmcomp/cmm.ml)]])>>=
type phrase =
    Cfunction of fundecl
  | Cdata of data_item list
@


%-------------------------------------------------------------

<<asmcomp/cmm.ml>>=
<<copyright header>>
<<type [[Cmm.machtype_component]]([[(asmcomp/cmm.ml)]])>>

<<type [[Cmm.machtype]]([[(asmcomp/cmm.ml)]])>>

<<constant [[Cmm.typ_void]]>>
<<constant [[Cmm.typ_addr]]>>
<<constant [[Cmm.typ_int]]>>
<<constant [[Cmm.typ_float]]>>

<<function [[Cmm.size_component]]>>

<<function [[Cmm.size_machtype]]>>

<<type [[Cmm.comparison]]([[(asmcomp/cmm.ml)]])>>

<<function [[Cmm.negate_comparison]]>>

<<function [[Cmm.swap_comparison]]>>

<<type [[Cmm.memory_chunk]]([[(asmcomp/cmm.ml)]])>>

<<type [[Cmm.operation]]([[(asmcomp/cmm.ml)]])>>

<<type [[Cmm.expression]]([[(asmcomp/cmm.ml)]])>>

<<type [[Cmm.fundecl]]([[(asmcomp/cmm.ml)]])>>

<<type [[Cmm.data_item]]([[(asmcomp/cmm.ml)]])>>

<<type [[Cmm.phrase]]([[(asmcomp/cmm.ml)]])>>

@


\subsection*{[[asmcomp/printcmm.mli]]}

<<signature [[Printcmm.machtype_component]]>>=
(* Pretty-printing of C-- code *)

val machtype_component : Cmm.machtype_component -> unit
@

<<signature [[Printcmm.machtype]]>>=
val machtype : Cmm.machtype_component array -> unit
@

<<signature [[Printcmm.comparison]]>>=
val comparison : Cmm.comparison -> unit
@

<<signature [[Printcmm.chunk]]>>=
val chunk : Cmm.memory_chunk -> unit
@

<<signature [[Printcmm.operation]]>>=
val operation : Cmm.operation -> unit
@

<<signature [[Printcmm.expression]]>>=
val expression : Cmm.expression -> unit
@

<<signature [[Printcmm.fundecl]]>>=
val fundecl : Cmm.fundecl -> unit
@

<<signature [[Printcmm.data]]>>=
val data : Cmm.data_item list -> unit
@

<<signature [[Printcmm.phrase]]>>=
val phrase : Cmm.phrase -> unit
@


%-------------------------------------------------------------

<<asmcomp/printcmm.mli>>=
<<copyright header>>

<<signature [[Printcmm.machtype_component]]>>
<<signature [[Printcmm.machtype]]>>
<<signature [[Printcmm.comparison]]>>
<<signature [[Printcmm.chunk]]>>
<<signature [[Printcmm.operation]]>>
<<signature [[Printcmm.expression]]>>
<<signature [[Printcmm.fundecl]]>>
<<signature [[Printcmm.data]]>>
<<signature [[Printcmm.phrase]]>>
@


\subsection*{[[asmcomp/printcmm.ml]]}

<<function [[Printcmm.machtype_component]]>>=
let machtype_component = function
    Addr -> print_string "addr"
  | Int -> print_string "int"
  | Float -> print_string "float"
@

<<function [[Printcmm.machtype]]>>=
let machtype mty =
  match Array.length mty with
    0 -> print_string "unit"
  | n -> machtype_component mty.(0);
         for i = 1 to n-1 do
           print_string "*"; machtype_component mty.(i)
         done
@

<<function [[Printcmm.comparison]]>>=
let comparison = function
    Ceq -> print_string "=="
  | Cne -> print_string "!="
  | Clt -> print_string "<"
  | Cle -> print_string "<="
  | Cgt -> print_string ">"
  | Cge -> print_string ">="
@

<<function [[Printcmm.chunk]]>>=
let chunk = function
    Byte_unsigned -> print_string "unsigned byte"
  | Byte_signed -> print_string "signed byte"
  | Sixteen_unsigned -> print_string "unsigned half"
  | Sixteen_signed -> print_string "signed half"
  | Word -> ()
@

<<function [[Printcmm.operation]]>>=
let operation = function
    Capply ty -> print_string "app"
  | Cextcall(lbl, ty, alloc) ->
      print_string "extcall \""; print_string lbl; print_string "\""
  | Cproj(ofs, len) ->
      print_string "proj "; print_int ofs;
      if len > 1 then begin print_string "-"; print_int (ofs + len - 1) end
  | Cload mty -> print_string "load"
  | Cloadchunk c -> print_string "load "; chunk c
  | Calloc -> print_string "alloc"
  | Cstore -> print_string "store"
  | Cstorechunk c -> print_string "store "; chunk c
  | Caddi -> print_string "+"
  | Csubi -> print_string "-"
  | Cmuli -> print_string "*"
  | Cdivi -> print_string "/"
  | Cmodi -> print_string "mod"
  | Cand -> print_string "and"
  | Cor -> print_string "or"
  | Cxor -> print_string "xor"
  | Clsl -> print_string "<<"
  | Clsr -> print_string ">>u"
  | Casr -> print_string ">>s"
  | Ccmpi c -> comparison c
  | Cadda -> print_string "+a"
  | Csuba -> print_string "-a"
  | Ccmpa c -> comparison c; print_string "a"
  | Cnegf -> print_string "~f"
  | Cabsf -> print_string "absf"
  | Caddf -> print_string "+f"
  | Csubf -> print_string "-f"
  | Cmulf -> print_string "*f"
  | Cdivf -> print_string "/f"
  | Cfloatofint -> print_string "floatofint"
  | Cintoffloat -> print_string "intoffloat"
  | Ccmpf c -> comparison c; print_string "f"
  | Craise -> print_string "raise"
  | Ccheckbound -> print_string "checkbound"
@

<<function [[Printcmm.fundecl]]>>=
let fundecl f =
  open_box 1;
  print_string "(function "; print_string f.fun_name; print_break 1 4;
  open_box 1;
  print_string "(";
  let first = ref true in
  List.iter
    (fun (id, ty) -> 
      if !first then first := false else print_space();
      Ident.print id; print_string ": "; machtype ty)
    f.fun_args;
  print_string ")"; close_box(); print_space();
  open_box 0;
  sequence f.fun_body;
  print_string ")";
  close_box(); close_box(); print_newline()
@

<<function [[Printcmm.data_item]]>>=
let data_item = function
    Cdefine_symbol s -> print_string "\""; print_string s; print_string "\":"
  | Cdefine_label l -> print_string "L"; print_int l; print_string ":"
  | Cint8 n -> print_string "byte "; print_int n
  | Cint16 n -> print_string "half "; print_int n
  | Cint n -> print_string "int "; print_string(Nativeint.to_string n)
  | Cfloat f -> print_string "float "; print_string f
  | Csymbol_address s ->
      print_string "addr \""; print_string s; print_string "\""
  | Clabel_address l -> print_string "addr L"; print_int l
  | Cstring s -> print_string "string \""; print_string s; print_string "\""
  | Cskip n -> print_string "skip "; print_int n
  | Calign n -> print_string "align "; print_int n
@

<<function [[Printcmm.data]]>>=
let data dl =
  open_hvbox 1;
  print_string "(data";
  List.iter (fun d -> print_space(); data_item d) dl;
  print_string ")"; close_box()
@

<<function [[Printcmm.phrase]]>>=
let phrase = function
    Cfunction f -> fundecl f
  | Cdata dl -> data dl
@


%-------------------------------------------------------------

<<asmcomp/printcmm.ml>>=
<<copyright header>>

(* Pretty-printing of C-- code *)

open Format
open Cmm

<<function [[Printcmm.machtype_component]]>>

<<function [[Printcmm.machtype]]>>

<<function [[Printcmm.comparison]]>>

<<function [[Printcmm.chunk]]>>

<<function [[Printcmm.operation]]>>

let rec expression = function
    Cconst_int n -> print_int n
  | Cconst_natint n -> print_string(Nativeint.to_string n)
  | Cconst_float s -> print_string s
  | Cconst_symbol s -> print_string "\""; print_string s; print_string "\""
  | Cconst_pointer n -> print_int n; print_string "a"
  | Cvar id -> Ident.print id
  | Clet(id, def, (Clet(_, _, _) as body)) ->
      open_box 2;
      print_string "(let"; print_space();
      open_box 1;
      print_string "(";
      open_box 2;
      Ident.print id; print_space(); expression def;
      close_box();
      let rec letdef = function
        Clet(id, def, body) ->
          print_space();
          open_box 2;
          Ident.print id; print_space(); expression def;
          close_box();
          letdef body
      | exp ->
          print_string ")"; close_box();
          print_space(); sequence exp
      in letdef body;
      print_string ")"; close_box()
  | Clet(id, def, body) ->
      open_box 2;
      print_string "(let"; print_space();
      open_box 2;
      Ident.print id; print_space(); expression def;
      close_box(); print_space();
      sequence body;
      print_string ")"; close_box()
  | Cassign(id, exp) ->
      open_box 2;
      print_string "(assign ";
      open_box 2;
      Ident.print id; print_space(); expression exp;
      close_box();
      print_string ")"; close_box()
  | Ctuple el ->
      open_box 1;
      print_string "[";
      let first = ref true in
      List.iter
        (fun e ->
          if !first then first := false else print_space();
          expression e)
        el;
      print_string "]";
      close_box()
  | Cop(op, el) ->
      open_box 2;
      print_string "("; operation op;
      List.iter (fun e -> print_space(); expression e) el;
      begin match op with
        Capply mty -> print_space(); machtype mty
      | Cextcall(_, mty, _) -> print_space(); machtype mty
      | Cload mty -> print_space(); machtype mty
      | _ -> ()
      end;
      print_string ")";
      close_box()
  | Csequence(e1, e2) ->
      open_box 2;
      print_string "(seq "; print_space();
      sequence e1; print_space();
      sequence e2; print_string ")"; close_box()
  | Cifthenelse(e1, e2, e3) ->
      open_box 2;
      print_string "(if";
      print_space(); expression e1;
      print_space(); expression e2;
      print_space(); expression e3;
      print_string ")"; close_box()
  | Cswitch(e1, index, cases) ->
      open_vbox 0;
      open_box 2;
      print_string "(switch"; print_space(); expression e1; print_space();
      close_box();
      for i = 0 to Array.length cases - 1 do
        print_space();
        open_box 2;
        for j = 0 to Array.length index - 1 do
          if index.(j) = i then begin
            print_string "case "; print_int j; print_string ":"; print_space()
          end
        done;
        sequence cases.(i);
        close_box()
      done;
      close_box()
  | Cloop e ->
      open_box 2;
      print_string "(loop";
      print_space(); sequence e;
      print_string ")"; close_box()
  | Ccatch(e1, e2) ->
      open_box 2;
      print_string "(catch";
      print_space(); sequence e1;
      print_break 1 (-2); print_string "with";
      print_space(); sequence e2;
      print_string ")"; close_box()
  | Cexit ->
      print_string "exit"
  | Ctrywith(e1, id, e2) ->
      open_box 2;
      print_string "(try";
      print_space(); sequence e1;
      print_break 1 (-2); print_string "with "; Ident.print id;
      print_space(); sequence e2;
      print_string ")"; close_box()

and sequence = function
    Csequence(e1, e2) ->
      sequence e1; print_space(); sequence e2
  | e ->
      expression e

<<function [[Printcmm.fundecl]]>>

<<function [[Printcmm.data_item]]>>

<<function [[Printcmm.data]]>>

<<function [[Printcmm.phrase]]>>
@


\subsection*{[[asmcomp/compilenv.mli]]}

<<type [[Compilenv.unit_infos]]>>=
type unit_infos =
  { mutable ui_name: string;                    (* Name of unit implemented *)
    mutable ui_imports_cmi: (string * Digest.t) list; (* Interfaces imported *)
    mutable ui_imports_cmx: (string * Digest.t) list; (* Infos imported *)
    mutable ui_approx: value_approximation;     (* Approx of the structure *)
    mutable ui_curry_fun: int list;             (* Currying functions needed *)
    mutable ui_apply_fun: int list;             (* Apply functions needed *)
    mutable ui_force_link: bool }               (* Always linked *)
@

<<signature [[Compilenv.reset]]>>=
val reset: string -> unit
        (* Reset the environment and record the name of the unit being
           compiled (arg). *)
@

<<signature [[Compilenv.current_unit_name]]>>=
val current_unit_name: unit -> string
        (* Return the name of the unit being compiled *)
@

<<signature [[Compilenv.global_approx]]>>=
val global_approx: Ident.t -> Clambda.value_approximation
        (* Return the approximation for the given global identifier *)
@

<<signature [[Compilenv.set_global_approx]]>>=
val set_global_approx: Clambda.value_approximation -> unit
        (* Record the approximation of the unit being compiled *)
@

<<signature [[Compilenv.need_curry_fun]]>>=
val need_curry_fun: int -> unit
@

<<signature [[Compilenv.need_apply_fun]]>>=
val need_apply_fun: int -> unit
        (* Record the need of a currying (resp. application) function
           with the given arity *)
@

<<signature [[Compilenv.read_unit_info]]>>=
val read_unit_info: string -> unit_infos * Digest.t
        (* Read infos and CRC from a [.cmx] file. *)
@

<<signature [[Compilenv.save_unit_info]]>>=
val save_unit_info: string -> unit
        (* Save the infos for the current unit in the given file *)
@

<<signature [[Compilenv.cmx_not_found_crc]]>>=
val cmx_not_found_crc: Digest.t
        (* Special digest used in the [ui_imports_cmx] list to signal
           that no [.cmx] file was found and used for the imported unit *)
@

<<type [[Compilenv.error]]>>=
type error =
    Not_a_unit_info of string
  | Corrupted_unit_info of string
  | Illegal_renaming of string * string
@

<<exception [[Compilenv.Error]]>>=
exception Error of error
@

<<signature [[Compilenv.report_error]]>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/compilenv.mli>>=
<<copyright header>>

(* Compilation environments for compilation units *)

open Clambda

<<type [[Compilenv.unit_infos]]>>

<<signature [[Compilenv.reset]]>>

<<signature [[Compilenv.current_unit_name]]>>

<<signature [[Compilenv.global_approx]]>>
<<signature [[Compilenv.set_global_approx]]>>

<<signature [[Compilenv.need_curry_fun]]>>
<<signature [[Compilenv.need_apply_fun]]>>

<<signature [[Compilenv.read_unit_info]]>>
<<signature [[Compilenv.save_unit_info]]>>

<<signature [[Compilenv.cmx_not_found_crc]]>>

<<type [[Compilenv.error]]>>

<<exception [[Compilenv.Error]]>>

<<signature [[Compilenv.report_error]]>>
@


\subsection*{[[asmcomp/compilenv.ml]]}

<<type [[Compilenv.error]]([[(asmcomp/compilenv.ml)]])>>=
type error =
    Not_a_unit_info of string
  | Corrupted_unit_info of string
  | Illegal_renaming of string * string
@

<<exception [[Compilenv.Error]]([[(asmcomp/compilenv.ml)]])>>=
exception Error of error
@

<<type [[Compilenv.unit_infos]]([[(asmcomp/compilenv.ml)]])>>=
(* Each .o file has a matching .cmx file that provides the following infos
   on the compilation unit:
     - list of other units imported, with CRCs of their .cmx files
     - approximation of the structure implemented
       (includes descriptions of known functions: arity and direct entry
        points)
     - list of currying functions and application functions needed
   The .cmx file contains these infos (as an externed record) plus a CRC
   of these infos *)

type unit_infos =
  { mutable ui_name: string;                    (* Name of unit implemented *)
    mutable ui_imports_cmi: (string * Digest.t) list; (* Interfaces imported *)
    mutable ui_imports_cmx: (string * Digest.t) list; (* Infos imported *)
    mutable ui_approx: value_approximation;     (* Approx of the structure *)
    mutable ui_curry_fun: int list;             (* Currying functions needed *)
    mutable ui_apply_fun: int list;             (* Apply functions needed *)
    mutable ui_force_link: bool }               (* Always linked *)
@

<<constant [[Compilenv.global_approx_table]]>>=
let global_approx_table =
@

<<constant [[Compilenv.current_unit]]>>=
let current_unit =
  { ui_name = "";
    ui_imports_cmi = [];
    ui_imports_cmx = [];
    ui_approx = Value_unknown;
    ui_curry_fun = [];
    ui_apply_fun = [];
    ui_force_link = false }
@

<<function [[Compilenv.reset]]>>=
let reset name =
  Hashtbl.clear global_approx_table;
  current_unit.ui_name <- name;
  current_unit.ui_imports_cmi <- [];
  current_unit.ui_imports_cmx <- [];
  current_unit.ui_curry_fun <- [];
  current_unit.ui_apply_fun <- [];
  current_unit.ui_force_link <- false
@

<<function [[Compilenv.current_unit_name]]>>=
let current_unit_name () =
  current_unit.ui_name
@

<<function [[Compilenv.read_unit_info]]>>=
let read_unit_info filename =
  let ic = open_in_bin filename in
  try
    let buffer = String.create (String.length cmx_magic_number) in
    really_input ic buffer 0 (String.length cmx_magic_number);
    if buffer <> cmx_magic_number then begin
      close_in ic;
      raise(Error(Not_a_unit_info filename))
    end;
    let ui = (input_value ic : unit_infos) in
    let crc = Digest.input ic in
    close_in ic;
    (ui, crc)
  with End_of_file | Failure _ ->
    close_in ic;
    raise(Error(Corrupted_unit_info(filename)))
@

<<constant [[Compilenv.cmx_not_found_crc]]>>=
(* Return the approximation of a global identifier *)

let cmx_not_found_crc =
  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
@

<<function [[Compilenv.global_approx]]>>=
let global_approx global_ident =
  let modname = Ident.name global_ident in
  try
    Hashtbl.find global_approx_table modname
  with Not_found ->
    let (approx, crc) =
      try
        let filename =
          find_in_path_uncap !load_path (modname ^ ".cmx") in
        let (ui, crc) = read_unit_info filename in
        if ui.ui_name <> modname then
          raise(Error(Illegal_renaming(modname, filename)));
        (ui.ui_approx, crc)
      with Not_found ->
        (Value_unknown, cmx_not_found_crc) in
    current_unit.ui_imports_cmx <-
      (modname, crc) :: current_unit.ui_imports_cmx;
    Hashtbl.add global_approx_table modname approx;
    approx
@

<<function [[Compilenv.set_global_approx]]>>=
(* Register the approximation of the module being compiled *)

let set_global_approx approx =
  current_unit.ui_approx <- approx
@

<<function [[Compilenv.need_curry_fun]]>>=
(* Record that a currying function or application function is needed *)

let need_curry_fun n =
  if not (List.mem n current_unit.ui_curry_fun) then
    current_unit.ui_curry_fun <- n :: current_unit.ui_curry_fun
@

<<function [[Compilenv.need_apply_fun]]>>=
let need_apply_fun n =
  if not (List.mem n current_unit.ui_apply_fun) then
    current_unit.ui_apply_fun <- n :: current_unit.ui_apply_fun
@

<<function [[Compilenv.save_unit_info]]>>=
(* Write the description of the current unit *)

let save_unit_info filename =
  current_unit.ui_imports_cmi <- Env.imported_units();
  let oc = open_out_bin filename in
  output_string oc cmx_magic_number;
  output_value oc current_unit;
  flush oc;
  let crc = Digest.file filename in
  Digest.output oc crc;
  close_out oc
@

<<function [[Compilenv.report_error]]>>=
let report_error = function
    Not_a_unit_info filename ->
      print_string filename; print_space();
      print_string "is not a compilation unit description."
  | Corrupted_unit_info filename ->
      print_string "Corrupted compilation unit description"; print_space();
      print_string filename
  | Illegal_renaming(modname, filename) ->
      print_string filename; print_space();
      print_string "contains the description for unit"; print_space();
      print_string modname
@


%-------------------------------------------------------------

<<asmcomp/compilenv.ml>>=
<<copyright header>>

(* Compilation environments for compilation units *)

open Config
open Misc
open Clambda

<<type [[Compilenv.error]]([[(asmcomp/compilenv.ml)]])>>

<<exception [[Compilenv.Error]]([[(asmcomp/compilenv.ml)]])>>

<<type [[Compilenv.unit_infos]]([[(asmcomp/compilenv.ml)]])>>

<<constant [[Compilenv.global_approx_table]]>>
  (Hashtbl.create 17 : (string, value_approximation) Hashtbl.t)

<<constant [[Compilenv.current_unit]]>>

<<function [[Compilenv.reset]]>>

<<function [[Compilenv.current_unit_name]]>>

<<function [[Compilenv.read_unit_info]]>>

<<constant [[Compilenv.cmx_not_found_crc]]>>

<<function [[Compilenv.global_approx]]>>

<<function [[Compilenv.set_global_approx]]>>

<<function [[Compilenv.need_curry_fun]]>>

<<function [[Compilenv.need_apply_fun]]>>

<<function [[Compilenv.save_unit_info]]>>

(* Error report *)

open Format

<<function [[Compilenv.report_error]]>>

@


\subsection*{[[asmcomp/reg.mli]]}

<<type [[Reg.t]]>>=
type t =
  { mutable name: string;               (* Name (for printing) *)
    stamp: int;                         (* Unique stamp *)
    typ: Cmm.machtype_component;        (* Type of contents *)
    mutable loc: location;              (* Actual location *)
    mutable spill: bool;                (* "true" to force stack allocation  *)
    mutable interf: t list;             (* Other regs live simultaneously *)
    mutable prefer: (t * int) list;     (* Preferences for other regs *)
    mutable degree: int;                (* Number of other regs live sim. *)
    mutable spill_cost: int;            (* Estimate of spilling cost *)
    mutable visited: bool }             (* For graph walks *)
@

<<type [[Reg.location]]>>=
and location =
    Unknown
  | Reg of int
  | Stack of stack_location
@

<<type [[Reg.stack_location]]>>=
and stack_location =
    Local of int
  | Incoming of int
  | Outgoing of int
@

<<signature [[Reg.dummy]]>>=
val dummy: t
@

<<signature [[Reg.create]]>>=
val create: Cmm.machtype_component -> t
@

<<signature [[Reg.createv]]>>=
val createv: Cmm.machtype -> t array
@

<<signature [[Reg.clone]]>>=
val clone: t -> t
@

<<signature [[Reg.at_location]]>>=
val at_location: Cmm.machtype_component -> location -> t
@

<<signature [[Reg.add_set_array]]>>=
val add_set_array: t Set.t -> t array -> t Set.t
@

<<signature [[Reg.diff_set_array]]>>=
val diff_set_array: t Set.t -> t array -> t Set.t
@

<<signature [[Reg.inter_set_array]]>>=
val inter_set_array: t Set.t -> t array -> t Set.t
@

<<signature [[Reg.set_of_array]]>>=
val set_of_array: t array -> t Set.t
@

<<signature [[Reg.reset]]>>=
val reset: unit -> unit
@

<<signature [[Reg.all_registers]]>>=
val all_registers: unit -> t list
@

<<signature [[Reg.num_registers]]>>=
val num_registers: unit -> int
@

<<signature [[Reg.reinit]]>>=
val reinit: unit -> unit
@


%-------------------------------------------------------------

<<asmcomp/reg.mli>>=
<<copyright header>>

(* Pseudo-registers *)

<<type [[Reg.t]]>>

<<type [[Reg.location]]>>

<<type [[Reg.stack_location]]>>

<<signature [[Reg.dummy]]>>
<<signature [[Reg.create]]>>
<<signature [[Reg.createv]]>>
<<signature [[Reg.clone]]>>
<<signature [[Reg.at_location]]>>

<<signature [[Reg.add_set_array]]>>
<<signature [[Reg.diff_set_array]]>>
<<signature [[Reg.inter_set_array]]>>
<<signature [[Reg.set_of_array]]>>

<<signature [[Reg.reset]]>>
<<signature [[Reg.all_registers]]>>
<<signature [[Reg.num_registers]]>>
<<signature [[Reg.reinit]]>>
@


\subsection*{[[asmcomp/reg.ml]]}

<<type [[Reg.t]]([[(asmcomp/reg.ml)]])>>=
type t =
  { mutable name: string;
    stamp: int;
    typ: Cmm.machtype_component;
    mutable loc: location;
    mutable spill: bool;
    mutable interf: t list;
    mutable prefer: (t * int) list;
    mutable degree: int;
    mutable spill_cost: int;
    mutable visited: bool }
@

<<type [[Reg.location]]([[(asmcomp/reg.ml)]])>>=
and location =
    Unknown
  | Reg of int
  | Stack of stack_location
@

<<type [[Reg.stack_location]]([[(asmcomp/reg.ml)]])>>=
and stack_location =
    Local of int
  | Incoming of int
  | Outgoing of int
@

<<type [[Reg.reg]]>>=
type reg = t
@

<<constant [[Reg.dummy]]>>=
let dummy =
  { name = ""; stamp = 0; typ = Int; loc = Unknown; spill = false;
    interf = []; prefer = []; degree = 0; spill_cost = 0; visited = false }
@

<<constant [[Reg.currstamp]]>>=
let currstamp = ref 0
@

<<constant [[Reg.reg_list]]>>=
let reg_list = ref([] : t list)
@

<<function [[Reg.create]]>>=
let create ty =
  let r = { name = ""; stamp = !currstamp; typ = ty; loc = Unknown;
            spill = false; interf = []; prefer = []; degree = 0;
            spill_cost = 0; visited = false } in
  reg_list := r :: !reg_list;
  incr currstamp;
  r
@

<<function [[Reg.createv]]>>=
let createv tyv =
  let n = Array.length tyv in
  let rv = Array.create n dummy in
  for i = 0 to n-1 do rv.(i) <- create tyv.(i) done;
  rv
@

<<function [[Reg.clone]]>>=
let clone r =
  let nr = create r.typ in
  nr.name <- r.name;
  nr
@

<<function [[Reg.at_location]]>>=
let at_location ty loc =
  let r = { name = "R"; stamp = !currstamp; typ = ty; loc = loc; spill = false;
            interf = []; prefer = []; degree = 0; spill_cost = 0;
            visited = false } in
  incr currstamp;
  r
@

<<function [[Reg.reset]]>>=
let reset() = currstamp := 100; reg_list := []
@

<<function [[Reg.all_registers]]>>=
let all_registers() = !reg_list
@

<<function [[Reg.num_registers]]>>=
let num_registers() = !currstamp
@

<<function [[Reg.reinit_reg]]>>=
let reinit_reg r =
  r.loc <- Unknown;
  r.interf <- [];
  r.prefer <- [];
  r.degree <- 0;
  (* Preserve the very high spill costs introduced by the reloading pass *)
  if r.spill_cost >= 100000
  then r.spill_cost <- 100000
  else r.spill_cost <- 0
@

<<function [[Reg.reinit]]>>=
let reinit() =
  List.iter reinit_reg !reg_list
@

<<function [[Reg.add_set_array]]>>=
(*
TODO good enough?
module RegOrder =
  struct
    type t = reg
    let compare r1 r2 = r1.stamp - r2.stamp
  end
module Set = Set.Make(RegOrder)
module Map = Map.Make(RegOrder)
*)


let add_set_array s v =
  match Array.length v with
    0 -> s
  | 1 -> Set.add v.(0) s
  | n -> let rec add_all i =
           if i >= n then s else Set.add v.(i) (add_all(i+1))
         in add_all 0
@

<<function [[Reg.diff_set_array]]>>=
let diff_set_array s v =
  match Array.length v with
    0 -> s
  | 1 -> Set.remove v.(0) s
  | n -> let rec remove_all i =
           if i >= n then s else Set.remove v.(i) (remove_all(i+1))
         in remove_all 0
@

<<function [[Reg.inter_set_array]]>>=
let inter_set_array s v =
  match Array.length v with
    0 -> Set.empty
  | 1 -> if Set.mem v.(0) s
         then Set.add v.(0) Set.empty
         else Set.empty
  | n -> let rec inter_all i =
           if i >= n then Set.empty
           else if Set.mem v.(i) s then Set.add v.(i) (inter_all(i+1))
           else inter_all(i+1)
         in inter_all 0
@

<<function [[Reg.set_of_array]]>>=
let set_of_array v =
  match Array.length v with
    0 -> Set.empty
  | 1 -> Set.add v.(0) Set.empty
  | n -> let rec add_all i =
           if i >= n then Set.empty else Set.add v.(i) (add_all(i+1))
         in add_all 0
@


%-------------------------------------------------------------

<<asmcomp/reg.ml>>=
<<copyright header>>

open Cmm

<<type [[Reg.t]]([[(asmcomp/reg.ml)]])>>

<<type [[Reg.location]]([[(asmcomp/reg.ml)]])>>

<<type [[Reg.stack_location]]([[(asmcomp/reg.ml)]])>>

<<type [[Reg.reg]]>>

<<constant [[Reg.dummy]]>>

<<constant [[Reg.currstamp]]>>
<<constant [[Reg.reg_list]]>>

<<function [[Reg.create]]>>

<<function [[Reg.createv]]>>

<<function [[Reg.clone]]>>

<<function [[Reg.at_location]]>>

<<function [[Reg.reset]]>>
<<function [[Reg.all_registers]]>>
<<function [[Reg.num_registers]]>>

<<function [[Reg.reinit_reg]]>>

<<function [[Reg.reinit]]>>

<<function [[Reg.add_set_array]]>>

<<function [[Reg.diff_set_array]]>>

<<function [[Reg.inter_set_array]]>>

<<function [[Reg.set_of_array]]>>
@


\subsection*{[[asmcomp/asmlibrarian.mli]]}

<<signature [[Asmlibrarian.create_archive]]>>=
(* Build libraries of .cmx files *)

val create_archive: string list -> string -> unit
@

<<type [[Asmlibrarian.error]]>>=
type error =
    File_not_found of string
  | Archiver_error of string
@

<<exception [[Asmlibrarian.Error]]>>=
exception Error of error
@

<<signature [[Asmlibrarian.report_error]]>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/asmlibrarian.mli>>=
<<copyright header>>

<<signature [[Asmlibrarian.create_archive]]>>

<<type [[Asmlibrarian.error]]>>

<<exception [[Asmlibrarian.Error]]>>

<<signature [[Asmlibrarian.report_error]]>>
@


\subsection*{[[asmcomp/asmlibrarian.ml]]}

<<type [[Asmlibrarian.error]]([[(asmcomp/asmlibrarian.ml)]])>>=
type error =
    File_not_found of string
  | Archiver_error of string
@

<<exception [[Asmlibrarian.Error]]([[(asmcomp/asmlibrarian.ml)]])>>=
exception Error of error
@

<<function [[Asmlibrarian.read_info]]>>=
let read_info name =
  let filename =
    try
      find_in_path !load_path name
    with Not_found ->
      raise(Error(File_not_found name)) in
  let (info, crc) = Compilenv.read_unit_info filename in
  info.ui_force_link <- !Clflags.link_everything;
  (* There is no need to keep the approximation in the .cmxa file,
     since the compiler will go looking directly for .cmx files.
     The linker, which is the only one that reads .cmxa files, does not
     need the approximation. *)
  info.ui_approx <- Clambda.Value_unknown;
  (Filename.chop_suffix filename ".cmx" ^ ext_obj, (info, crc))
@

<<function [[Asmlibrarian.create_archive]]>>=
let create_archive file_list lib_name =
  let archive_name = Filename.chop_suffix lib_name ".cmxa" ^ ext_lib in
  let outchan = open_out_bin lib_name in
  try
    output_string outchan cmxa_magic_number;
    let (objfile_list, descr_list) =
      List.split (List.map read_info file_list) in
    output_value outchan descr_list;
    if Ccomp.create_archive archive_name objfile_list <> 0
    then raise(Error(Archiver_error archive_name));
    close_out outchan
  with x ->
    close_out outchan;
    remove_file lib_name;
    remove_file archive_name;
    raise x
@

<<function [[Asmlibrarian.report_error]]>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Archiver_error name ->
      print_string "Error while creating the library ";
      print_string name
@


%-------------------------------------------------------------

<<asmcomp/asmlibrarian.ml>>=
<<copyright header>>

(* Build libraries of .cmx files *)

open Misc
open Config
open Compilenv

<<type [[Asmlibrarian.error]]([[(asmcomp/asmlibrarian.ml)]])>>

<<exception [[Asmlibrarian.Error]]([[(asmcomp/asmlibrarian.ml)]])>>

<<function [[Asmlibrarian.read_info]]>>

<<function [[Asmlibrarian.create_archive]]>>

open Format

<<function [[Asmlibrarian.report_error]]>>

@


\subsection*{[[asmcomp/closure.mli]]}

<<signature [[Closure.intro]]>>=
(* Introduction of closures, uncurrying, recognition of direct calls *)

val intro: int -> Lambda.lambda -> Clambda.ulambda
@


%-------------------------------------------------------------

<<asmcomp/closure.mli>>=
<<copyright header>>

<<signature [[Closure.intro]]>>

@


\subsection*{[[asmcomp/closure.ml]]}

<<function [[Closure.split_list]]>>=
(* Auxiliaries for compiling functions *)

let rec split_list n l =
  if n <= 0 then ([], l) else begin
    match l with
      [] -> fatal_error "Closure.split_list"
    | a::l -> let (l1, l2) = split_list (n-1) l in (a::l1, l2)
  end
@

<<function [[Closure.build_closure_env]]>>=
let rec build_closure_env env_param pos = function
    [] -> Tbl.empty
  | id :: rem ->
      Tbl.add id (Uprim(Pfield pos, [Uvar env_param])) 
              (build_closure_env env_param (pos+1) rem)
@

<<function [[Closure.occurs_var]]>>=
(* Check if a variable occurs in a [clambda] term. *)

let occurs_var var u =
  let rec occurs = function
      Uvar v -> v = var
    | Uconst cst -> false
    | Udirect_apply(lbl, args) -> List.exists occurs args
    | Ugeneric_apply(funct, args) -> occurs funct or List.exists occurs args
    | Uclosure(fundecls, clos) -> List.exists occurs clos
    | Uoffset(u, ofs) -> occurs u
    | Ulet(id, def, body) -> occurs def or occurs body
    | Uletrec(decls, body) ->
        List.exists (fun (id, u) -> occurs u) decls or occurs body
    | Uprim(p, args) -> List.exists occurs args
    | Uswitch(arg, s) ->
        occurs arg or occurs_array s.us_cases_consts
                   or occurs_array s.us_cases_blocks
    | Ustaticfail -> false
    | Ucatch(body, hdlr) -> occurs body or occurs hdlr
    | Utrywith(body, exn, hdlr) -> occurs body or occurs hdlr
    | Uifthenelse(cond, ifso, ifnot) ->
        occurs cond or occurs ifso or occurs ifnot
    | Usequence(u1, u2) -> occurs u1 or occurs u2
    | Uwhile(cond, body) -> occurs cond or occurs body
    | Ufor(id, lo, hi, dir, body) -> occurs lo or occurs hi or occurs body
    | Uassign(id, u) -> id = var or occurs u
  and occurs_array a =
    try
      for i = 0 to Array.length a - 1 do
        if occurs a.(i) then raise Exit
      done;
      false
    with Exit ->
      true
  in occurs u
@

<<function [[Closure.prim_size]]>>=
(* Determine whether the estimated size of a clambda term is below
   some threshold *)

let prim_size prim args =
  match prim with
    Pidentity -> 0
  | Pgetglobal id -> 1
  | Psetglobal id -> 1
  | Pmakeblock(tag, mut) -> 5 + List.length args
  | Pfield f -> 1
  | Psetfield(f, isptr) -> if isptr then 4 else 1
  | Pfloatfield f -> 1
  | Psetfloatfield f -> 1
  | Pccall p -> (if p.prim_alloc then 10 else 4) + List.length args
  | Praise -> 4
  | Pstringlength -> 5
  | Pstringrefs | Pstringsets -> 6
  | Pmakearray kind -> 5 + List.length args
  | Parraylength kind -> if kind = Pgenarray then 6 else 2
  | Parrayrefu kind -> if kind = Pgenarray then 12 else 2
  | Parraysetu kind -> if kind = Pgenarray then 16 else 4
  | Parrayrefs kind -> if kind = Pgenarray then 18 else 8
  | Parraysets kind -> if kind = Pgenarray then 22 else 10
  | Pbittest -> 3
  | _ -> 2 (* arithmetic and comparisons *)
@

<<function [[Closure.lambda_smaller]]>>=
let lambda_smaller lam threshold =
  let size = ref 0 in
  let rec lambda_size lam =
    if !size > threshold then raise Exit;
    match lam with
      Uvar v -> ()
    | Uconst(Const_base(Const_int _ | Const_char _ | Const_float _) |
             Const_pointer _) -> incr size
    | Uconst _ ->
        raise Exit (* avoid duplication of structured constants *)
    | Udirect_apply(fn, args) ->
        size := !size + 4; lambda_list_size args
    | Ugeneric_apply(fn, args) ->
        size := !size + 6; lambda_size fn; lambda_list_size args
    | Uclosure(defs, vars) ->
        raise Exit (* inlining would duplicate function definitions *)
    | Uoffset(lam, ofs) ->
        incr size; lambda_size lam
    | Ulet(id, lam, body) ->
        lambda_size lam; lambda_size body
    | Uletrec(bindings, body) ->
        raise Exit (* usually too large *)
    | Uprim(prim, args) ->
        size := !size + prim_size prim args;
        lambda_list_size args
    | Uswitch(lam, cases) ->
        if Array.length cases.us_cases_consts > 0 then size := !size + 5;
        if Array.length cases.us_cases_blocks > 0 then size := !size + 5;
        if cases.us_checked then size := !size + 2;
        lambda_size lam;
        lambda_array_size cases.us_cases_consts;
        lambda_array_size cases.us_cases_blocks
    | Ustaticfail -> ()
    | Ucatch(body, handler) ->
        incr size; lambda_size body; lambda_size handler
    | Utrywith(body, id, handler) ->
        size := !size + 8; lambda_size body; lambda_size handler
    | Uifthenelse(cond, ifso, ifnot) ->
        size := !size + 2;
        lambda_size cond; lambda_size ifso; lambda_size ifnot
    | Usequence(lam1, lam2) ->
        lambda_size lam1; lambda_size lam2
    | Uwhile(cond, body) ->
        size := !size + 2; lambda_size cond; lambda_size body
    | Ufor(id, low, high, dir, body) ->
        size := !size + 4; lambda_size low; lambda_size high; lambda_size body
    | Uassign(id, lam) ->
        incr size;  lambda_size lam
  and lambda_list_size l = List.iter lambda_size l
  and lambda_array_size a = Array.iter lambda_size a in
  try
    lambda_size lam; !size <= threshold
  with Exit ->
    false
@

<<function [[Closure.is_pure]]>>=
(* Check if a lambda term denoting a function is ``pure'',
   that is without side-effects *and* not containing function definitions *)

let rec is_pure = function
    Lvar v -> true
  | Lprim(Pgetglobal id, _) -> true
  | Lprim(Pfield n, [arg]) -> is_pure arg
  | _ -> false
@

<<function [[Closure.direct_apply]]>>=
(* Generate a direct application *)

let direct_apply fundesc funct ufunct uargs =
  let app_args =
    if fundesc.fun_closed then uargs else uargs @ [ufunct] in
  let app =
    match fundesc.fun_inline with
      None -> Udirect_apply(fundesc.fun_label, app_args)
    | Some(params, body) ->
        List.fold_right2
          (fun param arg body -> Ulet(param, arg, body))
          params app_args body in
  (if is_pure funct then app else Usequence(ufunct, app))
@

<<constant [[Closure.global_approx]]>>=
(* Maintain the approximation of the global structure being defined *)

let global_approx = ref([||] : value_approximation array)
@

<<function [[Closure.close_var]]>>=
(* Uncurry an expression and explicitate closures.
   Also return the approximation of the expression.
   The approximation environment [fenv] maps idents to approximations.
   Idents not bound in [fenv] approximate to [Value_unknown].
   The closure environment [cenv] maps idents to [ulambda] terms.
   It is used to substitute environment accesses for free identifiers. *)

let close_var cenv id =
  try Tbl.find id cenv with Not_found -> Uvar id
@

<<function [[Closure.approx_var]]>>=
let approx_var fenv id =
  try Tbl.find id fenv with Not_found -> Value_unknown 
@

<<function [[Closure.intro]]>>=
(* The entry point *)

let intro size lam =
  global_approx := Array.create size Value_unknown;
  let (ulam, approx) = close Tbl.empty Tbl.empty lam in
  Compilenv.set_global_approx(Value_tuple !global_approx);
  global_approx := [||];
  ulam
@


%-------------------------------------------------------------

<<asmcomp/closure.ml>>=
<<copyright header>>

(* Introduction of closures, uncurrying, recognition of direct calls *)

open Misc
open Asttypes
open Primitive
open Lambda
open Clambda

module IdentSet = Set

<<function [[Closure.split_list]]>>

<<function [[Closure.build_closure_env]]>>

<<function [[Closure.occurs_var]]>>

<<function [[Closure.prim_size]]>>

<<function [[Closure.lambda_smaller]]>>

<<function [[Closure.is_pure]]>>

<<function [[Closure.direct_apply]]>>

<<constant [[Closure.global_approx]]>>

<<function [[Closure.close_var]]>>

<<function [[Closure.approx_var]]>>

<<function [[Closure.close]]>>

<<function [[Closure.intro]]>>
@




\subsection*{[[asmcomp/mach.mli]]}

<<type [[Mach.integer_comparison]]>>=
(* Representation of machine code by sequences of pseudoinstructions *)

type integer_comparison =
    Isigned of Cmm.comparison
  | Iunsigned of Cmm.comparison
@

<<type [[Mach.integer_operation]]>>=
type integer_operation =
    Iadd | Isub | Imul | Idiv | Imod
  | Iand | Ior | Ixor | Ilsl | Ilsr | Iasr
  | Icomp of integer_comparison
  | Icheckbound
@

<<type [[Mach.test]]>>=
type test =
    Itruetest
  | Ifalsetest
  | Iinttest of integer_comparison
  | Iinttest_imm of integer_comparison * int
  | Ifloattest of Cmm.comparison * bool
  | Ioddtest
  | Ieventest
@

<<type [[Mach.operation]]>>=
type operation =
    Imove
  | Ispill
  | Ireload
  | Iconst_int of Nativeint.t
  | Iconst_float of string
  | Iconst_symbol of string
  | Icall_ind
  | Icall_imm of string
  | Itailcall_ind
  | Itailcall_imm of string
  | Iextcall of string * bool
  | Istackoffset of int
  | Iload of Cmm.memory_chunk * Arch.addressing_mode
  | Istore of Cmm.memory_chunk * Arch.addressing_mode
  | Ialloc of int
  | Iintop of integer_operation
  | Iintop_imm of integer_operation * int
  | Inegf | Iabsf | Iaddf | Isubf | Imulf | Idivf
  | Ifloatofint | Iintoffloat
  | Ispecific of Arch.specific_operation
@

<<type [[Mach.instruction]]>>=
type instruction =
  { desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    mutable live: Reg.t Set.t }
@

<<type [[Mach.instruction_desc]]>>=
and instruction_desc =
    Iend
  | Iop of operation
  | Ireturn
  | Iifthenelse of test * instruction * instruction
  | Iswitch of int array * instruction array
  | Iloop of instruction
  | Icatch of instruction * instruction
  | Iexit
  | Itrywith of instruction * instruction
  | Iraise
@

<<type [[Mach.fundecl]]>>=
type fundecl =
  { fun_name: string;
    fun_args: Reg.t array;
    fun_body: instruction;
    fun_fast: bool }
@

<<signature [[Mach.dummy_instr]]>>=
val dummy_instr: instruction
@

<<signature [[Mach.end_instr]]>>=
val end_instr: unit -> instruction
@

<<signature [[Mach.instr_cons]]>>=
val instr_cons: 
      instruction_desc -> Reg.t array -> Reg.t array -> instruction ->
        instruction
@

<<signature [[Mach.instr_cons_live]]>>=
val instr_cons_live: 
      instruction_desc -> Reg.t array -> Reg.t array -> Reg.t Set.t ->
        instruction -> instruction
@

<<signature [[Mach.instr_iter]]>>=
val instr_iter: (instruction -> unit) -> instruction -> unit
@


%-------------------------------------------------------------

<<asmcomp/mach.mli>>=
<<copyright header>>

<<type [[Mach.integer_comparison]]>>

<<type [[Mach.integer_operation]]>>

<<type [[Mach.test]]>>

<<type [[Mach.operation]]>>

<<type [[Mach.instruction]]>>

<<type [[Mach.instruction_desc]]>>

<<type [[Mach.fundecl]]>>

<<signature [[Mach.dummy_instr]]>>
<<signature [[Mach.end_instr]]>>
<<signature [[Mach.instr_cons]]>>
<<signature [[Mach.instr_cons_live]]>>
<<signature [[Mach.instr_iter]]>>

@


\subsection*{[[asmcomp/mach.ml]]}

<<type [[Mach.integer_comparison]]([[(asmcomp/mach.ml)]])>>=
(* Representation of machine code by sequences of pseudoinstructions *)

type integer_comparison =
    Isigned of Cmm.comparison
  | Iunsigned of Cmm.comparison
@

<<type [[Mach.integer_operation]]([[(asmcomp/mach.ml)]])>>=
type integer_operation =
    Iadd | Isub | Imul | Idiv | Imod
  | Iand | Ior | Ixor | Ilsl | Ilsr | Iasr
  | Icomp of integer_comparison
  | Icheckbound
@

<<type [[Mach.test]]([[(asmcomp/mach.ml)]])>>=
type test =
    Itruetest
  | Ifalsetest
  | Iinttest of integer_comparison
  | Iinttest_imm of integer_comparison * int
  | Ifloattest of Cmm.comparison * bool
  | Ioddtest
  | Ieventest
@

<<type [[Mach.operation]]([[(asmcomp/mach.ml)]])>>=
type operation =
    Imove
  | Ispill
  | Ireload
  | Iconst_int of Nativeint.t
  | Iconst_float of string
  | Iconst_symbol of string
  | Icall_ind
  | Icall_imm of string
  | Itailcall_ind
  | Itailcall_imm of string
  | Iextcall of string * bool
  | Istackoffset of int
  | Iload of Cmm.memory_chunk * Arch.addressing_mode
  | Istore of Cmm.memory_chunk * Arch.addressing_mode
  | Ialloc of int
  | Iintop of integer_operation
  | Iintop_imm of integer_operation * int
  | Inegf | Iabsf | Iaddf | Isubf | Imulf | Idivf
  | Ifloatofint | Iintoffloat
  | Ispecific of Arch.specific_operation
@

<<type [[Mach.instruction]]([[(asmcomp/mach.ml)]])>>=
type instruction =
  { desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    mutable live: Reg.t Set.t }
@

<<type [[Mach.instruction_desc]]([[(asmcomp/mach.ml)]])>>=
and instruction_desc =
    Iend
  | Iop of operation
  | Ireturn
  | Iifthenelse of test * instruction * instruction
  | Iswitch of int array * instruction array
  | Iloop of instruction
  | Icatch of instruction * instruction
  | Iexit
  | Itrywith of instruction * instruction
  | Iraise
@

<<type [[Mach.fundecl]]([[(asmcomp/mach.ml)]])>>=
type fundecl =
  { fun_name: string;
    fun_args: Reg.t array;
    fun_body: instruction;
    fun_fast: bool }
@

<<constant [[Mach.dummy_instr]]>>=
let rec dummy_instr =
  { desc = Iend; 
    next = dummy_instr;
    arg = [||]; 
    res = [||];
    live = (*Reg.*)Set.empty }
@

<<function [[Mach.end_instr]]>>=
let end_instr () =
  { desc = Iend; 
    next = dummy_instr;
    arg = [||]; 
    res = [||];
    live = (*Reg.*)Set.empty }
@

<<function [[Mach.instr_cons]]>>=
let instr_cons d a r n =
  { desc = d; next = n; arg = a; res = r; live = (*Reg.*)Set.empty }
@

<<function [[Mach.instr_cons_live]]>>=
let instr_cons_live d a r l n =
  { desc = d; next = n; arg = a; res = r; live = l }
@

<<function [[Mach.instr_iter]]>>=
let rec instr_iter f i =
  match i.desc with
    Iend -> ()
  | _ ->
      f i;
      match i.desc with
        Iend -> ()
      | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) -> ()
      | Iifthenelse(tst, ifso, ifnot) ->
          instr_iter f ifso; instr_iter f ifnot; instr_iter f i.next
      | Iswitch(index, cases) ->
          for i = 0 to Array.length cases - 1 do
            instr_iter f cases.(i)
          done;
          instr_iter f i.next
      | Iloop(body) ->
          instr_iter f body; instr_iter f i.next
      | Icatch(body, handler) ->
          instr_iter f body; instr_iter f handler; instr_iter f i.next
      | Iexit -> ()
      | Itrywith(body, handler) ->
          instr_iter f body; instr_iter f handler; instr_iter f i.next
      | Iraise -> ()
      | _ ->
          instr_iter f i.next      
@


%-------------------------------------------------------------

<<asmcomp/mach.ml>>=
<<copyright header>>

<<type [[Mach.integer_comparison]]([[(asmcomp/mach.ml)]])>>

<<type [[Mach.integer_operation]]([[(asmcomp/mach.ml)]])>>

<<type [[Mach.test]]([[(asmcomp/mach.ml)]])>>

<<type [[Mach.operation]]([[(asmcomp/mach.ml)]])>>

<<type [[Mach.instruction]]([[(asmcomp/mach.ml)]])>>

<<type [[Mach.instruction_desc]]([[(asmcomp/mach.ml)]])>>

<<type [[Mach.fundecl]]([[(asmcomp/mach.ml)]])>>

<<constant [[Mach.dummy_instr]]>>

<<function [[Mach.end_instr]]>>

<<function [[Mach.instr_cons]]>>

<<function [[Mach.instr_cons_live]]>>

<<function [[Mach.instr_iter]]>>

@


\subsection*{[[asmcomp/printmach.mli]]}

<<signature [[Printmach.reg]]>>=
(* Pretty-printing of pseudo machine code *)

val reg: Reg.t -> unit
@

<<signature [[Printmach.regs]]>>=
val regs: Reg.t array -> unit
@

<<signature [[Printmach.regset]]>>=
val regset: Reg.t Set.t -> unit
@

<<signature [[Printmach.regsetaddr]]>>=
val regsetaddr: Reg.t Set.t -> unit
@

<<signature [[Printmach.operation]]>>=
val operation: Mach.operation -> Reg.t array -> Reg.t array -> unit
@

<<signature [[Printmach.test]]>>=
val test: Mach.test -> Reg.t array -> unit
@

<<signature [[Printmach.instr]]>>=
val instr: Mach.instruction -> unit
@

<<signature [[Printmach.fundecl]]>>=
val fundecl: Mach.fundecl -> unit
@

<<signature [[Printmach.phase]]>>=
val phase: string -> Mach.fundecl -> unit
@

<<signature [[Printmach.interferences]]>>=
val interferences: unit -> unit
@

<<signature [[Printmach.preferences]]>>=
val preferences: unit -> unit
@

<<signature [[Printmach.print_live]]>>=
val print_live: bool ref
@


%-------------------------------------------------------------

<<asmcomp/printmach.mli>>=
<<copyright header>>

<<signature [[Printmach.reg]]>>
<<signature [[Printmach.regs]]>>
<<signature [[Printmach.regset]]>>
<<signature [[Printmach.regsetaddr]]>>
<<signature [[Printmach.operation]]>>
<<signature [[Printmach.test]]>>
<<signature [[Printmach.instr]]>>
<<signature [[Printmach.fundecl]]>>
<<signature [[Printmach.phase]]>>
<<signature [[Printmach.interferences]]>>
<<signature [[Printmach.preferences]]>>

<<signature [[Printmach.print_live]]>>
@


\subsection*{[[asmcomp/printmach.ml]]}

<<function [[Printmach.reg]]>>=
let reg r =
  if String.length r.name > 0 then
    print_string r.name
  else
    print_string(match r.typ with Addr -> "A" | Int -> "I" | Float -> "F");
  print_string "/";
  print_int r.stamp;
  begin match r.loc with
    Unknown -> ()
  | Reg r -> 
      print_string "["; print_string(Proc.register_name r); print_string "]"
  | Stack(Local s) ->
      print_string "[s"; print_int s; print_string "]"
  | Stack(Incoming s) ->
      print_string "[si"; print_int s; print_string "]"
  | Stack(Outgoing s) ->
      print_string "[so"; print_int s; print_string "]"
  end
@

<<function [[Printmach.regs]]>>=
let regs v =
  match Array.length v with
    0 -> ()
  | 1 -> reg v.(0)
  | n -> reg v.(0);
         for i = 1 to n-1 do print_string " "; reg v.(i) done
@

<<function [[Printmach.regset]]>>=
let regset s =
  let first = ref true in
  (*Reg.*)Set.iter
    (fun r ->
      if !first then first := false else print_space();
      reg r)
    s
@

<<function [[Printmach.regsetaddr]]>>=
let regsetaddr s =
  let first = ref true in
  (*Reg.*)Set.iter
    (fun r ->
      if !first then first := false else print_space();
      reg r;
      match r.typ with Addr -> print_string "*" | _ -> ())
    s
@

<<function [[Printmach.intcomp]]>>=
let intcomp = function
    Isigned c -> print_string " "; Printcmm.comparison c; print_string "s "
  | Iunsigned c -> print_string " "; Printcmm.comparison c; print_string "u "
@

<<function [[Printmach.floatcomp]]>>=
let floatcomp c =
    print_string " "; Printcmm.comparison c; print_string "f "
@

<<function [[Printmach.intop]]>>=
let intop = function
    Iadd -> print_string " + "
  | Isub -> print_string " - "
  | Imul -> print_string " * "
  | Idiv -> print_string " div "
  | Imod -> print_string " mod "
  | Iand -> print_string " & "
  | Ior -> print_string " | "
  | Ixor -> print_string " ^ "
  | Ilsl -> print_string " << "
  | Ilsr -> print_string " >>u "
  | Iasr -> print_string " >>s "
  | Icomp cmp -> intcomp cmp
  | Icheckbound -> print_string " check > "
@

<<function [[Printmach.test]]>>=
let test tst arg =
  match tst with
    Itruetest -> reg arg.(0)
  | Ifalsetest -> print_string "not "; reg arg.(0)
  | Iinttest cmp -> reg arg.(0); intcomp cmp; reg arg.(1)
  | Iinttest_imm(cmp, n) -> reg arg.(0); intcomp cmp; print_int n
  | Ifloattest(cmp, neg) ->
      if neg then print_string "not ";
      reg arg.(0); floatcomp cmp; reg arg.(1)
  | Ieventest -> reg arg.(0); print_string " & 1 == 0"
  | Ioddtest -> reg arg.(0); print_string " & 1 == 1"
@

<<constant [[Printmach.print_live]]>>=
let print_live = ref false
@

<<function [[Printmach.operation]]>>=
let operation op arg res =
  if Array.length res > 0 then begin regs res; print_string " := " end;
  match op with
    Imove -> regs arg
  | Ispill -> regs arg; print_string " (spill)"
  | Ireload -> regs arg; print_string " (reload)"
  | Iconst_int n -> print_string(Nativeint.to_string n)
  | Iconst_float s -> print_string s
  | Iconst_symbol s -> print_string "\""; print_string s; print_string "\""
  | Icall_ind -> print_string "call "; regs arg
  | Icall_imm lbl ->
      print_string "call \""; print_string lbl;
      print_string "\" "; regs arg
  | Itailcall_ind -> print_string "tailcall "; regs arg
  | Itailcall_imm lbl ->
      print_string "tailcall \""; print_string lbl;
      print_string "\" "; regs arg
  | Iextcall(lbl, alloc) ->
      print_string "extcall \""; print_string lbl;
      print_string "\" "; regs arg;
      if not alloc then print_string " (noalloc)"
  | Istackoffset n ->
      print_string "offset stack "; print_int n
  | Iload(chunk, addr) ->
      Printcmm.chunk chunk;
      print_string "[";
      Arch.print_addressing reg addr arg;
      print_string "]"
  | Istore(chunk, addr) ->
      Printcmm.chunk chunk;
      print_string "[";
      Arch.print_addressing reg addr (Array.sub arg 1 (Array.length arg - 1));
      print_string "] := ";
      reg arg.(0)
  | Ialloc n -> print_string "alloc "; print_int n
  | Iintop(op) -> reg arg.(0); intop op; reg arg.(1)
  | Iintop_imm(op, n) -> reg arg.(0); intop op; print_int n
  | Inegf -> print_string "-f "; reg arg.(0)
  | Iabsf -> print_string "absf "; reg arg.(0)
  | Iaddf -> reg arg.(0); print_string " +f "; reg arg.(1)
  | Isubf -> reg arg.(0); print_string " -f "; reg arg.(1)
  | Imulf -> reg arg.(0); print_string " *f "; reg arg.(1)
  | Idivf -> reg arg.(0); print_string " /f "; reg arg.(1)
  | Ifloatofint -> print_string "floatofint "; reg arg.(0)
  | Iintoffloat -> print_string "intoffloat "; reg arg.(0)
  | Ispecific op ->
      Arch.print_specific_operation reg op arg
@

<<function [[Printmach.instr]]>>=
let rec instr i =
  if !print_live then begin
    open_box 1;
    print_string "{";
    regsetaddr i.live;
    if Array.length i.arg > 0 then begin
      print_space(); print_string "+"; print_space(); regs i.arg
    end;
    print_string "}";
    close_box();
    print_cut()
  end;
  begin match i.desc with
    Iend -> ()
  | Iop op ->
      operation op i.arg i.res
  | Ireturn ->
      print_string "return "; regs i.arg
  | Iifthenelse(tst, ifso, ifnot) ->
      open_vbox 2;
      print_string "if "; test tst i.arg; print_string " then"; print_cut();
      instr ifso;
      begin match ifnot.desc with
        Iend -> ()
      | _ -> print_break 0 (-2); print_string "else"; print_cut(); instr ifnot
      end;
      print_break 0 (-2); print_string "endif";
      close_box()
  | Iswitch(index, cases) ->
      print_string "switch "; reg i.arg.(0);
      for i = 0 to Array.length cases - 1 do
        print_cut();
        open_vbox 2;
        open_box 0;
        for j = 0 to Array.length index - 1 do
          if index.(j) = i then begin
            print_string "case "; print_int j; print_string ":";
            print_cut()
          end
        done;
        close_box(); print_cut();
        instr cases.(i);
        close_box()
      done;
      print_cut(); print_string "endswitch"
  | Iloop(body) ->
      open_vbox 2;
      print_string "loop"; print_cut();
      instr body; print_break 0 (-2); 
      print_string "endloop ";
      close_box()
  | Icatch(body, handler) ->
      open_vbox 2;
      print_string "catch"; print_cut();
      instr body;
      print_break 0 (-2);  print_string "with"; print_cut();
      instr handler;
      print_break 0 (-2); print_string "endcatch";
      close_box()
  | Iexit ->
      print_string "exit"
  | Itrywith(body, handler) ->
      open_vbox 2;
      print_string "try"; print_cut();
      instr body;
      print_break 0 (-2);  print_string "with"; print_cut();
      instr handler;
      print_break 0 (-2); print_string "endtry";
      close_box()
  | Iraise ->
      print_string "raise "; reg i.arg.(0)
  end;
  begin match i.next.desc with
    Iend -> ()
  | _ -> print_cut(); instr i.next
  end
@

<<function [[Printmach.fundecl]]>>=
let fundecl f =
  open_vbox 2;
  print_string f.fun_name;
  print_string "("; regs f.fun_args; print_string ")";
  print_cut();
  instr f.fun_body;
  close_box()
@

<<function [[Printmach.phase]]>>=
let phase msg f =
  print_string "*** "; print_string msg; print_newline(); 
  fundecl f; print_newline()
@

<<function [[Printmach.interference]]>>=
let interference r =
  open_box 2;
  reg r; print_string ":";
  List.iter
    (fun r -> print_space(); reg r)
    r.interf;
  close_box();
  print_newline()
@

<<function [[Printmach.interferences]]>>=
let interferences () =
  print_string "*** Interferences"; print_newline();
  List.iter interference (Reg.all_registers())
@

<<function [[Printmach.preference]]>>=
let preference r =
  open_box 2;
  reg r; print_string ": ";
  List.iter
    (fun (r, w) -> print_space(); reg r; print_string " weight " ; print_int w)
    r.prefer;
  close_box();
  print_newline()
@

<<function [[Printmach.preferences]]>>=
let preferences () =
  print_string "*** Preferences"; print_newline();
  List.iter preference (Reg.all_registers())
@


%-------------------------------------------------------------

<<asmcomp/printmach.ml>>=
<<copyright header>>

(* Pretty-printing of pseudo machine code *)

open Format
open Cmm
open Reg
open Mach

<<function [[Printmach.reg]]>>

<<function [[Printmach.regs]]>>

<<function [[Printmach.regset]]>>

<<function [[Printmach.regsetaddr]]>>

<<function [[Printmach.intcomp]]>>

<<function [[Printmach.floatcomp]]>>

<<function [[Printmach.intop]]>>
    
<<function [[Printmach.test]]>>

<<constant [[Printmach.print_live]]>>

<<function [[Printmach.operation]]>>

<<function [[Printmach.instr]]>>

<<function [[Printmach.fundecl]]>>

<<function [[Printmach.phase]]>>

<<function [[Printmach.interference]]>>

<<function [[Printmach.interferences]]>>

<<function [[Printmach.preference]]>>

<<function [[Printmach.preferences]]>>
@


\subsection*{[[asmcomp/split.mli]]}

<<signature [[Split.fundecl]]>>=
(* Renaming of registers at reload points to split live ranges. *)

val fundecl: Mach.fundecl -> Mach.fundecl
@


%-------------------------------------------------------------

<<asmcomp/split.mli>>=
<<copyright header>>

<<signature [[Split.fundecl]]>>
@


\subsection*{[[asmcomp/split.ml]]}

<<type [[Split.subst]]>>=
(* Substitutions are represented by register maps *)

type subst = (Reg.t, Reg.t) Map.t
@

<<function [[Split.subst_reg]]>>=
let subst_reg r sub =
  try
    (*Reg.*)Map.find r sub
  with Not_found ->
    r
@

<<function [[Split.subst_regs]]>>=
let subst_regs rv sub =
  match sub with
    None -> rv
  | Some s ->
      let n = Array.length rv in
      let nv = Array.create n Reg.dummy in
      for i = 0 to n-1 do nv.(i) <- subst_reg rv.(i) s done;
      nv
@

<<constant [[Split.equiv_classes]]>>=
(* We maintain equivalence classes of registers using a standard
   union-find algorithm *)

let equiv_classes = ref ((*Reg.*)Map.empty : (Reg.t, Reg.t) Map.t)
@

<<function [[Split.repres_reg]]>>=
let rec repres_reg r =
  try
    repres_reg((*Reg.*)Map.find r !equiv_classes)
  with Not_found ->
    r
@

<<function [[Split.repres_regs]]>>=
let repres_regs rv =
  let n = Array.length rv in
  for i = 0 to n-1 do rv.(i) <- repres_reg rv.(i) done
@

<<function [[Split.identify]]>>=
(* Identify two registers.
   The second register is chosen as canonical representative. *)

let identify r1 r2 =
  let repres1 = repres_reg r1 in
  let repres2 = repres_reg r2 in
  if repres1.stamp = repres2.stamp then () else begin
    equiv_classes := (*Reg.*)Map.add repres1 repres2 !equiv_classes
  end
@

<<function [[Split.identify_sub]]>>=
(* Identify the image of a register by two substitutions.
   Be careful to use the original register as canonical representative
   in case it does not belong to the domain of one of the substitutions. *)

let identify_sub sub1 sub2 reg =
  try
    let r1 = (*Reg.*)Map.find reg sub1 in
    try
      let r2 = (*Reg.*)Map.find reg sub2 in
      identify r1 r2
    with Not_found ->
      identify r1 reg
  with Not_found ->
    try
      let r2 = (*Reg.*)Map.find reg sub2 in
      identify r2 reg
    with Not_found ->
      ()
@

<<function [[Split.merge_substs]]>>=
(* Identify registers so that the two substitutions agree on the
   registers live before the given instruction. *)

let merge_substs sub1 sub2 i =
  match (sub1, sub2) with
    (None, None) -> None
  | (Some s1, None) -> sub1
  | (None, Some s2) -> sub2
  | (Some s1, Some s2) ->
      (*Reg.*)Set.iter (identify_sub s1 s2) (Reg.add_set_array i.live i.arg);
      sub1
@

<<function [[Split.merge_subst_array]]>>=
(* Same, for N substitutions *)

let merge_subst_array subv instr =
  let rec find_one_subst i =
    if i >= Array.length subv then None else begin
      match subv.(i) with
        None -> find_one_subst (i+1)
      | Some si as sub ->
          for j = i+1 to Array.length subv - 1 do
            match subv.(j) with
              None -> ()
            | Some sj ->
                (*Reg.*)Set.iter (identify_sub si sj)
                             (Reg.add_set_array instr.live instr.arg)
          done;
          sub
    end in
  find_one_subst 0
@

<<constant [[Split.exit_subst]]>>=
(* First pass: rename registers at reload points *)

let exit_subst = ref (None: subst option)
@

<<function [[Split.rename]]>>=
let rec rename i sub =
  match i.desc with
    Iend ->
      (i, sub)
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (instr_cons i.desc (subst_regs i.arg sub) [||] i.next,
       None)
  | Iop Ireload when i.res.(0).loc = Unknown ->
      begin match sub with
        None -> rename i.next sub
      | Some s ->
          let oldr = i.res.(0) in
          let newr = Reg.clone i.res.(0) in
          let (new_next, sub_next) =
            rename i.next (Some((*Reg.*)Map.add oldr newr s)) in
          (instr_cons i.desc i.arg [|newr|] new_next,
           sub_next)
      end
  | Iop _ ->
      let (new_next, sub_next) = rename i.next sub in
      (instr_cons i.desc (subst_regs i.arg sub) (subst_regs i.res sub)
                         new_next,
       sub_next)
  | Iifthenelse(tst, ifso, ifnot) ->
      let (new_ifso, sub_ifso) = rename ifso sub in
      let (new_ifnot, sub_ifnot) = rename ifnot sub in
      let (new_next, sub_next) =
        rename i.next (merge_substs sub_ifso sub_ifnot i.next) in
      (instr_cons (Iifthenelse(tst, new_ifso, new_ifnot))
                  (subst_regs i.arg sub) [||] new_next,
       sub_next)
  | Iswitch(index, cases) ->
      let new_sub_cases = Array.map (fun c -> rename c sub) cases in
      let sub_merge =
        merge_subst_array (Array.map (fun (n, s) -> s) new_sub_cases) i.next in
      let (new_next, sub_next) = rename i.next sub_merge in
      (instr_cons (Iswitch(index, Array.map (fun (n, s) -> n) new_sub_cases))
                  (subst_regs i.arg sub) [||] new_next,
       sub_next)
  | Iloop(body) ->
      let (new_body, sub_body) = rename body sub in
      let (new_next, sub_next) = rename i.next (merge_substs sub sub_body i) in
      (instr_cons (Iloop(new_body)) [||] [||] new_next,
       sub_next)
  | Icatch(body, handler) ->
      let saved_exit_subst = !exit_subst in
      exit_subst := None;
      let (new_body, sub_body) = rename body sub in
      let sub_entry_handler = !exit_subst in
      exit_subst := saved_exit_subst;
      let (new_handler, sub_handler) = rename handler sub_entry_handler in
      let (new_next, sub_next) =
        rename i.next (merge_substs sub_body sub_handler i.next) in
      (instr_cons (Icatch(new_body, new_handler)) [||] [||] new_next,
       sub_next)
  | Iexit ->
      exit_subst := merge_substs !exit_subst sub i;
      (i, None)
  | Itrywith(body, handler) ->
      let (new_body, sub_body) = rename body sub in
      let (new_handler, sub_handler) = rename handler sub in
      let (new_next, sub_next) =
        rename i.next (merge_substs sub_body sub_handler i.next) in
      (instr_cons (Itrywith(new_body, new_handler)) [||] [||] new_next,
       sub_next)
  | Iraise ->
      (instr_cons Iraise (subst_regs i.arg sub) [||] i.next,
       None)
@

<<function [[Split.set_repres]]>>=
(* Second pass: replace registers by their final representatives *)

let set_repres i =
  instr_iter (fun i -> repres_regs i.arg; repres_regs i.res) i
@

<<function [[Split.fundecl]]>>=
(* Entry point *)

let fundecl f =
  equiv_classes := (*Reg.*)Map.empty;
  let new_args = Array.copy f.fun_args in
  let (new_body, sub_body) = rename f.fun_body (Some (*Reg.*)Map.empty) in
  repres_regs new_args;
  set_repres new_body;
  equiv_classes := (*Reg.*)Map.empty;
  { fun_name = f.fun_name;
    fun_args = new_args;
    fun_body = new_body;
    fun_fast = f.fun_fast }
@


%-------------------------------------------------------------

<<asmcomp/split.ml>>=
<<copyright header>>

(* Renaming of registers at reload points to split live ranges. *)

open Reg
open Mach

<<type [[Split.subst]]>>

<<function [[Split.subst_reg]]>>

<<function [[Split.subst_regs]]>>

<<constant [[Split.equiv_classes]]>>

<<function [[Split.repres_reg]]>>

<<function [[Split.repres_regs]]>>

<<function [[Split.identify]]>>

<<function [[Split.identify_sub]]>>

<<function [[Split.merge_substs]]>>

<<function [[Split.merge_subst_array]]>>

<<constant [[Split.exit_subst]]>>

<<function [[Split.rename]]>>
      
<<function [[Split.set_repres]]>>

<<function [[Split.fundecl]]>>
@


\subsection*{[[asmcomp/proc.mli]]}

<<signature [[Proc.word_addressed]]>>=
(* Instruction selection *)
val word_addressed: bool
@

<<signature [[Proc.num_register_classes]]>>=
(* Registers available for register allocation *)
val num_register_classes: int
@

<<signature [[Proc.register_class]]>>=
val register_class: Reg.t -> int
@

<<signature [[Proc.num_available_registers]]>>=
val num_available_registers: int array
@

<<signature [[Proc.first_available_register]]>>=
val first_available_register: int array
@

<<signature [[Proc.register_name]]>>=
val register_name: int -> string
@

<<signature [[Proc.phys_reg]]>>=
val phys_reg: int -> Reg.t
@

<<signature [[Proc.rotate_registers]]>>=
val rotate_registers: bool
@

<<signature [[Proc.loc_arguments]]>>=
(* Calling conventions *)
val loc_arguments: Reg.t array -> Reg.t array * int
@

<<signature [[Proc.loc_results]]>>=
val loc_results: Reg.t array -> Reg.t array
@

<<signature [[Proc.loc_parameters]]>>=
val loc_parameters: Reg.t array -> Reg.t array
@

<<signature [[Proc.loc_external_arguments]]>>=
val loc_external_arguments: Reg.t array -> Reg.t array * int
@

<<signature [[Proc.loc_external_results]]>>=
val loc_external_results: Reg.t array -> Reg.t array
@

<<signature [[Proc.loc_exn_bucket]]>>=
val loc_exn_bucket: Reg.t
@

<<signature [[Proc.safe_register_pressure]]>>=
(* Maximal register pressures for pre-spilling *)
val safe_register_pressure: Mach.operation -> int
@

<<signature [[Proc.max_register_pressure]]>>=
val max_register_pressure: Mach.operation -> int array
@

<<signature [[Proc.destroyed_at_oper]]>>=
(* Registers destroyed by operations *)
val destroyed_at_oper: Mach.instruction_desc -> Reg.t array
@

<<signature [[Proc.destroyed_at_raise]]>>=
val destroyed_at_raise: Reg.t array
@

<<signature [[Proc.num_stack_slots]]>>=
(* Info for laying out the stack frame *)
val num_stack_slots: int array
@

<<signature [[Proc.contains_calls]]>>=
val contains_calls: bool ref
@

<<signature [[Proc.assemble_file]]>>=
(* Calling the assembler *)
val assemble_file: string -> string -> int
@


%-------------------------------------------------------------

<<asmcomp/proc.mli>>=
<<copyright header>>

(* Processor descriptions *)

<<signature [[Proc.word_addressed]]>>

<<signature [[Proc.num_register_classes]]>>
<<signature [[Proc.register_class]]>>
<<signature [[Proc.num_available_registers]]>>
<<signature [[Proc.first_available_register]]>>
<<signature [[Proc.register_name]]>>
<<signature [[Proc.phys_reg]]>>
<<signature [[Proc.rotate_registers]]>>

<<signature [[Proc.loc_arguments]]>>
<<signature [[Proc.loc_results]]>>
<<signature [[Proc.loc_parameters]]>>
<<signature [[Proc.loc_external_arguments]]>>
<<signature [[Proc.loc_external_results]]>>
<<signature [[Proc.loc_exn_bucket]]>>

<<signature [[Proc.safe_register_pressure]]>>
<<signature [[Proc.max_register_pressure]]>>

<<signature [[Proc.destroyed_at_oper]]>>
<<signature [[Proc.destroyed_at_raise]]>>

<<signature [[Proc.num_stack_slots]]>>
<<signature [[Proc.contains_calls]]>>

<<signature [[Proc.assemble_file]]>>
@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/proc.ml]]}

<<constant [[Proc.word_addressed]]>>=
(* Instruction selection *)

let word_addressed = false
@

<<constant [[Proc.int_reg_name]]>>=
(* Register map:
    r0 - r7                     general purpose (r4 - r7 preserved by C)
    r8                          allocation pointer (preserved by C)
    r9                          allocation limit (preserved by C)
    r10                         general purpose
    r11                         trap pointer (preserved by C)
    r12                         general purpose
    r13                         stack pointer
    r14                         return address
    r15                         program counter

    f0 - f7                     general purpose (f4 - f7 preserved by C)
*)

let int_reg_name = [|
@

<<constant [[Proc.float_reg_name]]>>=
let float_reg_name = [|
@

<<constant [[Proc.num_register_classes]]>>=
let num_register_classes = 2
@

<<function [[Proc.register_class]]>>=
let register_class r =
  match r.typ with
    Int -> 0
  | Addr -> 0
  | Float -> 1
@

<<constant [[Proc.num_available_registers]]>>=
let num_available_registers = [| 10; 8 |]
@

<<constant [[Proc.first_available_register]]>>=
let first_available_register = [| 0; 100 |]
@

<<function [[Proc.register_name]]>>=
let register_name r =
  if r < 100 then int_reg_name.(r) else float_reg_name.(r - 100)
@

<<constant [[Proc.rotate_registers]]>>=
let rotate_registers = true
@

<<constant [[Proc.hard_int_reg]]>>=
(* Representation of hard registers by pseudo-registers *)

let hard_int_reg =
  let v = Array.create 10 Reg.dummy in
  for i = 0 to 9 do v.(i) <- Reg.at_location Int (Reg i) done;
  v
@

<<constant [[Proc.hard_float_reg]]>>=
let hard_float_reg =
  let v = Array.create 8 Reg.dummy in
  for i = 0 to 7 do v.(i) <- Reg.at_location Float (Reg(100 + i)) done;
  v
@

<<constant [[Proc.all_phys_regs]]>>=
let all_phys_regs =
  Array.append hard_int_reg hard_float_reg
@

<<function [[Proc.phys_reg]]>>=
let phys_reg n =
  if n < 100 then hard_int_reg.(n) else hard_float_reg.(n - 100)
@

<<function [[Proc.stack_slot]]>>=
let stack_slot slot ty =
  Reg.at_location ty (Stack slot)
@

<<function [[Proc.calling_conventions]]>>=
(* Calling conventions *)

let calling_conventions first_int last_int first_float last_float
                        make_stack arg =
  let loc = Array.create (Array.length arg) Reg.dummy in
  let int = ref first_int in
  let float = ref first_float in
  let ofs = ref 0 in
  for i = 0 to Array.length arg - 1 do
    match arg.(i).typ with
      Int | Addr as ty ->
        if !int <= last_int then begin
          loc.(i) <- phys_reg !int;
          incr int
        end else begin
          loc.(i) <- stack_slot (make_stack !ofs) ty;
          ofs := !ofs + size_int
        end
    | Float ->
        if !float <= last_float then begin
          loc.(i) <- phys_reg !float;
          incr float
        end else begin
          loc.(i) <- stack_slot (make_stack !ofs) Float;
          ofs := !ofs + size_float
        end
  done;
  (loc, !ofs)
@

<<function [[Proc.incoming]]>>=
let incoming ofs = Incoming ofs
@

<<function [[Proc.outgoing]]>>=
let outgoing ofs = Outgoing ofs
@

<<function [[Proc.not_supported]]>>=
let not_supported ofs = fatal_error "Proc.loc_results: cannot call"
@

<<function [[Proc.loc_arguments]]>>=
let loc_arguments arg =
  calling_conventions 0 7 100 103 outgoing arg
@

<<function [[Proc.loc_parameters]]>>=
let loc_parameters arg =
  let (loc, ofs) = calling_conventions 0 7 100 103 incoming arg in loc
@

<<function [[Proc.loc_results]]>>=
let loc_results res =
  let (loc, ofs) = calling_conventions 0 7 100 103 not_supported res in loc
@

<<function [[Proc.loc_external_arguments]]>>=
(* Calling conventions for C are as for Caml, except that float arguments
   are passed in pairs of integer registers. *)

let loc_external_arguments arg =
  let loc = Array.create (Array.length arg) Reg.dummy in
  let reg = ref 0 in
  let ofs = ref 0 in
  for i = 0 to Array.length arg - 1 do
    match arg.(i).typ with
      Int | Addr as ty ->
        if !reg <= 3 then begin
          loc.(i) <- phys_reg !reg;
          incr reg
        end else begin
          loc.(i) <- stack_slot (outgoing !ofs) ty;
          ofs := !ofs + size_int
        end
    | Float ->
        if !reg <= 2 then begin
          loc.(i) <- phys_reg !reg;
          reg := !reg + 2
        end else begin
          loc.(i) <- stack_slot (outgoing !ofs) Float;
          ofs := !ofs + size_float
        end
  done;
  (loc, !ofs)
@

<<function [[Proc.loc_external_results]]>>=
let loc_external_results res =
  let (loc, ofs) = calling_conventions 0 0 100 100 not_supported res in loc
@

<<constant [[Proc.loc_exn_bucket]]>>=
let loc_exn_bucket = phys_reg 0
@

<<constant [[Proc.destroyed_at_c_call]]>>=
(* Registers destroyed by operations *)

let destroyed_at_c_call =               (* r4-r9, f4-f7 preserved *)
  Array.of_list(List.map phys_reg [0;1;2;3;8;9; 100;101;102;103])
@

<<function [[Proc.destroyed_at_oper]]>>=
let destroyed_at_oper = function
    Iop(Icall_ind | Icall_imm _ | Iextcall(_, true)) -> all_phys_regs
  | Iop(Iextcall(_, false)) -> destroyed_at_c_call
  | Iop(Ialloc(_)) -> [|phys_reg 8|]	(* r10 destroyed *)
  | _ -> [||]
@

<<constant [[Proc.destroyed_at_raise]]>>=
let destroyed_at_raise = all_phys_regs
@

<<function [[Proc.safe_register_pressure]]>>=
(* Maximal register pressure *)

let safe_register_pressure = function
    Iextcall(_, _) -> 4
  | _ -> 8
@

<<function [[Proc.max_register_pressure]]>>=
let max_register_pressure = function
    Iextcall(_, _) -> [| 4; 4 |]
  | _ -> [| 10; 8 |]
@

<<constant [[Proc.num_stack_slots]]>>=
(* Layout of the stack *)

let num_stack_slots = [| 0; 0 |]
@

<<constant [[Proc.contains_calls]]>>=
let contains_calls = ref false
@

<<function [[Proc.assemble_file]]>>=
(* Calling the assembler *)

let assemble_file infile outfile =
  Sys.command ("as -o " ^ outfile ^ " " ^ infile)
@


%-------------------------------------------------------------

<<asmcomp/arm/proc.ml>>=
<<copyright header 1998>>

(* Description of the ARM processor *)

open Misc
open Cmm
open Reg
open Arch
open Mach

<<constant [[Proc.word_addressed]]>>

(* Registers available for register allocation *)

<<constant [[Proc.int_reg_name]]>>
  "r0"; "r1"; "r2"; "r3"; "r4"; "r5"; "r6"; "r7"; "r10"; "r12"
|]
  
<<constant [[Proc.float_reg_name]]>>
  "f0"; "f1"; "f2"; "f3"; "f4"; "f5"; "f6"; "f7"
|]

<<constant [[Proc.num_register_classes]]>>

<<function [[Proc.register_class]]>>

<<constant [[Proc.num_available_registers]]>>

<<constant [[Proc.first_available_register]]>>

<<function [[Proc.register_name]]>>

<<constant [[Proc.rotate_registers]]>>

<<constant [[Proc.hard_int_reg]]>>

<<constant [[Proc.hard_float_reg]]>>

<<constant [[Proc.all_phys_regs]]>>

<<function [[Proc.phys_reg]]>>

<<function [[Proc.stack_slot]]>>

<<function [[Proc.calling_conventions]]>>

<<function [[Proc.incoming]]>>
<<function [[Proc.outgoing]]>>
<<function [[Proc.not_supported]]>>

<<function [[Proc.loc_arguments]]>>
<<function [[Proc.loc_parameters]]>>
<<function [[Proc.loc_results]]>>

<<function [[Proc.loc_external_arguments]]>>

<<function [[Proc.loc_external_results]]>>

<<constant [[Proc.loc_exn_bucket]]>>

<<constant [[Proc.destroyed_at_c_call]]>>

<<function [[Proc.destroyed_at_oper]]>>

<<constant [[Proc.destroyed_at_raise]]>>

<<function [[Proc.safe_register_pressure]]>>
<<function [[Proc.max_register_pressure]]>>

<<constant [[Proc.num_stack_slots]]>>
<<constant [[Proc.contains_calls]]>>

<<function [[Proc.assemble_file]]>>

@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/reloadgen.mli]]}

<<type [[Reloadgen.reloader]]>>=

type reloader = {
 reload_operation :
    reloader ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array * Reg.t array;
 reload_test: 
    reloader ->
    Mach.test -> Reg.t array -> Reg.t array;
    (* Can be overriden to reflect instructions that can operate
       directly on stack locations *)
 makereg : Reg.t -> Reg.t;
    (* Can be overriden to avoid creating new registers of some class
       (i.e. if all "registers" of that class are actually on stack) *)
 fundecl : 
   reloader ->
   Mach.fundecl -> Mach.fundecl * bool;
    (* The entry point *)

 (* old: protected *)

 makeregs : reloader -> Reg.t array -> Reg.t array;
 makereg1 : reloader -> Reg.t array -> Reg.t array;
 
 reload:  
   reloader -> Mach.instruction -> Mach.instruction;
 
}
@

<<signature [[Reloadgen.reload_generic]]>>=
val reload_generic: unit -> reloader
@


%-------------------------------------------------------------

<<asmcomp/reloadgen.mli>>=
<<copyright header 1997>>

<<type [[Reloadgen.reloader]]>>

<<signature [[Reloadgen.reload_generic]]>>

(*
 reload_operation = super.eload_operation;
 reload_test: = super.eload_test:; makereg : Reg.t -> Reg.t;
 fundecl = super.undecl;
 makeregs = super.akeregs;
 makereg1 = super.akereg1;
 reload: = super.eload:;
*)
@


\subsection*{[[asmcomp/reloadgen.ml]]}

<<function [[Reloadgen.insert_move]]>>=
let insert_move src dst next =
  if src.loc = dst.loc
  then next
  else instr_cons (Iop Imove) [|src|] [|dst|] next
@

<<function [[Reloadgen.insert_moves]]>>=
let insert_moves src dst next =
  let rec insmoves i =
    if i >= Array.length src
    then next
    else insert_move src.(i) dst.(i) (insmoves (i+1))
  in insmoves 0
@

<<type [[Reloadgen.reloader]]([[(asmcomp/reloadgen.ml)]])>>=
type reloader = {
 reload_operation :
    reloader ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array * Reg.t array;
 reload_test: 
    reloader ->
    Mach.test -> Reg.t array -> Reg.t array;
    (* Can be overriden to reflect instructions that can operate
       directly on stack locations *)
 makereg : Reg.t -> Reg.t;
    (* Can be overriden to avoid creating new registers of some class
       (i.e. if all "registers" of that class are actually on stack) *)
 fundecl : 
   reloader ->
   Mach.fundecl -> Mach.fundecl * bool;
    (* The entry point *)

 (* old: protected *)

 makeregs : reloader -> Reg.t array -> Reg.t array;
 makereg1 : reloader -> Reg.t array -> Reg.t array;
 
 reload:  
   reloader -> Mach.instruction -> Mach.instruction;
 
}
@

<<function [[Reloadgen.reload_generic]]>>=
let reload_generic () =
  let redo_regalloc = ref false in
  {
  makereg = (fun r ->
  match r.loc with
    Unknown -> fatal_error "Reload.makereg"
  | Reg _ -> r
  | Stack _ ->
      redo_regalloc := true;
      let newr = Reg.clone r in
      (* Strongly discourage spilling this register *)
      newr.spill_cost <- 100000;
      newr
  );

  makeregs = (fun self rv ->
  let n = Array.length rv in
  let newv = Array.create n Reg.dummy in
  for i = 0 to n-1 do newv.(i) <- self.makereg rv.(i) done;
  newv
  );

  makereg1 = (fun self rv ->
  let newv = Array.copy rv in
  newv.(0) <- self.makereg rv.(0);
  newv
  );

 reload_operation = (fun self op arg res ->
  (* By default, assume that arguments and results must reside
     in hardware registers. For moves, allow one arg or one
     res to be stack-allocated, but do something for
     stack-to-stack moves *)
  match op with
    Imove | Ireload | Ispill ->
      begin match arg.(0), res.(0) with
        {loc = Stack s1}, {loc = Stack s2} when s1 <> s2 ->
          ([| self.makereg arg.(0) |], res)
      | _ ->
          (arg, res)
      end
  | _ ->
      (self.makeregs self arg, self.makeregs self res)
 );

 reload_test = (fun self tst args ->
  self.makeregs self args
 );

 reload = (fun self i ->
  match i.desc with
    (* For function calls, returns, etc: the arguments and results are
       already at the correct position (e.g. on stack for some arguments).
       However, something needs to be done for the function pointer in
       indirect calls. *)
    Iend | Ireturn | Iop(Itailcall_imm _) | Iraise -> i
  | Iop(Itailcall_ind) ->
      let newarg = self.makereg1 self i.arg in
      insert_moves i.arg newarg
        (instr_cons_live i.desc newarg i.res i.live i.next)
  | Iop(Icall_imm _ | Iextcall(_, _)) ->
      instr_cons_live i.desc i.arg i.res i.live (self.reload self i.next)
  | Iop(Icall_ind) ->
      let newarg = self.makereg1 self i.arg in
      insert_moves i.arg newarg
        (instr_cons_live i.desc newarg i.res i.live (self.reload self i.next))
  | Iop op ->
      let (newarg, newres) = self.reload_operation self op i.arg i.res in
      insert_moves i.arg newarg
        (instr_cons_live i.desc newarg newres i.live
          (insert_moves newres i.res
            (self.reload self i.next)))
  | Iifthenelse(tst, ifso, ifnot) ->
      let newarg = self.reload_test self tst i.arg in
      insert_moves i.arg newarg      
        (instr_cons
          (Iifthenelse(tst, self.reload self ifso, self.reload self ifnot)) newarg [||]
          (self.reload self i.next))
  | Iswitch(index, cases) ->
      let newarg = self.makeregs self i.arg in
      insert_moves i.arg newarg      
        (instr_cons (Iswitch(index, Array.map (self.reload self) cases)) newarg [||]
          (self.reload self i.next))
  | Iloop body ->
      instr_cons (Iloop(self.reload self body)) [||] [||] (self.reload self i.next)
  | Icatch(body, handler) ->
      instr_cons (Icatch(self.reload self body, self.reload self handler)) [||] [||]
        (self.reload self i.next)
  | Iexit ->
      instr_cons Iexit [||] [||] dummy_instr
  | Itrywith(body, handler) ->
      instr_cons (Itrywith(self.reload self body, self.reload self handler)) [||] [||]
        (self.reload self i.next)
 );

 fundecl = (fun self f ->
  redo_regalloc := false;
  let new_body = self.reload self f.fun_body in
  ({fun_name = f.fun_name; fun_args = f.fun_args;
    fun_body = new_body; fun_fast = f.fun_fast},
   !redo_regalloc)
 );
 }
@


%-------------------------------------------------------------

<<asmcomp/reloadgen.ml>>=
<<copyright header>>

(* Insert load/stores for pseudoregs that got assigned to stack locations. *)

open Misc
open Reg
open Mach

<<function [[Reloadgen.insert_move]]>>

<<function [[Reloadgen.insert_moves]]>>



<<type [[Reloadgen.reloader]]([[(asmcomp/reloadgen.ml)]])>>


<<function [[Reloadgen.reload_generic]]>>
@


\subsection*{[[asmcomp/interf.mli]]}

<<signature [[Interf.build_graph]]>>=
(* Construction of the interference graph.
   Annotate pseudoregs with interference lists and preference lists. *)

val build_graph: Mach.fundecl -> unit
@


%-------------------------------------------------------------

<<asmcomp/interf.mli>>=
<<copyright header>>

<<signature [[Interf.build_graph]]>>
@


\subsection*{[[asmcomp/reload.mli]]}

<<signature [[Reload.fundecl]]>>=
(* Insert load/stores for pseudoregs that got assigned to stack locations. *)

val fundecl: Mach.fundecl -> Mach.fundecl * bool
@


%-------------------------------------------------------------

<<asmcomp/reload.mli>>=
<<copyright header>>

<<signature [[Reload.fundecl]]>>

@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/reload.ml]]}

<<function [[Reload.fundecl]]>>=
(* Reloading for the ARM *)

let fundecl f =
  let reloader = Reloadgen.reload_generic () in
  reloader.fundecl reloader f
@


%-------------------------------------------------------------

<<asmcomp/arm/reload.ml>>=
<<copyright header 1998>>

open Reloadgen

<<function [[Reload.fundecl]]>>
@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/interf.ml]]}

<<function [[Interf.build_graph]]>>=
let build_graph fundecl =

  (* The interference graph is represented in two ways:
     - by adjacency lists for each register
     - by a triangular bit matrix *)

  let num_regs = Reg.num_registers() in
  let mat =
    String.make (((num_regs * (num_regs + 1)) lsr 1 + 7) lsr 3) '\000' in

  (* Record an interference between two registers *)
  let add_interf ri rj =
    let i = ri.stamp and j = rj.stamp in
    if i = j then () else begin
      let n = if i < j then ((j * (j + 1)) lsr 1) + i
                       else ((i * (i + 1)) lsr 1) + j in
      let b = Char.code(mat.[n lsr 3]) in
      let msk = 1 lsl (n land 7) in
      if b land msk = 0 then begin
        mat.[n lsr 3] <- Char.unsafe_chr(b lor msk);
        begin match ri.loc with
          Unknown -> ri.interf <- rj :: ri.interf | _ -> ()
        end;
        begin match rj.loc with
          Unknown -> rj.interf <- ri :: rj.interf | _ -> ()
        end
      end
    end in

  (* Record interferences between a register array and a set of registers *)
  let add_interf_set v s =
    for i = 0 to Array.length v - 1 do
      let r1 = v.(i) in
      (*Reg.*)Set.iter (add_interf r1) s
    done in

  (* Record interferences between elements of an array *)
  let add_interf_self v =
    for i = 0 to Array.length v - 2 do
      let ri = v.(i) in
      for j = i+1 to Array.length v - 1 do
        add_interf ri v.(j)
      done
    done in

  (* Record interferences between the destination of a move and a set
     of live registers. Since the destination is equal to the source,
     do not add an interference between them if the source is still live
     afterwards. *)
  let add_interf_move src dst s =
    (*Reg.*)Set.iter (fun r -> if r.stamp <> src.stamp then add_interf dst r) s in

  (* Compute interferences *)

  let rec interf i =
    let destroyed = Proc.destroyed_at_oper i.desc in
    if Array.length destroyed > 0 then add_interf_set destroyed i.live;
    match i.desc with
      Iend -> ()
    | Ireturn -> ()
    | Iop(Imove | Ispill | Ireload) ->
        add_interf_move i.arg.(0) i.res.(0) i.live;
        interf i.next
    | Iop(Itailcall_ind) -> ()
    | Iop(Itailcall_imm lbl) -> ()
    | Iop op ->
        add_interf_set i.res i.live;
        add_interf_self i.res;
        interf i.next
    | Iifthenelse(tst, ifso, ifnot) ->
        interf ifso;
        interf ifnot;
        interf i.next
    | Iswitch(index, cases) ->
        for i = 0 to Array.length cases - 1 do
          interf cases.(i)
        done;
        interf i.next
    | Iloop body ->
        interf body; interf i.next
    | Icatch(body, handler) ->
        interf body; interf handler; interf i.next
    | Iexit ->
        ()
    | Itrywith(body, handler) ->
        add_interf_set Proc.destroyed_at_raise handler.live;    
        interf body; interf handler; interf i.next
    | Iraise -> () in

  (* Add a preference from one reg to another.
     Do not add anything if the two registers conflict,
     or if the source register already has a location. *)

  let add_pref weight r1 r2 =
    if weight > 0 then begin
      let i = r1.stamp and j = r2.stamp in
      if i = j then () else begin
        match r1.loc with
          Unknown ->
            let n = if i < j then ((j * (j + 1)) lsr 1) + i
                             else ((i * (i + 1)) lsr 1) + j in
            let b = Char.code(mat.[n lsr 3]) in
            let msk = 1 lsl (n land 7) in
            if b land msk = 0 then r1.prefer <- (r2, weight) :: r1.prefer
        | _ -> ()
      end
    end in

  (* Add a mutual preference between two regs *)
  let add_mutual_pref weight r1 r2 =
    add_pref weight r1 r2; add_pref weight r2 r1 in

  (* Update the spill cost of the registers involved in an operation *)

  let add_spill_cost cost arg =
    for i = 0 to Array.length arg - 1 do
      let r = arg.(i) in r.spill_cost <- r.spill_cost + cost
    done in

  (* Compute preferences and spill costs *)

  let rec prefer weight i =
    add_spill_cost weight i.arg;
    add_spill_cost weight i.res;
    match i.desc with
      Iend -> ()
    | Ireturn -> ()
    | Iop(Imove) ->
        add_mutual_pref weight i.arg.(0) i.res.(0);
        prefer weight i.next
    | Iop(Ispill) ->
        add_pref (weight / 4) i.arg.(0) i.res.(0);
        prefer weight i.next
    | Iop(Ireload) ->
        add_pref (weight / 4) i.res.(0) i.arg.(0);
        prefer weight i.next
    | Iop(Itailcall_ind) -> ()
    | Iop(Itailcall_imm lbl) -> ()
    | Iop op ->
        prefer weight i.next
    | Iifthenelse(tst, ifso, ifnot) ->
        prefer (weight / 2) ifso;
        prefer (weight / 2) ifnot;
        prefer weight i.next
    | Iswitch(index, cases) ->
        for i = 0 to Array.length cases - 1 do
          prefer (weight / 2) cases.(i)
        done;
        prefer weight i.next
    | Iloop body ->
        (* Avoid overflow of weight and spill_cost *)
        prefer (if weight < 1000 then 8 * weight else weight) body;
        prefer weight i.next
    | Icatch(body, handler) ->
        prefer weight body; prefer weight handler; prefer weight i.next
    | Iexit ->
        ()
    | Itrywith(body, handler) ->
        prefer weight body; prefer weight handler; prefer weight i.next
    | Iraise -> ()
  in

  interf fundecl.fun_body; prefer 8 fundecl.fun_body
@


%-------------------------------------------------------------

<<asmcomp/interf.ml>>=
<<copyright header>>

(* Construction of the interference graph.
   Annotate pseudoregs with interference lists and preference lists. *)

open Reg
open Mach

<<function [[Interf.build_graph]]>>

@


\subsection*{[[asmcomp/coloring.mli]]}

<<signature [[Coloring.allocate_registers]]>>=
(* Register allocation by coloring of the interference graph *)

val allocate_registers: unit -> unit
@


%-------------------------------------------------------------

<<asmcomp/coloring.mli>>=
<<copyright header>>

<<signature [[Coloring.allocate_registers]]>>
@


\subsection*{[[asmcomp/coloring.ml]]}

<<function [[Coloring.allocate_spilled]]>>=
(* Preallocation of spilled registers in the stack. *)

let allocate_spilled reg =
  if reg.spill then begin
    let cl = Proc.register_class reg in
    let nslots = Proc.num_stack_slots.(cl) in
    let conflict = Array.create nslots false in
    List.iter
      (fun r ->
        match r.loc with
          Stack(Local n) ->
            if Proc.register_class r = cl then conflict.(n) <- true
        | _ -> ())
      reg.interf;
    let slot = ref 0 in
    while !slot < nslots & conflict.(!slot) do incr slot done;
    reg.loc <- Stack(Local !slot);
    if !slot >= nslots then Proc.num_stack_slots.(cl) <- !slot + 1
  end
@

<<constant [[Coloring.unconstrained]]>>=
(* Compute the degree (= number of neighbours of the same type)
   of each register, and split them in two sets:
   unconstrained (degree < number of available registers)
   and constrained (degree >= number of available registers).
   Spilled registers are ignored in the process. *)

let unconstrained = ref (*Reg.*)Set.empty
@

<<constant [[Coloring.constrained]]>>=
let constrained = ref (*Reg.*)Set.empty
@

<<function [[Coloring.find_degree]]>>=
let find_degree reg =
  if reg.spill then () else begin
    let cl = Proc.register_class reg in
    let avail_regs = Proc.num_available_registers.(cl) in
    if avail_regs = 0 then
      (* Don't bother computing the degree if there are no regs 
         in this class *)
      unconstrained := (*Reg.*)Set.add reg !unconstrained
    else begin
      let deg = ref 0 in
      List.iter
        (fun r -> if not r.spill & Proc.register_class r = cl then incr deg)
        reg.interf;
      reg.degree <- !deg;
      if !deg >= avail_regs
      then constrained := (*Reg.*)Set.add reg !constrained
      else unconstrained := (*Reg.*)Set.add reg !unconstrained
    end
  end
@

<<function [[Coloring.remove_all_regs]]>>=
(* Remove all registers one by one, unconstrained if possible, otherwise
   constrained with lowest spill cost. Return the list of registers removed
   in reverse order.
   The spill cost measure is [r.spill_cost / r.degree].
   [r.spill_cost] estimates the number of accesses to this register. *)

let rec remove_all_regs stack =
  if not ((*Reg.*)Set.is_empty !unconstrained) then begin
    (* Pick any unconstrained register *)
    let r = (*Reg.*)Set.choose !unconstrained in
    unconstrained := (*Reg.*)Set.remove r !unconstrained;
    remove_all_regs (r :: stack)
  end else
  if not ((*Reg.*)Set.is_empty !constrained) then begin
    (* Find a constrained reg with minimal cost *)
    let r = ref Reg.dummy in
    let min_degree = ref 0 and min_spill_cost = ref 1 in
      (* initially !min_spill_cost / !min_degree is +infty *)
    (*Reg.*)Set.iter
      (fun r2 ->
        (* if r2.spill_cost / r2.degree < !min_spill_cost / !min_degree *)
        if r2.spill_cost * !min_degree < !min_spill_cost * r2.degree
        then begin
          r := r2; min_degree := r2.degree; min_spill_cost := r2.spill_cost
        end)
      !constrained;
    constrained := (*Reg.*)Set.remove !r !constrained;
    remove_all_regs (!r :: stack)
  end else
    stack                             (* All regs have been removed *)
@

<<function [[Coloring.iter_preferred]]>>=
(* Iterate over all registers preferred by the given register (transitively) *)

let iter_preferred f reg =
  let rec walk r w =
    if not r.visited then begin
      f r w;
      begin match r.prefer with
          [] -> ()
        | p  -> r.visited <- true;
                List.iter (fun (r1, w1) -> walk r1 (min w w1)) p;
                r.visited <- false
      end
    end in
  reg.visited <- true;
  List.iter (fun (r, w) -> walk r w) reg.prefer;
  reg.visited <- false
@

<<constant [[Coloring.start_register]]>>=
(* Where to start the search for a suitable register. 
   Used to introduce some "randomness" in the choice between registers
   with equal scores. This offers more opportunities for scheduling. *)

let start_register = Array.create Proc.num_register_classes 0
@

<<function [[Coloring.assign_location]]>>=
(* Assign a location to a register, the best we can *)

let assign_location reg =
  let cl = Proc.register_class reg in
  let first_reg = Proc.first_available_register.(cl) in
  let num_regs = Proc.num_available_registers.(cl) in
  let last_reg = first_reg + num_regs in
  let score = Array.create num_regs 0 in
  let best_score = ref (-1000000) and best_reg = ref (-1) in
  let start = start_register.(cl) in
  if num_regs > 0 then begin
    (* Favor the registers that have been assigned to pseudoregs for which
       we have a preference. If these pseudoregs have not been assigned
       already, avoid the registers with which they conflict. *)
    iter_preferred
      (fun r w ->
        match r.loc with
          Reg n -> if n >= first_reg & n < last_reg then
                     score.(n - first_reg) <- score.(n - first_reg) + w
        | Unknown ->
            List.iter
              (fun neighbour ->
                match neighbour.loc with
                  Reg n -> if n >= first_reg & n < last_reg then
                           score.(n - first_reg) <- score.(n - first_reg) - w
                | _ -> ())
              r.interf
        | _ -> ())
      reg;
    List.iter
      (fun neighbour ->
        (* Prohibit the registers that have been assigned
           to our neighbours *)
        begin match neighbour.loc with
          Reg n -> if n >= first_reg & n < last_reg then
                     score.(n - first_reg) <- (-1000000)
        | _ -> ()
        end;
        (* Avoid the registers that have been assigned to pseudoregs
           for which our neighbours have a preference *)
        iter_preferred
          (fun r w ->
            match r.loc with
              Reg n -> if n >= first_reg & n < last_reg then
                         score.(n - first_reg) <- score.(n - first_reg) - (w - 1)
                       (* w-1 to break the symmetry when two conflicting regs
                          have the same preference for a third reg. *)
            | _ -> ())
          neighbour)
      reg.interf;
    (* Pick the register with the best score *)
    for n = start to num_regs - 1 do
      if score.(n) > !best_score then begin
        best_score := score.(n);
        best_reg := n
      end
    done;
    for n = 0 to start - 1 do
      if score.(n) > !best_score then begin
        best_score := score.(n);
        best_reg := n
      end
    done
  end;
  (* Found a register? *)
  if !best_reg >= 0 then begin
    reg.loc <- Reg(first_reg + !best_reg);
    if Proc.rotate_registers then
      start_register.(cl) <- (if start+1 >= num_regs then 0 else start+1)
  end else begin
    (* Sorry, we must put the pseudoreg in a stack location *)
    (* First, check if we have a preference for an incoming location
       we do not conflict with. *)
    let best_score = ref 0 and best_incoming_loc = ref (-1) in
    List.iter
      (fun (r, w) ->
        match r.loc with
          Stack(Incoming n) ->
            if w > !best_score
             & List.for_all (fun neighbour -> neighbour.loc <> r.loc)
                            reg.interf
            then begin
              best_score := w;
              best_incoming_loc := n
            end
        | _ -> ())
      reg.prefer;
    if !best_incoming_loc >= 0 then
      reg.loc <- Stack(Incoming !best_incoming_loc)
    else begin
      (* Now, look for a location in the local area *)
      let nslots = Proc.num_stack_slots.(cl) in
      let score = Array.create nslots 0 in
      (* Compute the scores as for registers *)
      List.iter
        (fun (r, w) ->
          match r.loc with
            Stack(Local n) -> if Proc.register_class r = cl then
                              score.(n) <- score.(n) + w
          | Unknown ->
              List.iter
                (fun neighbour ->
                  match neighbour.loc with
                    Stack(Local n) ->
                      if Proc.register_class neighbour = cl
                      then score.(n) <- score.(n) - w
                  | _ -> ())
                r.interf
          | _ -> ())
        reg.prefer;
      List.iter
        (fun neighbour ->
          begin match neighbour.loc with
              Stack(Local n) ->
                if Proc.register_class neighbour = cl then
                score.(n) <- (-1000000)
          | _ -> ()
          end;
          List.iter
            (fun (r, w) ->
              match r.loc with
                Stack(Local n) -> if Proc.register_class r = cl then
                                  score.(n) <- score.(n) - w
              | _ -> ())
            neighbour.prefer)
        reg.interf;
      (* Pick the location with the best score *)
      let best_score = ref (-1000000) and best_slot = ref (-1) in
      for n = 0 to nslots - 1 do
        if score.(n) > !best_score then begin
          best_score := score.(n);
          best_slot := n
        end
      done;
      (* Found one? *)
      if !best_slot >= 0 then
        reg.loc <- Stack(Local !best_slot)
      else begin
        (* Allocate a new stack slot *)
        reg.loc <- Stack(Local nslots);
        Proc.num_stack_slots.(cl) <- nslots + 1
      end
    end
  end;
  (* Cancel the preferences of this register so that they don't influence
     transitively the allocation of registers that prefer this reg. *)
  reg.prefer <- []
@

<<function [[Coloring.allocate_registers]]>>=
let allocate_registers() =
  (* First pass: preallocate spill registers
     Second pass: compute the degrees
     Third pass: determine coloring order by successive removals of regs
     Fourth pass: assign registers in that order *)
  for i = 0 to Proc.num_register_classes - 1 do
    Proc.num_stack_slots.(i) <- 0;
    start_register.(i) <- 0
  done;
  List.iter allocate_spilled (Reg.all_registers());
  List.iter find_degree (Reg.all_registers());
  List.iter assign_location (remove_all_regs [])
@


%-------------------------------------------------------------

<<asmcomp/coloring.ml>>=
<<copyright header>>

(* Register allocation by coloring of the interference graph *)

open Reg

<<function [[Coloring.allocate_spilled]]>>

<<constant [[Coloring.unconstrained]]>>
<<constant [[Coloring.constrained]]>>

<<function [[Coloring.find_degree]]>>

<<function [[Coloring.remove_all_regs]]>>

<<function [[Coloring.iter_preferred]]>>

<<constant [[Coloring.start_register]]>>

<<function [[Coloring.assign_location]]>>

<<function [[Coloring.allocate_registers]]>>
@


\subsection*{[[asmcomp/linearize.mli]]}

<<type [[Linearize.label]]>>=
(* Transformation of Mach code into a list of pseudo-instructions. *)

type label = int
@

<<signature [[Linearize.new_label]]>>=
val new_label: unit -> label
@

<<type [[Linearize.instruction]]>>=
type instruction =
  { mutable desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    live: Reg.t Set.t }
@

<<type [[Linearize.instruction_desc]]>>=
and instruction_desc =
    Lend
  | Lop of Mach.operation
  | Lreloadretaddr
  | Lreturn
  | Llabel of label
  | Lbranch of label
  | Lcondbranch of Mach.test * label
  | Lcondbranch3 of label option * label option * label option
  | Lswitch of label array
  | Lsetuptrap of label
  | Lpushtrap
  | Lpoptrap
  | Lraise
@

<<signature [[Linearize.end_instr]]>>=
val end_instr: instruction
@

<<signature [[Linearize.instr_cons]]>>=
val instr_cons: 
  instruction_desc -> Reg.t array -> Reg.t array -> instruction -> instruction
@

<<type [[Linearize.fundecl]]>>=
type fundecl =
  { fun_name: string;
    fun_body: instruction;
    fun_fast: bool }
@

<<signature [[Linearize.fundecl]]>>=
val fundecl: Mach.fundecl -> fundecl
@


%-------------------------------------------------------------

<<asmcomp/linearize.mli>>=
<<copyright header>>

<<type [[Linearize.label]]>>
<<signature [[Linearize.new_label]]>>

<<type [[Linearize.instruction]]>>

<<type [[Linearize.instruction_desc]]>>

<<signature [[Linearize.end_instr]]>>
<<signature [[Linearize.instr_cons]]>>

<<type [[Linearize.fundecl]]>>

<<signature [[Linearize.fundecl]]>>

@


\subsection*{[[asmcomp/linearize.ml]]}

<<type [[Linearize.label]]([[(asmcomp/linearize.ml)]])>>=
type label = int
@

<<constant [[Linearize.label_counter]]>>=
let label_counter = ref 99
@

<<function [[Linearize.new_label]]>>=
let new_label() = incr label_counter; !label_counter
@

<<type [[Linearize.instruction]]([[(asmcomp/linearize.ml)]])>>=
type instruction =
  { mutable desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    live: Reg.t Set.t }
@

<<type [[Linearize.instruction_desc]]([[(asmcomp/linearize.ml)]])>>=
and instruction_desc =
    Lend
  | Lop of operation
  | Lreloadretaddr
  | Lreturn
  | Llabel of label
  | Lbranch of label
  | Lcondbranch of test * label
  | Lcondbranch3 of label option * label option * label option
  | Lswitch of label array
  | Lsetuptrap of label
  | Lpushtrap
  | Lpoptrap
  | Lraise
@

<<type [[Linearize.fundecl]]([[(asmcomp/linearize.ml)]])>>=
type fundecl =
  { fun_name: string;
    fun_body: instruction;
    fun_fast: bool }
@

<<function [[Linearize.invert_integer_test]]>>=
(* Invert a test *)

let invert_integer_test = function
    Isigned cmp -> Isigned(Cmm.negate_comparison cmp)
  | Iunsigned cmp -> Iunsigned(Cmm.negate_comparison cmp)
@

<<function [[Linearize.invert_test]]>>=
let invert_test = function
    Itruetest -> Ifalsetest
  | Ifalsetest -> Itruetest
  | Iinttest(cmp) -> Iinttest(invert_integer_test cmp)
  | Iinttest_imm(cmp, n) -> Iinttest_imm(invert_integer_test cmp, n)
  | Ifloattest(cmp, neg) -> Ifloattest(cmp, not neg)
  | Ieventest -> Ioddtest
  | Ioddtest -> Ieventest
@

<<constant [[Linearize.end_instr]]>>=
(* The "end" instruction *)

let rec end_instr =
  { desc = Lend;
    next = end_instr;
    arg = [||];
    res = [||];
    live = (*Reg.*)Set.empty }
@

<<function [[Linearize.instr_cons]]>>=
(* Cons an instruction (live empty) *)

let instr_cons d a r n =
  { desc = d; next = n; arg = a; res = r; live = (*Reg.*)Set.empty }
@

<<function [[Linearize.cons_instr]]>>=
(* Cons a simple instruction (arg, res, live empty) *)

let cons_instr d n =
  { desc = d; next = n; arg = [||]; res = [||]; live = (*Reg.*)Set.empty }
@

<<function [[Linearize.copy_instr]]>>=
(* Build an instruction with arg, res, live taken from
   the given Mach.instruction *)

let copy_instr d i n =
  { desc = d; next = n;
    arg = i.Mach.arg; res = i.Mach.res; live = i.Mach.live }
@

<<function [[Linearize.get_label]]>>=
(* Label the beginning of the given instruction sequence.
   If the sequence starts with a branch, jump over it. *)

let get_label n =
  match n.desc with
    Lbranch lbl -> (lbl, n)
  | Llabel lbl -> (lbl, n)
  | _ -> let lbl = new_label() in (lbl, cons_instr (Llabel lbl) n)
@

<<function [[Linearize.discard_dead_code]]>>=
(* Discard all instructions up to the next label.
   This function is to be called before adding a non-terminating 
   instruction. *)

let rec discard_dead_code n =
  match n.desc with
    Lend -> n
  | Llabel _ -> n
(* Do not discard Lpoptrap or Istackoffset instructions,
   as this may cause a stack imbalance later during assembler generation. *)
  | Lpoptrap -> n
  | Lop(Istackoffset _) -> n
  | _ -> discard_dead_code n.next
@

<<function [[Linearize.add_branch]]>>=
(* Add a branch in front of a continuation.
   Discard dead code in the continuation.
   Does not insert anything if we're just falling through. *)

let add_branch lbl n =
  let n1 = discard_dead_code n in
  match n1.desc with
    Llabel lbl1 when lbl1 = lbl -> n1
  | _ -> cons_instr (Lbranch lbl) n1
@

<<constant [[Linearize.exit_label]]>>=
(* Current label for exit handler *)

let exit_label = ref 99
@

<<function [[Linearize.linear]]>>=
(* Linearize an instruction [i]: add it in front of the continuation [n] *)

let rec linear i n =
  match i.Mach.desc with
    Iend -> n
  | Iop(Itailcall_ind | Itailcall_imm _ as op) ->
      copy_instr (Lop op) i (discard_dead_code n)
  | Iop(Imove | Ireload | Ispill)
    when i.Mach.arg.(0).loc = i.Mach.res.(0).loc ->
      linear i.Mach.next n
  | Iop op ->
      copy_instr (Lop op) i (linear i.Mach.next n)
  | Ireturn ->
      let n1 = copy_instr Lreturn i (discard_dead_code n) in
      if !Proc.contains_calls
      then cons_instr Lreloadretaddr n1
      else n1
  | Iifthenelse(test, ifso, ifnot) ->
      let n1 = linear i.Mach.next n in
      begin match (ifso.Mach.desc, ifnot.Mach.desc) with
        Iexit, _ ->
          copy_instr (Lcondbranch(test, !exit_label)) i
            (linear ifnot n1)
      | _,  Iexit ->
          copy_instr (Lcondbranch(invert_test test, !exit_label)) i
            (linear ifso n1)
      | Iend, _ ->
          let (lbl_end, n2) = get_label n1 in
          copy_instr (Lcondbranch(test, lbl_end)) i
            (linear ifnot n2)
      | _,  Iend ->
          let (lbl_end, n2) = get_label n1 in
          copy_instr (Lcondbranch(invert_test test, lbl_end)) i
            (linear ifso n2)
      | _, _ ->
        (* Should attempt branch prediction here *)
          let (lbl_end, n2) = get_label n1 in
          let (lbl_else, nelse) = get_label (linear ifnot n2) in
          copy_instr (Lcondbranch(invert_test test, lbl_else)) i
            (linear ifso (add_branch lbl_end nelse))
      end
  | Iswitch(index, cases) ->
      let lbl_cases = Array.create (Array.length cases) 0 in
      let (lbl_end, n1) = get_label(linear i.Mach.next n) in
      let n2 = ref (discard_dead_code n1) in
      for i = Array.length cases - 1 downto 0 do
        let (lbl_case, ncase) =
                get_label(linear cases.(i) (add_branch lbl_end !n2)) in
        lbl_cases.(i) <- lbl_case;
        n2 := discard_dead_code ncase
      done;
      (* Switches with 1 and 2 branches have been eliminated earlier.
         Here, we do something for switches with 3 branches. *)
      if Array.length index = 3 then begin
        let fallthrough_lbl =
          match !n2.desc with Llabel lbl -> lbl | _ -> -1 in
        let find_label n =
          let lbl = lbl_cases.(index.(n)) in
          if lbl = fallthrough_lbl then None else Some lbl in
        copy_instr (Lcondbranch3(find_label 0, find_label 1, find_label 2))
                   i !n2
      end else
        copy_instr (Lswitch(Array.map (fun n -> lbl_cases.(n)) index)) i !n2
  | Iloop body ->
      let lbl_head = new_label() in
      let n1 = linear i.Mach.next n in
      let n2 = linear body (cons_instr (Lbranch lbl_head) n1) in
      cons_instr (Llabel lbl_head) n2
  | Icatch(body, handler) ->
      let (lbl_end, n1) = get_label(linear i.Mach.next n) in
      let (lbl_handler, n2) = get_label(linear handler n1) in
      let saved_exit_label = !exit_label in
      exit_label := lbl_handler;
      let n3 = linear body (add_branch lbl_end n2) in
      exit_label := saved_exit_label;
      n3
  | Iexit ->
      add_branch !exit_label (linear i.Mach.next n)
  | Itrywith(body, handler) ->
      let (lbl_join, n1) = get_label (linear i.Mach.next n) in
      let (lbl_body, n2) =
        get_label (cons_instr Lpushtrap
                    (linear body (cons_instr Lpoptrap n1))) in
      cons_instr (Lsetuptrap lbl_body)
        (linear handler (add_branch lbl_join n2))
  | Iraise ->
      copy_instr Lraise i (discard_dead_code n)
@

<<function [[Linearize.fundecl]]>>=
let fundecl f =
  { fun_name = f.Mach.fun_name;
    fun_body = linear f.Mach.fun_body end_instr;
    fun_fast = f.Mach.fun_fast }
@


%-------------------------------------------------------------

<<asmcomp/linearize.ml>>=
<<copyright header>>

(* Transformation of Mach code into a list of pseudo-instructions. *)

open Reg
open Mach

<<type [[Linearize.label]]([[(asmcomp/linearize.ml)]])>>

<<constant [[Linearize.label_counter]]>>

<<function [[Linearize.new_label]]>>

<<type [[Linearize.instruction]]([[(asmcomp/linearize.ml)]])>>

<<type [[Linearize.instruction_desc]]([[(asmcomp/linearize.ml)]])>>

<<type [[Linearize.fundecl]]([[(asmcomp/linearize.ml)]])>>

<<function [[Linearize.invert_integer_test]]>>

<<function [[Linearize.invert_test]]>>

<<constant [[Linearize.end_instr]]>>

<<function [[Linearize.instr_cons]]>>

<<function [[Linearize.cons_instr]]>>

<<function [[Linearize.copy_instr]]>>

<<function [[Linearize.get_label]]>>

<<function [[Linearize.discard_dead_code]]>>

<<function [[Linearize.add_branch]]>>

<<constant [[Linearize.exit_label]]>>

<<function [[Linearize.linear]]>>

<<function [[Linearize.fundecl]]>>

@


\subsection*{[[asmcomp/printlinear.mli]]}

<<signature [[Printlinear.instr]]>>=
val instr: instruction -> unit
@

<<signature [[Printlinear.fundecl]]>>=
val fundecl: fundecl -> unit
@


%-------------------------------------------------------------

<<asmcomp/printlinear.mli>>=
<<copyright header>>

(* Pretty-printing of linearized machine code *)

open Linearize

<<signature [[Printlinear.instr]]>>
<<signature [[Printlinear.fundecl]]>>
@


\subsection*{[[asmcomp/printlinear.ml]]}

<<function [[Printlinear.label]]>>=
let label l =
  print_string "L"; print_int l
@

<<function [[Printlinear.instr]]>>=
let instr i =
  match i.desc with
    Lend -> ()
  | Lop op ->
      begin match op with
        Ialloc _ | Icall_ind | Icall_imm _ | Iextcall(_, _) ->
          open_box 1;
          print_string "{";
          regsetaddr i.live;
          print_string "}";
          close_box();
          print_cut()
      | _ -> ()
      end;
      operation op i.arg i.res
  | Lreloadretaddr ->
      print_string "reload retaddr"
  | Lreturn ->
      print_string "return "; regs i.arg
  | Llabel lbl ->
      label lbl; print_string ":"
  | Lbranch lbl ->
      print_string "goto "; label lbl
  | Lcondbranch(tst, lbl) ->
      print_string "if "; test tst i.arg; print_string " goto "; label lbl
  | Lcondbranch3(lbl0, lbl1, lbl2) ->
      print_string "switch3 "; reg i.arg.(0);
      let case n = function
        None -> ()
      | Some lbl ->
          print_cut();
          print_string "case "; print_int n;
          print_string ": goto "; label lbl in
      case 0 lbl0; case 1 lbl1; case 2 lbl2;
      print_cut(); print_string "endswitch"
  | Lswitch lblv ->
      print_string "switch "; reg i.arg.(0);
      for i = 0 to Array.length lblv - 1 do
        print_cut();
        print_string "case "; print_int i;
        print_string ": goto "; label lblv.(i)
      done;
      print_cut(); print_string "endswitch"
  | Lsetuptrap lbl ->
      print_string "setup trap "; label lbl
  | Lpushtrap ->
      print_string "push trap"
  | Lpoptrap ->
      print_string "pop trap"
  | Lraise ->
      print_string "raise "; reg i.arg.(0)
@

<<function [[Printlinear.all_instr]]>>=
let rec all_instr i =
  match i.desc with
    Lend -> ()
  | _ -> instr i; print_cut(); all_instr i.next
@

<<function [[Printlinear.fundecl]]>>=
let fundecl f =
  open_vbox 2;
  print_string f.fun_name; print_string ":"; print_cut();
  all_instr f.fun_body;
  close_box()
@


%-------------------------------------------------------------

<<asmcomp/printlinear.ml>>=
<<copyright header>>

(* Pretty-printing of linearized machine code *)

open Format
open Mach
open Printmach
open Linearize

<<function [[Printlinear.label]]>>

<<function [[Printlinear.instr]]>>

<<function [[Printlinear.all_instr]]>>

<<function [[Printlinear.fundecl]]>>
@


\subsection*{[[asmcomp/spill.mli]]}

<<signature [[Spill.fundecl]]>>=
(* Insertion of moves to suggest possible spilling / reloading points 
   before register allocation. *)

val fundecl: Mach.fundecl -> Mach.fundecl
@


%-------------------------------------------------------------

<<asmcomp/spill.mli>>=
<<copyright header>>

<<signature [[Spill.fundecl]]>>
@


\subsection*{[[asmcomp/spill.ml]]}

<<constant [[Spill.spill_env]]>>=
(* Association of spill registers to registers *)

let spill_env = ref ((*Reg.*)Map.empty: (Reg.t , Reg.t) (*Reg.*)Map.t)
@

<<function [[Spill.spill_reg]]>>=
let spill_reg r =
  try
    (*Reg.*)Map.find r !spill_env
  with Not_found ->
    let spill_r = Reg.create r.typ in
    spill_r.spill <- true;
    if String.length r.name > 0 then spill_r.name <- "spilled-" ^ r.name;
    spill_env := (*Reg.*)Map.add r spill_r !spill_env;
    spill_r
@

<<constant [[Spill.use_date]]>>=
(* Record the position of last use of registers *)

let use_date = ref ((*Reg.*)Map.empty: (Reg.t, int) (*Reg.*)Map.t)
@

<<constant [[Spill.current_date]]>>=
let current_date = ref 0
@

<<function [[Spill.record_use]]>>=
let record_use regv =
  for i = 0 to Array.length regv - 1 do
    let r = regv.(i) in
    let prev_date = try (*Reg.*)Map.find r !use_date with Not_found -> 0 in
    if !current_date > prev_date then
      use_date := (*Reg.*)Map.add r !current_date !use_date
  done
@

<<function [[Spill.add_superpressure_regs]]>>=
(* Check if the register pressure overflows the maximum pressure allowed
   at that point. If so, spill enough registers to lower the pressure. *)

let add_superpressure_regs op live_regs res_regs spilled =
  let max_pressure = Proc.max_register_pressure op in
  let regs = Reg.add_set_array live_regs res_regs in
  (* Compute the pressure in each register class *)
  let pressure = Array.create Proc.num_register_classes 0 in
  (*Reg.*)Set.iter
    (fun r ->
      if (*Reg.*)Set.mem r spilled then () else begin
        match r.loc with
          Stack s -> ()
        | _ -> let c = Proc.register_class r in
               pressure.(c) <- pressure.(c) + 1
      end)
    regs;
  (* Check if pressure is exceeded for each class. *)
  let rec check_pressure cl spilled =
    if cl >= Proc.num_register_classes then
      spilled
    else if pressure.(cl) <= max_pressure.(cl) then
      check_pressure (cl+1) spilled
    else begin
      (* Find the least recently used, unspilled, unallocated, live register
         in the class *)
      let lru_date = ref 1000000 and lru_reg = ref Reg.dummy in
      (*Reg.*)Set.iter
        (fun r ->
          if Proc.register_class r = cl &
             not ((*Reg.*)Set.mem r spilled) &
             r.loc = Unknown then begin
            try
              let d = (*Reg.*)Map.find r !use_date in
              if d < !lru_date then begin
                lru_date := d;
                lru_reg := r
              end
            with Not_found ->                 (* Should not happen *)
              ()
          end)
        live_regs;
      pressure.(cl) <- pressure.(cl) - 1;
      check_pressure cl ((*Reg.*)Set.add !lru_reg spilled)
    end in
  check_pressure 0 spilled
@

<<constant [[Spill.destroyed_at_fork]]>>=
(* A-list recording what is destroyed at if-then-else points. *)

let destroyed_at_fork = ref ([] : (instruction * Reg.t Set.t) list)
@

<<function [[Spill.add_reloads]]>>=
(* First pass: insert reload instructions based on an approximation of
   what is destroyed at pressure points. *)

let add_reloads regset i =
  (*Reg.*)Set.fold
    (fun r i -> instr_cons (Iop Ireload) [|spill_reg r|] [|r|] i)
    regset i
@

<<constant [[Spill.reload_at_exit]]>>=
let reload_at_exit = ref (*Reg.*)Set.empty
@

<<constant [[Spill.reload_at_break]]>>=
let reload_at_break = ref (*Reg.*)Set.empty
@

<<function [[Spill.reload]]>>=
let rec reload i before =
  incr current_date;
  record_use i.arg;
  record_use i.res;
  match i.desc with
    Iend ->
      (i, before)
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (add_reloads (Reg.inter_set_array before i.arg) i,
       (*Reg.*)Set.empty)
  | Iop(Icall_ind | Icall_imm _ | Iextcall(_, true)) ->
      (* All regs live across must be spilled *)
      let (new_next, finally) = reload i.next i.live in
      (add_reloads (Reg.inter_set_array before i.arg)
                   (instr_cons i.desc i.arg i.res new_next),
       finally)
  | Iop op ->
      let new_before =
        (* Quick check to see if the register pressure is below the maximum *)
        if (*Reg.*)Set.cardinal i.live + Array.length i.res <=
           Proc.safe_register_pressure op
        then before
        else add_superpressure_regs op i.live i.res before in
      let after =
        Reg.diff_set_array (Reg.diff_set_array new_before i.arg) i.res in
      let (new_next, finally) = reload i.next after in
      (add_reloads (Reg.inter_set_array new_before i.arg)
                   (instr_cons i.desc i.arg i.res new_next),
       finally)
  | Iifthenelse(test, ifso, ifnot) ->
      let at_fork = Reg.diff_set_array before i.arg in
      let date_fork = !current_date in
      let (new_ifso, after_ifso) = reload ifso at_fork in
      let date_ifso = !current_date in
      current_date := date_fork;
      let (new_ifnot, after_ifnot) = reload ifnot at_fork in
      current_date := max date_ifso !current_date;
      let (new_next, finally) =
        reload i.next ((*Reg.*)Set.union after_ifso after_ifnot) in
      let new_i =
        instr_cons (Iifthenelse(test, new_ifso, new_ifnot))
        i.arg i.res new_next in
      destroyed_at_fork := (new_i, at_fork) :: !destroyed_at_fork;
      (add_reloads (Reg.inter_set_array before i.arg) new_i,
       finally)
  | Iswitch(index, cases) ->
      let at_fork = Reg.diff_set_array before i.arg in
      let date_fork = !current_date in
      let date_join = ref 0 in
      let after_cases = ref (*Reg.*)Set.empty in
      let new_cases =
        Array.map
          (fun c ->
            current_date := date_fork;
            let (new_c, after_c) = reload c at_fork in
            after_cases := (*Reg.*)Set.union !after_cases after_c;
            date_join := max !date_join !current_date;
            new_c)
          cases in
      current_date := !date_join;
      let (new_next, finally) = reload i.next !after_cases in
      (add_reloads (Reg.inter_set_array before i.arg)
                   (instr_cons (Iswitch(index, new_cases))
                               i.arg i.res new_next),
       finally)
  | Iloop(body) ->
      let date_start = !current_date in
      let at_head = ref before in
      let final_body = ref body in
      begin try
        while true do
          current_date := date_start;
          let (new_body, new_at_head) = reload body !at_head in
          let merged_at_head = (*Reg.*)Set.union !at_head new_at_head in
          if (*Reg.*)Set.equal merged_at_head !at_head then begin
            final_body := new_body;
            raise Exit
          end;
          at_head := merged_at_head
        done
      with Exit -> ()
      end;
      let (new_next, finally) = reload i.next (*Reg.*)Set.empty in
      (instr_cons (Iloop(!final_body)) i.arg i.res new_next,
       finally)
  | Icatch(body, handler) ->
      let saved_reload_at_exit = !reload_at_exit in
      reload_at_exit := (*Reg.*)Set.empty;
      let (new_body, after_body) = reload body before in
      let at_exit = !reload_at_exit in
      reload_at_exit := saved_reload_at_exit;
      let (new_handler, after_handler) = reload handler at_exit in
      let (new_next, finally) =
        reload i.next ((*Reg.*)Set.union after_body after_handler) in
      (instr_cons (Icatch(new_body, new_handler)) i.arg i.res new_next,
       finally)
  | Iexit ->
      reload_at_exit := (*Reg.*)Set.union !reload_at_exit before;
      (i, (*Reg.*)Set.empty)
  | Itrywith(body, handler) ->
      let (new_body, after_body) = reload body before in
      let (new_handler, after_handler) = reload handler handler.live in
      let (new_next, finally) =
        reload i.next ((*Reg.*)Set.union after_body after_handler) in
      (instr_cons (Itrywith(new_body, new_handler)) i.arg i.res new_next,
       finally)
  | Iraise ->
      (add_reloads (Reg.inter_set_array before i.arg) i, (*Reg.*)Set.empty)
@

<<constant [[Spill.spill_at_exit]]>>=
(* As an optimization, if a register needs to be spilled in one branch of
   a conditional but not in the other, then we spill it late on entrance
   in the branch that needs it spilled.
   This strategy is turned off in loops, as it may prevent a spill from
   being lifted up all the way out of the loop. *)

let spill_at_exit = ref (*Reg.*)Set.empty
@

<<constant [[Spill.spill_at_raise]]>>=
let spill_at_raise = ref (*Reg.*)Set.empty
@

<<constant [[Spill.inside_loop]]>>=
let inside_loop = ref false
@

<<function [[Spill.add_spills]]>>=
let add_spills regset i =
  (*Reg.*)Set.fold
    (fun r i -> instr_cons (Iop Ispill) [|r|] [|spill_reg r|] i)
    regset i
@

<<function [[Spill.spill]]>>=
let rec spill i finally =
  match i.desc with
    Iend ->
      (i, finally)
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (i, (*Reg.*)Set.empty)
  | Iop Ireload ->
      let (new_next, after) = spill i.next finally in
      let before1 = Reg.diff_set_array after i.res in
      (instr_cons i.desc i.arg i.res new_next,
       Reg.add_set_array before1 i.res)
  | Iop _ ->
      let (new_next, after) = spill i.next finally in
      let before1 = Reg.diff_set_array after i.res in
      let before =
        match i.desc with
          Iop(Icall_ind) | Iop(Icall_imm _) | Iop(Iextcall(_, _)) ->
            (*Reg.*)Set.union before1 !spill_at_raise
        | _ ->
            before1 in
      (instr_cons i.desc i.arg i.res
                  (add_spills (Reg.inter_set_array after i.res) new_next),
       before)
  | Iifthenelse(test, ifso, ifnot) ->
      let (new_next, at_join) = spill i.next finally in
      let (new_ifso, before_ifso) = spill ifso at_join in
      let (new_ifnot, before_ifnot) = spill ifnot at_join in
      if !inside_loop then
        (instr_cons (Iifthenelse(test, new_ifso, new_ifnot))
                     i.arg i.res new_next,
         (*Reg.*)Set.union before_ifso before_ifnot)
      else begin
        let destroyed = List.assq i !destroyed_at_fork in
        let spill_ifso_branch =
          (*Reg.*)Set.diff ((*Reg.*)Set.diff before_ifso before_ifnot) destroyed
        and spill_ifnot_branch =
          (*Reg.*)Set.diff ((*Reg.*)Set.diff before_ifnot before_ifso) destroyed in
        (instr_cons
            (Iifthenelse(test, add_spills spill_ifso_branch new_ifso,
                               add_spills spill_ifnot_branch new_ifnot))
            i.arg i.res new_next,
         (*Reg.*)Set.diff ((*Reg.*)Set.diff ((*Reg.*)Set.union before_ifso before_ifnot)
                                    spill_ifso_branch)
                       spill_ifnot_branch)
      end
  | Iswitch(index, cases) ->
      let (new_next, at_join) = spill i.next finally in
      let before = ref (*Reg.*)Set.empty in
      let new_cases =
        Array.map
          (fun c ->
            let (new_c, before_c) = spill c at_join in
            before := (*Reg.*)Set.union !before before_c;
            new_c)
          cases in
      (instr_cons (Iswitch(index, new_cases)) i.arg i.res new_next,
       !before)
  | Iloop(body) ->
      let (new_next, _) = spill i.next finally in
      let saved_inside_loop = !inside_loop in
      inside_loop := true;
      let at_head = ref (*Reg.*)Set.empty in
      let final_body = ref body in
      begin try
        while true do
          let (new_body, before_body) = spill body !at_head in
          let new_at_head = (*Reg.*)Set.union !at_head before_body in
          if (*Reg.*)Set.equal new_at_head !at_head then begin
            final_body := new_body; raise Exit
          end;
          at_head := new_at_head
        done
      with Exit -> ()
      end;
      inside_loop := saved_inside_loop;
      (instr_cons (Iloop(!final_body)) i.arg i.res new_next,
       !at_head)
  | Icatch(body, handler) ->
      let (new_next, at_join) = spill i.next finally in
      let (new_handler, at_exit) = spill handler at_join in
      let saved_spill_at_exit = !spill_at_exit in
      spill_at_exit := at_exit;
      let (new_body, before) = spill body at_join in
      spill_at_exit := saved_spill_at_exit;
      (instr_cons (Icatch(new_body, new_handler)) i.arg i.res new_next,
       before)
  | Iexit ->
      (i, !spill_at_exit)
  | Itrywith(body, handler) ->
      let (new_next, at_join) = spill i.next finally in
      let (new_handler, before_handler) = spill handler at_join in
      let saved_spill_at_raise = !spill_at_raise in
      spill_at_raise := before_handler;
      let (new_body, before_body) = spill body at_join in
      spill_at_raise := saved_spill_at_raise;
      (instr_cons (Itrywith(new_body, new_handler)) i.arg i.res new_next,
       before_body)
  | Iraise ->
      (i, !spill_at_raise)
@

<<function [[Spill.fundecl]]>>=
(* Entry point *)

let fundecl f =
  spill_env := (*Reg.*)Map.empty;
  use_date := (*Reg.*)Map.empty;
  current_date := 0;
  let (body1, _) = reload f.fun_body (*Reg.*)Set.empty in
  let (body2, tospill_at_entry) = spill body1 (*Reg.*)Set.empty in
  let new_body =
    add_spills (Reg.inter_set_array tospill_at_entry f.fun_args) body2 in
  spill_env := (*Reg.*)Map.empty;
  use_date := (*Reg.*)Map.empty;
  { fun_name = f.fun_name;
    fun_args = f.fun_args;
    fun_body = new_body;
    fun_fast = f.fun_fast }
@


%-------------------------------------------------------------

<<asmcomp/spill.ml>>=
<<copyright header>>

(* Insertion of moves to suggest possible spilling / reloading points 
   before register allocation. *)

open Reg
open Mach

(* We say that a register is "destroyed" if it is live across a construct
   that potentially destroys all physical registers: function calls or
   try...with constructs.

   The "destroyed" registers must therefore reside in the stack during
   these instructions.. We will insert spills (stores) just after they
   are defined, and reloads just before their first use following a
   "destroying" construct.

   Instructions with more live registers than actual registers also
   "destroy" registers: we mark as "destroyed" the registers live
   across the instruction that haven't been used for the longest time.
   These registers will be spilled and reloaded as described above. *)

<<constant [[Spill.spill_env]]>>

<<function [[Spill.spill_reg]]>>

<<constant [[Spill.use_date]]>>
<<constant [[Spill.current_date]]>>

<<function [[Spill.record_use]]>>

<<function [[Spill.add_superpressure_regs]]>>

<<constant [[Spill.destroyed_at_fork]]>>

<<function [[Spill.add_reloads]]>>

<<constant [[Spill.reload_at_exit]]>>
<<constant [[Spill.reload_at_break]]>>

<<function [[Spill.reload]]>>

(* Second pass: add spill instructions based on what we've decided to reload.
   That is, any register that may be reloaded in the future must be spilled
   just after its definition. *)

<<constant [[Spill.spill_at_exit]]>>
<<constant [[Spill.spill_at_raise]]>>
<<constant [[Spill.inside_loop]]>>

<<function [[Spill.add_spills]]>>

<<function [[Spill.spill]]>>

<<function [[Spill.fundecl]]>>
  
@


\subsection*{[[asmcomp/selectgen.mli]]}

<<type [[Selectgen.environment]]>>=
(* Selection of pseudo-instructions, assignment of pseudo-registers,
   sequentialization. *)

type environment = (Ident.t, Reg.t array) Tbl.t
@

<<signature [[Selectgen.size_expr]]>>=
val size_expr : environment -> Cmm.expression -> int
@

<<type [[Selectgen.selector]]>>=
type selector = {
  (* old: virtuals *)

  (* The following methods must or can be overriden by the processor
     description *)
  is_immediate : (int -> bool);
    (* Must be defined to indicate whether a constant is a suitable
       immediate operand to arithmetic instructions *)
  select_addressing :
    (Cmm.expression -> Arch.addressing_mode * Cmm.expression);
    (* Must be defined to select addressing modes *)

  (* old: regular *)

  select_operation :
    selector ->
    Cmm.operation ->
    Cmm.expression list -> Mach.operation * Cmm.expression list;
    (* Can be overriden to deal with special arithmetic instructions *)
  select_condition : 
    selector ->
    Cmm.expression -> Mach.test * Cmm.expression;
    (* Can be overriden to deal with special test instructions *)
  select_store :
    Arch.addressing_mode -> Cmm.expression -> Mach.operation * Cmm.expression;
    (* Can be overriden to deal with special store constant instructions *)
  insert_op :
    selector ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array;
    (* Can be overriden to deal with 2-address instructions
       or instructions with hardwired input/output registers *)
  emit_extcall_args :
    selector ->
    environment -> Cmm.expression list -> Reg.t array * int;
    (* Can be overriden to deal with stack-based calling conventions *)

  (* The following method is the entry point and should not be overriden *)
  emit_fundecl : 
    selector ->
    Cmm.fundecl -> Mach.fundecl;
  
  (* The following methods should not be overriden.  They cannot be
     declared "private" in the current implementation because they
     are not always applied to "self", but ideally they should be private. *)
  extract : Mach.instruction;
  insert : Mach.instruction_desc -> Reg.t array -> Reg.t array -> unit;
  insert_move : 
    selector ->
    Reg.t -> Reg.t -> unit;
  insert_move_args : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_move_results : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_moves : 
    selector ->
    Reg.t array -> Reg.t array -> unit;
  emit_expr :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> Reg.t array;

  emit_tail : 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> unit;


  (* old: protected *)

  select_arith_comm: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_shift: 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith_comp: 
     selector -> 
     Mach.integer_comparison -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;


  emit_let :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Ident.t -> Cmm.expression -> 
     (Ident.t, Reg.t array) Tbl.t;
  emit_parts_list:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Cmm.expression list * (Ident.t, Reg.t array) Tbl.t;
  emit_parts:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Cmm.expression * (Ident.t, Reg.t array) Tbl.t;
  emit_tuple:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Reg.t array;
  emit_stores: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> Reg.t array -> 
     Arch.addressing_mode -> unit;
  emit_sequence: 
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Reg.t array * selector;

  emit_return: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     unit;

  emit_tail_sequence: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
    Mach.instruction;

  (* old: in children *)

  select_floatarith: 
   selector ->
   Mach.operation -> 
   Mach.operation -> 
   Arch.float_operation -> 
   Arch.float_operation -> 
   Cmm.expression list -> 
   Mach.operation * Cmm.expression list;

  select_push:
   selector ->
   Cmm.expression -> Mach.operation * Cmm.expression;

}
@

<<signature [[Selectgen.selector_generic]]>>=
val selector_generic: unit -> selector
@


%-------------------------------------------------------------

<<asmcomp/selectgen.mli>>=
<<copyright header>>

<<type [[Selectgen.environment]]>>

<<signature [[Selectgen.size_expr]]>>


<<type [[Selectgen.selector]]>>

<<signature [[Selectgen.selector_generic]]>>


(*
  is_immediate = super.is_immediate;
  select_addressing = super.select_addressing;
  select_operation = super.select_operation;
  select_condition = super.select_condition;
  select_store = super.select_store;
  insert_op = super.insert_op;
  emit_extcall_args = super.emit_extcall_args;
  emit_fundecl = super.emit_fundecl;
  extract = super.extract;
  insert = super.insert;
  insert_move = super.insert_move;
  insert_move_args = super.insert_move_args;
  insert_move_results = super.insert_move_results;
  insert_moves = super.insert_moves;
  emit_expr = super.emit_expr;
  emit_tail = super.emit_tail;
  select_arith_comm = super.select_arith_comm;
  select_arith = super.select_arith;
  select_shift = super.select_shift;
  select_arith_comp = super.select_arith_comp;
  emit_let = super.emit_let;
  emit_parts_list = super.emit_parts_list;
  emit_parts = super.emit_parts;
  emit_tuple = super.emit_tuple;
  emit_stores = super.emit_stores;
  emit_sequence = super.emit_sequence;
  emit_return = super.emit_return;
  emit_tail_sequence = super.emit_tail_sequence;
  select_floatarith = super.select_floatarith;
  select_push = super.select_push;
*)
@


\subsection*{[[asmcomp/selectgen.ml]]}

<<type [[Selectgen.environment]]([[(asmcomp/selectgen.ml)]])>>=
type environment = (Ident.t, Reg.t array) Tbl.t
@

<<type [[Selectgen.selector]]([[(asmcomp/selectgen.ml)]])>>=
type selector = {
  (* The following methods must or can be overriden by the processor
     description *)
  is_immediate : (int -> bool);
    (* Must be defined to indicate whether a constant is a suitable
       immediate operand to arithmetic instructions *)
  select_addressing :
    (Cmm.expression -> Arch.addressing_mode * Cmm.expression);
    (* Must be defined to select addressing modes *)

  select_operation :
    selector ->
    Cmm.operation ->
    Cmm.expression list -> Mach.operation * Cmm.expression list;
    (* Can be overriden to deal with special arithmetic instructions *)
  select_condition : 
    selector ->
    Cmm.expression -> Mach.test * Cmm.expression;
    (* Can be overriden to deal with special test instructions *)
  select_store :
    Arch.addressing_mode -> Cmm.expression -> Mach.operation * Cmm.expression;
    (* Can be overriden to deal with special store constant instructions *)
  insert_op :
    selector ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array;
    (* Can be overriden to deal with 2-address instructions
       or instructions with hardwired input/output registers *)
  emit_extcall_args :
    selector ->
    environment -> Cmm.expression list -> Reg.t array * int;
    (* Can be overriden to deal with stack-based calling conventions *)

  (* The following method is the entry point and should not be overriden *)
  emit_fundecl : 
    selector ->
    Cmm.fundecl -> Mach.fundecl;
  
  (* The following methods should not be overriden.  They cannot be
     declared "private" in the current implementation because they
     are not always applied to "self", but ideally they should be private. *)
  extract : Mach.instruction;
  insert : Mach.instruction_desc -> Reg.t array -> Reg.t array -> unit;
  insert_move : 
    selector ->
    Reg.t -> Reg.t -> unit;
  insert_move_args : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_move_results : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_moves : 
    selector ->
    Reg.t array -> Reg.t array -> unit;
  emit_expr :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> Reg.t array;

  emit_tail : 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> unit;



  select_arith_comm: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_shift: 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith_comp: 
     selector -> 
     Mach.integer_comparison -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;


  emit_let :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Ident.t -> Cmm.expression -> 
     (Ident.t, Reg.t array) Tbl.t;
  emit_parts_list:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Cmm.expression list * (Ident.t, Reg.t array) Tbl.t;
  emit_parts:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Cmm.expression * (Ident.t, Reg.t array) Tbl.t;
  emit_tuple:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Reg.t array;
  emit_stores: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> Reg.t array -> 
     Arch.addressing_mode -> unit;
  emit_sequence: 
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Reg.t array * selector;

  emit_return: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     unit;

  emit_tail_sequence: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
    Mach.instruction;


   (* in children *)
  select_floatarith:
   selector ->
   Mach.operation -> 
   Mach.operation -> 
   Arch.float_operation -> 
   Arch.float_operation -> 
   Cmm.expression list -> 
   Mach.operation * Cmm.expression list;

  select_push:
   selector ->
   Cmm.expression -> Mach.operation * Cmm.expression;

}
@

<<function [[Selectgen.oper_result_type]]>>=
(* Infer the type of the result of an operation *)

let oper_result_type = function
    Capply ty -> ty
  | Cextcall(s, ty, alloc) -> ty
  | Cload ty -> ty
  | Cloadchunk c -> typ_int
  | Calloc -> typ_addr
  | Cstore -> typ_void
  | Cstorechunk c -> typ_void
  | Caddi | Csubi | Cmuli | Cdivi | Cmodi
  | Cand | Cor | Cxor | Clsl | Clsr | Casr
  | Ccmpi _ | Ccmpa _ | Ccmpf _ -> typ_int
  | Cadda | Csuba -> typ_addr
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> typ_float
  | Cfloatofint -> typ_float
  | Cintoffloat -> typ_int
  | Craise -> typ_void
  | Ccheckbound -> typ_void
  | _ -> fatal_error "Selection.oper_result_type"
@

<<function [[Selectgen.size_expr]]>>=
(* Infer the size in bytes of the result of a simple expression *)

let size_expr env exp =
  let rec size localenv = function
      Cconst_int _ | Cconst_natint _ -> Arch.size_int
    | Cconst_symbol _ | Cconst_pointer _ -> Arch.size_addr
    | Cconst_float _ -> Arch.size_float
    | Cvar id ->
        begin try
          Tbl.find id localenv
        with Not_found ->
        try
          let regs = Tbl.find id env in
          size_machtype (Array.map (fun r -> r.typ) regs)
        with Not_found ->
          fatal_error("Selection.size_expr: unbound var " ^ Ident.name id)
        end
    | Ctuple el ->
        List.fold_right (fun e sz -> size localenv e + sz) el 0
    | Cop(op, args) ->
        size_machtype(oper_result_type op)
    | Clet(id, arg, body) ->
        size (Tbl.add id (size localenv arg) localenv) body
    | _ ->
        fatal_error "Selection.size_expr"
  in size Tbl.empty exp
@

<<function [[Selectgen.is_simple_expr]]>>=
(* Says if an expression is "simple". A "simple" expression has no
   side-effects and its execution can be delayed until its value
   is really needed. In the case of e.g. an [alloc] instruction,
   the non-simple arguments are computed in right-to-left order
   first, then the block is allocated, then the simple arguments are
   evaluated and stored. *)

let rec is_simple_expr = function
    Cconst_int _ -> true
  | Cconst_natint _ -> true
  | Cconst_float _ -> true
  | Cconst_symbol _ -> true
  | Cconst_pointer _ -> true
  | Cvar _ -> true
  | Ctuple el -> List.for_all is_simple_expr el
  | Clet(id, arg, body) -> is_simple_expr arg && is_simple_expr body
  | Cop(op, args) ->
      begin match op with
        (* The following may have side effects *)
        Capply _ | Cextcall(_, _, _) | Calloc | Cstore | Cstorechunk _ | 
        Craise -> false
        (* The remaining operations are simple if their args are *)
      | _ -> List.for_all is_simple_expr args
      end
  | _ -> false
@

<<function [[Selectgen.swap_intcomp]]>>=
(* Swap the two arguments of an integer comparison *)

let swap_intcomp = function
    Isigned cmp -> Isigned(swap_comparison cmp)
  | Iunsigned cmp -> Iunsigned(swap_comparison cmp)
@

<<function [[Selectgen.all_regs_anonymous]]>>=
(* Naming of registers *)

let all_regs_anonymous rv =
  try
    for i = 0 to Array.length rv - 1 do
      if String.length rv.(i).name > 0 then raise Exit
    done;
    true
  with Exit ->
    false
@

<<function [[Selectgen.name_regs]]>>=
let name_regs id rv =
  if Array.length rv = 1 then
    rv.(0).name <- Ident.name id
  else
    for i = 0 to Array.length rv - 1 do
      rv.(i).name <- Ident.name id ^ "#" ^ string_of_int i
    done
@

<<function [[Selectgen.join]]>>=
(* "Join" two instruction sequences, making sure they return their results
   in the same registers. *)

let join r1 seq1 r2 seq2 =
  let l1 = Array.length r1 and l2 = Array.length r2 in
  if l1 = 0 then r2
  else if l2 = 0 then r1
  else begin
    let r = Array.create l1 Reg.dummy in
    for i = 0 to l1-1 do
      if String.length r1.(i).name = 0 then begin
        r.(i) <- r1.(i);
        seq2.insert_move seq2 r2.(i) r1.(i)
      end else if String.length r2.(i).name = 0 then begin
        r.(i) <- r2.(i);
        seq1.insert_move seq1 r1.(i) r2.(i)
      end else begin
        r.(i) <- Reg.create r1.(i).typ;
        seq1.insert_move seq1 r1.(i) r.(i);
        seq2.insert_move seq1 r2.(i) r.(i)
      end
    done;
    r
  end
@

<<function [[Selectgen.join_array]]>>=
(* Same, for N branches *)

let join_array rs =
  let some_res = ref [||] in
  for i = 0 to Array.length rs - 1 do
    let (r, s) = rs.(i) in
    if Array.length r > 0 then some_res := r
  done;
  let size_res = Array.length !some_res in
  if size_res = 0 then [||] else begin
    let res = Array.create size_res Reg.dummy in
    for i = 0 to size_res - 1 do
      res.(i) <- Reg.create (!some_res).(i).typ
    done;
    for i = 0 to Array.length rs - 1 do
      let (r, s) = rs.(i) in
      if Array.length r > 0 then s.insert_moves s r res
    done;
    res
  end
@

<<function [[Selectgen.selector_generic]]>>=
(* The default instruction selection class *)

let selector_generic () =
 let instr_seq = ref dummy_instr in
 {

(* Says whether an integer constant is a suitable immediate argument *)

 is_immediate = (fun _ -> 
  failwith "virtual: selector_generic.is_immediate");

(* Selection of addressing modes *)

 select_addressing = (fun _ -> 
   failwith "virtual: selector_generic.select_addr");

(* Default instruction selection for stores *)

 select_store = (fun addr arg ->
  (Istore(Word, addr), arg)
 );

(* Default instruction selection for operators *)

 select_operation = (fun self op args ->
  match (op, args) with
    (Capply ty, Cconst_symbol s :: rem) -> (Icall_imm s, rem)
  | (Capply ty, _) -> (Icall_ind, args)
  | (Cextcall(s, ty, alloc), _) -> (Iextcall(s, alloc), args)
  | (Cload ty, [arg]) ->
      let (addr, eloc) = self.select_addressing arg in
      (Iload(Word, addr), [eloc])
  | (Cloadchunk chunk, [arg]) ->
      let (addr, eloc) = self.select_addressing arg in
      (Iload(chunk, addr), [eloc])
  | (Cstore, [arg1; arg2]) ->
      let (addr, eloc) = self.select_addressing arg1 in
      let (op, newarg2) = self.select_store addr arg2 in
      (op, [newarg2; eloc])
      (* Inversion addr/datum in Istore *)
  | (Cstorechunk chunk, [arg1; arg2]) ->
      let (addr, eloc) = self.select_addressing arg1 in
      (Istore(chunk, addr), [arg2; eloc])
      (* Inversion addr/datum in Istore *)
  | (Calloc, _) -> (Ialloc 0, args)
  | (Caddi, _) -> self.select_arith_comm self Iadd args
  | (Csubi, _) -> self.select_arith self Isub args
  | (Cmuli, [arg1; Cconst_int n]) ->
      let l = Misc.log2 n in
      if n = 1 lsl l
      then (Iintop_imm(Ilsl, l), [arg1])
      else self.select_arith_comm self Imul args
  | (Cmuli, [Cconst_int n; arg1]) ->
      let l = Misc.log2 n in
      if n = 1 lsl l
      then (Iintop_imm(Ilsl, l), [arg1])
      else self.select_arith_comm self Imul args
  | (Cmuli, _) -> self.select_arith_comm self Imul args
  | (Cdivi, _) -> self.select_arith self Idiv args
  | (Cmodi, _) -> self.select_arith_comm self Imod args
  | (Cand, _) -> self.select_arith_comm self Iand args
  | (Cor, _) -> self.select_arith_comm self Ior args
  | (Cxor, _) -> self.select_arith_comm self Ixor args
  | (Clsl, _) -> self.select_shift Ilsl args
  | (Clsr, _) -> self.select_shift Ilsr args
  | (Casr, _) -> self.select_shift Iasr args
  | (Ccmpi comp, _) -> self.select_arith_comp self (Isigned comp) args
  | (Cadda, _) -> self.select_arith_comm self Iadd args
  | (Csuba, _) -> self.select_arith self Isub args
  | (Ccmpa comp, _) -> self.select_arith_comp self (Iunsigned comp) args
  | (Cnegf, _) -> (Inegf, args)
  | (Cabsf, _) -> (Iabsf, args)
  | (Caddf, _) -> (Iaddf, args)
  | (Csubf, _) -> (Isubf, args)  
  | (Cmulf, _) -> (Imulf, args)  
  | (Cdivf, _) -> (Idivf, args)
  | (Cfloatofint, _) -> (Ifloatofint, args)
  | (Cintoffloat, _) -> (Iintoffloat, args)
  | (Ccheckbound, _) -> self.select_arith self Icheckbound args
  | _ -> fatal_error "Selection.select_oper"
 );

 select_arith_comm = (fun self op -> function
    [arg; Cconst_int n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [arg; Cconst_pointer n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [Cconst_int n; arg] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [Cconst_pointer n; arg] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | args ->
       (Iintop op, args)
 );

 select_arith = (fun self op -> function
    [arg; Cconst_int n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [arg; Cconst_pointer n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | args ->
      (Iintop op, args)
 );

 select_shift = (fun op -> function
    [arg; Cconst_int n] when n >= 0 & n < Arch.size_int * 8 ->
      (Iintop_imm(op, n), [arg])
  | args ->
      (Iintop op, args)
 );

 select_arith_comp = (fun self cmp -> function
    [arg; Cconst_int n] when self.is_immediate n ->
      (Iintop_imm(Icomp cmp, n), [arg])
  | [arg; Cconst_pointer n] when self.is_immediate n ->
      (Iintop_imm(Icomp cmp, n), [arg])
  | [Cconst_int n; arg] when self.is_immediate n ->
      (Iintop_imm(Icomp(swap_intcomp cmp), n), [arg])
  | [Cconst_pointer n; arg] when self.is_immediate n ->
      (Iintop_imm(Icomp(swap_intcomp cmp), n), [arg])
  | args ->
      (Iintop(Icomp cmp), args)
 );

(* Instruction selection for conditionals *)

 select_condition = (fun self -> function
    Cop(Ccmpi cmp, [arg1; Cconst_int n]) when self.is_immediate n ->
      (Iinttest_imm(Isigned cmp, n), arg1)
  | Cop(Ccmpi cmp, [Cconst_int n; arg2]) when self.is_immediate n ->
      (Iinttest_imm(Isigned(swap_comparison cmp), n), arg2)
  | Cop(Ccmpi cmp, args) ->
      (Iinttest(Isigned cmp), Ctuple args)
  | Cop(Ccmpa cmp, [arg1; Cconst_pointer n]) when self.is_immediate n ->
      (Iinttest_imm(Iunsigned cmp, n), arg1)
  | Cop(Ccmpa cmp, [Cconst_pointer n; arg2]) when self.is_immediate n ->
      (Iinttest_imm(Iunsigned(swap_comparison cmp), n), arg2)
  | Cop(Ccmpa cmp, args) ->
      (Iinttest(Iunsigned cmp), Ctuple args)
  | Cop(Ccmpf cmp, args) ->
      (Ifloattest(cmp, false), Ctuple args)
  | Cop(Cand, [arg; Cconst_int 1]) ->
      (Ioddtest, arg)
  | arg ->
      (Itruetest, arg)
 );

(* Buffering of instruction sequences *)


 insert = (fun desc arg res ->
  instr_seq := instr_cons desc arg res !instr_seq
 );

 extract = (
  let rec extract res i =
    if i == dummy_instr
    then res
    else extract (instr_cons i.desc i.arg i.res res) i.next in
  extract (end_instr()) !instr_seq
 );

(* Insert a sequence of moves from one pseudoreg set to another. *)

 insert_move = (fun self src dst ->
  if src.stamp <> dst.stamp then
    self.insert (Iop Imove) [|src|] [|dst|]
 ); 

 insert_moves = (fun self src dst ->
  for i = 0 to Array.length src - 1 do
    self.insert_move self src.(i) dst.(i)
  done
 );

(* Insert moves and stack offsets for function arguments and results *)

 insert_move_args = (fun self arg loc stacksize ->
  if stacksize <> 0 then self.insert (Iop(Istackoffset stacksize)) [||] [||];
  self.insert_moves self arg loc
 );

 insert_move_results = (fun self loc res stacksize ->
  if stacksize <> 0 then self.insert(Iop(Istackoffset(-stacksize))) [||] [||];
  self.insert_moves self loc res
 );

(* Add an Iop opcode. Can be overriden by processor description
   to insert moves before and after the operation, i.e. for two-address 
   instructions, or instructions using dedicated registers. *)

 insert_op = (fun self op rs rd ->
  self.insert (Iop op) rs rd;
  rd
 );

(* Add the instructions for the given expression
   at the end of the self sequence *)

 emit_expr = (fun self env exp ->
  match exp with
    Cconst_int n ->
      let r = Reg.createv typ_int in
      self.insert_op self (Iconst_int(Nativeint.from n)) [||] r
  | Cconst_natint n ->
      let r = Reg.createv typ_int in
      self.insert_op self (Iconst_int n) [||] r
  | Cconst_float n ->
      let r = Reg.createv typ_float in
      self.insert_op self (Iconst_float n) [||] r
  | Cconst_symbol n ->
      let r = Reg.createv typ_addr in
      self.insert_op self (Iconst_symbol n) [||] r
  | Cconst_pointer n ->
      let r = Reg.createv typ_addr in
      self.insert_op self (Iconst_int(Nativeint.from n)) [||] r
  | Cvar v ->
      begin try
        Tbl.find v env
      with Not_found ->
        fatal_error("Selection.emit_expr: unbound var " ^ Ident.name v)
      end
  | Clet(v, e1, e2) ->
      self.emit_expr self (self.emit_let self env v e1) e2
  | Cassign(v, e1) ->
      let rv =
        try
          Tbl.find v env
        with Not_found ->
          fatal_error ("Selection.emit_expr: unbound var " ^ Ident.name v) in
      let r1 = self.emit_expr self env e1 in
      self.insert_moves self r1 rv;
      [||]
  | Ctuple [] ->
      [||]
  | Ctuple exp_list ->
      let (simple_list, ext_env) = self.emit_parts_list self env exp_list in
      self.emit_tuple self ext_env simple_list
  | Cop(Cproj(ofs, len), [Cop(Cload ty, [arg])]) ->
      let byte_offset = size_machtype(Array.sub ty 0 ofs) in
      self.emit_expr self env
        (Cop(Cload(Array.sub ty ofs len),
             [Cop(Cadda, [arg; Cconst_int byte_offset])]))
  | Cop(Cproj(ofs, len), [arg]) ->
      let r = self.emit_expr self env arg in
      Array.sub r ofs len
  | Cop(Craise, [arg]) ->
      let r1 = self.emit_expr self  env arg in
      let rd = [|Proc.loc_exn_bucket|] in
      self.insert (Iop Imove) r1 rd;
      self.insert Iraise rd [||];
      [||]
  | Cop(Ccmpf comp, args) ->
      self.emit_expr self  env (Cifthenelse(exp, Cconst_int 1, Cconst_int 0))
  | Cop(op, args) ->
      let (simple_args, env) = self.emit_parts_list self env args in
      let ty = oper_result_type op in
      let (new_op, new_args) = self.select_operation self op simple_args in
      begin match new_op with
        Icall_ind ->
          Proc.contains_calls := true;
          let r1 = self.emit_tuple self env new_args in
          let rarg = Array.sub r1 1 (Array.length r1 - 1) in
          let rd = Reg.createv ty in
          let (loc_arg, stack_ofs) = Proc.loc_arguments rarg in
          let loc_res = Proc.loc_results rd in
          self.insert_move_args self rarg loc_arg stack_ofs;
          self.insert (Iop Icall_ind)
                      (Array.append [|r1.(0)|] loc_arg) loc_res;
          self.insert_move_results self loc_res rd stack_ofs;
          rd
      | Icall_imm lbl ->
          Proc.contains_calls := true;
          let r1 = self.emit_tuple self env new_args in
          let rd = Reg.createv ty in
          let (loc_arg, stack_ofs) = Proc.loc_arguments r1 in
          let loc_res = Proc.loc_results rd in
          self.insert_move_args self r1 loc_arg stack_ofs;
          self.insert (Iop(Icall_imm lbl)) loc_arg loc_res;
          self.insert_move_results self loc_res rd stack_ofs;
          rd
      | Iextcall(lbl, alloc) ->
          Proc.contains_calls := true;
          let (loc_arg, stack_ofs) = self.emit_extcall_args self env new_args in
          let rd = Reg.createv ty in
          let loc_res = Proc.loc_external_results rd in
          self.insert (Iop(Iextcall(lbl, alloc))) loc_arg loc_res;
          self.insert_move_results self loc_res rd stack_ofs;
          rd
      | Ialloc _ ->
          Proc.contains_calls := true;
          let rd = Reg.createv typ_addr in
          let size = size_expr env (Ctuple new_args) in
          self.insert (Iop(Ialloc size)) [||] rd;
          self.emit_stores self env new_args rd 
            (Arch.offset_addressing Arch.identity_addressing (-Arch.size_int));
          rd
      | op ->
          let r1 = self.emit_tuple self env new_args in
          let rd = Reg.createv ty in
          self.insert_op self op r1 rd
      end        
  | Csequence(e1, e2) ->
      self.emit_expr self  env e1;
      self.emit_expr self  env e2
  | Cifthenelse(econd, eif, eelse) ->
      let (cond, earg) = self.select_condition self econd in
      let rarg = self.emit_expr self  env earg in
      let (rif, sif) = self.emit_sequence env eif in
      let (relse, selse) = self.emit_sequence env eelse in
      let r = join rif sif relse selse in
      self.insert (Iifthenelse(cond, sif.extract, selse.extract)) rarg [||];
      r
  | Cswitch(esel, index, ecases) ->
      let rsel = self.emit_expr self  env esel in
      let rscases = Array.map (self.emit_sequence env) ecases in
      let r = join_array rscases in
      self.insert (Iswitch(index, Array.map (fun (r, s) -> s.extract) rscases))
                  rsel [||];
      r
  | Cloop(ebody) ->
      let (rarg, sbody) = self.emit_sequence env ebody in
      self.insert (Iloop(sbody.extract)) [||] [||];
      [||]
  | Ccatch(e1, e2) ->
      let (r1, s1) = self.emit_sequence env e1 in
      let (r2, s2) = self.emit_sequence env e2 in
      let r = join r1 s1 r2 s2 in
      self.insert (Icatch(s1.extract, s2.extract)) [||] [||];
      r
  | Cexit ->
      self.insert Iexit [||] [||];
      [||]
  | Ctrywith(e1, v, e2) ->
      Proc.contains_calls := true;
      let (r1, s1) = self.emit_sequence env e1 in
      let rv = Reg.createv typ_addr in
      let (r2, s2) = self.emit_sequence (Tbl.add v rv env) e2 in
      let r = join r1 s1 r2 s2 in
      self.insert
        (Itrywith(s1.extract,
                  instr_cons (Iop Imove) [|Proc.loc_exn_bucket|] rv
                             s2.extract))
        [||] [||];
      r
 );

 emit_sequence = (fun env exp ->
  let s =
   (* {< instr_seq = dummy_instr >}  *)
    failwith "Selectgen.emit_sequence:TODO"
  in
  let r = s.emit_expr s env exp in
  (r, s)
 );

 emit_let = (fun self env v e1 ->
  let r1 = self.emit_expr self  env e1 in
  if all_regs_anonymous r1 then begin
    name_regs v r1;
    Tbl.add v r1 env
  end else begin
    let rv = Array.create (Array.length r1) Reg.dummy in
    for i = 0 to Array.length r1 - 1 do rv.(i) <- Reg.create r1.(i).typ done;
    name_regs v rv;
    self.insert_moves self r1 rv;
    Tbl.add v rv env
  end
 );

 emit_parts = (fun self env exp ->
  if is_simple_expr exp then
    (exp, env)
  else begin
    let r = self.emit_expr self  env exp in
    if Array.length r = 0 then
      (Ctuple [], env)
    else begin
      let id = Ident.create "bind" in
      if all_regs_anonymous r then
        (Cvar id, Tbl.add id r env)
      else begin
        let rv = Array.create (Array.length r) Reg.dummy in
        for i = 0 to Array.length r - 1 do
          rv.(i) <- Reg.create r.(i).typ
        done;
        self.insert_moves self r rv;
        (Cvar id, Tbl.add id rv env)
      end          
    end
  end
 );

 emit_parts_list = (fun self env exp_list ->
  match exp_list with
    [] -> ([], env)
  | exp :: rem ->
      (* This ensures right-to-left evaluation, consistent with the
         bytecode compiler *)
      let (new_rem, new_env) = self.emit_parts_list self env rem in
      let (new_exp, fin_env) = self.emit_parts self new_env exp in
      (new_exp :: new_rem, fin_env)
 );

 emit_tuple = (fun self env exp_list ->
  let rec emit_list = function
    [] -> []
  | exp :: rem ->
      (* Again, force right-to-left evaluation *)
      let loc_rem = emit_list rem in
      let loc_exp = self.emit_expr self  env exp in
      loc_exp :: loc_rem in
  Array.concat(emit_list exp_list)
 );

 emit_extcall_args = (fun self env args ->
  let r1 = self.emit_tuple self env args in
  let (loc_arg, stack_ofs as arg_stack) = Proc.loc_external_arguments r1 in
  self.insert_move_args self r1 loc_arg stack_ofs;
  arg_stack
 );

 emit_stores = (fun self env data regs_addr addr ->
  let a = ref addr in
  List.iter
    (fun e ->
      let (op, arg) = self.select_store !a e in
      let r = self.emit_expr self  env arg in
      self.insert (Iop op) (Array.append r regs_addr) [||];
      a := Arch.offset_addressing !a (size_expr env e))
    data
 );

(* Same, but in tail position *)

 emit_return = (fun self env exp ->
  let r = self.emit_expr self  env exp in
  let loc = Proc.loc_results r in
  self.insert_moves self r loc;
  self.insert Ireturn loc [||]
 );

 emit_tail = (fun self env exp ->
  match exp with
    Clet(v, e1, e2) ->
      self.emit_tail self (self.emit_let self env v e1) e2
  | Cop(Capply ty as op, args) ->
      let (simple_args, env) = self.emit_parts_list self env args in
      let (new_op, new_args) = self.select_operation self op simple_args in
      begin match new_op with
        Icall_ind ->
          let r1 = self.emit_tuple self env new_args in
          let rarg = Array.sub r1 1 (Array.length r1 - 1) in
          let (loc_arg, stack_ofs) = Proc.loc_arguments rarg in
          if stack_ofs = 0 then begin
            self.insert_moves self rarg loc_arg;
            self.insert (Iop Itailcall_ind)
                        (Array.append [|r1.(0)|] loc_arg) [||]
          end else begin
            Proc.contains_calls := true;
            let rd = Reg.createv ty in
            let loc_res = Proc.loc_results rd in
            self.insert_move_args self rarg loc_arg stack_ofs;
            self.insert (Iop Icall_ind)
                        (Array.append [|r1.(0)|] loc_arg) loc_res;
            self.insert(Iop(Istackoffset(-stack_ofs))) [||] [||];
            self.insert Ireturn loc_res [||]
          end
      | Icall_imm lbl ->
          let r1 = self.emit_tuple self env new_args in
          let (loc_arg, stack_ofs) = Proc.loc_arguments r1 in
          if stack_ofs = 0 then begin
            self.insert_moves self r1 loc_arg;
            self.insert (Iop(Itailcall_imm lbl)) loc_arg [||]
          end else begin
            Proc.contains_calls := true;
            let rd = Reg.createv ty in
            let loc_res = Proc.loc_results rd in
            self.insert_move_args self r1 loc_arg stack_ofs;
            self.insert (Iop(Icall_imm lbl)) loc_arg loc_res;
            self.insert(Iop(Istackoffset(-stack_ofs))) [||] [||];
            self.insert Ireturn loc_res [||]
          end
      | _ -> fatal_error "Selection.emit_tail"
      end
  | Cop(Craise, [e1]) ->
      let r1 = self.emit_expr self  env e1 in
      let rd = [|Proc.loc_exn_bucket|] in
      self.insert (Iop Imove) r1 rd;
      self.insert Iraise rd [||]
  | Csequence(e1, e2) ->
      self.emit_expr self env e1;
      self.emit_tail self env e2
  | Cifthenelse(econd, eif, eelse) ->
      let (cond, earg) = self.select_condition self econd in
      let rarg = self.emit_expr self  env earg in
      self.insert (Iifthenelse(cond, self.emit_tail_sequence self env eif,
                                     self.emit_tail_sequence self env eelse))
                  rarg [||]
  | Cswitch(esel, index, ecases) ->
      let rsel = self.emit_expr self  env esel in
      self.insert
        (Iswitch(index, Array.map (self.emit_tail_sequence self env) ecases))
        rsel [||]
  | Ccatch(e1, e2) ->
      self.insert (Icatch(self.emit_tail_sequence self env e1,
                          self.emit_tail_sequence self env e2))
                  [||] [||]
  | Cexit ->
      self.insert Iexit [||] [||]
  | Ctrywith(e1, v, e2) ->
      Proc.contains_calls := true;
      let (r1, s1) = self.emit_sequence env e1 in
      let rv = Reg.createv typ_addr in
      let s2 = self.emit_tail_sequence self (Tbl.add v rv env) e2 in
      let loc = Proc.loc_results r1 in
      self.insert
        (Itrywith(s1.extract,
                  instr_cons (Iop Imove) [|Proc.loc_exn_bucket|] rv s2))
        [||] [||];
      self.insert_moves self r1 loc;
      self.insert Ireturn loc [||]
  | _ ->
      self.emit_return self env exp
 );

 emit_tail_sequence = (fun self env exp ->
  let s = 
   (* {< instr_seq = dummy_instr >}  *)
    failwith "emit_tail_sequence:TODO"
  in
  s.emit_tail s env exp;
  s.extract
 );

(* Sequentialization of a function definition *)

 emit_fundecl = (fun self f ->
  Proc.contains_calls := false;
  let rargs =
    List.map
      (fun (id, ty) -> let r = Reg.createv ty in name_regs id r; r)
      f.Cmm.fun_args in
  let rarg = Array.concat rargs in
  let loc_arg = Proc.loc_parameters rarg in
  let env =
    List.fold_right2
      (fun (id, ty) r env -> Tbl.add id r env)
      f.Cmm.fun_args rargs Tbl.empty in
  self.insert_moves self loc_arg rarg;
  self.emit_tail self env f.Cmm.fun_body;
  { fun_name = f.Cmm.fun_name;
    fun_args = loc_arg;
    fun_body = self.extract;
    fun_fast = f.Cmm.fun_fast }
 );

  select_floatarith = (fun _ -> failwith "select_floatarith");
  select_push = (fun _ -> failwith "select_floatarith");
 }
@


%-------------------------------------------------------------

<<asmcomp/selectgen.ml>>=
<<copyright header>>

(* Selection of pseudo-instructions, assignment of pseudo-registers,
   sequentialization. *)

open Misc
open Cmm
open Reg
open Mach

<<type [[Selectgen.environment]]([[(asmcomp/selectgen.ml)]])>>

<<type [[Selectgen.selector]]([[(asmcomp/selectgen.ml)]])>>




<<function [[Selectgen.oper_result_type]]>>

<<function [[Selectgen.size_expr]]>>

<<function [[Selectgen.is_simple_expr]]>>

<<function [[Selectgen.swap_intcomp]]>>

<<function [[Selectgen.all_regs_anonymous]]>>

<<function [[Selectgen.name_regs]]>>

<<function [[Selectgen.join]]>>

<<function [[Selectgen.join_array]]>>

<<function [[Selectgen.selector_generic]]>>

@


\subsection*{[[asmcomp/cmmgen.mli]]}

<<signature [[Cmmgen.compunit]]>>=
(* Translation from closed lambda to C-- *)

val compunit: int -> Clambda.ulambda -> Cmm.phrase list
@

<<signature [[Cmmgen.apply_function]]>>=
val apply_function: int -> Cmm.phrase
@

<<signature [[Cmmgen.curry_function]]>>=
val curry_function: int -> Cmm.phrase list
@

<<signature [[Cmmgen.entry_point]]>>=
val entry_point: string list -> Cmm.phrase
@

<<signature [[Cmmgen.global_table]]>>=
val global_table: string list -> Cmm.phrase
@

<<signature [[Cmmgen.frame_table]]>>=
val frame_table: string list -> Cmm.phrase
@

<<signature [[Cmmgen.data_segment_table]]>>=
val data_segment_table: string list -> Cmm.phrase
@

<<signature [[Cmmgen.code_segment_table]]>>=
val code_segment_table: string list -> Cmm.phrase
@

<<signature [[Cmmgen.predef_exception]]>>=
val predef_exception: string -> Cmm.phrase
@


%-------------------------------------------------------------

<<asmcomp/cmmgen.mli>>=
<<copyright header>>

<<signature [[Cmmgen.compunit]]>>

<<signature [[Cmmgen.apply_function]]>>
<<signature [[Cmmgen.curry_function]]>>
<<signature [[Cmmgen.entry_point]]>>
<<signature [[Cmmgen.global_table]]>>
<<signature [[Cmmgen.frame_table]]>>
<<signature [[Cmmgen.data_segment_table]]>>
<<signature [[Cmmgen.code_segment_table]]>>
<<signature [[Cmmgen.predef_exception]]>>
@


\subsection*{[[asmcomp/cmmgen.ml]]}

<<function [[Cmmgen.bind]]>>=
(* Local binding of complex expressions *)

let bind name arg fn =
  match arg with
    Cvar _ | Cconst_int _ | Cconst_natint _ | Cconst_symbol _
  | Cconst_pointer _ -> fn arg
  | _ -> let id = Ident.create name in Clet(id, arg, fn (Cvar id))
@

<<constant [[Cmmgen.float_tag]]>>=
(* Block headers. Meaning of the tag field:
       0 - 248: regular blocks
       249: infix closure
       250: closures
       251: abstract
       252: string
       253: float
       254: float array
       255: finalized *)

let float_tag = Cconst_int 253
@

<<constant [[Cmmgen.floatarray_tag]]>>=
let floatarray_tag = Cconst_int 254
@

<<function [[Cmmgen.block_header]]>>=
let block_header tag sz =
  Nativeint.add (Nativeint.shift (Nativeint.from sz) 10) (Nativeint.from tag)
@

<<function [[Cmmgen.closure_header]]>>=
let closure_header sz = block_header 250 sz
@

<<function [[Cmmgen.infix_header]]>>=
let infix_header ofs = block_header 249 ofs
@

<<constant [[Cmmgen.float_header]]>>=
let float_header = block_header 253 (size_float / size_addr)
@

<<function [[Cmmgen.floatarray_header]]>>=
let floatarray_header len = block_header 254 (len * size_float / size_addr)
@

<<function [[Cmmgen.string_header]]>>=
let string_header len = block_header 252 ((len + size_addr) / size_addr)
@

<<function [[Cmmgen.alloc_block_header]]>>=
let alloc_block_header tag sz = Cconst_natint(block_header tag sz)
@

<<constant [[Cmmgen.alloc_float_header]]>>=
let alloc_float_header = Cconst_natint(float_header)
@

<<function [[Cmmgen.alloc_floatarray_header]]>>=
let alloc_floatarray_header len = Cconst_natint(floatarray_header len)
@

<<function [[Cmmgen.alloc_closure_header]]>>=
let alloc_closure_header sz = Cconst_natint(closure_header sz)
@

<<function [[Cmmgen.alloc_infix_header]]>>=
let alloc_infix_header ofs = Cconst_natint(infix_header ofs)
@

<<constant [[Cmmgen.max_repr_int]]>>=
(* Integers *)

let max_repr_int = max_int asr 1
@

<<constant [[Cmmgen.min_repr_int]]>>=
let min_repr_int = min_int asr 1
@

<<function [[Cmmgen.int_const]]>>=
let int_const n =
  if n <= max_repr_int & n >= min_repr_int
  then Cconst_int((n lsl 1) + 1)
  else Cconst_natint(Nativeint.add (Nativeint.shift (Nativeint.from n) 1)
                                   (Nativeint.from 1))
@

<<function [[Cmmgen.add_const]]>>=
let add_const c n =
  if n = 0 then c else Cop(Caddi, [c; Cconst_int n])
@

<<function [[Cmmgen.incr_int]]>>=
let incr_int = function
    Cconst_int n when n < max_int -> Cconst_int(n+1)
  | Cop(Caddi, [c; Cconst_int n]) when n < max_int -> add_const c (n+1)
  | c -> add_const c 1
@

<<function [[Cmmgen.decr_int]]>>=
let decr_int = function
    Cconst_int n when n > min_int -> Cconst_int(n-1)
  | Cop(Caddi, [c; Cconst_int n]) when n > min_int -> add_const c (n-1)
  | c -> add_const c (-1)
@

<<function [[Cmmgen.add_int]]>>=
let add_int c1 c2 =
  match (c1, c2) with
    (Cop(Caddi, [c1; Cconst_int n1]),
     Cop(Caddi, [c2; Cconst_int n2])) when no_overflow_add n1 n2 ->
      add_const (Cop(Caddi, [c1; c2])) (n1 + n2)
  | (Cop(Caddi, [c1; Cconst_int n1]), c2) ->
      add_const (Cop(Caddi, [c1; c2])) n1
  | (c1, Cop(Caddi, [c2; Cconst_int n2])) ->
      add_const (Cop(Caddi, [c1; c2])) n2
  | (c1, c2) ->
      Cop(Caddi, [c1; c2])
@

<<function [[Cmmgen.sub_int]]>>=
let sub_int c1 c2 =
  match (c1, c2) with
    (Cop(Caddi, [c1; Cconst_int n1]),
     Cop(Caddi, [c2; Cconst_int n2])) when no_overflow_sub n1 n2 ->
      add_const (Cop(Csubi, [c1; c2])) (n1 - n2)
  | (Cop(Caddi, [c1; Cconst_int n1]), c2) ->
      add_const (Cop(Csubi, [c1; c2])) n1
  | (c1, Cop(Caddi, [c2; Cconst_int n2])) when n2 <> min_int ->
      add_const (Cop(Csubi, [c1; c2])) (-n2)
  | (c1, Cconst_int n) when n <> min_int ->
      add_const c1 (-n)
  | (c1, c2) ->
      Cop(Csubi, [c1; c2])
@

<<function [[Cmmgen.tag_int]]>>=
let tag_int = function
    Cconst_int n -> int_const n
  | c -> Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1])
@

<<function [[Cmmgen.untag_int]]>>=
let untag_int = function
    Cconst_int n -> Cconst_int(n asr 1)
  | Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1]) -> c
  | c -> Cop(Casr, [c; Cconst_int 1])
@

<<function [[Cmmgen.test_bool]]>>=
(* Bool *)

let test_bool = function
    Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1]) -> c
  | Cop(Clsl, [c; Cconst_int 1]) -> c
  | c -> Cop(Ccmpi Cne, [c; Cconst_int 1])
@

<<function [[Cmmgen.box_float]]>>=
(* Float *)

let box_float c = Cop(Calloc, [alloc_float_header; c])
@

<<function [[Cmmgen.unbox_float]]>>=
let unbox_float = function
    Cop(Calloc, [header; c]) -> c
  | c -> Cop(Cload typ_float, [c])
@

<<function [[Cmmgen.is_unboxed_float]]>>=
let is_unboxed_float = function
    Uconst(Const_base(Const_float f)) -> true
  | Uprim(p, _) ->
      begin match p with
          Pccall p -> p.prim_native_float
        | Pfloatfield _ | Pfloatofint | Pnegfloat | Pabsfloat
        | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
        | Parrayrefu Pfloatarray | Parrayrefs Pfloatarray -> true
        | _ -> false
      end
  | _ -> false
@

<<exception [[Cmmgen.Cannot_subst_float]]>>=
exception Cannot_subst_float
@

<<function [[Cmmgen.subst_boxed_float]]>>=
let subst_boxed_float boxed_id unboxed_id exp =
  let need_boxed = ref false in
  let assigned = ref false in
  let rec subst = function
      Cvar id as e ->
        if Ident.same id boxed_id then need_boxed := true; e
    | Clet(id, arg, body) -> Clet(id, subst arg, subst body)
    | Cassign(id, arg) -> 
        if Ident.same id boxed_id then begin
          assigned := true;
          Cassign(unboxed_id, subst(unbox_float arg))
        end else
          Cassign(id, subst arg)
    | Ctuple argl -> Ctuple(List.map subst argl)
    | Cop(Cload _, [Cvar id]) as e ->
        if Ident.same id boxed_id then Cvar unboxed_id else e
    | Cop(op, argl) -> Cop(op, List.map subst argl)
    | Csequence(e1, e2) -> Csequence(subst e1, subst e2)
    | Cifthenelse(e1, e2, e3) -> Cifthenelse(subst e1, subst e2, subst e3)
    | Cswitch(arg, index, cases) ->
        Cswitch(subst arg, index, Array.map subst cases)
    | Cloop e -> Cloop(subst e)
    | Ccatch(e1, e2) -> Ccatch(subst e1, subst e2)
    | Ctrywith(e1, id, e2) -> Ctrywith(subst e1, id, subst e2)
    | e -> e in
  let res = subst exp in
  (res, !need_boxed, !assigned)  
@

<<function [[Cmmgen.return_unit]]>>=
(* Unit *)

let return_unit c = Csequence(c, Cconst_pointer 1)
@

<<function [[Cmmgen.remove_unit]]>>=
let rec remove_unit = function
    Cconst_pointer 1 -> Ctuple []
  | Csequence(c, Cconst_pointer 1) -> c
  | Csequence(c1, c2) ->
      Csequence(c1, remove_unit c2)
  | Cifthenelse(cond, ifso, ifnot) ->
      Cifthenelse(cond, remove_unit ifso, remove_unit ifnot)
  | Cswitch(sel, index, cases) ->
      Cswitch(sel, index, Array.map remove_unit cases)
  | Ccatch(body, handler) ->
      Ccatch(remove_unit body, remove_unit handler)
  | Ctrywith(body, exn, handler) ->
      Ctrywith(remove_unit body, exn, remove_unit handler)
  | Clet(id, c1, c2) ->
      Clet(id, c1, remove_unit c2)
  | Cop(Capply mty, args) ->
      Cop(Capply [||], args)
  | Cop(Cextcall(proc, mty, alloc), args) ->
      Cop(Cextcall(proc, [||], alloc), args)
  | Cexit -> Cexit
  | Ctuple [] as c -> c
  | c -> Csequence(c, Ctuple [])
@

<<function [[Cmmgen.field_address]]>>=
(* Access to block fields *)

let field_address ptr n =
  if n = 0
  then ptr
  else Cop(Cadda, [ptr; Cconst_int(n * size_addr)])
@

<<function [[Cmmgen.get_field]]>>=
let get_field ptr n =
  Cop(Cload typ_addr, [field_address ptr n])
@

<<function [[Cmmgen.set_field]]>>=
let set_field ptr n newval =
  Cop(Cstore, [field_address ptr n; newval])
@

<<function [[Cmmgen.header]]>>=
let header ptr =
  Cop(Cload typ_int, [Cop(Cadda, [ptr; Cconst_int(-size_int)])])
@

<<constant [[Cmmgen.tag_offset]]>>=
let tag_offset =
  if big_endian then -1 else -size_int
@

<<function [[Cmmgen.get_tag]]>>=
let get_tag ptr =
  if Proc.word_addressed then           (* If byte loads are slow *)
    Cop(Cand, [header ptr; Cconst_int 255])
  else                                  (* If byte loads are efficient *)
    Cop(Cloadchunk Byte_unsigned,
        [Cop(Cadda, [ptr; Cconst_int(tag_offset)])])
@

<<constant [[Cmmgen.log2_size_addr]]>>=
(* Array indexing *)

let log2_size_addr = Misc.log2 size_addr
@

<<constant [[Cmmgen.log2_size_float]]>>=
let log2_size_float = Misc.log2 size_float
@

<<constant [[Cmmgen.wordsize_shift]]>>=
let wordsize_shift = 9
@

<<constant [[Cmmgen.numfloat_shift]]>>=
let numfloat_shift = 9 + log2_size_float - log2_size_addr
@

<<function [[Cmmgen.is_addr_array]]>>=
let is_addr_array hdr =
  Cop(Ccmpi Cne, [Cop(Cand, [hdr; Cconst_int 255]); floatarray_tag])
@

<<function [[Cmmgen.addr_array_length]]>>=
let addr_array_length hdr = Cop(Clsr, [hdr; Cconst_int wordsize_shift])
@

<<function [[Cmmgen.float_array_length]]>>=
let float_array_length hdr = Cop(Clsr, [hdr; Cconst_int numfloat_shift])
@

<<function [[Cmmgen.lsl_const]]>>=
let lsl_const c n =
  Cop(Clsl, [c; Cconst_int n])
@

<<function [[Cmmgen.array_indexing]]>>=
let array_indexing log2size ptr ofs =
  match ofs with
    Cconst_int n ->
      let i = n asr 1 in
      if i = 0 then ptr else Cop(Cadda, [ptr; Cconst_int(i lsl log2size)])
  | Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1]) ->
      Cop(Cadda, [ptr; lsl_const c log2size])
  | Cop(Caddi, [c; Cconst_int n]) ->
      Cop(Cadda, [Cop(Cadda, [ptr; lsl_const c (log2size - 1)]);
                  Cconst_int((n-1) lsl (log2size - 1))])
  | _ ->
      Cop(Cadda, [Cop(Cadda, [ptr; lsl_const ofs (log2size - 1)]);
                  Cconst_int((-1) lsl (log2size - 1))])
@

<<function [[Cmmgen.addr_array_ref]]>>=
let addr_array_ref arr ofs =
  Cop(Cload typ_addr, [array_indexing log2_size_addr arr ofs])
@

<<function [[Cmmgen.unboxed_float_array_ref]]>>=
let unboxed_float_array_ref arr ofs =
  Cop(Cload typ_float, [array_indexing log2_size_float arr ofs])
@

<<function [[Cmmgen.float_array_ref]]>>=
let float_array_ref arr ofs =
  box_float(unboxed_float_array_ref arr ofs)
@

<<function [[Cmmgen.addr_array_set]]>>=
let addr_array_set arr ofs newval =
  Cop(Cextcall("modify", typ_void, false),
      [array_indexing log2_size_addr arr ofs; newval])
@

<<function [[Cmmgen.int_array_set]]>>=
let int_array_set arr ofs newval =
  Cop(Cstore, [array_indexing log2_size_addr arr ofs; newval])
@

<<function [[Cmmgen.float_array_set]]>>=
let float_array_set arr ofs newval =
  Cop(Cstore, [array_indexing log2_size_float arr ofs; newval])
@

<<function [[Cmmgen.string_length]]>>=
(* String length *)

let string_length exp =
  bind "str" exp (fun str ->
    let tmp_var = Ident.create "tmp" in
    Clet(tmp_var,
         Cop(Csubi,
             [Cop(Clsl,
                  [Cop(Clsr, [get_field str (-1); Cconst_int 10]);
                   Cconst_int log2_size_addr]);
              Cconst_int 1]),
         Cop(Csubi,
             [Cvar tmp_var;
              Cop(Cloadchunk Byte_unsigned,
                  [Cop(Cadda, [str; Cvar tmp_var])])])))
@

<<function [[Cmmgen.fundecls_size]]>>=
(* To compile "let rec" over values *)

let fundecls_size fundecls =
  let sz = ref (-1) in
  List.iter
    (fun (label, arity, params, body) ->
      sz := !sz + 1 + (if arity = 1 then 2 else 3))
    fundecls;
  !sz
@

<<function [[Cmmgen.expr_size_and_tag]]>>=
let rec expr_size_and_tag = function
    Uclosure(fundecls, clos_vars) ->
      (fundecls_size fundecls + List.length clos_vars, 250)
  | Uprim(Pmakeblock(tag, mut), args) ->
      (List.length args, tag)
  | Uprim(Pmakearray(Paddrarray | Pintarray), args) ->
      (List.length args, 0)
  | Ulet(id, exp, body) ->
      expr_size_and_tag body
  | Uletrec(bindings, body) ->
      expr_size_and_tag body
  | _ ->
      fatal_error "Cmmgen.expr_size_and_tag"
@

<<function [[Cmmgen.dummy_block]]>>=
let dummy_block (size, tag) =
  let rec init_val i =
    if i >= size then [] else Cconst_int 0 :: init_val(i+1) in
  Cop(Calloc, alloc_block_header tag size :: init_val 0)
@

<<function [[Cmmgen.apply_function]]>>=
(* Record application and currying functions *)

let apply_function n =
  Compilenv.need_apply_fun n; "caml_apply" ^ string_of_int n
@

<<function [[Cmmgen.curry_function]]>>=
let curry_function n =
  Compilenv.need_curry_fun n;
  if n >= 0
  then "caml_curry" ^ string_of_int n
  else "caml_tuplify" ^ string_of_int (-n)
@

<<function [[Cmmgen.transl_comparison]]>>=
(* Comparisons *)

let transl_comparison = function
    Lambda.Ceq -> Ceq
  | Lambda.Cneq -> Cne
  | Lambda.Cge -> Cge
  | Lambda.Cgt -> Cgt
  | Lambda.Cle -> Cle
  | Lambda.Clt -> Clt
@

<<constant [[Cmmgen.const_label]]>>=
(* Translate structured constants *)

let const_label = ref 0
@

<<function [[Cmmgen.new_const_label]]>>=
let new_const_label () =
  incr const_label;
  !const_label
@

<<function [[Cmmgen.new_const_symbol]]>>=
let new_const_symbol () =
  incr const_label;
  Compilenv.current_unit_name () ^ "_" ^ string_of_int !const_label
@

<<constant [[Cmmgen.structured_constants]]>>=
let structured_constants =
@

<<function [[Cmmgen.transl_constant]]>>=
let transl_constant = function
    Const_base(Const_int n) ->
      int_const n
  | Const_base(Const_char c) ->
      Cconst_int(((Char.code c) lsl 1) + 1)
  | Const_pointer n ->
      Cconst_pointer((n lsl 1) + 1)
  | cst ->
      let lbl =
        try
          Hashtbl.find structured_constants cst
        with Not_found ->
          let lbl = new_const_symbol() in
          Hashtbl.add structured_constants cst lbl;
          lbl
      in Cconst_symbol lbl
@

<<constant [[Cmmgen.functions]]>>=
(* Translate an expression *)

let functions = (Queue.create() : (string * Ident.t list * ulambda) Queue.t)
@

<<function [[Cmmgen.transl_function]]>>=
(* Translate a function definition *)

let transl_function lbl params body =
  Cfunction {fun_name = lbl;
             fun_args = List.map (fun id -> (id, typ_addr)) params;
             fun_body = transl body;
             fun_fast = !Clflags.optimize_for_speed}
@

<<function [[Cmmgen.transl_all_functions]]>>=
let rec transl_all_functions already_translated cont =
  try
    let (lbl, params, body) = Queue.take functions in
    if StringSet.mem lbl already_translated then
      transl_all_functions already_translated cont
    else
      transl_all_functions (StringSet.add lbl already_translated)
                           (transl_function lbl params body :: cont)
  with Queue.Empty ->
    cont
@

<<function [[Cmmgen.emit_all_constants]]>>=
(* Emit all structured constants *)

let emit_all_constants cont =
  let c = ref cont in
  Hashtbl.iter
    (fun cst lbl -> c := Cdata(emit_constant lbl cst []) :: !c)
    structured_constants;
  Hashtbl.clear structured_constants;
  !c
@

<<function [[Cmmgen.compunit]]>>=
(* Translate a compilation unit *)

let compunit size ulam =
  let glob = Compilenv.current_unit_name () in
  let init_code = transl ulam in
  let c1 = [Cfunction {fun_name = glob ^ "_entry"; fun_args = [];
                       fun_body = init_code; fun_fast = false}] in
  let c2 = transl_all_functions StringSet.empty c1 in
  let c3 = emit_all_constants c2 in
  Cdata [Cint(block_header 0 size);
         Cdefine_symbol glob;
         Cskip(size * size_addr)] :: c3
@

<<function [[Cmmgen.apply_function]]([[(asmcomp/cmmgen.ml)]])>>=
(* Generate an application function:
     (defun caml_applyN (a1 ... aN clos)
       (if (= clos.arity N)
         (app clos.direct a1 ... aN clos)
         (let (clos1 (app clos.code a1 clos)
               clos2 (app clos1.code a2 clos)
               ...
               closN-1 (app closN-2.code aN-1 closN-2))
           (app closN-1.code aN closN-1))))
*)

let apply_function arity =
  let arg = Array.create arity (Ident.create "arg") in
  for i = 1 to arity - 1 do arg.(i) <- Ident.create "arg" done;
  let clos = Ident.create "clos" in
  let rec app_fun clos n =
    if n = arity-1 then
      Cop(Capply typ_addr,
          [get_field (Cvar clos) 0; Cvar arg.(n); Cvar clos])
    else begin
      let newclos = Ident.create "clos" in
      Clet(newclos,
           Cop(Capply typ_addr,
               [get_field (Cvar clos) 0; Cvar arg.(n); Cvar clos]),
           app_fun newclos (n+1))
    end in
  let all_args = Array.to_list arg @ [clos] in
  let body =
    Cifthenelse(
      Cop(Ccmpi Ceq, [get_field (Cvar clos) 1; int_const arity]),
      Cop(Capply typ_addr,
          get_field (Cvar clos) 2 :: List.map (fun s -> Cvar s) all_args),
      app_fun clos 0) in
  Cfunction
   {fun_name = "caml_apply" ^ string_of_int arity;
    fun_args = List.map (fun id -> (id, typ_addr)) all_args;
    fun_body = body;
    fun_fast = true}
@

<<function [[Cmmgen.tuplify_function]]>>=
(* Generate tuplifying functions:
      (defun caml_tuplifyN (arg clos)
        (app clos.direct #0(arg) ... #N-1(arg) clos)) *)

let tuplify_function arity =
  let arg = Ident.create "arg" in
  let clos = Ident.create "clos" in
  let rec access_components i =
    if i >= arity
    then []
    else get_field (Cvar arg) i :: access_components(i+1) in
  Cfunction
   {fun_name = "caml_tuplify" ^ string_of_int arity;
    fun_args = [arg, typ_addr; clos, typ_addr];
    fun_body =
      Cop(Capply typ_addr,
          get_field (Cvar clos) 2 :: access_components 0 @ [Cvar clos]);
    fun_fast = true}
@

<<function [[Cmmgen.final_curry_function]]>>=
(* Generate currying functions:
      (defun caml_curryN (arg clos)
         (alloc HDR caml_curryN_1 arg clos))
      (defun caml_curryN_1 (arg clos)
         (alloc HDR caml_curryN_2 arg clos))
      ...
      (defun caml_curryN_N-1 (arg clos)
         (let (closN-2 clos.cdr
               closN-3 closN-2.cdr
               ...
               clos1 clos2.cdr
               clos clos1.cdr)
           (app clos.direct
                clos1.car clos2.car ... closN-2.car clos.car arg clos))) *)

let final_curry_function arity =
  let last_arg = Ident.create "arg" in
  let last_clos = Ident.create "clos" in
  let rec curry_fun args clos n =
    if n = 0 then
      Cop(Capply typ_addr,
          get_field (Cvar clos) 2 ::
          args @ [Cvar last_arg; Cvar clos])
    else begin
      let newclos = Ident.create "clos" in
      Clet(newclos,
           get_field (Cvar clos) 3,
           curry_fun (get_field (Cvar clos) 2 :: args) newclos (n-1))
    end in
  Cfunction
   {fun_name = "caml_curry" ^ string_of_int arity ^
               "_" ^ string_of_int (arity-1);
    fun_args = [last_arg, typ_addr; last_clos, typ_addr];
    fun_body = curry_fun [] last_clos (arity-1);
    fun_fast = true}
@

<<function [[Cmmgen.intermediate_curry_functions]]>>=
let rec intermediate_curry_functions arity num =
  if num = arity - 1 then
    [final_curry_function arity]
  else begin
    let name1 = "caml_curry" ^ string_of_int arity in
    let name2 = if num = 0 then name1 else name1 ^ "_" ^ string_of_int num in
    let arg = Ident.create "arg" and clos = Ident.create "clos" in
    Cfunction
     {fun_name = name2;
      fun_args = [arg, typ_addr; clos, typ_addr];
      fun_body = Cop(Calloc,
                     [alloc_closure_header 4; 
                      Cconst_symbol(name1 ^ "_" ^ string_of_int (num+1));
                      int_const 1; Cvar arg; Cvar clos]);
      fun_fast = true}
    :: intermediate_curry_functions arity (num+1)
  end
@

<<function [[Cmmgen.curry_function]]([[(asmcomp/cmmgen.ml)]])>>=
let curry_function arity =
  if arity >= 0
  then intermediate_curry_functions arity 0
  else [tuplify_function (-arity)]
@

<<function [[Cmmgen.entry_point]]>>=
(* Generate the entry point *)

let entry_point namelist =
  let body =
    List.fold_right
      (fun name next ->
        Csequence(Cop(Capply typ_void, [Cconst_symbol(name ^ "_entry")]),
                  next))
      namelist (Ctuple []) in
  Cfunction {fun_name = "caml_program";
             fun_args = [];
             fun_body = body;
             fun_fast = false}
@

<<constant [[Cmmgen.cint_zero]]>>=
(* Generate the table of globals *)

let cint_zero = Cint(Nativeint.from 0)
@

<<function [[Cmmgen.global_table]]>>=
let global_table namelist =
  Cdata(Cdefine_symbol "caml_globals" ::
        List.map (fun name -> Csymbol_address name) namelist @
        [cint_zero])
@

<<function [[Cmmgen.frame_table]]>>=
(* Generate the master table of frame descriptors *)

let frame_table namelist =
  Cdata(Cdefine_symbol "caml_frametable" ::
        List.map (fun name -> Csymbol_address(name ^ "_frametable")) namelist @
        [cint_zero])
@

<<function [[Cmmgen.segment_table]]>>=
(* Generate the table of module data and code segments *)

let segment_table namelist symbol begname endname =
  Cdata(Cdefine_symbol symbol ::
        List.fold_right
          (fun name lst ->
            Csymbol_address(name ^ begname) ::
            Csymbol_address(name ^ endname) :: lst)
          namelist
          [cint_zero])
@

<<function [[Cmmgen.data_segment_table]]>>=
let data_segment_table namelist =
  segment_table namelist "caml_data_segments" "_data_begin" "_data_end"
@

<<function [[Cmmgen.code_segment_table]]>>=
let code_segment_table namelist =
  segment_table namelist "caml_code_segments" "_code_begin" "_code_end"
@

<<function [[Cmmgen.predef_exception]]>>=
(* Initialize a predefined exception *)

let predef_exception name =
  Cdata(emit_constant name (Const_block(0,[Const_base(Const_string name)])) [])
@


%-------------------------------------------------------------

<<asmcomp/cmmgen.ml>>=
<<copyright header>>

(* Translation from closed lambda to C-- *)

open Misc
open Arch
open Asttypes
open Primitive
open Types
open Lambda
open Clambda
open Cmm

<<function [[Cmmgen.bind]]>>

<<constant [[Cmmgen.float_tag]]>>
<<constant [[Cmmgen.floatarray_tag]]>>

<<function [[Cmmgen.block_header]]>>
<<function [[Cmmgen.closure_header]]>>
<<function [[Cmmgen.infix_header]]>>
<<constant [[Cmmgen.float_header]]>>
<<function [[Cmmgen.floatarray_header]]>>
<<function [[Cmmgen.string_header]]>>

<<function [[Cmmgen.alloc_block_header]]>>
<<constant [[Cmmgen.alloc_float_header]]>>
<<function [[Cmmgen.alloc_floatarray_header]]>>
<<function [[Cmmgen.alloc_closure_header]]>>
<<function [[Cmmgen.alloc_infix_header]]>>

<<constant [[Cmmgen.max_repr_int]]>>
<<constant [[Cmmgen.min_repr_int]]>>

<<function [[Cmmgen.int_const]]>>

<<function [[Cmmgen.add_const]]>>

<<function [[Cmmgen.incr_int]]>>

<<function [[Cmmgen.decr_int]]>>

<<function [[Cmmgen.add_int]]>>

<<function [[Cmmgen.sub_int]]>>

<<function [[Cmmgen.tag_int]]>>

<<function [[Cmmgen.untag_int]]>>

<<function [[Cmmgen.test_bool]]>>

<<function [[Cmmgen.box_float]]>>

<<function [[Cmmgen.unbox_float]]>>

<<function [[Cmmgen.is_unboxed_float]]>>

<<exception [[Cmmgen.Cannot_subst_float]]>>

<<function [[Cmmgen.subst_boxed_float]]>>

<<function [[Cmmgen.return_unit]]>>

<<function [[Cmmgen.remove_unit]]>>

<<function [[Cmmgen.field_address]]>>

<<function [[Cmmgen.get_field]]>>

<<function [[Cmmgen.set_field]]>>

<<function [[Cmmgen.header]]>>

<<constant [[Cmmgen.tag_offset]]>>

<<function [[Cmmgen.get_tag]]>>

<<constant [[Cmmgen.log2_size_addr]]>>
<<constant [[Cmmgen.log2_size_float]]>>

<<constant [[Cmmgen.wordsize_shift]]>>
<<constant [[Cmmgen.numfloat_shift]]>>

<<function [[Cmmgen.is_addr_array]]>>

<<function [[Cmmgen.addr_array_length]]>>
<<function [[Cmmgen.float_array_length]]>>

<<function [[Cmmgen.lsl_const]]>>

<<function [[Cmmgen.array_indexing]]>>

<<function [[Cmmgen.addr_array_ref]]>>
<<function [[Cmmgen.unboxed_float_array_ref]]>>
<<function [[Cmmgen.float_array_ref]]>>

<<function [[Cmmgen.addr_array_set]]>>
<<function [[Cmmgen.int_array_set]]>>
<<function [[Cmmgen.float_array_set]]>>

<<function [[Cmmgen.string_length]]>>

<<function [[Cmmgen.fundecls_size]]>>

<<function [[Cmmgen.expr_size_and_tag]]>>

<<function [[Cmmgen.dummy_block]]>>

let rec store_contents ptr = function
    Cop(Calloc, header :: fields) ->
      store_fields ptr 0 fields
  | Clet(id, exp, body) ->
      Clet(id, exp, store_contents ptr body)
  | _ ->
      fatal_error "Cmmgen.store_contents"

and store_fields ptr pos = function
    [] -> Ctuple []
  | c :: rem ->
      let store =
        match c with
          Cconst_int _ | Cconst_symbol _ | Cconst_pointer _ ->
            Cop(Cstore, [field_address ptr pos; c])
        | _ ->
            Cop(Cextcall("modify", typ_void, false),
                [field_address ptr pos; c]) in
      Csequence(store, store_fields ptr (pos + 1) rem)
            

<<function [[Cmmgen.apply_function]]>>
<<function [[Cmmgen.curry_function]]>>

<<function [[Cmmgen.transl_comparison]]>>

<<constant [[Cmmgen.const_label]]>>

<<function [[Cmmgen.new_const_label]]>>

<<function [[Cmmgen.new_const_symbol]]>>

<<constant [[Cmmgen.structured_constants]]>>
  (Hashtbl.create 19 : (structured_constant, string) Hashtbl.t)

<<function [[Cmmgen.transl_constant]]>>

<<constant [[Cmmgen.functions]]>>

let rec transl = function
    Uvar id ->
      Cvar id
  | Uconst sc ->
      transl_constant sc
  | Uclosure(fundecls, clos_vars) ->
      let block_size =
        fundecls_size fundecls + List.length clos_vars in
      let rec transl_fundecls pos = function
        [] ->
          List.map transl clos_vars
      | (label, arity, params, body) :: rem ->
          Queue.add (label, params, body) functions;
          let header =
            if pos = 0
            then alloc_closure_header block_size
            else alloc_infix_header pos in
          if arity = 1 then
            header ::
            Cconst_symbol label ::
            int_const 1 ::
            transl_fundecls (pos + 3) rem
          else
            header ::
            Cconst_symbol(curry_function arity) ::
            int_const arity ::
            Cconst_symbol label ::
            transl_fundecls (pos + 4) rem in
      Cop(Calloc, transl_fundecls 0 fundecls)
  | Uoffset(arg, offset) ->
      field_address (transl arg) offset
  | Udirect_apply(lbl, args) ->
      Cop(Capply typ_addr, Cconst_symbol lbl :: List.map transl args)
  | Ugeneric_apply(clos, [arg]) ->
      bind "fun" (transl clos) (fun clos ->
        Cop(Capply typ_addr, [get_field clos 0; transl arg; clos]))
  | Ugeneric_apply(clos, args) ->
      let arity = List.length args in
      Cop(Capply typ_addr,
          Cconst_symbol(apply_function arity) ::
          List.map transl (args @ [clos]))
  | Ulet(id, exp, body) ->
      if is_unboxed_float exp then begin
        let unboxed_id = Ident.create (Ident.name id) in
        let (tr_body, need_boxed, is_assigned) =
          subst_boxed_float id unboxed_id (transl body) in
        if need_boxed & is_assigned then
          Clet(id, transl exp, transl body)
        else
          Clet(unboxed_id, transl_unbox_float exp,
               if need_boxed
               then Clet(id, box_float(Cvar unboxed_id), tr_body)
               else tr_body)
      end else
        Clet(id, transl exp, transl body)
  | Uletrec(bindings, body) ->
      transl_letrec bindings (transl body)

  (* Primitives *)
  | Uprim(Pidentity, [arg]) ->
      transl arg
  | Uprim(Pgetglobal id, []) ->
      Cconst_symbol(Ident.name id)

  (* Heap blocks *)
  | Uprim(Pmakeblock(tag, mut), []) ->
      transl_constant(Const_block(tag, []))
  | Uprim(Pmakeblock(tag, mut), args) ->
      Cop(Calloc, alloc_block_header tag (List.length args) ::
                  List.map transl args)
  | Uprim(Pfield n, [arg]) ->
      get_field (transl arg) n
  | Uprim(Psetfield(n, ptr), [loc; newval]) ->
      if ptr then
        return_unit(Cop(Cextcall("modify", typ_void, false),
                        [field_address (transl loc) n; transl newval]))
      else
        return_unit(set_field (transl loc) n (transl newval))
  | Uprim(Pfloatfield n, [arg]) ->
      let ptr = transl arg in
      box_float(Cop(Cload typ_float,
                [if n = 0 then ptr
                          else Cop(Cadda, [ptr; Cconst_int(n * size_float)])]))
  | Uprim(Psetfloatfield n, [loc; newval]) ->
      let ptr = transl loc in
      return_unit(Cop(Cstore,
                  [if n = 0 then ptr
                            else Cop(Cadda, [ptr; Cconst_int(n * size_float)]);
                   transl_unbox_float newval]))

  (* External call *)
  | Uprim(Pccall prim, args) ->
      if prim.prim_native_float then
        box_float
          (Cop(Cextcall(prim.prim_native_name, typ_float, false),
               List.map transl_unbox_float args))
      else begin
        let name =
          if prim.prim_native_name <> ""
          then prim.prim_native_name
          else prim.prim_name in
        Cop(Cextcall(name, typ_addr, prim.prim_alloc), List.map transl args)
      end
  (* Exceptions *)
  | Uprim(Praise, [arg]) ->
      Cop(Craise, [transl arg])

  (* Boolean operations *)
  | Uprim(Psequand, [arg1; arg2]) ->
      Cifthenelse(test_bool(transl arg1), transl arg2, Cconst_int 1)
  | Uprim(Psequor, [arg1; arg2]) ->
      Cifthenelse(test_bool(transl arg1), Cconst_int 3, transl arg2)
  | Uprim(Pnot, [arg]) ->
      Cop(Csubi, [Cconst_int 4; transl arg]) (* 1 -> 3, 3 -> 1 *)

  (* Integer operations *)
  | Uprim(Pnegint, [arg]) ->
      Cop(Csubi, [Cconst_int 2; transl arg])
  | Uprim(Paddint, [arg1; arg2]) ->
      decr_int(add_int (transl arg1) (transl arg2))
  | Uprim(Psubint, [arg1; arg2]) ->
      incr_int(sub_int (transl arg1) (transl arg2))
  | Uprim(Pmulint, [arg1; arg2]) ->
      incr_int(Cop(Cmuli, [decr_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Pdivint, [arg1; arg2]) ->
      tag_int(Cop(Cdivi, [untag_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Pmodint, [arg1; arg2]) ->
      tag_int(Cop(Cmodi, [untag_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Pandint, [arg1; arg2]) ->
      Cop(Cand, [transl arg1; transl arg2])
  | Uprim(Porint, [arg1; arg2]) ->
      Cop(Cor, [transl arg1; transl arg2])
  | Uprim(Pxorint, [arg1; arg2]) ->
      incr_int(Cop(Cxor, [transl arg1; transl arg2]))
  | Uprim(Plslint, [arg1; arg2]) ->
      incr_int(Cop(Clsl, [decr_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Plsrint, [arg1; arg2]) ->
      Cop(Cor, [Cop(Clsr, [transl arg1; untag_int(transl arg2)]);
                Cconst_int 1])
  | Uprim(Pasrint, [arg1; arg2]) ->
      Cop(Cor, [Cop(Casr, [transl arg1; untag_int(transl arg2)]);
                Cconst_int 1])
  | Uprim(Pintcomp cmp, [arg1; arg2]) ->
      tag_int(Cop(Ccmpi(transl_comparison cmp), [transl arg1; transl arg2]))
  | Uprim(Poffsetint n, [arg]) ->
      add_const (transl arg) (n lsl 1)
  | Uprim(Poffsetref n, [arg]) ->
      return_unit
        (bind "ref" (transl arg) (fun arg ->
          Cop(Cstore,
              [arg; add_const (Cop(Cload typ_int, [arg])) (n lsl 1)])))

  (* Float operations *)
  | Uprim(Pfloatofint, [arg]) ->
      box_float(Cop(Cfloatofint, [untag_int(transl arg)]))
  | Uprim(Pintoffloat, [arg]) ->
     tag_int(Cop(Cintoffloat, [transl_unbox_float arg]))
  | Uprim(Pnegfloat, [arg]) ->
      box_float(Cop(Cnegf, [transl_unbox_float arg]))
  | Uprim(Pabsfloat, [arg]) ->
      box_float(Cop(Cabsf, [transl_unbox_float arg]))
  | Uprim(Paddfloat, [arg1; arg2]) ->
      box_float(Cop(Caddf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Psubfloat, [arg1; arg2]) ->
      box_float(Cop(Csubf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Pmulfloat, [arg1; arg2]) ->
      box_float(Cop(Cmulf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Pdivfloat, [arg1; arg2]) ->
      box_float(Cop(Cdivf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Pfloatcomp cmp, [arg1; arg2]) ->
      tag_int(Cop(Ccmpf(transl_comparison cmp),
                  [transl_unbox_float arg1; transl_unbox_float arg2]))

  (* String operations *)
  | Uprim(Pstringlength, [arg]) ->
      tag_int(string_length (transl arg))
  | Uprim(Pstringrefu, [arg1; arg2]) ->
      tag_int(Cop(Cloadchunk Byte_unsigned,
                  [add_int (transl arg1) (untag_int(transl arg2))]))
  | Uprim(Pstringsetu, [arg1; arg2; arg3]) ->
      return_unit(Cop(Cstorechunk Byte_unsigned,
                      [add_int (transl arg1) (untag_int(transl arg2));
                       untag_int(transl arg3)]))
  | Uprim(Pstringrefs, [arg1; arg2]) ->
      tag_int
        (bind "str" (transl arg1) (fun str ->
          bind "index" (untag_int (transl arg2)) (fun idx ->
            Csequence(
              Cop(Ccheckbound, [string_length str; idx]),
              Cop(Cloadchunk Byte_unsigned, [add_int str idx])))))
  | Uprim(Pstringsets, [arg1; arg2; arg3]) ->
      return_unit
        (bind "str" (transl arg1) (fun str ->
          bind "index" (untag_int (transl arg2)) (fun idx ->
            Csequence(
              Cop(Ccheckbound, [string_length str; idx]),
              Cop(Cstorechunk Byte_unsigned,
                  [add_int str idx; untag_int(transl arg3)])))))

  (* Array operations *)
  | Uprim(Pmakearray kind, []) ->
      transl_constant(Const_block(0, []))
  | Uprim(Pmakearray kind, args) ->
      begin match kind with
        Pgenarray ->
          Cop(Cextcall("make_array", typ_addr, true),
              [Cop(Calloc, alloc_block_header 0 (List.length args) ::
                           List.map transl args)])
      | Paddrarray | Pintarray ->
          Cop(Calloc, alloc_block_header 0 (List.length args) ::
                      List.map transl args)
      | Pfloatarray ->
          Cop(Calloc, alloc_floatarray_header (List.length args) ::
                      List.map transl_unbox_float args)
      end
  | Uprim(Parraylength kind, [arg]) ->
      begin match kind with
        Pgenarray ->
          let len =
            if wordsize_shift = numfloat_shift then
              Cop(Clsr, [header(transl arg); Cconst_int wordsize_shift])
            else
              bind "header" (header(transl arg)) (fun hdr ->
                Cifthenelse(is_addr_array hdr,
                            Cop(Clsr, [hdr; Cconst_int wordsize_shift]),
                            Cop(Clsr, [hdr; Cconst_int numfloat_shift]))) in
          Cop(Cor, [len; Cconst_int 1])
      | Paddrarray | Pintarray ->
          Cop(Cor, [addr_array_length(header(transl arg)); Cconst_int 1])
      | Pfloatarray ->
          Cop(Cor, [float_array_length(header(transl arg)); Cconst_int 1])
      end
  | Uprim(Parrayrefu kind, [arg1; arg2]) ->
      begin match kind with
        Pgenarray ->
          bind "arr" (transl arg1) (fun arr ->
            bind "index" (transl arg2) (fun idx ->
              Cifthenelse(is_addr_array(header arr),
                          addr_array_ref arr idx,
                          float_array_ref arr idx)))
      | Paddrarray | Pintarray ->
          addr_array_ref (transl arg1) (transl arg2)
      | Pfloatarray ->
          float_array_ref (transl arg1) (transl arg2)
      end
  | Uprim(Parraysetu kind, [arg1; arg2; arg3]) ->
      return_unit(begin match kind with
        Pgenarray ->
          bind "newval" (transl arg3) (fun newval ->
            bind "index" (transl arg2) (fun index ->
              bind "arr" (transl arg1) (fun arr ->
                Cifthenelse(is_addr_array(header arr),
                            addr_array_set arr index newval,
                            float_array_set arr index (unbox_float newval)))))
      | Paddrarray ->
          addr_array_set (transl arg1) (transl arg2) (transl arg3)
      | Pintarray ->
          int_array_set (transl arg1) (transl arg2) (transl arg3)
      | Pfloatarray ->
          float_array_set (transl arg1) (transl arg2) (transl_unbox_float arg3)
      end)
  | Uprim(Parrayrefs kind, [arg1; arg2]) ->
      begin match kind with
        Pgenarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              bind "header" (header arr) (fun hdr ->
                Cifthenelse(is_addr_array hdr,
                  Csequence(Cop(Ccheckbound, [addr_array_length hdr; idx]),
                            addr_array_ref arr idx),
                  Csequence(Cop(Ccheckbound, [float_array_length hdr; idx]),
                            float_array_ref arr idx)))))
      | Paddrarray | Pintarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [addr_array_length(header arr); idx]),
                        addr_array_ref arr idx)))
      | Pfloatarray ->
          box_float(
            bind "index" (transl arg2) (fun idx ->
              bind "arr" (transl arg1) (fun arr ->
                Csequence(Cop(Ccheckbound, 
                              [float_array_length(header arr); idx]),
                          unboxed_float_array_ref arr idx))))
      end
  | Uprim(Parraysets kind, [arg1; arg2; arg3]) ->
      return_unit(begin match kind with
        Pgenarray ->
          bind "newval" (transl arg3) (fun newval ->
            bind "index" (transl arg2) (fun idx ->
              bind "arr" (transl arg1) (fun arr ->
                bind "header" (header arr) (fun hdr ->
                  Cifthenelse(is_addr_array hdr,
                    Csequence(Cop(Ccheckbound, [addr_array_length hdr; idx]),
                              addr_array_set arr idx newval),
                    Csequence(Cop(Ccheckbound, [float_array_length hdr; idx]),
                              float_array_set arr idx
                                              (unbox_float newval)))))))
      | Paddrarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [addr_array_length(header arr); idx]),
                        addr_array_set arr idx (transl arg3))))
      | Pintarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [addr_array_length(header arr); idx]),
                        int_array_set arr idx (transl arg3))))
      | Pfloatarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [float_array_length(header arr);idx]),
                        float_array_set arr idx (transl_unbox_float arg3))))
      end)

  (* Operations on bitvects *)
  | Uprim(Pbittest, [arg1; arg2]) ->
      bind "index" (untag_int(transl arg2)) (fun idx ->
        tag_int(
          Cop(Cand, [Cop(Clsr, [Cop(Cloadchunk Byte_unsigned,
                                    [add_int (transl arg1)
                                      (Cop(Clsr, [idx; Cconst_int 3]))]);
                                Cop(Cand, [idx; Cconst_int 7])]);
                     Cconst_int 1])))

  | Uprim(_, _) ->
      fatal_error "Cmmgen.transl"

  | Uswitch(arg, s) ->
      (* As in the bytecode interpreter, only matching against constants
         can be checked *)
      if Array.length s.us_index_blocks = 0 then
        if s.us_checked then
          bind "switch" (untag_int (transl arg)) (fun idx ->
            Cifthenelse(
              Cop(Ccmpa Cge,
                  [idx; Cconst_pointer(Array.length s.us_index_consts)]),
              Cexit,
              transl_switch idx s.us_index_consts s.us_cases_consts))
        else
          transl_switch (untag_int (transl arg))
                        s.us_index_consts s.us_cases_consts
      else if Array.length s.us_index_consts = 0 then
        transl_switch (get_tag (transl arg))
                      s.us_index_blocks s.us_cases_blocks
      else
        bind "switch" (transl arg) (fun arg ->
          Cifthenelse(
            Cop(Cand, [arg; Cconst_int 1]),
            transl_switch (untag_int arg) s.us_index_consts s.us_cases_consts,
            transl_switch (get_tag arg) s.us_index_blocks s.us_cases_blocks))
  | Ustaticfail ->
      Cexit
  | Ucatch(body, handler) ->
      Ccatch(transl body, transl handler)
  | Utrywith(body, exn, handler) ->
      Ctrywith(transl body, exn, transl handler)
  | Uifthenelse(Uprim(Pnot, [arg]), ifso, ifnot) ->
      transl (Uifthenelse(arg, ifnot, ifso))
  | Uifthenelse(cond, ifso, Ustaticfail) ->
      exit_if_false cond (transl ifso)
  | Uifthenelse(cond, Ustaticfail, ifnot) ->
      exit_if_true cond (transl ifnot)
  | Uifthenelse(Uprim(Psequand, _) as cond, ifso, ifnot) ->
      Ccatch(exit_if_false cond (transl ifso), transl ifnot)
  | Uifthenelse(Uprim(Psequor, _) as cond, ifso, ifnot) ->
      Ccatch(exit_if_true cond (transl ifnot), transl ifso)
  | Uifthenelse(cond, ifso, ifnot) ->
      Cifthenelse(test_bool(transl cond), transl ifso, transl ifnot)
  | Usequence(exp1, exp2) ->
      Csequence(remove_unit(transl exp1), transl exp2)
  | Uwhile(cond, body) ->
      return_unit(Ccatch(Cloop(exit_if_false cond (remove_unit(transl body))),
                         Ctuple []))
  | Ufor(id, low, high, dir, body) ->
      let tst = match dir with Upto -> Cgt   | Downto -> Clt in
      let inc = match dir with Upto -> Caddi | Downto -> Csubi in
      return_unit
        (Clet(id, transl low,
          bind "bound" (transl high) (fun high ->
            Ccatch(
              Cloop(Cifthenelse(
                Cop(Ccmpi tst, [Cvar id; high]),
                Cexit,
                 Csequence(remove_unit(transl body),
                           Cassign(id, Cop(inc, 
                                           [Cvar id; Cconst_int 2]))))),
              Ctuple []))))
  | Uassign(id, exp) ->
      return_unit(Cassign(id, transl exp))

and transl_unbox_float = function
    Uconst(Const_base(Const_float f)) -> Cconst_float f
  | exp -> unbox_float(transl exp)

and exit_if_true cond otherwise =
  match cond with
    Uprim(Psequor, [arg1; arg2]) ->
      exit_if_true arg1 (exit_if_true arg2 otherwise)
  | Uprim(Psequand, [arg1; arg2]) ->
      Csequence(Ccatch(exit_if_true arg1 (Ctuple []),
                       exit_if_true arg2 (Ctuple [])),
                otherwise)
  | _ ->
      Cifthenelse(test_bool(transl cond), Cexit, otherwise)

and exit_if_false cond otherwise =
  match cond with
    Uprim(Psequand, [arg1; arg2]) ->
      exit_if_false arg1 (exit_if_false arg2 otherwise)
  | Uprim(Psequor, [arg1; arg2]) ->
      Csequence(Ccatch(exit_if_false arg1 (Ctuple []),
                       exit_if_false arg2 (Ctuple [])),
                otherwise)
  | _ ->
      Cifthenelse(test_bool(transl cond), otherwise, Cexit)

and transl_switch arg index cases =
  match Array.length index with
    1 -> transl cases.(0)
  | 2 -> Cifthenelse(arg, transl cases.(index.(1)), transl cases.(index.(0)))
  | _ ->
      (* Determine whether all actions minus one or two are equal to
         Ustaticfail *)
      let num_fail = ref 0 in
      let key1 = ref (-1) in
      let key2 = ref (-1) in
      for i = 0 to Array.length index - 1 do
        if cases.(index.(i)) = Ustaticfail then incr num_fail
        else if !key1 < 0 then key1 := i
        else if !key2 < 0 then key2 := i
      done;
      match Array.length index - !num_fail with
        0 -> Csequence(arg, Cexit)
      | 1 -> Cifthenelse(Cop(Ccmpi Ceq, [arg; Cconst_int !key1]),
                         transl cases.(index.(!key1)), Cexit)
      | 2 -> bind "test" arg (fun a ->
               Cifthenelse(Cop(Ccmpi Ceq, [a; Cconst_int !key1]),
                           transl cases.(index.(!key1)),
                           Cifthenelse(Cop(Ccmpi Ceq, [a; Cconst_int !key2]),
                                       transl cases.(index.(!key2)), Cexit)))
      | _ -> Cswitch(arg, index, Array.map transl cases)

and transl_letrec bindings cont =
  let rec init_blocks = function
      [] -> fill_blocks bindings
    | (id, exp) :: rem ->
        Clet(id, dummy_block(expr_size_and_tag exp), init_blocks rem)
  and fill_blocks = function
      [] -> cont
    | (id, exp) :: rem ->
        Csequence(store_contents (Cvar id) (transl exp), fill_blocks rem)
  in init_blocks bindings

<<function [[Cmmgen.transl_function]]>>

(* Translate all function definitions *)

module StringSet = Set

<<function [[Cmmgen.transl_all_functions]]>>

(* Emit structured constants *)

let rec emit_constant symb cst cont =
  match cst with
    Const_base(Const_float s) ->
      Cint(float_header) :: Cdefine_symbol symb :: Cfloat s :: cont
  | Const_base(Const_string s) ->
      Cint(string_header (String.length s)) ::
      Cdefine_symbol symb ::
      emit_string_constant s cont
  | Const_block(tag, fields) ->
      let (emit_fields, cont1) = emit_constant_fields fields cont in
      Cint(block_header tag (List.length fields)) ::
      Cdefine_symbol symb ::
      emit_fields @ cont1
  | Const_float_array(fields) ->
      Cint(floatarray_header (List.length fields)) ::
      Cdefine_symbol symb ::
      Misc.map_end (fun f -> Cfloat f) fields cont
  | _ -> fatal_error "gencmm.emit_constant"

and emit_constant_fields fields cont =
  match fields with
    [] -> ([], cont)
  | f1 :: fl ->
      let (data1, cont1) = emit_constant_field f1 cont in
      let (datal, contl) = emit_constant_fields fl cont1 in
      (data1 :: datal, contl)

and emit_constant_field field cont =
  match field with
    Const_base(Const_int n) ->
      (Cint(Nativeint.add (Nativeint.shift (Nativeint.from n) 1)
                          (Nativeint.from 1)),
       cont)
  | Const_base(Const_char c) ->
      (Cint(Nativeint.from(((Char.code c) lsl 1) + 1)), cont)
  | Const_base(Const_float s) ->
      let lbl = new_const_label() in
      (Clabel_address lbl,
       Cint(float_header) :: Cdefine_label lbl :: Cfloat s :: cont)
  | Const_base(Const_string s) ->
      let lbl = new_const_label() in
      (Clabel_address lbl,
       Cint(string_header (String.length s)) :: Cdefine_label lbl :: 
       emit_string_constant s cont)
  | Const_pointer n ->
      (Cint(Nativeint.from((n lsl 1) + 1)), cont)
  | Const_block(tag, fields) ->
      let lbl = new_const_label() in
      let (emit_fields, cont1) = emit_constant_fields fields cont in
      (Clabel_address lbl,
       Cint(block_header tag (List.length fields)) :: Cdefine_label lbl ::
       emit_fields @ cont1)
  | Const_float_array(fields) ->
      let lbl = new_const_label() in
      (Clabel_address lbl,
       Cint(floatarray_header (List.length fields)) :: Cdefine_label lbl ::
       Misc.map_end (fun f -> Cfloat f) fields cont)

and emit_string_constant s cont =
  let n = size_int - 1 - (String.length s) mod size_int in
  Cstring s :: Cskip n :: Cint8 n :: cont

<<function [[Cmmgen.emit_all_constants]]>>

<<function [[Cmmgen.compunit]]>>

<<function [[Cmmgen.apply_function]]([[(asmcomp/cmmgen.ml)]])>>

<<function [[Cmmgen.tuplify_function]]>>

<<function [[Cmmgen.final_curry_function]]>>

<<function [[Cmmgen.intermediate_curry_functions]]>>
    
<<function [[Cmmgen.curry_function]]([[(asmcomp/cmmgen.ml)]])>>

<<function [[Cmmgen.entry_point]]>>

<<constant [[Cmmgen.cint_zero]]>>

<<function [[Cmmgen.global_table]]>>

<<function [[Cmmgen.frame_table]]>>

<<function [[Cmmgen.segment_table]]>>

<<function [[Cmmgen.data_segment_table]]>>

<<function [[Cmmgen.code_segment_table]]>>

<<function [[Cmmgen.predef_exception]]>>
@


\subsection*{[[asmcomp/liveness.mli]]}

<<signature [[Liveness.fundecl]]>>=
(* Liveness analysis.
   Annotate mach code with the set of regs live at each point. *)

val fundecl: Mach.fundecl -> unit
@


%-------------------------------------------------------------

<<asmcomp/liveness.mli>>=
<<copyright header>>

<<signature [[Liveness.fundecl]]>>
@


\subsection*{[[asmcomp/liveness.ml]]}

<<constant [[Liveness.live_at_exit]]>>=
let live_at_exit = ref (*Reg.*)Set.empty
@

<<constant [[Liveness.live_at_break]]>>=
let live_at_break = ref (*Reg.*)Set.empty
@

<<constant [[Liveness.live_at_raise]]>>=
let live_at_raise = ref (*Reg.*)Set.empty
@

<<function [[Liveness.live]]>>=
let rec live i finally =
  (* finally is the set of registers live after execution of the
     instruction sequence.
     The result of the function is the set of registers live just
     before the instruction sequence.
     The instruction i is annotated by the set of registers live across
     the instruction. *)
  match i.desc with
    Iend ->
      i.live <- finally;
      finally
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (* i.live remains empty since no regs are live across *)
      Reg.set_of_array i.arg
  | Iifthenelse(test, ifso, ifnot) ->
      let at_join = live i.next finally in
      let at_fork = (*Reg.*)Set.union (live ifso at_join) (live ifnot at_join) in
      i.live <- at_fork;
      Reg.add_set_array at_fork i.arg
  | Iswitch(index, cases) ->
      let at_join = live i.next finally in
      let at_fork = ref (*Reg.*)Set.empty in
      for i = 0 to Array.length cases - 1 do
        at_fork := (*Reg.*)Set.union !at_fork (live cases.(i) at_join)
      done;
      i.live <- !at_fork;
      Reg.add_set_array !at_fork i.arg
  | Iloop(body) ->
      let at_top = ref (*Reg.*)Set.empty in
      (* Yes, there are better algorithms, but we'll just iterate till
         reaching a fixpoint. *)
      begin try
        while true do
          let new_at_top = (*Reg.*)Set.union !at_top (live body !at_top) in
          if (*Reg.*)Set.equal !at_top new_at_top then raise Exit;
          at_top := new_at_top
        done
      with Exit -> ()
      end;
      i.live <- !at_top;
      !at_top
  | Icatch(body, handler) ->
      let at_join = live i.next finally in
      let before_handler = live handler at_join in
      let saved_live_at_exit = !live_at_exit in
      live_at_exit := before_handler;
      let before_body = live body at_join in
      live_at_exit := saved_live_at_exit;
      i.live <- before_body;
      before_body
  | Iexit ->
      i.live <- !live_at_exit;          (* These regs are live across *)
      !live_at_exit
  | Itrywith(body, handler) ->
      let at_join = live i.next finally in
      let before_handler = live handler at_join in
      let saved_live_at_raise = !live_at_raise in
      live_at_raise := (*Reg.*)Set.remove Proc.loc_exn_bucket before_handler;
      let before_body = live body at_join in
      live_at_raise := saved_live_at_raise;
      i.live <- before_body;
      before_body
  | Iraise ->
      (* i.live remains empty since no regs are live across *)
      Reg.add_set_array !live_at_raise i.arg
  | _ ->
      let across_after = Reg.diff_set_array (live i.next finally) i.res in
      let across =
        match i.desc with
          Iop(Icall_ind) | Iop(Icall_imm _) | Iop(Iextcall(_, _)) ->
            (* The function call may raise an exception, branching to the
               nearest enclosing try ... with. Hence, everything that must
               be live at the beginning of the exception handler must also
               be live across the call. *)
             (*Reg.*)Set.union across_after !live_at_raise
         | _ ->
             across_after in
      i.live <- across;
      Reg.add_set_array across i.arg
@

<<function [[Liveness.fundecl]]>>=
let fundecl f =
  let initially_live = live f.fun_body (*Reg.*)Set.empty in
  (* Sanity check: only function parameters can be live at entrypoint *)
  let wrong_live = (*Reg.*)Set.diff initially_live (Reg.set_of_array f.fun_args) in
  if not ((*Reg.*)Set.is_empty wrong_live) then begin
    Printmach.regset wrong_live; Format.print_newline();
    Misc.fatal_error "Liveness.fundecl"
  end
@


%-------------------------------------------------------------

<<asmcomp/liveness.ml>>=
<<copyright header>>

(* Liveness analysis.
   Annotate mach code with the set of regs live at each point. *)

open Mach

<<constant [[Liveness.live_at_exit]]>>
<<constant [[Liveness.live_at_break]]>>
<<constant [[Liveness.live_at_raise]]>>

<<function [[Liveness.live]]>>

<<function [[Liveness.fundecl]]>>
@


\subsection*{[[asmcomp/schedgen.mli]]}

<<type [[Schedgen.code_dag_node]]>>=
(* Instruction scheduling *)

type code_dag_node =
  { instr: Linearize.instruction;
    delay: int;
    mutable sons: (code_dag_node * int) list;
    mutable date: int;
    mutable length: int;
    mutable ancestors: int;
    mutable emitted_ancestors: int }
@

<<type [[Schedgen.scheduler]]>>=
type scheduler = {
  (* old: virtual *)
  (* Can be overriden by processor description *)
  oper_issue_cycles : Mach.operation -> int;
      (* Number of cycles needed to issue the given operation *)
  oper_latency : Mach.operation -> int;
      (* Number of cycles needed to complete the given operation *)
  oper_in_basic_block : Mach.operation -> bool;
      (* Says whether the given operation terminates a basic block *)

  (* Entry point *)
  schedule_fundecl : 
    scheduler ->
    Linearize.fundecl -> Linearize.fundecl;

  (* old: protected *)

  instr_in_basic_block: 
   scheduler -> Linearize.instruction -> bool;
  instr_latency:
   scheduler -> Linearize.instruction -> int;
  instr_issue_cycles:
   scheduler -> Linearize.instruction -> int;
  add_instruction:
   scheduler -> 
   code_dag_node list -> Linearize.instruction -> code_dag_node list;
  ready_instruction:
   int -> code_dag_node list -> code_dag_node option;
  reschedule:  
   scheduler -> 
   code_dag_node list -> int -> Linearize.instruction -> Linearize.instruction;
 
}
@

<<signature [[Schedgen.scheduler_generic]]>>=
val scheduler_generic: unit -> scheduler
@


%-------------------------------------------------------------

<<asmcomp/schedgen.mli>>=
<<copyright header 1997>>

<<type [[Schedgen.code_dag_node]]>>

<<type [[Schedgen.scheduler]]>>

<<signature [[Schedgen.scheduler_generic]]>>

(*
  oper_issue_cycles = super.oper_issue_cycles;
  oper_latency = super.oper_latency;
  oper_in_basic_block = super.oper_in_basic_block;
  schedule_fundecl = super.schedule_fundecl;
  instr_in_basic_block = super.instr_in_basic_block;
  instr_latency = super.instr_latency;
  instr_issue_cycles = super.instr_issue_cycles;
  add_instruction = super.add_instruction;
  ready_instruction = super.ready_instruction;
  reschedule = super.reschedule;
*)
@


\subsection*{[[asmcomp/selection.mli]]}

<<signature [[Selection.fundecl]]>>=
(* Selection of pseudo-instructions, assignment of pseudo-registers,
   sequentialization. *)

val fundecl: Cmm.fundecl -> Mach.fundecl
@


%-------------------------------------------------------------

<<asmcomp/selection.mli>>=
<<copyright header>>

<<signature [[Selection.fundecl]]>>
@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/selection.ml]]}

<<function [[Selection.is_immed]]>>=
(* Immediate operands are 8-bit immediate values, zero-extended, and rotated
   right by 0, 2, 4, ... 30 bits.
   To avoid problems with Caml's 31-bit arithmetic,
   we check only with 8-bit values shifted left 0 to 22 bits. *)

let rec is_immed n shift =
  if shift > 22 then false
  else if n land (0xFF lsl shift) = n then true
  else is_immed n (shift + 2)
@

<<function [[Selection.is_offset]]>>=
(* We have 12-bit signed offsets for word accesses,
   8-bit signed word offsets for float accesses,
   and 8-bit byte offsets for bytes and shorts.
   Use lowest common denominator. *)

let is_offset n = n < 128 && n > -128
@

<<function [[Selection.is_intconst]]>>=
let is_intconst = function Cconst_int n -> true | _ -> false
@

<<function [[Selection.select_shift_arith]]>>=
let select_shift_arith super self = (fun op shiftop shiftrevop args ->
  match args with
    [arg1; Cop(Clsl, [arg2; Cconst_int n])]
    when n > 0 && n < 32 && not(is_intconst arg2) ->
      (Ispecific(Ishiftarith(shiftop, n)), [arg1; arg2])
  | [arg1; Cop(Casr, [arg2; Cconst_int n])]
    when n > 0 && n < 32 && not(is_intconst arg2) ->
      (Ispecific(Ishiftarith(shiftop, -n)), [arg1; arg2])
  | [Cop(Clsl, [arg1; Cconst_int n]); arg2]
    when n > 0 && n < 32 && not(is_intconst arg1) ->
      (Ispecific(Ishiftarith(shiftrevop, n)), [arg2; arg1])
  | [Cop(Casr, [arg1; Cconst_int n]); arg2]
    when n > 0 && n < 32 && not(is_intconst arg1) ->
      (Ispecific(Ishiftarith(shiftrevop, -n)), [arg2; arg1])
  | _ ->
      super.select_operation self op args
 )
@

<<function [[Selection.selector]]>>=
(* Instruction selection *)

let selector () = 

 let super = Selectgen.selector_generic () in
 {

  (* todo: super with feature needed ... *)
  select_condition = super.select_condition;
  select_store = super.select_store;
  emit_extcall_args = super.emit_extcall_args;
  emit_fundecl = super.emit_fundecl;
  extract = super.extract;
  insert = super.insert;
  insert_move = super.insert_move;
  insert_move_args = super.insert_move_args;
  insert_move_results = super.insert_move_results;
  insert_moves = super.insert_moves;
  emit_expr = super.emit_expr;
  emit_tail = super.emit_tail;
  select_arith_comm = super.select_arith_comm;
  select_arith = super.select_arith;
  select_shift = super.select_shift;
  select_arith_comp = super.select_arith_comp;
  emit_let = super.emit_let;
  emit_parts_list = super.emit_parts_list;
  emit_parts = super.emit_parts;
  emit_tuple = super.emit_tuple;
  emit_stores = super.emit_stores;
  emit_sequence = super.emit_sequence;
  emit_return = super.emit_return;
  emit_tail_sequence = super.emit_tail_sequence;
  select_floatarith = super.select_floatarith;
  select_push = super.select_push;

 is_immediate = (fun n ->
  n land 0xFF = n || is_immed n 2
 );

 select_addressing = (function
    Cop(Cadda, [arg; Cconst_int n]) when is_offset n ->
      (Iindexed n, arg)
  | Cop(Cadda, [arg1; Cop(Caddi, [arg2; Cconst_int n])]) when is_offset n ->
      (Iindexed n, Cop(Cadda, [arg1; arg2]))
  | arg ->
      (Iindexed 0, arg)
 );
 

 select_operation = (fun self op args ->
  match op with
    Cadda | Caddi ->
      begin match args with
        [arg1; Cconst_int n] when n < 0 && self.is_immediate (-n) ->
          (Iintop_imm(Isub, -n), [arg1])
      | _ ->
          select_shift_arith super self op Ishiftadd Ishiftadd args
      end
  | Csuba | Csubi ->
      begin match args with
        [arg1; Cconst_int n] when n < 0 && self.is_immediate (-n) ->
          (Iintop_imm(Iadd, -n), [arg1])
      | [Cconst_int n; arg2] when self.is_immediate n ->
          (Ispecific(Irevsubimm n), [arg2])
      | _ ->
          select_shift_arith super self op Ishiftsub Ishiftsubrev args
      end
  | Cmuli ->			(* no multiply immediate *)
      (Iintop Imul, args)
  | Cdivi ->
      begin match args with
        [arg1; Cconst_int n] when n = 1 lsl (Misc.log2 n) ->
          (Iintop_imm(Idiv, n), [arg1])
      | _ ->
          (Iextcall("__divsi3", false), args)
      end
  | Cmodi ->
      begin match args with
        [arg1; Cconst_int n] when n = 1 lsl (Misc.log2 n) ->
          (Iintop_imm(Imod, n), [arg1])
      | _ ->
          (Iextcall("__modsi3", false), args)
      end
  | Ccheckbound ->
      begin match args with
        [Cop(Clsr, [arg1; Cconst_int n]); arg2]
    when n > 0 && n < 32 && not(is_intconst arg2) ->
      (Ispecific(Ishiftcheckbound n), [arg1; arg2])
      | _ ->
        super.select_operation self op args
      end
  | _ -> super.select_operation self op args
 );

(* In mul rd, rm, rs,  rm and rd must be different.
   We deal with this by pretending that rm is also a result of the mul
   operation. *)

 insert_op = (fun self op rs rd ->
  if op = Iintop(Imul) then begin
    self.insert (Iop op) rs [| rd.(0); rs.(0) |]; rd
  end else
    super.insert_op self op rs rd
 );
 }
@

<<function [[Selection.fundecl]]>>=
let fundecl f = 
  let s = selector () in
  s.emit_fundecl s f
@


%-------------------------------------------------------------

<<asmcomp/arm/selection.ml>>=
<<copyright header 1998>>

(* Instruction selection for the ARM processor *)

open Misc
open Cmm
open Reg
open Arch
open Mach

open Selectgen

<<function [[Selection.is_immed]]>>

<<function [[Selection.is_offset]]>>

<<function [[Selection.is_intconst]]>>




<<function [[Selection.select_shift_arith]]>>


<<function [[Selection.selector]]>>


<<function [[Selection.fundecl]]>>

@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/schedgen.ml]]}

<<type [[Schedgen.code_dag_node]]([[(asmcomp/schedgen.ml)]])>>=
(* Representation of the code DAG. *)

type code_dag_node =
  { instr: instruction;                 (* The instruction *)
    delay: int;           (* How many cycles before result is available *)
    mutable sons: (code_dag_node * int) list;
                                        (* Instructions that depend on it *)
    mutable date: int;                  (* Start date *)
    mutable length: int;                (* Length of longest path to result *)
    mutable ancestors: int;             (* Number of ancestors *)
    mutable emitted_ancestors: int }    (* Number of emitted ancestors *)
@

<<constant [[Schedgen.dummy_node]]>>=
let dummy_node =
  { instr = end_instr; delay = 0; sons = []; date = 0;
    length = -1; ancestors = 0; emitted_ancestors = 0 }
@

<<constant [[Schedgen.code_results]]>>=
(* The code dag itself is represented by two tables from registers to nodes:
   - "results" maps registers to the instructions that produced them;
   - "uses" maps registers to the instructions that use them. *)

let code_results = (Hashtbl.create 31 : (location, code_dag_node) Hashtbl.t)
@

<<constant [[Schedgen.code_uses]]>>=
let code_uses = (Hashtbl.create 31 : (location, code_dag_node) Hashtbl.t)
@

<<function [[Schedgen.clear_code_dag]]>>=
let clear_code_dag () =
  Hashtbl.clear code_results;
  Hashtbl.clear code_uses
@

<<function [[Schedgen.add_edge]]>>=
(* Add an edge to the code DAG *)

let add_edge ancestor son delay =
  ancestor.sons <- (son, delay) :: ancestor.sons;
  son.ancestors <- son.ancestors + 1
@

<<function [[Schedgen.is_critical]]>>=
(* Compute length of longest path to a result.
   For leafs of the DAG, see whether their result is used in the instruction
   immediately following the basic block (a "critical" output). *)

let is_critical critical_outputs results =
  try
    for i = 0 to Array.length results - 1 do
      let r = results.(i).loc in
      for j = 0 to Array.length critical_outputs - 1 do
        if critical_outputs.(j).loc = r then raise Exit
      done
    done;
    false
  with Exit ->
    true
@

<<function [[Schedgen.longest_path]]>>=
let rec longest_path critical_outputs node =
  if node.length < 0 then begin
    match node.sons with
      [] ->
        node.length <-
          if is_critical critical_outputs node.instr.res
          or node.instr.desc = Lreloadretaddr (* alway critical *)
          then node.delay
          else 0
    | sons ->
        node.length <- 
          List.fold_left
            (fun len (son, delay) ->
              max len (longest_path critical_outputs son + delay))
            0 sons
  end;
  node.length
@

<<function [[Schedgen.remove_instr]]>>=
(* Remove an instruction from the ready queue *)

let rec remove_instr node = function
    [] -> []
  | instr :: rem ->
      if instr == node then rem else instr :: remove_instr node rem
@

<<constant [[Schedgen.some_load]]>>=
(* We treat Lreloadretaddr as a word-sized load *)

let some_load = (Iload(Cmm.Word, Arch.identity_addressing))
@

<<type [[Schedgen.scheduler]]([[(asmcomp/schedgen.ml)]])>>=
type scheduler = {
  (* old: virtual *)
  (* Can be overriden by processor description *)
  oper_issue_cycles : Mach.operation -> int;
      (* Number of cycles needed to issue the given operation *)
  oper_latency : Mach.operation -> int;
      (* Number of cycles needed to complete the given operation *)
  oper_in_basic_block : Mach.operation -> bool;
      (* Says whether the given operation terminates a basic block *)

  (* Entry point *)
  schedule_fundecl : 
    scheduler ->
    Linearize.fundecl -> Linearize.fundecl;

  (* old: protected *)

  instr_in_basic_block: 
   scheduler -> Linearize.instruction -> bool;
  instr_latency:
   scheduler -> Linearize.instruction -> int;
  instr_issue_cycles:
   scheduler -> Linearize.instruction -> int;
  add_instruction:
   scheduler -> 
   code_dag_node list -> Linearize.instruction -> code_dag_node list;
  ready_instruction:
   int -> code_dag_node list -> code_dag_node option;
  reschedule:  
   scheduler -> 
   code_dag_node list -> int -> Linearize.instruction -> Linearize.instruction;
 
}
@

<<function [[Schedgen.scheduler_generic]]>>=
(* The generic scheduler *)

let scheduler_generic () =
 {

(* Determine whether an operation ends a basic block or not.
   Can be overriden for some processors to signal specific instructions
   that terminate a basic block, e.g. Istore_symbol for the 386. *)

 oper_in_basic_block = (function
    Icall_ind -> false
  | Icall_imm _ -> false
  | Itailcall_ind -> false
  | Itailcall_imm _ -> false
  | Iextcall(_, _) -> false
  | Istackoffset _ -> false
  | Istore(_, _) -> false
  | Ialloc _ -> false
  | _ -> true
 );

(* Determine whether an instruction ends a basic block or not *)

 instr_in_basic_block = (fun self instr ->
  match instr.desc with
    Lop op -> self.oper_in_basic_block op
  | Lreloadretaddr -> true
  | _ -> false
 );

(* Estimate the delay needed to evaluate an operation. *)

 oper_latency = (fun _ -> failwith "Schedgen.oper_lantency: virtual");

(* Estimate the delay needed to evaluate an instruction *)

 instr_latency = (fun self instr ->
  match instr.desc with
    Lop op ->
      self.oper_latency op
  | Lreloadretaddr ->
      self.oper_latency some_load
  | _ ->
      assert false
 );

(* Estimate the number of cycles consumed by emitting an operation. *)

 oper_issue_cycles = (fun _ -> failwith "Schedgen.oper_issue_cycles: virtual");

(* Estimate the number of cycles consumed by emitting an instruction. *)

 instr_issue_cycles = (fun self instr ->
  match instr.desc with
    Lop op ->
      self.oper_issue_cycles op
  | Lreloadretaddr ->
      self.oper_issue_cycles some_load
  | _ ->
      assert false
 );

(* Add an instruction to the code dag *)

 add_instruction = (fun self ready_queue instr ->
  let delay = self.instr_latency self instr in
  let node =
    { instr = instr;
      delay = delay;
      sons = [];
      date = 0;
      length = -1;
      ancestors = 0;
      emitted_ancestors = 0 } in
  (* Add edges from all instructions that define one of the registers used
     (RAW dependencies) *)
  for i = 0 to Array.length instr.arg - 1 do
    try
      let ancestor = Hashtbl.find code_results instr.arg.(i).loc in
      add_edge ancestor node ancestor.delay
    with Not_found ->
      ()
  done;
  (* Also add edges from all instructions that use one of the result regs
     of this instruction (WAR dependencies). *)
  for i = 0 to Array.length instr.res - 1 do
    let ancestors = Hashtbl.find_all code_uses instr.res.(i).loc in
    List.iter (fun ancestor -> add_edge ancestor node 0) ancestors
  done;
  (* Also add edges from all instructions that have already defined one
     of the results of this instruction (WAW dependencies). *)
  for i = 0 to Array.length instr.res - 1 do
    try
      let ancestor = Hashtbl.find code_results instr.res.(i).loc in
      add_edge ancestor node 0
    with Not_found ->
      ()
  done;
  (* Remember the registers used and produced by this instruction *)
  for i = 0 to Array.length instr.res - 1 do
    Hashtbl.add code_results instr.res.(i).loc node
  done;
  for i = 0 to Array.length instr.arg - 1 do
    Hashtbl.add code_uses instr.arg.(i).loc node
  done;
  (* If this is a root instruction (all arguments already computed),
     add it to the ready queue *)
  if node.ancestors = 0 then node :: ready_queue else ready_queue
 );

(* Given a list of instructions and a date, choose one or several
   that are ready to be computed (start date <= current date)
   and that we can emit in one cycle.  Favor instructions with
   maximal distance to result.  If we can't find any, return None.
   This does not take multiple issues into account, though. *)

 ready_instruction = (fun date queue ->
  let rec extract best = function
    [] ->
      if best == dummy_node then None else Some best
  | instr :: rem ->
      let new_best =
        if instr.date <= date && instr.length > best.length
        then instr else best in
      extract new_best rem in
  extract dummy_node queue
 );
  
(* Schedule a basic block, adding its instructions in front of the given
   instruction sequence *)

 reschedule = (fun self ready_queue date cont ->
  if ready_queue = [] then cont else begin
    match self.ready_instruction date ready_queue with
      None ->
        self.reschedule self ready_queue (date + 1) cont
    | Some node ->
        (* Remove node from queue *)
        let new_queue = ref (remove_instr node ready_queue) in
        (* Update the start date and number of ancestors emitted of
           all descendents of this node. Enter those that become ready
           in the queue. *)
        let issue_cycles = self.instr_issue_cycles self node.instr in
        List.iter
          (fun (son, delay) ->
            let completion_date = date + issue_cycles + delay - 1 in
            if son.date < completion_date then son.date <- completion_date;
            son.emitted_ancestors <- son.emitted_ancestors + 1;
            if son.emitted_ancestors = son.ancestors then
              new_queue := son :: !new_queue)
          node.sons;
        instr_cons node.instr.desc node.instr.arg node.instr.res
          (self.reschedule self !new_queue (date + issue_cycles) cont)
  end
 );

(* Entry point *)
(* Don't bother to schedule for initialization code and the like. *)

 schedule_fundecl = (fun self f ->

  let rec schedule i =
    match i.desc with
      Lend -> i
    | _ ->
        if self.instr_in_basic_block self i then begin
          clear_code_dag();
          schedule_block [] i
        end else
          { desc = i.desc; arg = i.arg; res = i.res; live = i.live;
            next = schedule i.next }

  and schedule_block ready_queue i =
    if self.instr_in_basic_block self i then
      schedule_block (self.add_instruction self ready_queue i) i.next
    else begin
      let critical_outputs =
        match i.desc with
          Lop(Icall_ind | Itailcall_ind) -> [| i.arg.(0) |]
        | Lop(Icall_imm _ | Itailcall_imm _ | Iextcall(_, _)) -> [||]
        | Lreturn -> [||]
        | _ -> i.arg in
      List.iter (fun x -> longest_path critical_outputs x; ()) ready_queue;
      self.reschedule self ready_queue 0 (schedule i)
    end in

  if f.fun_fast then begin
    let new_body = schedule f.fun_body in
    clear_code_dag();
    { fun_name = f.fun_name;
      fun_body = new_body;
      fun_fast = f.fun_fast }
  end else
    f
 );
 }
@


%-------------------------------------------------------------

<<asmcomp/schedgen.ml>>=
<<copyright header>>

(* Instruction scheduling *)

open Misc
open Reg
open Mach
open Linearize

<<type [[Schedgen.code_dag_node]]([[(asmcomp/schedgen.ml)]])>>

<<constant [[Schedgen.dummy_node]]>>

<<constant [[Schedgen.code_results]]>>
<<constant [[Schedgen.code_uses]]>>

<<function [[Schedgen.clear_code_dag]]>>

<<function [[Schedgen.add_edge]]>>

<<function [[Schedgen.is_critical]]>>

<<function [[Schedgen.longest_path]]>>

<<function [[Schedgen.remove_instr]]>>

<<constant [[Schedgen.some_load]]>>

<<type [[Schedgen.scheduler]]([[(asmcomp/schedgen.ml)]])>>

<<function [[Schedgen.scheduler_generic]]>>

@


\subsection*{[[asmcomp/emit.mli]]}

<<signature [[Emit.fundecl]]>>=
(* Generation of assembly code *)

val fundecl: Linearize.fundecl -> unit
@

<<signature [[Emit.data]]>>=
val data: Cmm.data_item list -> unit
@

<<signature [[Emit.begin_assembly]]>>=
val begin_assembly: unit -> unit
@

<<signature [[Emit.end_assembly]]>>=
val end_assembly: unit -> unit
@


%-------------------------------------------------------------

<<asmcomp/emit.mli>>=
<<copyright header>>

<<signature [[Emit.fundecl]]>>
<<signature [[Emit.data]]>>
<<signature [[Emit.begin_assembly]]>>
<<signature [[Emit.end_assembly]]>>
@


\subsection*{[[asmcomp/asmgen.mli]]}

<<signature [[Asmgen.compile_implementation]]>>=
(* From lambda to assembly code *)

val compile_implementation: string -> int -> Lambda.lambda -> unit
@

<<signature [[Asmgen.compile_phrase]]>>=
val compile_phrase: Cmm.phrase -> unit
@

<<type [[Asmgen.error]]>>=
type error = Assembler_error of string
@

<<exception [[Asmgen.Error]]>>=
exception Error of error
@

<<signature [[Asmgen.report_error]]>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/asmgen.mli>>=
<<copyright header>>

<<signature [[Asmgen.compile_implementation]]>>
<<signature [[Asmgen.compile_phrase]]>>

<<type [[Asmgen.error]]>>
<<exception [[Asmgen.Error]]>>
<<signature [[Asmgen.report_error]]>>


@


\subsection*{[[asmcomp/asmgen.ml]]}

<<type [[Asmgen.error]]([[(asmcomp/asmgen.ml)]])>>=
type error = Assembler_error of string
@

<<exception [[Asmgen.Error]]([[(asmcomp/asmgen.ml)]])>>=
exception Error of error
@

<<function [[Asmgen.liveness]]>>=
let liveness phrase =
  Liveness.fundecl phrase; phrase
@

<<function [[Asmgen.dump_if]]>>=
let dump_if flag message phrase =
  if !flag then Printmach.phase message phrase;
  phrase
@

<<function [[Asmgen.dump_linear_if]]>>=
let dump_linear_if flag message phrase =
  if !flag then begin
    print_string "*** "; print_string message; print_newline();
    Printlinear.fundecl phrase; print_newline()
  end;
  phrase
@

<<function [[Asmgen.regalloc]]>>=
let rec regalloc round fd =
  if round > 50 then
    fatal_error(fd.Mach.fun_name ^
                ": function too complex, cannot complete register allocation");
  dump_if dump_live "Liveness analysis" fd;
  Interf.build_graph fd;
  if !dump_interf then Printmach.interferences();
  if !dump_prefer then Printmach.preferences();
  Coloring.allocate_registers();
  dump_if dump_regalloc "After register allocation" fd;
  let (newfd, redo_regalloc) = Reload.fundecl fd in
  dump_if dump_reload "After insertion of reloading code" newfd;
  if redo_regalloc 
  then begin Reg.reinit(); Liveness.fundecl newfd; regalloc (round+1) newfd end
  else newfd
@

<<function [[Asmgen.TODOOPERATOR]]>>=
let (++) x f = f x
@

<<function [[Asmgen.compile_fundecl]]>>=
let compile_fundecl fd_cmm =
  Reg.reset();
  fd_cmm
  ++ Selection.fundecl
  ++ dump_if dump_selection "After instruction selection"
  ++ liveness
  ++ dump_if dump_live "Liveness analysis"
  ++ Spill.fundecl
  ++ liveness
  ++ dump_if dump_spill "After spilling"
  ++ Split.fundecl
  ++ dump_if dump_split "After live range splitting"
  ++ liveness
  ++ regalloc 1
  ++ Linearize.fundecl
  ++ dump_linear_if dump_linear "Linearized code"
  ++ Scheduling.fundecl
  ++ dump_linear_if dump_scheduling "After instruction scheduling"
  ++ Emit.fundecl
@

<<function [[Asmgen.compile_phrase]]>>=
let compile_phrase p =
  if !dump_cmm then begin Printcmm.phrase p; print_newline() end;
  match p with
    Cfunction fd -> compile_fundecl fd
  | Cdata dl -> Emit.data dl
@

<<function [[Asmgen.compile_implementation]]>>=
let compile_implementation prefixname size lam =
  let asmfile =
    if !keep_asm_file
    then prefixname ^ ext_asm
    else Filename.temp_file "camlasm" ext_asm in
  let oc = open_out asmfile in
  begin try
    Emitaux.output_channel := oc;
    Emit.begin_assembly();
    List.iter compile_phrase (Cmmgen.compunit size (Closure.intro size lam));
    Emit.end_assembly();
    close_out oc
  with x ->
    close_out oc;
    if !keep_asm_file then () else remove_file asmfile;
    raise x
  end;
  if Proc.assemble_file asmfile (prefixname ^ ext_obj) <> 0
  then raise(Error(Assembler_error asmfile));
  if !keep_asm_file then () else remove_file asmfile
@

<<function [[Asmgen.report_error]]>>=
(* Error report *)

let report_error = function
    Assembler_error file ->
      print_string "Assembler error, input left in file ";
      print_string file
@


%-------------------------------------------------------------

<<asmcomp/asmgen.ml>>=
<<copyright header>>

(* From lambda to assembly code *)

open Format
open Config
open Clflags
open Misc
open Cmm

<<type [[Asmgen.error]]([[(asmcomp/asmgen.ml)]])>>

<<exception [[Asmgen.Error]]([[(asmcomp/asmgen.ml)]])>>

<<function [[Asmgen.liveness]]>>

<<function [[Asmgen.dump_if]]>>

<<function [[Asmgen.dump_linear_if]]>>

<<function [[Asmgen.regalloc]]>>

<<function [[Asmgen.TODOOPERATOR]]>>

<<function [[Asmgen.compile_fundecl]]>>

<<function [[Asmgen.compile_phrase]]>>

<<function [[Asmgen.compile_implementation]]>>

<<function [[Asmgen.report_error]]>>
@


\subsection*{[[asmcomp/asmlink.mli]]}

<<signature [[Asmlink.link]]>>=
(* Link a set of .cmx/.o files and produce an executable *)

val link: string list -> unit
@

<<type [[Asmlink.error]]>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
  | Missing_implementations of string list
  | Inconsistent_interface of string * string * string
  | Inconsistent_implementation of string * string * string
  | Assembler_error of string
  | Linking_error
@

<<exception [[Asmlink.Error]]>>=
exception Error of error
@

<<signature [[Asmlink.report_error]]>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/asmlink.mli>>=
<<copyright header>>

<<signature [[Asmlink.link]]>>

<<type [[Asmlink.error]]>>

<<exception [[Asmlink.Error]]>>

<<signature [[Asmlink.report_error]]>>
@


\subsection*{[[asmcomp/asmlink.ml]]}

<<type [[Asmlink.error]]([[(asmcomp/asmlink.ml)]])>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
  | Missing_implementations of string list
  | Inconsistent_interface of string * string * string
  | Inconsistent_implementation of string * string * string
  | Assembler_error of string
  | Linking_error
@

<<exception [[Asmlink.Error]]([[(asmcomp/asmlink.ml)]])>>=
exception Error of error
@

<<constant [[Asmlink.crc_interfaces]]>>=
(* Consistency check between interfaces and implementations *)

let crc_interfaces =
@

<<constant [[Asmlink.crc_implementations]]>>=
let crc_implementations =
@

<<function [[Asmlink.check_consistency]]>>=
let check_consistency file_name unit crc =
  List.iter
    (fun (name, crc) ->
      if name = unit.ui_name then begin
        Hashtbl.add crc_interfaces name (file_name, crc)
      end else begin
        try
          let (auth_name, auth_crc) = Hashtbl.find crc_interfaces name in
          if crc <> auth_crc then
            raise(Error(Inconsistent_interface(name, file_name, auth_name)))
        with Not_found ->
          (* Can only happen for unit for which only a .cmi file was used,
             but no .cmo is provided *)
          Hashtbl.add crc_interfaces name (file_name, crc)
      end)
    unit.ui_imports_cmi;
  List.iter
    (fun (name, crc) ->
      if crc <> cmx_not_found_crc then begin
      try
        let (auth_name, auth_crc) = Hashtbl.find crc_implementations name in
        if crc <> auth_crc then
          raise(Error(Inconsistent_implementation(name, file_name, auth_name)))
      with Not_found ->
        Hashtbl.add crc_implementations name (file_name, crc)
      end)
    unit.ui_imports_cmx;
  Hashtbl.add crc_implementations unit.ui_name (file_name, crc)
@

<<constant [[Asmlink.missing_globals]]>>=
let missing_globals = ref StringSet.empty
@

<<function [[Asmlink.is_required]]>>=
let is_required name =
  StringSet.mem name !missing_globals
@

<<function [[Asmlink.add_required]]>>=
let add_required (name, crc) =
  missing_globals := StringSet.add name !missing_globals
@

<<function [[Asmlink.remove_required]]>>=
let remove_required name =
  missing_globals := StringSet.remove name !missing_globals
@

<<function [[Asmlink.scan_file]]>>=
let scan_file obj_name tolink =
  let file_name =
    try
      find_in_path !load_path obj_name
    with Not_found ->
      raise(Error(File_not_found obj_name)) in
  if Filename.check_suffix file_name ".cmx" then begin
    (* This is a .cmx file. It must be linked in any case.
       Read the infos to see which modules it requires. *)
    let (info, crc) = Compilenv.read_unit_info file_name in
    check_consistency file_name info crc;
    remove_required info.ui_name;
    List.iter add_required info.ui_imports_cmx;
    info :: tolink
  end
  else if Filename.check_suffix file_name ".cmxa" then begin
    (* This is an archive file. Each unit contained in it will be linked
       in only if needed. *)
    let ic = open_in_bin file_name in
    let buffer = String.create (String.length cmxa_magic_number) in
    really_input ic buffer 0 (String.length cmxa_magic_number);
    if buffer <> cmxa_magic_number then
      raise(Error(Not_an_object_file file_name));
    let info_crc_list = (input_value ic : (unit_infos * Digest.t) list) in
    close_in ic;
    List.fold_right
      (fun (info, crc) reqd ->
        if info.ui_force_link
        || !Clflags.link_everything
        || is_required info.ui_name then begin
          check_consistency file_name info crc;
          remove_required info.ui_name;
          List.iter add_required info.ui_imports_cmx;
          info :: reqd
        end else
          reqd)
    info_crc_list tolink
  end
  else raise(Error(Not_an_object_file file_name))
@

<<function [[Asmlink.make_startup_file]]>>=
let make_startup_file filename info_list =
  let oc = open_out filename in
  Emitaux.output_channel := oc;
  Location.input_name := "startup"; (* set the name of the "current" input *)
  Compilenv.reset "startup"; (* set the name of the "current" compunit *)
  Emit.begin_assembly();
  let name_list = List.map (fun ui -> ui.ui_name) info_list in
  Asmgen.compile_phrase(Cmmgen.entry_point name_list);
  let apply_functions = ref (IntSet.add 2 (IntSet.add 3 IntSet.empty)) in
  (* The callback functions always reference caml_apply[23] *)
  let curry_functions =
    ref IntSet.empty in
  List.iter
    (fun info ->
      List.iter
        (fun n -> apply_functions := IntSet.add n !apply_functions)
        info.ui_apply_fun;
      List.iter
        (fun n -> curry_functions := IntSet.add n !curry_functions)
        info.ui_curry_fun)
    info_list;
  IntSet.iter
    (fun n -> Asmgen.compile_phrase(Cmmgen.apply_function n))
    !apply_functions;
  IntSet.iter
    (fun n -> List.iter Asmgen.compile_phrase (Cmmgen.curry_function n))
    !curry_functions;
  Array.iter
    (fun name -> Asmgen.compile_phrase(Cmmgen.predef_exception name))
    Runtimedef.builtin_exceptions;
  Asmgen.compile_phrase(Cmmgen.global_table name_list);
  Asmgen.compile_phrase(Cmmgen.data_segment_table name_list);
  Asmgen.compile_phrase(Cmmgen.code_segment_table name_list);
  Asmgen.compile_phrase
    (Cmmgen.frame_table("startup" :: "system" :: name_list));
  Emit.end_assembly();
  close_out oc
@

<<function [[Asmlink.call_linker]]>>=
let call_linker file_list startup_file =
  let libname = "libasmrun" ^ ext_lib in
  let runtime_lib =
    try
      find_in_path !load_path libname
    with Not_found ->
      raise(Error(File_not_found libname)) in
  let cmd =
    match Config.system with
    | _ ->
        if not !Clflags.output_c_object then
          Printf.sprintf "%s -o %s -I%s %s %s %s -L%s %s %s %s"
            Config.native_c_compiler
            !Clflags.exec_name
            Config.standard_library
            (String.concat " " (List.rev !Clflags.ccopts))
            startup_file
            (String.concat " " (List.rev file_list))
            Config.standard_library
            (String.concat " " (List.rev !Clflags.ccobjs))
            runtime_lib
            Config.c_libraries
        else
          Printf.sprintf "%s -o %s %s %s"
            Config.native_partial_linker
            !Clflags.object_name
            startup_file
            (String.concat " " (List.rev file_list))
  in if Ccomp.command cmd <> 0 then raise(Error Linking_error)
@

<<signature [[Config.native_partial_linker]]>>=
val native_partial_linker: string
        (* The linker to use for partial links (-output-obj option) *)
@

<<function [[Asmlink.object_file_name]]>>=
let object_file_name name =
  let file_name =
    try
      find_in_path !load_path name
    with Not_found ->
      fatal_error "Asmlink.object_file_name: not found" in
  if Filename.check_suffix file_name ".cmx" then
    Filename.chop_suffix file_name ".cmx" ^ ext_obj
  else if Filename.check_suffix file_name ".cmxa" then
    Filename.chop_suffix file_name ".cmxa" ^ ext_lib
  else
    fatal_error "Asmlink.object_file_name: bad ext"
@

<<constant [[Clflags.keep_startup_file]]>>=
let keep_startup_file = ref false       (* -dstartup *)
@

<<function [[Asmlink.link]]>>=
(* Main entry point *)

let link objfiles =
  let objfiles = "stdlib.cmxa" :: (objfiles @ ["std_exit.cmx"]) in
  let units_tolink = List.fold_right scan_file objfiles [] in
  Array.iter remove_required Runtimedef.builtin_exceptions;
  if not (StringSet.is_empty !missing_globals) then
    raise(Error(Missing_implementations(StringSet.elements !missing_globals)));
  let startup = Filename.temp_file "camlstartup" ext_asm in
  make_startup_file startup units_tolink;
  let startup_obj = Filename.temp_file "camlstartup" ext_obj in
  if Proc.assemble_file startup startup_obj <> 0 then
    raise(Error(Assembler_error startup));
  try
    call_linker (List.map object_file_name objfiles) startup_obj;
    if not !Clflags.keep_startup_file then remove_file startup;
    remove_file startup_obj
  with x ->
    remove_file startup_obj;
    raise x
@

<<function [[Asmlink.report_error]]>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Not_an_object_file name ->
      print_string "The file "; print_string name;
      print_string " is not a compilation unit description"
  | Missing_implementations l ->
      open_box 0;
      print_string
        "No implementation(s) provided for the following module(s):";
      List.iter (fun s -> print_space(); print_string s) l;
      close_box()
  | Inconsistent_interface(intf, file1, file2) ->
      open_hvbox 0;
      print_string "Files "; print_string file1; print_string " and ";
      print_string file2; print_space();
      print_string "make inconsistent assumptions over interface ";
      print_string intf;
      close_box()
  | Inconsistent_implementation(intf, file1, file2) ->
      open_hvbox 0;
      print_string "Files "; print_string file1; print_string " and ";
      print_string file2; print_space();
      print_string "make inconsistent assumptions over implementation ";
      print_string intf;
      close_box()
  | Assembler_error file ->
      print_string "Error while assembling "; print_string file
  | Linking_error ->
      print_string "Error during linking"
@


%-------------------------------------------------------------

<<asmcomp/asmlink.ml>>=
<<copyright header>>

(* Link a set of .cmx/.o files and produce an executable *)

open Sys
open Misc
open Config
open Compilenv

<<type [[Asmlink.error]]([[(asmcomp/asmlink.ml)]])>>

<<exception [[Asmlink.Error]]([[(asmcomp/asmlink.ml)]])>>

<<constant [[Asmlink.crc_interfaces]]>>
      (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)
<<constant [[Asmlink.crc_implementations]]>>
      (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)

<<function [[Asmlink.check_consistency]]>>

(* First pass: determine which units are needed *)

module StringSet = Set

<<constant [[Asmlink.missing_globals]]>>

<<function [[Asmlink.is_required]]>>

<<function [[Asmlink.add_required]]>>

<<function [[Asmlink.remove_required]]>>

<<function [[Asmlink.scan_file]]>>

(* Second pass: generate the startup file and link it with everything else *)

module IntSet = Set

<<function [[Asmlink.make_startup_file]]>>

<<function [[Asmlink.call_linker]]>>

<<function [[Asmlink.object_file_name]]>>

<<function [[Asmlink.link]]>>

(* Error report *)

open Format

<<function [[Asmlink.report_error]]>>
@


\section{[[driver/]]}

\subsection*{[[driver/optcompile.mli]]}

<<signature [[Optcompile.interface]]>>=
(* Compile a .ml or .mli file *)

val interface: string -> unit
@

<<signature [[Optcompile.implementation]]>>=
val implementation: string -> unit
@

<<signature [[Optcompile.c_file]]>>=
val c_file: string -> unit
@

<<signature [[Optcompile.initial_env]]>>=
val initial_env: unit -> Env.t
@

<<signature [[Optcompile.init_path]]>>=
val init_path: unit -> unit
@


%-------------------------------------------------------------

<<driver/optcompile.mli>>=
<<copyright header>>

<<signature [[Optcompile.interface]]>>
<<signature [[Optcompile.implementation]]>>
<<signature [[Optcompile.c_file]]>>

<<signature [[Optcompile.initial_env]]>>
<<signature [[Optcompile.init_path]]>>
@


\subsection*{[[driver/optcompile.ml]]}

<<function [[Optcompile.init_path]]>>=
(* Initialize the search path.
   The current directory is always searched first,
   then the directories specified with the -I option (in command-line order),
   then the standard library directory. *)

let init_path () =
  let dirs =
    if !Clflags.thread_safe then
     Filename.concat Config.standard_library "threads" :: !Clflags.include_dirs
    else
     !Clflags.include_dirs in
  load_path := "" :: List.rev (Config.standard_library :: dirs);
  Env.reset_cache()
@

<<function [[Optcompile.initial_env]]>>=
(* Return the initial environment in which compilation proceeds. *)

let initial_env () =
  init_path();
  try
    if !Clflags.nopervasives
    then Env.initial
    else Env.open_pers_signature "Pervasives" Env.initial
  with Not_found ->
    fatal_error "cannot open Pervasives.cmi"
@

<<function [[Optcompile.preprocess]]>>=
(* Optionally preprocess a source file *)

let preprocess sourcefile tmpfile =
  match !Clflags.preprocessor with
    None -> sourcefile
  | Some pp ->
      let comm = pp ^ " " ^ sourcefile ^ " > " ^ tmpfile in
      if Ccomp.command comm <> 0 then begin
        Printf.eprintf "Preprocessing error\n";
        flush stderr;
        exit 2
      end;
      tmpfile
@

<<function [[Optcompile.remove_preprocessed]]>>=
let remove_preprocessed inputfile =
  match !Clflags.preprocessor with
    None -> ()
  | Some _ -> remove_file inputfile
@

<<exception [[Optcompile.Outdated_version]]>>=
(* Parse a file or get a dumped syntax tree in it *)

exception Outdated_version
@

<<function [[Optcompile.parse_file]]>>=
let parse_file inputfile parse_fun ast_magic =
  let ic = open_in_bin inputfile in
  let is_ast_file =
    try
      let buffer = Bytes.create (String.length ast_magic) in
      really_input ic buffer 0 (String.length ast_magic);
      if buffer = ast_magic then true
      else if String.sub buffer 0 9 = String.sub ast_magic 0 9 then
        raise Outdated_version
      else false
    with
      Outdated_version ->
        fatal_error "Ocaml and preprocessor have incompatible versions"
    | _ -> false
  in
  let ast =
    try
      if is_ast_file then begin
        Location.input_name := input_value ic;
        input_value ic
      end else begin
        seek_in ic 0;
        Location.input_name := inputfile;
        parse_fun (Lexing.from_channel ic)
      end
    with x -> close_in ic; raise x
  in
  close_in ic;
  ast
@

<<function [[Optcompile.interface]]>>=
(* Compile a .mli file *)

let interface sourcefile =
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppi") in
  let ast = parse_file inputfile Parse.interface ast_intf_magic_number in
  let sg = Typemod.transl_signature (initial_env()) ast in
  if !Clflags.print_types then (Printtyp.signature sg; print_newline());
  Env.save_signature sg modulename (prefixname ^ ".cmi");
  remove_preprocessed inputfile
@

<<function [[Optcompile.print_if]]>>=
(* Compile a .ml file *)

let print_if flag printer arg =
  if !flag then begin printer arg; print_newline() end;
  arg
@

<<function [[Optcompile.implementation]]>>=
let implementation sourcefile =
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppo") in
  let ast = parse_file inputfile Parse.implementation ast_impl_magic_number in
  let (str, sg, finalenv) = Typemod.type_structure (initial_env()) ast in
  if !Clflags.print_types then (Printtyp.signature sg; print_newline());

(*
  let coercion =
    if Sys.file_exists (prefixname ^ ".mli") then begin
      let intf_file =
        try find_in_path !load_path (prefixname ^ ".cmi")
        with Not_found -> prefixname ^ ".cmi" in
      let dclsig = Env.read_signature modulename intf_file in
      Includemod.compunit sourcefile sg intf_file dclsig
    end else begin
      Typemod.check_nongen_schemes finalenv str;
      Env.save_signature sg modulename (prefixname ^ ".cmi");
      Tcoerce_none
    end in
*)

    let (coercion, crc) =
      if Sys.file_exists (prefixname ^ ".mli") then begin
        let intf_file =
          try find_in_path !load_path (prefixname ^ ".cmi")
          with Not_found -> prefixname ^ ".cmi" in
        let (dclsig, crc) = Env.read_signature modulename intf_file in
        (Includemod.compunit sourcefile sg intf_file dclsig, crc)
      end else begin
        let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
        Typemod.check_nongen_schemes str;
        (Tcoerce_none, crc)
      end in

  Compilenv.reset modulename;
  let (compunit_size, lam) =
    Translmod.transl_store_implementation modulename str coercion in
  Asmgen.compile_implementation prefixname compunit_size
    (print_if Clflags.dump_lambda Printlambda.lambda
      (Simplif.simplify_lambda
        (print_if Clflags.dump_rawlambda Printlambda.lambda lam)));
  Compilenv.save_unit_info (prefixname ^ ".cmx");
  remove_preprocessed inputfile
@

<<function [[Optcompile.c_file]]>>=
let c_file name =
  if Ccomp.compile_file_native name <> 0 then exit 2
@


%-------------------------------------------------------------

<<driver/optcompile.ml>>=
<<copyright header>>

(* The batch compiler *)

open Misc
open Config
open Format
open Typedtree

<<function [[Optcompile.init_path]]>>

<<function [[Optcompile.initial_env]]>>

<<function [[Optcompile.preprocess]]>>

<<function [[Optcompile.remove_preprocessed]]>>

<<exception [[Optcompile.Outdated_version]]>>

<<function [[Optcompile.parse_file]]>>

<<function [[Optcompile.interface]]>>

<<function [[Optcompile.print_if]]>>

<<function [[Optcompile.implementation]]>>

<<function [[Optcompile.c_file]]>>
@


\subsection*{[[driver/opterrors.mli]]}

<<signature [[Opterrors.report_error]]>>=
(* Error report *)

val report_error: exn -> unit
@


%-------------------------------------------------------------

<<driver/opterrors.mli>>=
<<copyright header>>

<<signature [[Opterrors.report_error]]>>
@


\subsection*{[[driver/opterrors.ml]]}

<<function [[Opterrors.report_error]]>>=
(* Report an error *)

let report_error exn =
  open_box 0;
  begin match exn with
    Lexer.Error(err, start, stop) ->
      Location.print {loc_start = start; loc_end = stop};
      Lexer.report_error err
  | Syntaxerr.Error err ->
      Syntaxerr.report_error err
  | Env.Error err ->
      Env.report_error err
  | Typecore.Error(loc, err) ->
      Location.print loc; Typecore.report_error err
  | Typetexp.Error(loc, err) ->
      Location.print loc; Typetexp.report_error err
  | Typedecl.Error(loc, err) ->
      Location.print loc; Typedecl.report_error err
  | Includemod.Error err ->
      Includemod.report_error err
  | Typemod.Error(loc, err) ->
      Location.print loc; Typemod.report_error err
  | Translcore.Error(loc, err) ->
      Location.print loc; Translcore.report_error err
  | Compilenv.Error code ->
      Compilenv.report_error code
  | Asmgen.Error code ->
      Asmgen.report_error code
  | Asmlink.Error code ->
      Asmlink.report_error code
  | Asmlibrarian.Error code ->
      Asmlibrarian.report_error code
  | Sys_error msg ->
      print_string "I/O error: "; print_string msg
  | x ->
      close_box(); raise x
  end;
  close_box(); print_newline()
@


%-------------------------------------------------------------

<<driver/opterrors.ml>>=
<<copyright header>>

(* Error report *)

open Format
open Location

<<function [[Opterrors.report_error]]>>
@


\subsection*{[[driver/optmain.ml]]}

<<function [[Optmain.process_interface_file]]>>=
let process_interface_file name =
  Optcompile.interface name
@

<<function [[Optmain.process_implementation_file]]>>=
let process_implementation_file name =
  Optcompile.implementation name;
  objfiles := (Filename.chop_extension name ^ ".cmx") :: !objfiles
@

<<function [[Optmain.process_file]]>>=
let process_file name =
  if Filename.check_suffix name ".ml"
  or Filename.check_suffix name ".mlt" then begin
    Optcompile.implementation name;
    objfiles := (Filename.chop_extension name ^ ".cmx") :: !objfiles
  end
  else if Filename.check_suffix name ".mli" then
    Optcompile.interface name
  else if Filename.check_suffix name ".cmx" 
       or Filename.check_suffix name ".cmxa" then
    objfiles := name :: !objfiles
  else if Filename.check_suffix name ext_obj
       or Filename.check_suffix name ext_lib then
    ccobjs := name :: !ccobjs
  else if Filename.check_suffix name ".c" then begin
    Optcompile.c_file name;
    ccobjs := (Filename.chop_suffix (Filename.basename name) ".c" ^ ext_obj)
    :: !ccobjs
  end
  else
    raise(Arg.Bad("don't know what to do with " ^ name))
@

<<function [[Optmain.print_version_number]]>>=
let print_version_number () =
  print_string "The Objective Caml native-code compiler, version ";
  print_string Config.version; print_newline();
  print_string "Standard library directory: ";
  print_string Config.standard_library; print_newline()
@

<<constant [[Optmain.usage]]>>=
let usage = "Usage: ocamlopt <options> <files>\nOptions are:"
@

<<function [[Optmain.main]]>>=
let main () =
  try
    native_code := true;
    Arg.parse [
       "-a", Arg.Set make_archive, " Build a library";
       "-c", Arg.Set compile_only, " Compile only (do not link)";
       "-cclib", Arg.String(fun s -> ccobjs := s :: !ccobjs),
             "<opt>  Pass option <opt> to the C linker";
       "-ccopt", Arg.String(fun s -> ccopts := s :: !ccopts),
             "<opt>  Pass option <opt> to the C compiler and linker";
       "-compact", Arg.Clear optimize_for_speed,
             " Optimize code size rather than speed";
       "-i", Arg.Set print_types, " Print the types";
       "-I", Arg.String(fun dir -> include_dirs := dir :: !include_dirs),
             "<dir>  Add <dir> to the list of include directories";
       "-impl", Arg.String process_implementation_file,
             "<file>  Compile <file> as a .ml file";
       "-inline", Arg.Int(fun n -> inline_threshold := n * 8),
             "<n>  Set aggressiveness of inlining to <n>";
       "-intf", Arg.String process_interface_file,
             "<file>  Compile <file> as a .mli file";
       "-linkall", Arg.Set link_everything,
             " Link all modules, even unused ones";
       "-noassert", Arg.Set noassert, " Don't compile assertion checks";
       "-o", Arg.String(fun s -> exec_name := s;
                                 archive_name := s;
                                 object_name := s),
             "<file>  Set output file name to <file> (default a.out)";
       "-output-obj", Arg.Unit(fun () -> output_c_object := true),
             "Output a C object file instead of an executable";
       "-pp", Arg.String(fun s -> preprocessor := Some s),
             "<command>  Pipe sources through preprocessor <command>";
       "-S", Arg.Set keep_asm_file, " Keep intermediate assembly file";
       "-thread", Arg.Set thread_safe, " Use thread-safe standard library";
       "-unsafe", Arg.Set fast,
             " No bounds checking on array and string access";
       "-v", Arg.Unit print_version_number, " Print compiler version number";
       "-verbose", Arg.Set verbose, " Print calls to external commands";

       "-nopervasives", Arg.Set nopervasives, " (undocumented)";
       "-drawlambda", Arg.Set dump_rawlambda, " (undocumented)";
       "-dlambda", Arg.Set dump_lambda, " (undocumented)";
       "-dcmm", Arg.Set dump_cmm, " (undocumented)";
       "-dsel", Arg.Set dump_selection, " (undocumented)";
       "-dlive", Arg.Unit(fun () -> dump_live := true;
                                    Printmach.print_live := true),
             " (undocumented)";
       "-dspill", Arg.Set dump_spill, " (undocumented)";
       "-dsplit", Arg.Set dump_split, " (undocumented)";
       "-dinterf", Arg.Set dump_interf, " (undocumented)";
       "-dprefer", Arg.Set dump_prefer, " (undocumented)";
       "-dalloc", Arg.Set dump_regalloc, " (undocumented)";
       "-dreload", Arg.Set dump_reload, " (undocumented)";
       "-dscheduling", Arg.Set dump_scheduling, " (undocumented)";
       "-dlinear", Arg.Set dump_linear, " (undocumented)";
       "-dstartup", Arg.Set keep_startup_file, " (undocumented)";

       "-", Arg.String process_file,
            "<file>  Treat <file> as a file name (even if it starts with `-')"
      ] process_file usage;
    if !make_archive then begin
      Optcompile.init_path();
      Asmlibrarian.create_archive (List.rev !objfiles) !archive_name
    end
    else if not !compile_only & !objfiles <> [] then begin
      Optcompile.init_path();
      Asmlink.link (List.rev !objfiles)
    end;
    exit 0
  with x ->
    Format.set_formatter_out_channel stderr;
    Opterrors.report_error x;
    exit 2
@

<<toplevel [[Optmain._1]]>>=
let _ = Printexc.catch main ()
@


%-------------------------------------------------------------

<<driver/optmain.ml>>=
<<copyright header>>

open Config
open Clflags

<<function [[Optmain.process_interface_file]]>>

<<function [[Optmain.process_implementation_file]]>>

<<function [[Optmain.process_file]]>>

<<function [[Optmain.print_version_number]]>>

<<constant [[Optmain.usage]]>>

<<function [[Optmain.main]]>>

<<toplevel [[Optmain._1]]>>
@


