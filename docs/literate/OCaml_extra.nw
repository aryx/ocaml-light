%TODO: stdlib/

% for syncweb -to_tex to be happy
% derives from utils/config.mlp, which is processed by configure?
<<utils/config.ml>>=
@

\section{[[utils/]]}

\subsection*{[[utils/config.mli]]}

<<signature [[Config.max_tag]]>>=
val max_tag: int
        (* Biggest tag that can be stored in the header of a block. *)
@

<<signature [[Config.max_young_wosize]]>>=
val max_young_wosize: int
        (* Maximal size of arrays that are directly allocated in the
           minor heap *)
@

<<signature [[Config.architecture]]>>=
val architecture: string
        (* Name of processor type for the native-code compiler *)
@

<<signature [[Config.model]]>>=
val model: string
        (* Name of processor submodel for the native-code compiler *)
@

<<signature [[Config.system]]>>=
val system: string
        (* Name of operating system for the native-code compiler *)
@


<<signature [[Config.ext_asm]]>>=
val ext_asm: string
        (* Extension for assembler files, e.g. [.s] under Unix. *)
@



%-------------------------------------------------------------

<<utils/config.mli>>=

<<copyright header>>

(* System configuration *)

<<signature [[Config.version]]>>

<<signature [[Config.standard_library]]>>
<<signature [[Config.bytecomp_c_compiler]]>>
<<signature [[Config.native_c_compiler]]>>
<<signature [[Config.native_partial_linker]]>>
<<signature [[Config.c_libraries]]>>
<<signature [[Config.ranlib]]>>

<<signature [[Config.load_path]]>>

<<signature [[Config.exec_magic_number]]>>
<<signature [[Config.cmi_magic_number]]>>
<<signature [[Config.cmo_magic_number]]>>
<<signature [[Config.cma_magic_number]]>>
<<signature [[Config.cmx_magic_number]]>>
<<signature [[Config.cmxa_magic_number]]>>
<<signature [[Config.ast_intf_magic_number]]>>
<<signature [[Config.ast_impl_magic_number]]>>

<<signature [[Config.max_tag]]>>
<<signature [[Config.max_young_wosize]]>>
<<signature [[Config.architecture]]>>
<<signature [[Config.model]]>>
<<signature [[Config.system]]>>

<<signature [[Config.ext_obj]]>>
<<signature [[Config.ext_asm]]>>
<<signature [[Config.ext_lib]]>>
@


\subsection*{[[utils/misc.mli]]}


%-------------------------------------------------------------

<<utils/misc.mli>>=
<<copyright header>>

(* Miscellaneous useful types and functions *)

<<signature [[Misc.fatal_error]]>>
<<exception [[Misc.Fatal_error]]>>

<<signature [[Misc.map_end]]>>
<<signature [[Misc.for_all2]]>>
<<signature [[Misc.filter]]>>
<<signature [[Misc.mem_assq]]>>
<<signature [[Misc.replicate_list]]>>

<<signature [[Misc.find_in_path]]>>
<<signature [[Misc.remove_file]]>>

<<signature [[Misc.create_hashtable]]>>

<<signature [[Misc.copy_file]]>>
<<signature [[Misc.copy_file_chunk]]>>

<<signature [[Misc.log2]]>>
<<signature [[Misc.align]]>>
<<signature [[Misc.no_overflow_add]]>>
<<signature [[Misc.no_overflow_sub]]>>
@


\subsection*{[[utils/misc.ml]]}



%-------------------------------------------------------------

<<utils/misc.ml>>=
<<copyright header>>

(* Errors *)

<<exception [[Misc.Fatal_error]]>>

<<function [[Misc.fatal_error]]>>

(* List functions *)

<<function [[Misc.map_end]]>>

<<function [[Misc.for_all2]]>>

<<function [[Misc.filter]]>>

<<function [[Misc.mem_assq]]>>

<<function [[Misc.replicate_list]]>>

(* File functions *)

<<function [[Misc.find_in_path]]>>

<<function [[Misc.remove_file]]>>

(* Hashtable functions *)

<<function [[Misc.create_hashtable]]>>

<<function [[Misc.copy_file]]>>

<<function [[Misc.copy_file_chunk]]>>

(* Integer operations *)

<<function [[Misc.log2]]>>

<<function [[Misc.align]]>>

<<function [[Misc.no_overflow_add]]>>

<<function [[Misc.no_overflow_sub]]>>

@


\subsection*{[[utils/tbl.mli]]}

<<signature [[Tbl.empty]]>>=
val empty: ('a, 'b) t
@

<<signature [[Tbl.add]]>>=
val add: 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t
@

<<signature [[Tbl.find]]>>=
val find: 'a -> ('a, 'b) t -> 'b
@

<<signature [[Tbl.remove]]>>=
val remove: 'a -> ('a,  'b) t -> ('a, 'b) t
@

<<signature [[Tbl.iter]]>>=
val iter: ('a -> 'b -> 'c) -> ('a, 'b) t -> unit
@

<<signature [[Tbl.print]]>>=
val print: ('a -> unit) -> ('b -> unit) -> ('a, 'b) t -> unit
@


%-------------------------------------------------------------

<<utils/tbl.mli>>=
<<copyright header>>

(* Association tables from any ordered type to any type.
   We use the generic ordering to compare keys. *)

type ('a, 'b) t

<<signature [[Tbl.empty]]>>
<<signature [[Tbl.add]]>>
<<signature [[Tbl.find]]>>
<<signature [[Tbl.remove]]>>
<<signature [[Tbl.iter]]>>

<<signature [[Tbl.print]]>>
@


\subsection*{[[utils/tbl.ml]]}

% lol, can now use Map :)

<<type [[Tbl.t]]>>=

type ('a, 'b) t =
    Empty
  | Node of ('a, 'b) t * 'a * 'b * ('a, 'b) t * int
@

<<constant [[Tbl.empty]]>>=
let empty = Empty
@

<<constant [[Tbl.height]]>>=
let height = function
    Empty -> 0
  | Node(_,_,_,_,h) -> h
@

<<function [[Tbl.create]]>>=
let create l x d r =
  let hl = height l and hr = height r in
  Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))
@

<<function [[Tbl.bal]]>>=
let bal l x d r =
  let hl = height l and hr = height r in
  if hl > hr + 1 then
    match l with
    | Node (ll, lv, ld, lr, _) when height ll >= height lr ->
        create ll lv ld (create lr x d r)
    | Node (ll, lv, ld, Node (lrl, lrv, lrd, lrr, _), _) ->
        create (create ll lv ld lrl) lrv lrd (create lrr x d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rv, rd, rr, _) when height rr >= height rl ->
        create (create l x d rl) rv rd rr
    | Node (Node (rll, rlv, rld, rlr, _), rv, rd, rr, _) ->
        create (create l x d rll) rlv rld (create rlr rv rd rr)
    | _ -> assert false
  else
    create l x d r
@

<<function [[Tbl.add]]>>=
let rec add x data = function
    Empty ->
      Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) as t ->
      let c = compare x v in
      if c = 0 then
        Node(l, x, data, r, h)
      else if c < 0 then
        bal (add x data l) v d r
      else
        bal l v d (add x data r)
@

<<function [[Tbl.find]]>>=
let rec find x = function
    Empty ->
      raise Not_found
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      if c = 0 then d
      else find x (if c < 0 then l else r)
@

<<function [[Tbl.merge]]>>=
let rec merge t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (Node(l1, v1, d1, r1, h1), Node(l2, v2, d2, r2, h2)) ->
      bal l1 v1 d1 (bal (merge r1 l2) v2 d2 r2)
@

<<function [[Tbl.remove]]>>=
let rec remove x = function
    Empty ->
      Empty
  | Node(l, v, d, r, h) as t ->
      let c = compare x v in
      if c = 0 then
        merge l r
      else if c < 0 then
        bal (remove x l) v d r
      else
        bal l v d (remove x r)
@

<<function [[Tbl.iter]]>>=
let rec iter f = function
    Empty -> ()
  | Node(l, v, d, r, _) ->
      iter f l; f v d; iter f r
@

<<function [[Tbl.print]]>>=
(* @Scheck: dumper *)
let print print_key print_data tbl =
  open_hvbox 2;
  print_string "[[";
  iter (fun k d ->
          open_box 2;
          print_key k; print_string " ->"; print_space();
          print_data d; print_string ";";
          close_box(); print_space())
        tbl;
  print_string "]]";
  close_box()
@


%-------------------------------------------------------------

<<utils/tbl.ml>>=
<<copyright header>>
<<type [[Tbl.t]]>>

<<constant [[Tbl.empty]]>>

<<constant [[Tbl.height]]>>

<<function [[Tbl.create]]>>

<<function [[Tbl.bal]]>>

<<function [[Tbl.add]]>>

<<function [[Tbl.find]]>>

<<function [[Tbl.merge]]>>

<<function [[Tbl.remove]]>>

<<function [[Tbl.iter]]>>

open Format

<<function [[Tbl.print]]>>
@


\subsection*{[[utils/terminfo.mli]]}


%-------------------------------------------------------------

<<utils/terminfo.mli>>=
<<copyright header>>

(* Basic interface to the terminfo database *)

external setupterm: unit -> unit = "terminfo_setup"
external getstr: string -> string = "terminfo_getstr"
external getnum: string -> int = "terminfo_getnum"
external puts: out_channel -> string -> int -> unit = "terminfo_puts"

@


\subsection*{[[utils/terminfo.ml]]}


%-------------------------------------------------------------

<<utils/terminfo.ml>>=
<<copyright header>>

(* Basic interface to the terminfo database *)

external setupterm: unit -> unit = "terminfo_setup"
external getstr: string -> string = "terminfo_getstr"
external getnum: string -> int = "terminfo_getnum"
external puts: out_channel -> string -> int -> unit = "terminfo_puts"

@


\subsection*{[[utils/clflags.ml]]}



%-------------------------------------------------------------

<<utils/clflags.ml>>=
<<copyright header>>

(* Command-line parameters *)

<<constant [[Clflags.objfiles]]>>
<<constant [[Clflags.ccobjs]]>>
<<constant [[Clflags.compile_only]]>>
<<constant [[Clflags.exec_name]]>>
<<constant [[Clflags.archive_name]]>>
<<constant [[Clflags.object_name]]>>
<<constant [[Clflags.include_dirs]]>>
<<constant [[Clflags.print_types]]>>
<<constant [[Clflags.make_archive]]>>
<<constant [[Clflags.debug]]>>
<<constant [[Clflags.fast]]>>
<<constant [[Clflags.link_everything]]>>
<<constant [[Clflags.custom_runtime]]>>
<<constant [[Clflags.output_c_object]]>>
<<constant [[Clflags.ccopts]]>>
<<constant [[Clflags.nopervasives]]>>
<<constant [[Clflags.preprocessor]]>>
<<constant [[Clflags.thread_safe]]>>
<<constant [[Clflags.noassert]]>>
<<constant [[Clflags.verbose]]>>

let output_c = ref false         (* -output-c *)

<<constant [[Clflags.dump_rawlambda]]>>
<<constant [[Clflags.dump_lambda]]>>
<<constant [[Clflags.dump_instr]]>>

<<constant [[Clflags.keep_asm_file]]>>
<<constant [[Clflags.optimize_for_speed]]>>

<<constant [[Clflags.dump_cmm]]>>
<<constant [[Clflags.dump_selection]]>>
<<constant [[Clflags.dump_live]]>>
<<constant [[Clflags.dump_spill]]>>
<<constant [[Clflags.dump_split]]>>
<<constant [[Clflags.dump_scheduling]]>>
<<constant [[Clflags.dump_interf]]>>
<<constant [[Clflags.dump_prefer]]>>
<<constant [[Clflags.dump_regalloc]]>>
<<constant [[Clflags.dump_reload]]>>
<<constant [[Clflags.dump_linear]]>>
<<constant [[Clflags.keep_startup_file]]>>

<<constant [[Clflags.native_code]]>>

<<constant [[Clflags.inline_threshold]]>>
@


\subsection*{[[utils/ccomp.mli]]}



%-------------------------------------------------------------

<<utils/ccomp.mli>>=
<<copyright header>>

(* Compiling C files and building C libraries *)

<<signature [[Ccomp.command]]>>
<<signature [[Ccomp.compile_file_bytecode]]>>
<<signature [[Ccomp.compile_file_native]]>>
<<signature [[Ccomp.create_archive]]>>
@


\subsection*{[[utils/ccomp.ml]]}

%-------------------------------------------------------------

<<utils/ccomp.ml>>=
<<copyright header>>

(* Compiling C files and building C libraries *)

<<function [[Ccomp.command]]>>

<<function [[Ccomp.compile_file_bytecode]]>>

<<function [[Ccomp.compile_file_native]]>>

<<function [[Ccomp.create_archive]]>>
@


\section{[[parsing/]]}

\subsection*{[[parsing/asttypes.mli]]}



%-------------------------------------------------------------

<<parsing/asttypes.mli>>=
<<copyright header>>

(* Auxiliary a.s.t. types used by parsetree and typedtree. *)

<<type [[Asttypes.constant]]>>

<<type [[Asttypes.rec_flag]]>>

<<type [[Asttypes.direction_flag]]>>

<<type [[Asttypes.mutable_flag]]>>
@


\subsection*{[[parsing/linenum.mli]]}



%-------------------------------------------------------------

<<parsing/linenum.mli>>=
<<copyright header 1997>>

<<signature [[Linenum.for_position]]>>
@

\subsection*{[[parsing/longident.mli]]}


%-------------------------------------------------------------

<<parsing/longident.mli>>=
<<copyright header>>

<<type [[Longident.t]]>>
@


\subsection*{[[parsing/longident.ml]]}


%-------------------------------------------------------------

<<parsing/longident.ml>>=
<<copyright header>>

<<type [[Longident.t]]>>
@


\subsection*{[[parsing/location.mli]]}



%-------------------------------------------------------------

<<parsing/location.mli>>=
<<copyright header>>

<<type [[Location.t]]>>

<<signature [[Location.none]]>>
<<signature [[Location.symbol_loc]]>>
<<signature [[Location.rhs_loc]]>>

<<signature [[Location.input_name]]>>
<<signature [[Location.input_lexbuf]]>>

<<signature [[Location.print]]>>
<<signature [[Location.print_warning]]>>
<<signature [[Location.echo_eof]]>>
<<signature [[Location.reset]]>>

<<signature [[Location.highlight_locations]]>>
@


\subsection*{[[parsing/location.ml]]}



<<type [[Location.terminal_info_status]]>>=
(* Terminal info *)

type terminal_info_status = Unknown | Bad_term | Good_term
@

<<function [[Location.setup_terminal_info]]>>=
let setup_terminal_info() =
  try
    Terminfo.setupterm();
    num_lines := Terminfo.getnum "li";
    cursor_up := Terminfo.getstr "up";
    cursor_down := Terminfo.getstr "do";
    begin try
      start_standout := Terminfo.getstr "us";
      end_standout := Terminfo.getstr "ue"
    with Not_found ->
      start_standout := Terminfo.getstr "so";
      end_standout := Terminfo.getstr "se"
    end;
    status := Good_term
  with _ ->
    status := Bad_term
@

<<constant [[Location.num_loc_lines]]>>=
(* Print the location using standout mode. *)

let num_loc_lines = ref 0 (* number of lines already printed after input *)
@

<<signature [[Location.highlight_locations]]>>=
val highlight_locations: t -> t -> bool
@

<<signature [[Location.input_lexbuf]]>>=
val input_lexbuf: Lexing.lexbuf option ref
@

<<constant [[Location.input_lexbuf]]>>=
let input_lexbuf = ref (None : lexbuf option)
@


<<function [[Location.highlight_locations]]>>=
let rec highlight_locations loc1 loc2 =
  match !status with
    Unknown ->
      setup_terminal_info(); highlight_locations loc1 loc2
  | Bad_term ->
      false
  | Good_term ->
      match !input_lexbuf with
        None -> false
      | Some lb ->
          (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
          let pos0 = -lb.lex_abs_pos in
          (* Do nothing if the buffer does not contain the whole phrase. *)
          if pos0 < 0 then false else begin
            (* Count number of lines in phrase *)
            let lines = ref !num_loc_lines in
            for i = pos0 to String.length lb.lex_buffer - 1 do
              if lb.lex_buffer.[i] = '\n' then incr lines
            done;
            (* If too many lines, give up *)
            if !lines >= !num_lines - 2 then false else begin
              (* Move cursor up that number of lines *)
              for i = 1 to !lines do
                Terminfo.puts stdout !cursor_up 1
              done;
              (* Print the input, switching to standout for the location *)
              let bol = ref false in
          print_string "# ";
              for pos = 0 to String.length lb.lex_buffer - pos0 - 1 do
                if !bol then (print_string "  "; bol := false);
                if pos = loc1.loc_start || pos = loc2.loc_start then
                  Terminfo.puts stdout !start_standout 1;
                if pos = loc1.loc_end || pos = loc2.loc_end then
                  Terminfo.puts stdout !end_standout 1;
                let c = lb.lex_buffer.[pos + pos0] in
                print_char c;
                bol := (c = '\n')
              done;
              (* Make sure standout mode is over *)
              Terminfo.puts stdout !end_standout 1;
              (* Position cursor back to original location *)
              for i = 1 to !num_loc_lines do
                Terminfo.puts stdout !cursor_down 1
              done;
              true
            end
          end
@

<<signature [[Location.reset]]>>=
val reset: unit -> unit
@

<<function [[Location.reset]]>>=
let reset () =
  num_loc_lines := 0
@


<<signature [[Location.echo_eof]]>>=
val echo_eof: unit -> unit
@

<<function [[Location.echo_eof]]>>=
let echo_eof () =
  print_newline ();
  incr num_loc_lines
@


%-------------------------------------------------------------

<<parsing/location.ml>>=
<<copyright header>>

open Lexing

<<type [[Location.t]]>>

<<constant [[Location.none]]>>

<<function [[Location.symbol_loc]]>>

<<function [[Location.rhs_loc]]>>

<<constant [[Location.input_name]]>>

<<constant [[Location.input_lexbuf]]>>

<<type [[Location.terminal_info_status]]>>

let status = ref Unknown
and num_lines = ref 0
and cursor_up = ref ""
and cursor_down = ref ""
and start_standout = ref ""
and end_standout = ref ""

<<function [[Location.setup_terminal_info]]>>

<<constant [[Location.num_loc_lines]]>>

<<function [[Location.highlight_locations]]>>

(* Print the location in some way or another *)

open Format

<<function [[Location.reset]]>>

<<constants [[Location.msg_xxx]]>>

<<function [[Location.print]]>>

<<function [[Location.print_warning]]>>

<<function [[Location.echo_eof]]>>

@


\subsection*{[[parsing/syntaxerr.mli]]}


%-------------------------------------------------------------

<<parsing/syntaxerr.mli>>=
<<copyright header 1997>>

<<type [[Syntaxerr.error]]>>

<<exception [[Syntaxerr.Error]]>>
<<exception [[Syntaxerr.Escape_error]]>>

<<signature [[Syntaxerr.report_error]]>>
@

\subsection*{[[parsing/syntaxerr.ml]]}



%-------------------------------------------------------------

<<parsing/syntaxerr.ml>>=
<<copyright header 1997>>

(* Auxiliary type for reporting syntax errors *)

open Format

<<type [[Syntaxerr.error]]>>

<<exception [[Syntaxerr.Error]]>>
<<exception [[Syntaxerr.Escape_error]]>>

<<function [[Syntaxerr.report_error]]>>

@


\subsection*{[[parsing/parsetree.mli]]}


%-------------------------------------------------------------

<<parsing/parsetree.mli>>=
<<copyright header>>

(* Abstract syntax tree produced by parsing *)

open Asttypes

(* Type expressions for the core language *)

<<type [[Parsetree.core_type]]>>

<<type [[Parsetree.core_type_desc]]>>

(* Value expressions for the core language *)

<<type [[Parsetree.pattern]]>>

<<type [[Parsetree.pattern_desc]]>>

<<type [[Parsetree.expression]]>>

<<type [[Parsetree.expression_desc]]>>

<<type [[Parsetree.value_description]]>>

(* Type declarations *)

<<type [[Parsetree.type_declaration]]>>

<<type [[Parsetree.type_kind]]>>

<<type [[Parsetree.exception_declaration]]>>

(* Type expressions for the module language *)

<<type [[Parsetree.module_type]]>>

<<type [[Parsetree.module_type_desc]]>>


<<type [[Parsetree.signature]]>>

<<type [[Parsetree.signature_item]]>>

<<type [[Parsetree.signature_item_desc]]>>

(* Value expressions for the module language *)

<<type [[Parsetree.module_expr]]>>

<<type [[Parsetree.module_expr_desc]]>>

<<type [[Parsetree.structure]]>>

<<type [[Parsetree.structure_item]]>>

<<type [[Parsetree.structure_item_desc]]>>

(* Toplevel phrases *)

<<type [[Parsetree.toplevel_phrase]]>>

<<type [[Parsetree.directive_argument]]>>
@




\subsection*{[[parsing/lexer.mll]]}



\subsection*{[[parsing/parser.mly]]}




\subsection*{[[parsing/lexer.mli]]}


%-------------------------------------------------------------

<<parsing/lexer.mli>>=
<<copyright header>>

<<signature [[Lexer.token]]>>

<<type [[Lexer.error]]>>

<<exception [[Lexer.Error]]>>

<<signature [[Lexer.report_error]]>>

@


\subsection*{[[parsing/parse.mli]]}


%-------------------------------------------------------------

<<parsing/parse.mli>>=
<<copyright header>>

(* Entry points in the parser *)

<<signature [[Parse.implementation]]>>
<<signature [[Parse.interface]]>>
<<signature [[Parse.toplevel_phrase]]>>
<<signature [[Parse.use_file]]>>

@


\subsection*{[[parsing/parse.ml]]}

%-------------------------------------------------------------

<<parsing/parse.ml>>=
<<copyright header>>

(* Entry points in the parser *)

open Location

<<function [[Parse.skip_phrase]]>>

<<function [[Parse.maybe_skip_phrase]]>>

<<function [[Parse.wrap]]>>

<<function [[Parse.implementation]]>>
<<function [[Parse.interface]]>>

<<function [[Parse.xxx]]>>
@


\section{[[typing/]]}

\subsection*{[[typing/ident.mli]]}














% todo, again replace with Map?
<<signature [[Ident.empty]]>>=
val empty: 'a tbl
@

<<signature [[Ident.add]]>>=
val add: t -> 'a -> 'a tbl -> 'a tbl
@

<<signature [[Ident.find_same]]>>=
val find_same: t -> 'a tbl -> 'a
@

<<signature [[Ident.find_name]]>>=
val find_name: string -> 'a tbl -> 'a
@

<<signature [[Ident.print_tbl]]>>=
val print_tbl: ('a -> unit) -> 'a tbl -> unit
@


%-------------------------------------------------------------

<<typing/ident.mli>>=
<<copyright header0>>

(* Identifiers (unique names) *)

type t

<<signature [[Ident.create]]>>
<<signature [[Ident.create_persistent]]>>
<<signature [[Ident.name]]>>
<<signature [[Ident.unique_name]]>>
<<signature [[Ident.persistent]]>>
<<signature [[Ident.same]]>>
<<signature [[Ident.identify]]>>
<<signature [[Ident.hide]]>>

<<signature [[Ident.make_global]]>>
<<signature [[Ident.global]]>>

<<signature [[Ident.print]]>>

type 'a tbl
        (* Association tables from identifiers to type 'a. *)

<<signature [[Ident.empty]]>>
<<signature [[Ident.add]]>>
<<signature [[Ident.find_same]]>>
<<signature [[Ident.find_name]]>>

<<signature [[Ident.print_tbl]]>>

@


\subsection*{[[typing/ident.ml]]}


%<<signature Ident.equal>>=
%val equal: t -> t -> bool
%        (* Compare identifiers by name. *)      
%@
%<<function Ident.equal>>=
%let equal i1 i2 = 
%  i1.name = i2.name
%@



<<type [[Ident.tbl]]>>=
type 'a tbl =
    Empty
  | Node of 'a tbl * 'a data * 'a tbl * int
@

<<type [[Ident.data]]>>=
and 'a data =
  { ident: t;
    data: 'a;
    previous: 'a data option }
@

<<constant [[Ident.empty]]>>=
let empty = Empty
@

<<function [[Ident.mknode]]>>=
(* Inline expansion of height for better speed
 * let height = function
 *     Empty -> 0
 *   | Node(_,_,_,h) -> h
 *)

let mknode l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))
@

<<function [[Ident.balance]]>>=
let balance l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 1 then
    let (Node(ll, ld, lr, _)) = l in
    if (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
       (match lr with Empty -> 0 | Node(_,_,_,h) -> h) then
      mknode ll ld (mknode lr d r)
    else
      let (Node(lrl, lrd, lrr, _)) = lr in
      mknode (mknode ll ld lrl) lrd (mknode lrr d r)
  else if hr > hl + 1 then
    let (Node(rl, rd, rr, _)) = r in
    if (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
       (match rl with Empty -> 0 | Node(_,_,_,h) -> h) then
      mknode (mknode l d rl) rd rr
    else
      let (Node(rll, rld, rlr, _)) = rl in
      mknode (mknode l d rll) rld (mknode rlr rd rr)
  else
    mknode l d r
@

<<function [[Ident.add]]>>=
let rec add id data = function
    Empty ->
      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
  | Node(l, k, r, h) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        Node(l, {ident = id; data = data; previous = Some k}, r, h)
      else if c < 0 then
        balance (add id data l) k r
      else
        balance l k (add id data r)
@

<<function [[Ident.find_stamp]]>>=
let rec find_stamp s = function
    None ->
      raise Not_found
  | Some k ->
      if k.ident.stamp = s then k.data else find_stamp s k.previous
@

<<function [[Ident.find_same]]>>=
let rec find_same id = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        if id.stamp = k.ident.stamp
        then k.data
        else find_stamp id.stamp k.previous
      else
        find_same id (if c < 0 then l else r)
@

<<function [[Ident.find_name]]>>=
let rec find_name name = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data
      else
        find_name name (if c < 0 then l else r)
@

<<function [[Ident.print_tbl]]>>=
let print_tbl print_elt tbl =
  open_hovbox 2;
  print_string "[[";
  let rec print_tbl = function
      Empty -> ()
    | Node(l, k, r, _) ->
        print_tbl l;
        print_entry k;
        print_tbl r
  and print_entry k =
    open_hovbox 2;
    print k.ident; print_string " ->"; print_space(); print_elt k.data;
    print_string ";"; close_box(); print_space();
    match k.previous with None -> () | Some k -> print_entry k in
  print_tbl tbl;
  print_string "]]";
  close_box()
@

<<signature [[Ident.print]]>>=
val print: t -> unit
@
<<function [[Ident.print]]>>=
let print i =
  print_string i.name;
  match i.stamp with
    0 -> print_string "!"
  | -1 -> print_string "#"
  | n -> print_string "/"; print_int n; if i.global then print_string "g"
@


%<<signature Ident.current_time>>=
%val current_time: unit -> int
%@
%% ???
%
%<<function Ident.current_time>>=
%let current_time _ = 1
%@
% ???

%-------------------------------------------------------------

<<typing/ident.ml>>=
<<copyright header0>>

open Format

<<type [[Ident.t]]>>

<<constant [[Ident.currentstamp]]>>

<<function [[Ident.create]]>>

<<function [[Ident.create_persistent]]>>

<<function [[Ident.name]]>>

<<function [[Ident.unique_name]]>>

<<function [[Ident.persistent]]>>

<<function [[Ident.same]]>>

<<function [[Ident.identify]]>>

<<function [[Ident.hide]]>>

<<function [[Ident.make_global]]>>

<<function [[Ident.global]]>>

<<function [[Ident.print]]>>

<<type [[Ident.tbl]]>>

<<type [[Ident.data]]>>

<<constant [[Ident.empty]]>>

<<function [[Ident.mknode]]>>

<<function [[Ident.balance]]>>

<<function [[Ident.add]]>>

<<function [[Ident.find_stamp]]>>

<<function [[Ident.find_same]]>>

<<function [[Ident.find_name]]>>

<<function [[Ident.print_tbl]]>>

@


\subsection*{[[typing/primitive.mli]]}


%-------------------------------------------------------------

<<typing/primitive.mli>>=
<<copyright header0>>


<<type [[Primitive.description]]>>

<<signature [[Primitive.parse_declaration]]>>
<<signature [[Primitive.print_description]]>>
@


\subsection*{[[typing/primitive.ml]]}



%-------------------------------------------------------------

<<typing/primitive.ml>>=
<<copyright header0>>

(* Description of primitive functions *)

open Format

<<type [[Primitive.description]]>>

<<function [[Primitive.parse_declaration]]>>

<<function [[Primitive.print_quoted]]>>

<<function [[Primitive.print_description]]>>
@


\subsection*{[[typing/path.mli]]}


%-------------------------------------------------------------

<<typing/path.mli>>=
<<copyright header0>>

<<type [[Path.t]]>>

<<signature [[Path.same]]>>
<<signature [[Path.isfree]]>>

<<signature [[Path.nopos]]>>
@


\subsection*{[[typing/path.ml]]}


%-------------------------------------------------------------

<<typing/path.ml>>=
<<copyright header0>>

<<type [[Path.t]]>>

<<constant [[Path.nopos]]>>

<<function [[Path.same]]>>

<<function [[Path.isfree]]>>
@


\subsection*{[[typing/types.ml]]}



%-------------------------------------------------------------

<<typing/types.ml>>=
<<copyright header0>>

open Asttypes

(* Type expressions for the core language *)

<<type [[Types.type_expr]]>>

<<type [[Types.type_variable]]>>

<<type [[Types.value_description]]>>

(* Constructor descriptions *)

<<type [[Types.constructor_description]]>>

<<type [[Types.constructor_tag]]>>

(* Record label descriptions *)

<<type [[Types.label_description]]>>

<<type [[Types.record_representation]]>>

(* Type definitions *)

<<type [[Types.type_declaration]]>>

<<type [[Types.type_kind]]>>

<<type [[Types.exception_declaration]]>>

(* Type expressions for the module language *)

<<type [[Types.module_type]]>>

<<type [[Types.signature]]>>

<<type [[Types.signature_item]]>>
@


\subsection*{[[typing/subst.mli]]}



%-------------------------------------------------------------

<<typing/subst.mli>>=
<<copyright header0>>

(* Substitutions *)

open Types

type t

<<signature [[Subst.identity]]>>

<<signature [[Subst.add_type]]>>
<<signature [[Subst.add_module]]>>
<<signature [[Subst.add_modtype]]>>

<<signature [[Subst.type_expr]]>>
<<signature [[Subst.value_description]]>>
<<signature [[Subst.type_declaration]]>>
<<signature [[Subst.exception_declaration]]>>
<<signature [[Subst.modtype]]>>
<<signature [[Subst.signature]]>>

@


\subsection*{[[typing/subst.ml]]}


%-------------------------------------------------------------

<<typing/subst.ml>>=
<<copyright header0>>

(* Substitutions *)

open Misc
open Path
open Types


<<type [[Subst.t]]>>

<<constant [[Subst.identity]]>>

<<function [[Subst.add_type]]>>

<<function [[Subst.add_module]]>>

<<function [[Subst.add_modtype]]>>

<<function [[Subst.module_path]]>>

<<function [[Subst.type_path]]>>

<<function [[Subst.type_expr]]>>

<<function [[Subst.value_description]]>>

<<function [[Subst.type_declaration]]>>

<<function [[Subst.exception_declaration]]>>

<<function [[Subst.modtype]]>>

@


\subsection*{[[typing/predef.mli]]}

%-------------------------------------------------------------

<<typing/predef.mli>>=
<<copyright header0>>

(* Predefined type constructors (with special typing rules in typecore) *)

open Types

<<signatures [[Predef.type_xxx]]>>

<<signatures [[Predef.path_xxx]]>>

<<signature [[Predef.path_match_failure]]>>

<<signature [[Predef.build_initial_env]]>>

<<signature [[Predef.builtin_values]]>>
@


\subsection*{[[typing/predef.ml]]}


%-------------------------------------------------------------

<<typing/predef.ml>>=
<<copyright header0>>

(* Predefined type constructors (with special typing rules in typecore) *)

open Path
open Types


<<constants [[Predef.ident_xxx]]>>
<<constants [[Predef.path_xxx]]>>

<<constants [[Predef.type_xxx]]>>


<<constants [[Predef.ident_exn_xxx]]>>

<<constant [[Predef.path_match_failure]]>>

<<function [[Predef.build_initial_env]]>>

<<constant [[Predef.builtin_values]]>>
@


\subsection*{[[typing/datarepr.mli]]}

%-------------------------------------------------------------

<<typing/datarepr.mli>>=
<<copyright header0>>

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types

<<signature [[Datarepr.constructor_descrs]]>>
<<signature [[Datarepr.exception_descr]]>>
<<signature [[Datarepr.label_descrs]]>>
@


\subsection*{[[typing/datarepr.ml]]}



%-------------------------------------------------------------

<<typing/datarepr.ml>>=
<<copyright header0>>

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Misc
open Asttypes
open Types

<<function [[Datarepr.constructor_descrs]]>>

<<function [[Datarepr.exception_descr]]>>

<<constant [[Datarepr.dummy_label]]>>

<<function [[Datarepr.is_float]]>>

<<function [[Datarepr.label_descrs]]>>
@


\subsection*{[[typing/env.mli]]}


%<<type Env.summary>>=
%@
% was for debugger, but deleted for now
%
%<<signature Env.summary>>=
%@


%-------------------------------------------------------------

<<typing/env.mli>>=
<<copyright header0>>

(* Environment handling *)

open Types

<<signature type Env.t>>

<<signature [[Env.empty]]>>
<<signature [[Env.initial]]>>

<<signature [[Env.find_value]]>>
<<signature [[Env.find_type]]>>

<<signature [[Env.lookup_value]]>>
<<signature [[Env.lookup_constructor]]>>
<<signature [[Env.lookup_label]]>>
<<signature [[Env.lookup_type]]>>
<<signature [[Env.lookup_module]]>>

(* Insertion by identifier *)

<<signature [[Env.add_value]]>>
<<signature [[Env.add_type]]>>
<<signature [[Env.add_exception]]>>
<<signature [[Env.add_module]]>>

<<signature [[Env.add_signature]]>>

<<signature [[Env.open_signature]]>>
<<signature [[Env.open_pers_signature]]>>

(* Insertion by name *)

<<signature [[Env.enter_value]]>>
<<signature [[Env.enter_type]]>>
<<signature [[Env.enter_exception]]>>
<<signature [[Env.enter_module]]>>

<<signature [[Env.reset_cache]]>>

<<signature [[Env.read_signature]]>>
<<signature [[Env.save_signature]]>>

<<signature [[Env.imported_units]]>>

<<type [[Env.error]]>>

<<exception [[Env.Error]]>>

<<signature [[Env.report_error]]>>

<<signature [[Env.check_modtype_inclusion]]>>

@


\subsection*{[[typing/env.ml]]}



%-------------------------------------------------------------

<<typing/env.ml>>=
<<copyright header0>>

(* Environment handling *)

open Format
open Config
open Misc
open Asttypes
open Longident
open Path
open Types


<<type [[Env.error]]>>

<<exception [[Env.Error]]>>


<<type [[Env.t]]>>

<<type [[Env.module_components]]>>

<<type [[Env.structure_components]]>>



<<constant [[Env.empty]]>>

<<type [[Env.pers_struct]]>>

<<constant [[Env.persistent_structures]]>>

<<constant [[Env.imported_units]]>>

<<function [[Env.read_pers_struct]]>>

<<function [[Env.find_pers_struct]]>>

<<function [[Env.reset_cache]]>>

<<constant [[Env.check_modtype_inclusion]]>>

<<function [[Env.find_module_descr]]>>

<<function [[Env.find]]>>

<<function [[Env.find_value]]>>
<<function [[Env.find_type]]>>


(* Lookup by name *)

<<function [[Env.lookup_module_descr]]>>

<<function [[Env.lookup_module]]>>


<<function [[Env.lookup]]>>

<<function [[Env.lookup_simple]]>>

<<function [[Env.lookup_value]]>>
<<function [[Env.lookup_type]]>>

<<function [[Env.lookup_constructor]]>>
<<function [[Env.lookup_label]]>>

<<function [[Env.scrape_modtype]]>>

<<function [[Env.constructors_of_type]]>>

<<function [[Env.labels_of_type]]>>

<<function [[Env.prefix_idents]]>>

(* Compute structure descriptions *)

<<function [[Env.components_of_module]]>>

(* Insertion of bindings by identifier + path *)

<<function [[Env.store_value]]>>

<<function [[Env.store_type]]>>

<<function [[Env.store_exceptions]]>>

<<function [[Env.store_module]]>>

<<function [[Env.store_components]]>>


(* Insertion of bindings by identifier *)

<<function [[Env.add_value]]>>
<<function [[Env.add_type]]>>
<<function [[Env.add_exception]]>>
<<function [[Env.add_module]]>>


<<function [[Env.enter]]>>

<<functions [[Env.enter_xxx]]>>

<<function [[Env.add_signature_component]]>>

<<function [[Env.add_signature]]>>

<<function [[Env.open_signature]]>>

<<function [[Env.open_pers_signature]]>>

<<function [[Env.read_signature]]>>

<<function [[Env.save_signature]]>>

<<constant [[Env.initial]]>>

<<function [[Env.imported_units]]>>

<<function [[Env.report_error]]>>
@


\subsection*{[[typing/typedtree.mli]]}


%-------------------------------------------------------------

<<typing/typedtree.mli>>=
<<copyright header0>>

(* Abstract syntax tree after typing *)

open Asttypes
open Types

(* Value expressions for the core language *)

<<type [[Typedtree.pattern]]>>

<<type [[Typedtree.pattern_desc]]>>

<<type [[Typedtree.expression]]>>

<<type [[Typedtree.expression_desc]]>>

(* Value expressions for the module language *)

<<type [[Typedtree.module_expr]]>>

<<type [[Typedtree.module_expr_desc]]>>

<<type [[Typedtree.structure]]>>

<<type [[Typedtree.structure_item]]>>

<<type [[Typedtree.module_coercion]]>>

<<signature [[Typedtree.pat_bound_idents]]>>
<<signature [[Typedtree.let_bound_idents]]>>
<<signature [[Typedtree.rev_let_bound_idents]]>>
@


\subsection*{[[typing/typedtree.ml]]}


<<signature [[Typedtree.pat_bound_idents]]>>=
(* Auxiliary functions over the a.s.t. *)

val pat_bound_idents: pattern -> Ident.t list
@

<<signature [[Typedtree.let_bound_idents]]>>=
val let_bound_idents: (pattern * expression) list -> Ident.t list
@

<<signature [[Typedtree.rev_let_bound_idents]]>>=
val rev_let_bound_idents: (pattern * expression) list -> Ident.t list
@

<<constant [[Typedtree.idents]]>>=
(* List the identifiers bound by a pattern or a let *)

let idents = ref([]: Ident.t list)
@

<<function [[Typedtree.bound_idents]]>>=
let rec bound_idents pat =
  match pat.pat_desc with
    Tpat_any -> ()
  | Tpat_var id -> idents := id :: !idents
  | Tpat_alias(p, id) -> bound_idents p; idents := id :: !idents
  | Tpat_constant cst -> ()
  | Tpat_tuple patl -> List.iter bound_idents patl
  | Tpat_construct(cstr, patl) -> List.iter bound_idents patl
  | Tpat_record lbl_pat_list ->
      List.iter (fun (lbl, pat) -> bound_idents pat) lbl_pat_list
  | Tpat_or(p1, p2) -> bound_idents p1; bound_idents p2
@

<<function [[Typedtree.pat_bound_idents]]>>=
let pat_bound_idents pat =
  idents := []; bound_idents pat; let res = !idents in idents := []; res
@

<<function [[Typedtree.rev_let_bound_idents]]>>=
let rev_let_bound_idents pat_expr_list =
  idents := [];
  List.iter (fun (pat, expr) -> bound_idents pat) pat_expr_list;
  let res = !idents in idents := []; res
@

<<function [[Typedtree.let_bound_idents]]>>=
let let_bound_idents pat_expr_list =
  List.rev(rev_let_bound_idents pat_expr_list)
@


%-------------------------------------------------------------

<<typing/typedtree.ml>>=
<<copyright header0>>

(* Abstract syntax tree after typing *)

open Misc
open Asttypes
open Types

(* Value expressions for the core language *)

<<type [[Typedtree.pattern]]>>

<<type [[Typedtree.pattern_desc]]>>

<<type [[Typedtree.expression]]>>

<<type [[Typedtree.expression_desc]]>>


(* Value expressions for the module language *)

<<type [[Typedtree.module_expr]]>>

<<type [[Typedtree.module_expr_desc]]>>

<<type [[Typedtree.structure]]>>

<<type [[Typedtree.structure_item]]>>

<<type [[Typedtree.module_coercion]]>>

(* Auxiliary functions over the a.s.t. *)

<<constant [[Typedtree.idents]]>>

<<function [[Typedtree.bound_idents]]>>

<<function [[Typedtree.pat_bound_idents]]>>

<<function [[Typedtree.rev_let_bound_idents]]>>

<<function [[Typedtree.let_bound_idents]]>>
      
@


\subsection*{[[typing/ctype.mli]]}




<<signature [[Ctype.moregeneral]]>>=
val moregeneral: Env.t -> type_expr -> type_expr -> bool
        (* Check if the first type scheme is more general than the second. *)
@

<<signature [[Ctype.equal]]>>=
val equal: Env.t -> type_expr list -> type_expr ->
                       type_expr list -> type_expr -> bool
        (* [equal env [x1...xn] tau [y1...yn] sigma]
           checks whether the parameterized types
           [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
@

<<signature [[Ctype.closed_schema]]>>=
val closed_schema: type_expr -> bool
        (* Check whether the given type scheme contains no non-generic
           type variables *)
@

<<signature [[Ctype.nondep_type]]>>=
val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
        (* Return a type equivalent to the given type but without
           references to the given module identifier. Raise [Not_found]
           if no such type exists. *)
@


<<signature [[Ctype.is_generic]]>>=
val is_generic: type_expr -> bool
        (* Test whether the given type variable is generic *)
@

<<signature [[Ctype.arity]]>>=
val arity: type_expr -> int
        (* Return the arity (as for curried functions) of the given type. *)
@







%-------------------------------------------------------------

<<typing/ctype.mli>>=
<<copyright header0>>

(* Operations on core types *)

open Types

<<signature [[Ctype.begin_def]]>>
<<signature [[Ctype.end_def]]>>
<<signature [[Ctype.reset_def]]>>
<<signature [[Ctype.newvar]]>>
<<signature [[Ctype.new_global_var]]>>
<<signature [[Ctype.repr]]>>
<<signature [[Ctype.generalize]]>>
<<signature [[Ctype.make_nongen]]>>
<<signature [[Ctype.instance]]>>
<<signature [[Ctype.instance_constructor]]>>
<<signature [[Ctype.instance_label]]>>
<<signature [[Ctype.unify]]>>
<<signature [[Ctype.filter_arrow]]>>
<<signature [[Ctype.moregeneral]]>>
<<signature [[Ctype.equal]]>>
<<signature [[Ctype.closed_schema]]>>
<<signature [[Ctype.nondep_type]]>>
<<signature [[Ctype.free_type_ident]]>>
<<signature [[Ctype.is_generic]]>>
<<signature [[Ctype.arity]]>>
<<signature [[Ctype.none]]>>
<<signature [[Ctype.substitute]]>>

<<exception [[Ctype.Unify]]>>

@


\subsection*{[[typing/ctype.ml]]}




<<signature [[Path.isfree]]>>=
val isfree: Ident.t -> t -> bool
@

<<function [[Path.isfree]]>>=
let rec isfree id = function
    Pident id' -> Ident.same id id'
  | Pdot(p, s, pos) -> isfree id p
@

<<function [[Ctype.nondep_type]]>>=
(* Remove dependencies *)

let rec nondep_type env id ty =
  match repr ty with
    Tvar v as tvar -> tvar
  | Tarrow(t1, t2) ->
      Tarrow(nondep_type env id t1, nondep_type env id t2)
  | Ttuple tl ->
      Ttuple(List.map (nondep_type env id) tl)
  | Tconstr(p, tl) ->
      if Path.isfree id p then begin
        let ty' =
          try
            expand_abbrev env p tl
          with Cannot_expand ->
            raise Not_found in
        nondep_type env id ty'
      end else
        Tconstr(p, List.map (nondep_type env id) tl)
@


<<function [[Ctype.closed_schema]]>>=
(* Miscellaneous *)

let rec closed_schema ty =
  match repr ty with
    Tvar v -> v.tvar_level = generic_level
  | Tarrow(t1, t2) -> closed_schema t1 & closed_schema t2
  | Ttuple tl -> List.for_all closed_schema tl
  | Tconstr(p, tl) -> List.for_all closed_schema tl
@

<<function [[Ctype.is_generic]]>>=
let is_generic ty =
  match repr ty with
    Tvar v -> v.tvar_level = generic_level
  | _ -> fatal_error "Ctype.is_generic"
@

<<function [[Ctype.arity]]>>=
let rec arity ty =
  match repr ty with
    Tarrow(t1, t2) -> 1 + arity t2
  | _ -> 0
@



%-------------------------------------------------------------

<<typing/ctype.ml>>=
<<copyright header0>>

(* Operations on core types *)

open Misc
open Path
open Types

<<exception [[Ctype.Unify]]>>

<<constant [[Ctype.current_level]]>>

<<constant [[Ctype.generic_level]]>>

<<function [[Ctype.reset_def]]>>
<<function [[Ctype.begin_def]]>>
<<function [[Ctype.end_def]]>>

<<function [[Ctype.newvar]]>>

<<function [[Ctype.new_global_var]]>>

<<function [[Ctype.repr]]>>

<<constant [[Ctype.none]]>>

<<function [[Ctype.generalize]]>>

<<function [[Ctype.make_nongen]]>>

<<constant [[Ctype.inst_subst]]>>

<<function [[Ctype.copy]]>>

<<function [[Ctype.instance]]>>

<<function [[Ctype.instance_constructor]]>>

<<function [[Ctype.instance_label]]>>

<<function [[Ctype.substitute]]>>

<<exception [[Ctype.Cannot_expand]]>>

<<function [[Ctype.expand_abbrev]]>>

<<function [[Ctype.occur]]>>

<<function [[Ctype.unify]]>>

<<function [[Ctype.filter_arrow]]>>

<<function [[Ctype.moregen_occur]]>>

<<function [[Ctype.moregen]]>>
  
<<function [[Ctype.moregeneral]]>>

<<function [[Ctype.equal]]>>

<<function [[Ctype.nondep_type]]>>

<<function [[Ctype.free_type_ident]]>>

<<function [[Ctype.closed_schema]]>>

<<function [[Ctype.is_generic]]>>

<<function [[Ctype.arity]]>>

@


\subsection*{[[typing/includecore.mli]]}


%-------------------------------------------------------------

<<typing/includecore.mli>>=
<<copyright header0>>

(* Inclusion checks for the core language *)

open Types
open Typedtree

<<exception [[Includecore.Dont_match]]>>

<<signature [[Includecore.value_descriptions]]>>
<<signature [[Includecore.type_declarations]]>>
<<signature [[Includecore.exception_declarations]]>>


@


\subsection*{[[typing/includecore.ml]]}


%-------------------------------------------------------------

<<typing/includecore.ml>>=
<<copyright header0>>

(* Inclusion checks for the core language *)

open Misc
open Path
open Types
open Typedtree

(* Inclusion between value descriptions *)

<<exception [[Includecore.Dont_match]]>>

<<function [[Includecore.value_descriptions]]>>

<<function [[Includecore.type_declarations]]>>

<<function [[Includecore.exception_declarations]]>>

@


\subsection*{[[typing/mtype.mli]]}

%less: delete?

<<signature [[Mtype.scrape]]>>=
val scrape: Env.t -> module_type -> module_type
        (* Expand toplevel module type abbreviations
           till hitting a "hard" module type (signature, functor,
           or abstract module type ident. *)
@

<<signature [[Mtype.strengthen]]>>=
val strengthen: Env.t -> module_type -> Path.t -> module_type
        (* Strengthen abstract type components relative to the
           given path. *)
@

<<signature [[Mtype.nondep_supertype]]>>=
val nondep_supertype: Env.t -> Ident.t -> module_type -> module_type
        (* Return the smallest supertype of the given type
           in which the given ident does not appear.
           Raise [Not_found] if no such type List.exists. *)
@


%-------------------------------------------------------------

<<typing/mtype.mli>>=
<<copyright header0>>

(* Operations on module types *)

open Types

<<signature [[Mtype.scrape]]>>
<<signature [[Mtype.strengthen]]>>
<<signature [[Mtype.nondep_supertype]]>>
@


\subsection*{[[typing/mtype.ml]]}

<<function [[Mtype.scrape]]>>=
let rec scrape env mty =
  match mty with
    Tmty_ident p ->
      failwith "Mtype.scrape:TODO"
(*
      begin try
        match Env.find_modtype p env with
          Tmodtype_abstract -> mty
        | Tmodtype_manifest mty' -> scrape env mty'
      with Not_found ->
        mty
      end
*)
  | _ -> mty
@

<<type [[Mtype.variance]]>>=
(* In nondep_supertype, env is only used for the type it assigns to id.
   Hence there is no need to keep env up-to-date by adding the bindings
   traversed. *)

type variance = Co | Contra | Strict
@
% delete!

<<function [[Mtype.nondep_supertype]]>>=
let nondep_supertype env mid mty =

  let rec nondep_mty var mty =
    match mty with
      Tmty_ident p ->
        if Path.isfree mid p then begin
          failwith "nondep_mty:TODO"
            (*
          match Env.find_modtype p env with
            Tmodtype_abstract -> raise Not_found
          | Tmodtype_manifest mty -> nondep_mty var mty      
            *)
        end else mty
    | Tmty_signature sg ->
        Tmty_signature(nondep_sig var sg)

  and nondep_sig var = function
    [] -> []
  | item :: rem ->
      let rem' = nondep_sig var rem in
      match item with
        Tsig_value(id, d) ->
          Tsig_value(id, {val_type = Ctype.nondep_type env mid d.val_type;
                          val_prim = d.val_prim}) :: rem'
      | Tsig_type(id, d) ->
          Tsig_type(id, nondep_type_decl var d) :: rem'
      | Tsig_exception(id, d) ->
          Tsig_exception(id, List.map (Ctype.nondep_type env mid) d) :: rem'
      | Tsig_module(id, mty) ->
          Tsig_module(id, nondep_mty var mty) :: rem'

  and nondep_type_decl var d =
    {type_params = d.type_params;
     type_arity = d.type_arity;
     type_kind =
       begin try
         match d.type_kind with
           Type_abstract ->
             Type_abstract
         | Type_variant cstrs ->
             Type_variant(List.map
               (fun (c, tl) -> (c, List.map (Ctype.nondep_type env mid) tl))
               cstrs)
         | Type_record lbls ->
             Type_record(List.map
               (fun (c, mut, t) -> (c, mut, Ctype.nondep_type env mid t))
               lbls)
       with Not_found ->
         match var with Co -> Type_abstract | _ -> raise Not_found
       end;
     type_manifest =
       begin try
         match d.type_manifest with
           None -> None
         | Some ty -> Some(Ctype.nondep_type env mid ty)
       with Not_found ->
         match var with Co -> None | _ -> raise Not_found
       end}

  in
    nondep_mty Co mty
@


%-------------------------------------------------------------

<<typing/mtype.ml>>=
<<copyright header0>>

(* Operations on module types *)

open Path
open Types


<<function [[Mtype.scrape]]>>

let rec strengthen env mty p =
  match scrape env mty with
    Tmty_signature sg ->
      Tmty_signature(strengthen_sig env sg p)
  | mty ->
      mty

and strengthen_sig env sg p =
  match sg with
    [] -> []
  | (Tsig_value(id, desc) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Tsig_type(id, decl) :: rem ->
      let newdecl =
        match decl.type_manifest with
          None ->
            { type_params = decl.type_params;
              type_arity = decl.type_arity;
              type_kind = decl.type_kind;
              type_manifest = Some(Tconstr(Pdot(p, Ident.name id, nopos),
                                                decl.type_params)) }
        | _ -> decl in
      Tsig_type(id, newdecl) :: strengthen_sig env rem p
  | (Tsig_exception(id, d) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Tsig_module(id, mty) :: rem ->
      Tsig_module(id, strengthen env mty (Pdot(p, Ident.name id, nopos))) ::
      strengthen_sig (Env.add_module id mty env) rem p
      (* Need to add the module in case it defines manifest module types *)

<<type [[Mtype.variance]]>>

<<function [[Mtype.nondep_supertype]]>>
@


\subsection*{[[typing/printtyp.mli]]}


<<signature [[Printtyp.reset_var_names]]>>=
val reset_var_names: unit -> unit
@


<<signature [[Printtyp.type_scheme]]>>=
val type_scheme: type_expr -> unit
@


<<signature [[Printtyp.signature_item]]>>=
val signature_item: signature_item -> unit
@


%-------------------------------------------------------------

<<typing/printtyp.mli>>=
<<copyright header0>>

(* Printing functions *)
open Types
open Typedtree

<<signature [[Printtyp.longident]]>>
<<signature [[Printtyp.ident]]>>
<<signature [[Printtyp.path]]>>
<<signature [[Printtyp.reset_var_names]]>>
<<signature [[Printtyp.type_expr]]>>
<<signature [[Printtyp.type_scheme]]>>
<<signature [[Printtyp.value_description]]>>
<<signature [[Printtyp.type_declaration]]>>
<<signature [[Printtyp.exception_declaration]]>>
<<signature [[Printtyp.modtype]]>>
<<signature [[Printtyp.signature]]>>
<<signature [[Printtyp.signature_item]]>>
@


\subsection*{[[typing/printtyp.ml]]}


%-------------------------------------------------------------

<<typing/printtyp.ml>>=
<<copyright header0>>

(* Printing functions *)

open Format
open Longident
open Path
open Asttypes
open Types
open Typedtree


<<function [[Printtyp.longident]]>>

<<function [[Printtyp.ident]]>>

<<constant [[Printtyp.ident_pervasive]]>>

<<function [[Printtyp.path]]>>

<<constant [[Printtyp.var_names]]>>
<<constant [[Printtyp.var_counter]]>>

<<function [[Printtyp.reset_var_names]]>>

<<function [[Printtyp.name_of_var]]>>

<<function [[Printtyp.typeexp]]>>
<<function [[Printtyp.type_expr]]>>

<<function [[Printtyp.type_scheme]]>>

(* Print one type declaration *)

<<function [[Printtyp.type_declaration]]>>

<<function [[Printtyp.exception_declaration]]>>

<<function [[Printtyp.value_description]]>>

(* Print a module type *)

<<function [[Printtyp.modtype]]>>

<<function [[Printtyp.signature]]>>
@


\subsection*{[[typing/parmatch.mli]]}


%-------------------------------------------------------------

<<typing/parmatch.mli>>=
<<copyright header0>>

(* Detection of partial matches and unused match cases. *)

open Typedtree

<<signature [[Parmatch.check_partial]]>>
<<signature [[Parmatch.check_unused]]>>
@


\subsection*{[[typing/parmatch.ml]]}

<<function [[Parmatch.make_pat]]>>=
let make_pat desc ty =
  {pat_desc = desc; pat_loc = Location.none; pat_type = ty}
@

<<constant [[Parmatch.omega]]>>=
let omega = make_pat Tpat_any Ctype.none
@

<<signature [[Ctype.none]]>>=
val none: type_expr
        (* A dummy type expression *)
@
<<constant [[Ctype.none]]>>=
let none = Ttuple []                  (* Clearly ill-formed type *)
@


<<function [[Parmatch.omegas]]>>=
let rec omegas i =
  if i <= 0 then [] else omega :: omegas (i-1)
@

<<function [[Parmatch.omega_list]]>>=
let omega_list l = omegas(List.length l)
@

<<function [[Parmatch.has_guard]]>>=
let has_guard act =
  match act.exp_desc with
    Texp_when(_, _) -> true
  | _ -> false
@

<<function [[Parmatch.simple_match]]>>=
let simple_match p1 p2 = 
  match p1.pat_desc, p2.pat_desc with
    Tpat_construct(c1, _), Tpat_construct(c2, _) ->
      c1.cstr_tag = c2.cstr_tag
  | Tpat_constant(c1), Tpat_constant(c2) ->
      c1 = c2
  | Tpat_tuple(_), Tpat_tuple(_) -> true
  | Tpat_record(_), Tpat_record(_) -> true
  | _, (Tpat_any | Tpat_var(_)) -> true
  | _, _ -> false
@

<<function [[Parmatch.record_labels]]>>=
(* Return the set of labels and number of fields for a record pattern. *)

let record_labels p =
  match p.pat_desc with
    Tpat_record((lbl1, pat1) :: rem) -> Array.to_list lbl1.lbl_all
  | _ -> fatal_error "Parmatch.record_labels"
@

<<function [[Parmatch.record_num_fields]]>>=
let record_num_fields p =
  match p.pat_desc with
    Tpat_record((lbl1, pat1) :: rem) -> Array.length lbl1.lbl_all
  | _ -> fatal_error "Parmatch.record_num_fields"
@

<<function [[Parmatch.set_fields]]>>=
let set_fields size l =
  let v = Array.create size omega in
  let rec change_rec l = match l with
    (lbl,p)::l ->  v.(lbl.lbl_pos) <- p ;  change_rec l 
  | [] -> () in
  change_rec l;
  Array.to_list v
@

<<function [[Parmatch.simple_match_args]]>>=
let simple_match_args p1 p2 =
  match p2.pat_desc with
    Tpat_construct(cstr, args) -> args
  | Tpat_tuple(args)  -> args
  | Tpat_record(args) ->  set_fields (record_num_fields p1) args
  | (Tpat_any | Tpat_var(_)) ->
      begin match p1.pat_desc with
        Tpat_construct(_, args) -> omega_list args
      | Tpat_tuple(args) -> omega_list args
      | Tpat_record(args) ->  omega_list args
      | _ -> []
      end
  | _ -> []
@

<<function [[Parmatch.simple_pat]]>>=
(*
  Computes the discriminating pattern for matching by the first
  column of pss, that is:
     checks for a tuple or a record when q is a variable.
*)

let rec simple_pat q pss = match pss with
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        simple_pat q ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        simple_pat q ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
        simple_pat q pss
  | (({pat_desc = Tpat_tuple(args)} as p)::_)::_ ->
        make_pat (Tpat_tuple(omega_list args)) p.pat_type
  | (({pat_desc = Tpat_record(args)} as p)::_)::pss ->
        make_pat (Tpat_record (List.map (fun lbl -> (lbl,omega)) (record_labels p)))
                 p.pat_type
  | _ -> q
@

<<function [[Parmatch.filter_one]]>>=
let filter_one q pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | (p::ps)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss
@

<<function [[Parmatch.filter_extra]]>>=
let filter_extra pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | ({pat_desc = (Tpat_any | Tpat_var(_))} :: qs) :: pss ->
        qs :: filter_rec pss
    | _::pss  -> filter_rec pss
    | [] -> [] in
  filter_rec pss
@

<<function [[Parmatch.filter_all]]>>=
let filter_all pat0 pss =

  let rec insert q qs env =
    match env with
      [] -> [q, [simple_match_args q q @ qs]]
    | ((p,pss) as c)::env ->
        if simple_match q p
        then (p, ((simple_match_args p q @ qs) :: pss)) :: env
        else c :: insert q qs env in

  let rec filter_rec env = function
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss ->
      filter_rec env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
      filter_rec env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
      filter_rec env pss
  | (p::ps)::pss ->
      filter_rec (insert p ps env) pss
  | _ -> env

  and filter_omega env = function
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss ->
      filter_omega env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
      filter_omega env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::ps)::pss ->
      filter_omega
        (List.map (fun (q,qss) -> (q,(simple_match_args q omega @ ps) :: qss)) env)
        pss
  | _::pss -> filter_omega env pss
  | [] -> env in
        
  filter_omega
    (filter_rec
      (match pat0.pat_desc with
        (Tpat_record(_) | Tpat_tuple(_)) -> [pat0,[]]
      | _ -> [])
      pss)
    pss
@

<<function [[Parmatch.full_match]]>>=
let full_match env =
  match env with
    ({pat_desc = Tpat_construct(c,_)},_) :: _ ->
      List.length env = c.cstr_consts + c.cstr_nonconsts
  | ({pat_desc = Tpat_constant(Const_char _)},_) :: _ ->
      List.length env = 256
  | ({pat_desc = Tpat_constant(_)},_) :: _ -> false
  | ({pat_desc = Tpat_tuple(_)},_) :: _ -> true
  | ({pat_desc = Tpat_record(_)},_) :: _ -> true
  | _ -> fatal_error "Parmatch.full_match"
@

<<function [[Parmatch.satisfiable]]>>=
(*
  Is the last row of pattern matrix pss + qs satisfiable ?
        That is :
  Does there List.exists at least one value vector, es such that :
   1/ for all ps in pss ps # es (ps and es are not compatible)
   2/ qs <= es                  (es matches qs)
*)

let rec satisfiable pss qs =
  match pss with
    [] -> true
  | _ ->
    match qs with
      [] -> false
    | {pat_desc = Tpat_or(q1,q2)}::qs ->
        satisfiable pss (q1::qs) or satisfiable pss (q2::qs)
    | {pat_desc = Tpat_alias(q,_)}::qs ->
        satisfiable pss (q::qs)
    | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
        let q0 = simple_pat omega pss in     
        begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
          [] -> satisfiable (filter_extra pss) qs 
        | constrs ->          
            let try_non_omega (p,pss) =
              satisfiable pss (simple_match_args p omega @ qs)  in
            if full_match constrs
            then List.exists try_non_omega constrs
            else satisfiable (filter_extra pss) qs or
                 List.exists try_non_omega constrs
        end
    | q::qs ->
        let q0 = simple_pat q pss in
        satisfiable (filter_one q0 pss) (simple_match_args q0 q @ qs)
@

<<function [[Parmatch.initial_matrix]]>>=
let rec initial_matrix = function
    [] -> []
  | (pat, act) :: rem ->
       if has_guard act
       then initial_matrix rem
       else [pat] :: initial_matrix rem
@

<<function [[Parmatch.get_mins]]>>=
let get_mins ps =
  let rec select_rec r = function
    [] -> r
  | p::ps ->
      if List.exists (fun p0 -> le_pats p0 p) ps
      then select_rec r ps
      else select_rec (p::r) ps in
  select_rec [] (select_rec [] ps)
@

<<function [[Parmatch.check_partial]]>>=
let check_partial loc casel =
  let pss = get_mins (initial_matrix casel) in
  if match pss with
      []     -> true
    | ps::_  -> satisfiable pss (List.map (fun _ -> omega) ps)
  then Location.print_warning loc "this pattern-matching is not exhaustive"
@

<<function [[Parmatch.location_of_clause]]>>=
let location_of_clause = function
    pat :: _ -> pat.pat_loc
  | _ -> fatal_error "Parmatch.location_of_clause"
@

<<function [[Parmatch.check_unused]]>>=
let check_unused casel =
  let prefs =   
    List.fold_right
      (fun (pat,act as clause) r ->
         if has_guard act
         then ([], ([pat], act)) :: r
         else ([], ([pat], act)) :: 
              List.map (fun (pss,clause) -> [pat]::pss,clause) r)
      casel [] in
  List.iter
    (fun (pss, ((qs, _) as clause)) ->
      if not (satisfiable pss qs) then
        Location.print_warning (location_of_clause qs)
                                "this match case is unused.")
    prefs
@


%-------------------------------------------------------------

<<typing/parmatch.ml>>=
<<copyright header0>>

(* Detection of partial matches and unused match cases. *)

open Misc
open Asttypes
open Types
open Typedtree


<<function [[Parmatch.make_pat]]>>

<<constant [[Parmatch.omega]]>>

<<function [[Parmatch.omegas]]>>

<<function [[Parmatch.omega_list]]>>

<<function [[Parmatch.has_guard]]>>

<<function [[Parmatch.simple_match]]>>

<<function [[Parmatch.record_labels]]>>

<<function [[Parmatch.record_num_fields]]>>

<<function [[Parmatch.set_fields]]>>

<<function [[Parmatch.simple_match_args]]>>

<<function [[Parmatch.simple_pat]]>>

<<function [[Parmatch.filter_one]]>>

<<function [[Parmatch.filter_extra]]>>

<<function [[Parmatch.filter_all]]>>

      
<<function [[Parmatch.full_match]]>>

<<function [[Parmatch.satisfiable]]>>

<<function [[Parmatch.initial_matrix]]>>

<<function [[Parmatch.le_pat]]>>

<<function [[Parmatch.get_mins]]>>

<<function [[Parmatch.check_partial]]>>

<<function [[Parmatch.location_of_clause]]>>

<<function [[Parmatch.check_unused]]>>
@

<<function [[Parmatch.le_pat]]>>=
let rec le_pat p q =
  match (p.pat_desc, q.pat_desc) with
    (Tpat_var _ | Tpat_any), _ -> true
  | Tpat_alias(p,_), _ -> le_pat p q
  | _, Tpat_alias(q,_) -> le_pat p q
  | Tpat_or(p1,p2), _ -> le_pat p1 q or le_pat p2 q
  | _, Tpat_or(q1,q2) -> le_pat p q1 & le_pat p q2
  | Tpat_constant(c1), Tpat_constant(c2) -> c1 = c2
  | Tpat_construct(c1,ps), Tpat_construct(c2,qs) ->
      c1.cstr_tag = c2.cstr_tag & le_pats ps qs
  | Tpat_tuple(ps), Tpat_tuple(qs) -> le_pats ps qs
  | Tpat_record(l1), Tpat_record(l2) ->
     let size = record_num_fields p in
     le_pats (set_fields size l1) (set_fields size l2)
  | _, _ -> false  

and le_pats ps qs =
  match ps,qs with
    p::ps, q::qs -> le_pat p q & le_pats ps qs
  | _, _         -> true
@


\subsection*{[[typing/typetexp.mli]]}



%-------------------------------------------------------------

<<typing/typetexp.mli>>=
<<copyright header0>>

<<signature [[Typetexp.transl_simple_type]]>>
<<signature [[Typetexp.transl_type_scheme]]>>
<<signature [[Typetexp.reset_type_variables]]>>
<<signature [[Typetexp.enter_type_variable]]>>

<<exception [[Typetexp.Already_bound]]>>

<<type [[Typetexp.error]]>>

<<exception [[Typetexp.Error]]>>

<<signature [[Typetexp.report_error]]>>
@


\subsection*{[[typing/typetexp.ml]]}

%-------------------------------------------------------------

<<typing/typetexp.ml>>=
<<copyright header0>>

(* Typechecking of type expressions for the core language *)

open Parsetree
open Types
open Ctype

<<exception [[Typetexp.Already_bound]]>>

<<type [[Typetexp.error]]>>

<<exception [[Typetexp.Error]]>>

<<constant [[Typetexp.type_variables]]>>

<<function [[Typetexp.reset_type_variables]]>>

<<function [[Typetexp.enter_type_variable]]>>

<<function [[Typetexp.transl_simple_type]]>>

<<function [[Typetexp.transl_type_scheme]]>>

(* Error report *)

open Format
open Printtyp

<<function [[Typetexp.report_error]]>>
@


\subsection*{[[typing/includemod.mli]]}





%-------------------------------------------------------------

<<typing/includemod.mli>>=
<<copyright header0>>

(* Inclusion checks for the module language *)

open Types
open Typedtree

<<signature [[Includemod.modtypes]]>>
<<signature [[Includemod.signatures]]>>
<<signature [[Includemod.compunit]]>>

<<type [[Includemod.error]]>>

<<exception [[Includemod.Error]]>>

<<signature [[Includemod.report_error]]>>
@


\subsection*{[[typing/includemod.ml]]}



<<exception [[Includemod.Dont_match]]>>=
(* Expand a module type identifier when possible *)

exception Dont_match
@

<<function [[Includemod.expand_module_path]]>>=
let expand_module_path env path =
  failwith "expand_module_path:TODO"
(*
  try
    match Env.find_modtype path env with
      Tmodtype_abstract -> raise Dont_match
    | Tmodtype_manifest mty -> mty
  with Not_found ->
    raise Dont_match
*)
@

<<type [[Includemod.field_desc]]>>=
(* Extract name, kind and ident from a signature item *)

type field_desc =
    Field_value of string
  | Field_type of string
  | Field_exception of string
  | Field_module of string
  | Field_modtype of string
@

<<function [[Includemod.item_ident_name]]>>=
let item_ident_name = function
    Tsig_value(id, _) -> (id, Field_value(Ident.name id))
  | Tsig_type(id, _) -> (id, Field_type(Ident.name id))
  | Tsig_exception(id, _) -> (id, Field_exception(Ident.name id))
  | Tsig_module(id, _) -> (id, Field_module(Ident.name id))
@

<<function [[Includemod.simplify_structure_coercion]]>>=
(* Simplify a structure coercion *)

let simplify_structure_coercion cc =
  let pos = ref 0 in
  try
    List.iter
      (fun (n, c) ->
        if n <> !pos or c <> Tcoerce_none then raise Exit;
        incr pos)
      cc;
    Tcoerce_none
  with Exit ->
    Tcoerce_structure cc
@





%-------------------------------------------------------------

<<typing/includemod.ml>>=
<<copyright header0>>

(* Inclusion checks for the module language *)

open Misc
open Path
open Types
open Typedtree


<<type [[Includemod.error]]>>

<<exception [[Includemod.Error]]>>

(* All functions "blah env x1 x2" check that x1 is included in x2,
   i.e. that x1 is the type of an implementation that fulfills the
   specification x2. If not, Error is raised with a backtrace of the error. *)

<<function [[Includemod.value_descriptions]]>>

<<function [[Includemod.type_declarations]]>>

<<function [[Includemod.exception_declarations]]>>

<<exception [[Includemod.Dont_match]]>>

<<function [[Includemod.expand_module_path]]>>

<<type [[Includemod.field_desc]]>>

<<function [[Includemod.item_ident_name]]>>

<<function [[Includemod.simplify_structure_coercion]]>>

<<function [[Includemod.modtypes]]>>

<<function [[Includemod.signatures]]>>

<<function [[Includemod.signature_components]]>>

<<function [[Includemod.check_modtype_inclusion]]>>

<<toplevel [[Includemod._1]]>>

<<function [[Includemod.compunit]]>>

(* Error report *)

open Format
open Printtyp

<<function [[Includemod.include_err]]>>

<<function [[Includemod.report_error]]>>

@




<<function [[Includemod.modtypes]]>>=
(* Inclusion between module types. 
   Return the restriction that transforms a value of the smaller type
   into a value of the bigger type. *)

let rec modtypes env mty1 mty2 =
  try
    try_modtypes env mty1 mty2
  with 
    Dont_match ->
      raise(Error[Module_types(mty1, mty2)])
  | Error reasons ->
      raise(Error(Module_types(mty1, mty2) :: reasons))

and try_modtypes env mty1 mty2 =
  match (mty1, mty2) with
    (Tmty_ident p1, Tmty_ident p2) when Path.same p1 p2 ->
      Tcoerce_none
  | (Tmty_ident p1, _) ->
      try_modtypes env (expand_module_path env p1) mty2
  | (_, Tmty_ident p2) ->
      try_modtypes env mty1 (expand_module_path env p2)
  | (Tmty_signature sig1, Tmty_signature sig2) ->
      signatures env sig1 sig2
  | (_, _) ->
      raise Dont_match
@







\subsection*{[[typing/typedecl.mli]]}


%-------------------------------------------------------------

<<typing/typedecl.mli>>=
<<copyright header0>>

(* Typing of type definitions and primitive definitions *)

open Types
open Typedtree

<<signature [[Typedecl.transl_type_decl]]>>
<<signature [[Typedecl.transl_exception]]>>

<<signature [[Typedecl.transl_value_decl]]>>
   
<<type [[Typedecl.error]]>>

<<exception [[Typedecl.Error]]>>

<<signature [[Typedecl.report_error]]>>
@


\subsection*{[[typing/typedecl.ml]]}


%-------------------------------------------------------------

<<typing/typedecl.ml>>=
<<copyright header0>>

(* Typing of type definitions *)

open Parsetree
open Types
open Typedtree
open Typetexp


<<type [[Typedecl.error]]>>

<<exception [[Typedecl.Error]]>>

<<function [[Typedecl.enter_types]]>>

(* Translate one type declaration *)

module StringSet = Set

<<function [[Typedecl.transl_declaration]]>>

<<function [[Typedecl.check_recursive_abbrev]]>>

<<function [[Typedecl.transl_type_decl]]>>

<<function [[Typedecl.transl_exception]]>>

<<function [[Typedecl.transl_value_decl]]>>

(* Error report *)

open Format

<<function [[Typedecl.report_error]]>>

@


\subsection*{[[typing/typecore.mli]]}



%-------------------------------------------------------------

<<typing/typecore.mli>>=
<<copyright header0>>

(* Type inference for the core language *)

open Asttypes
open Types

<<signature [[Typecore.type_binding]]>>

<<signature [[Typecore.type_expression]]>>
        
<<type [[Typecore.error]]>>

<<exception [[Typecore.Error]]>>

<<signature [[Typecore.report_error]]>>
@


\subsection*{[[typing/typecore.ml]]}



<<function [[Typecore.unify_pat]]>>=
(* Typing of patterns *)

let unify_pat env pat expected_ty =
  try
    unify env pat.pat_type expected_ty
  with Unify ->
    raise(Error(pat.pat_loc, Pattern_type_clash(pat.pat_type, expected_ty)))
@

<<constant [[Typecore.pattern_variables]]>>=
let pattern_variables = ref ([]: (Ident.t * type_expr) list)
@

<<function [[Typecore.enter_variable]]>>=
let enter_variable loc name ty =
  if List.exists (fun (id, ty) -> Ident.name id = name) !pattern_variables
  then raise(Error(loc, Multiply_bound_variable));
  let id = Ident.create name in
  pattern_variables := (id, ty) :: !pattern_variables;
  id
@

<<function [[Typecore.type_pat]]>>=
let rec type_pat env sp =
  match sp.ppat_desc with
    Ppat_any ->
      { pat_desc = Tpat_any;
        pat_loc = sp.ppat_loc;
        pat_type = newvar() }
  | Ppat_var name ->
      let ty = newvar() in
      let id = enter_variable sp.ppat_loc name ty in
      { pat_desc = Tpat_var id;
        pat_loc = sp.ppat_loc;
        pat_type = ty }
  | Ppat_alias(sp, name) ->
      let p = type_pat env sp in
      let id = enter_variable sp.ppat_loc name p.pat_type in
      { pat_desc = Tpat_alias(p, id);
        pat_loc = sp.ppat_loc;
        pat_type = p.pat_type }
  | Ppat_constant cst ->
      { pat_desc = Tpat_constant cst;
        pat_loc = sp.ppat_loc;
        pat_type = type_constant cst }
  | Ppat_tuple spl ->
      let pl = List.map (type_pat env) spl in
      { pat_desc = Tpat_tuple pl;
        pat_loc = sp.ppat_loc;
        pat_type = Ttuple(List.map (fun p -> p.pat_type) pl) }
  | Ppat_construct(lid, sarg) ->
      let constr =
        try
          Env.lookup_constructor lid env
        with Not_found ->
          raise(Error(sp.ppat_loc, Unbound_constructor lid)) in
      let sargs =
        match sarg with
          None -> []
        | Some {ppat_desc = Ppat_tuple spl} when constr.cstr_arity > 1 -> spl
        | Some({ppat_desc = Ppat_any} as sp) when constr.cstr_arity > 1 ->
            replicate_list sp constr.cstr_arity
        | Some sp -> [sp] in
      if List.length sargs <> constr.cstr_arity then
        raise(Error(sp.ppat_loc, Constructor_arity_mismatch(lid,
                                     constr.cstr_arity, List.length sargs)));
      let args = List.map (type_pat env) sargs in
      let (ty_args, ty_res) = instance_constructor constr in
      List.iter2 (unify_pat env) args ty_args;
      { pat_desc = Tpat_construct(constr, args);
        pat_loc = sp.ppat_loc;
        pat_type = ty_res }
  | Ppat_record lid_sp_list ->
      let ty = newvar() in
      let type_label_pat (lid, sarg) =
        let label =
          try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sp.ppat_loc, Unbound_label lid)) in
        let (ty_arg, ty_res) = instance_label label in
        begin try
          unify env ty_res ty
        with Unify ->
          raise(Error(sp.ppat_loc, Label_mismatch(lid, ty_res, ty)))
        end;
        let arg = type_pat env sarg in
        unify_pat env arg ty_arg;
        (label, arg)
      in
      { pat_desc = Tpat_record(List.map type_label_pat lid_sp_list);
        pat_loc = sp.ppat_loc;
        pat_type = ty }
  | Ppat_or(sp1, sp2) ->
      let initial_pattern_variables = !pattern_variables in
      let p1 = type_pat env sp1 in
      let p2 = type_pat env sp2 in
      if !pattern_variables != initial_pattern_variables then
        raise(Error(sp.ppat_loc, Orpat_not_closed));
      unify_pat env p2 p1.pat_type;
      { pat_desc = Tpat_or(p1, p2);
        pat_loc = sp.ppat_loc;
        pat_type = p1.pat_type }
  | Ppat_constraint(sp, sty) ->
      let p = type_pat env sp in
      let ty = Typetexp.transl_simple_type env false sty in
      unify_pat env p ty;
      p
@

<<function [[Typecore.add_pattern_variables]]>>=
let add_pattern_variables env =
  let pv = !pattern_variables in
  pattern_variables := [];
  List.fold_right
    (fun (id, ty) env ->
      Env.add_value id {val_type = ty; val_prim = None} env)
    pv env
@

<<function [[Typecore.type_pattern]]>>=
let type_pattern env spat =
  pattern_variables := [];
  let pat = type_pat env spat in
  let new_env = add_pattern_variables env in
  (pat, new_env)
@

<<function [[Typecore.type_pattern_list]]>>=
let type_pattern_list env spatl =
  pattern_variables := [];
  let patl = List.map (type_pat env) spatl in
  let new_env = add_pattern_variables env in
  (patl, new_env)
@





%-------------------------------------------------------------

<<typing/typecore.ml>>=
<<copyright header0>>

(* Typechecking for the core language *)

open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Ctype


<<type [[Typecore.error]]>>

<<exception [[Typecore.Error]]>>

<<function [[Typecore.type_constant]]>>

<<function [[Typecore.unify_pat]]>>

<<constant [[Typecore.pattern_variables]]>>

<<function [[Typecore.enter_variable]]>>

<<function [[Typecore.type_pat]]>>

<<function [[Typecore.add_pattern_variables]]>>

<<function [[Typecore.type_pattern]]>>

<<function [[Typecore.type_pattern_list]]>>

<<function [[Typecore.is_nonexpansive]]>>

<<function [[Typecore.type_format]]>>

<<function [[Typecore.unify_exp]]>>

<<function [[Typecore.type_exp]]>>

<<function [[Typecode.type_expect]]>>

<<function [[Typecore.type_statement]]>>

<<function [[Typecore.type_cases]]>>

<<function [[Typecode.type_let]]>>

<<function [[Typecore.type_binding]]>>

<<function [[Typecore.type_expression]]>>

(* Error report *)

open Format
open Printtyp

<<function [[Typecore.report_error]]>>
@


\subsection*{[[typing/typemod.mli]]}

<<signature [[Typemod.check_nongen_schemes]]>>=
val check_nongen_schemes:
        structure -> unit
@


%-------------------------------------------------------------

<<typing/typemod.mli>>=
<<copyright header0>>

(* Type-checking of the module language *)

open Types
open Typedtree

<<signature [[Typemod.type_structure]]>>
<<signature [[Typemod.transl_signature]]>>
<<signature [[Typemod.check_nongen_schemes]]>>

<<type [[Typemod.error]]>>

<<exception [[Typemod.Error]]>>

<<signature [[Typemod.report_error]]>>
@


\subsection*{[[typing/typemod.ml]]}


<<function [[Typemod.extract_sig]]>>=
(* Extract a signature from a module type *)

let extract_sig env loc mty =
  match Mtype.scrape env mty with
    Tmty_signature sg -> sg
  | _ -> raise(Error(loc, Signature_expected))
@

<<function [[Typemod.extract_sig_open]]>>=
let extract_sig_open env loc mty =
  match Mtype.scrape env mty with
    Tmty_signature sg -> sg
  | _ -> raise(Error(loc, Structure_expected mty))
@

<<function [[Typemod.type_module_path]]>>=
(* Lookup the type of a module path *)

let type_module_path env loc lid =
  try
    Env.lookup_module lid env
  with Not_found ->
    raise(Error(loc, Unbound_module lid))
@

<<exception [[Typemod.Not_a_path]]>>=
(* Try to convert a module expression to a module path. *)

exception Not_a_path
@

<<function [[Typemod.path_of_module]]>>=
let rec path_of_module mexp =
  match mexp.mod_desc with
    Tmod_ident p -> p
  | _ -> raise Not_a_path
@

<<function [[Typemod.check_unique_names]]>>=
let check_unique_names sg =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in
  let check cl loc set_ref name =
    if StringSet.mem name !set_ref
    then raise(Error(loc, Repeated_name(cl, name)))
    else set_ref := StringSet.add name !set_ref in
  let check_item item =
    match item.pstr_desc with
      Pstr_eval exp -> ()
    | Pstr_value(rec_flag, exps) -> ()
    | Pstr_primitive(name, desc) -> ()
    | Pstr_type name_decl_list ->
        List.iter
          (fun (name, decl) -> check "type" item.pstr_loc type_names name)
          name_decl_list
    | Pstr_exception(name, decl) -> ()
    | Pstr_module(name, smod) ->
        check "module" item.pstr_loc module_names name
    | Pstr_open lid -> () in
  List.iter check_item sg
@

<<function [[Typemod.check_nongen_schemes]]>>=
(* Check that all core type schemes in a structure are closed *)

let check_nongen_schemes str =
  List.iter 
    (function
        Tstr_value(rec_flag, pat_exp_list) ->
          List.iter
            (fun (pat, exp) ->
              if not (Ctype.closed_schema exp.exp_type) then
                raise(Error(exp.exp_loc, Non_generalizable exp.exp_type)))
            pat_exp_list
      | _ -> ())  (* Sub-structures have been checked before *)
  str
@



%-------------------------------------------------------------

<<typing/typemod.ml>>=
<<copyright header0>>

(* Type-checking of the module language *)

open Misc
open Longident
open Path
open Parsetree
open Types
open Typedtree


<<type [[Typemod.error]]>>

<<exception [[Typemod.Error]]>>

<<function [[Typemod.extract_sig]]>>

<<function [[Typemod.extract_sig_open]]>>

<<function [[Typemod.type_module_path]]>>

(* Check and translate a module type expression *)

let rec transl_modtype env smty =
  match smty.pmty_desc with
    Pmty_ident lid ->
      failwith "transl_modtype:TODO"
(*
      begin try
        let (path, info) = Env.lookup_modtype lid env in 
        Tmty_ident path
      with Not_found ->
        raise(Error(smty.pmty_loc, Unbound_modtype lid))
      end
*)
  | Pmty_signature ssg ->
      Tmty_signature(transl_signature env ssg)
      
and transl_signature env sg =
  match sg with
    [] -> []
  | {psig_desc = Psig_value(name, sdesc)} :: srem ->
      let desc = Typedecl.transl_value_decl env sdesc in
      let (id, newenv) = Env.enter_value name desc env in
      let rem = transl_signature newenv srem in
      Tsig_value(id, desc) :: rem
  | {psig_desc = Psig_type sdecls} :: srem ->
      let (decls, newenv) = Typedecl.transl_type_decl env sdecls in
      let rem = transl_signature newenv srem in
      map_end (fun (id, info) -> Tsig_type(id, info)) decls rem
  | {psig_desc = Psig_exception(name, sarg)} :: srem ->
      let arg = Typedecl.transl_exception env sarg in
      let (id, newenv) = Env.enter_exception name arg env in
      let rem = transl_signature newenv srem in
      Tsig_exception(id, arg) :: rem
  | {psig_desc = Psig_module(name, smty)} :: srem ->
      let mty = transl_modtype env smty in
      let (id, newenv) = Env.enter_module name mty env in
      let rem = transl_signature newenv srem in
      Tsig_module(id, mty) :: rem
  | {psig_desc = Psig_open lid; psig_loc = loc} :: srem ->
      let (path, mty) = type_module_path env loc lid in
      let sg = extract_sig_open env loc mty in
      let newenv = Env.open_signature path sg env in
      transl_signature newenv srem

<<exception [[Typemod.Not_a_path]]>>

<<function [[Typemod.path_of_module]]>>

(* Check that all type and module identifiers in a structure have
   distinct names (so that access by named paths is unambiguous). *)

module StringSet = Set

<<function [[Typemod.check_unique_names]]>>

<<function [[Typemod.check_nongen_schemes]]>>

(* Type a module value expression *)

let rec type_module env smod =
  match smod.pmod_desc with
    Pmod_ident lid ->
      let (path, mty) = type_module_path env smod.pmod_loc lid in
      { mod_desc = Tmod_ident path;
        mod_type = Mtype.strengthen env mty path;
        mod_loc = smod.pmod_loc }
  | Pmod_structure sstr ->
      let (str, sg, _) = type_structure env sstr in
      check_nongen_schemes str;
      { mod_desc = Tmod_structure str;
        mod_type = Tmty_signature sg;
        mod_loc = smod.pmod_loc }
  | Pmod_constraint(sarg, smty) ->
      let arg = type_module env sarg in
      let mty = transl_modtype env smty in
      let coercion =
        try
          Includemod.modtypes env arg.mod_type mty
        with Includemod.Error msg ->
          raise(Error(sarg.pmod_loc, Not_included msg)) in
      { mod_desc = Tmod_constraint(arg, mty, coercion);
        mod_type = mty;
        mod_loc = smod.pmod_loc }

and type_structure env sstr =
  check_unique_names sstr;
  type_struct env sstr

and type_struct env = function
    [] ->
      ([], [], env)
  | {pstr_desc = Pstr_eval sexpr} :: srem ->
      let expr = Typecore.type_expression env sexpr in
      let (str_rem, sig_rem, final_env) = type_struct env srem in
      (Tstr_eval expr :: str_rem, sig_rem, final_env)
  | {pstr_desc = Pstr_value(rec_flag, sdefs)} :: srem ->
      let (defs, newenv) =
        Typecore.type_binding env rec_flag sdefs in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      let bound_idents = let_bound_idents defs in
      let make_sig_value id =
        Tsig_value(id, Env.find_value (Pident id) newenv) in
      (Tstr_value(rec_flag, defs) :: str_rem,
       map_end make_sig_value bound_idents sig_rem,
       final_env)
  | {pstr_desc = Pstr_primitive(name, sdesc)} :: srem ->
      let desc = Typedecl.transl_value_decl env sdesc in
      let (id, newenv) = Env.enter_value name desc env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_primitive(id, desc) :: str_rem,
       Tsig_value(id, desc) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_type sdecls} :: srem ->
      let (decls, newenv) = Typedecl.transl_type_decl env sdecls in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_type decls :: str_rem,
       map_end (fun (id, info) -> Tsig_type(id, info)) decls sig_rem,
       final_env)
  | {pstr_desc = Pstr_exception(name, sarg)} :: srem ->
      let arg = Typedecl.transl_exception env sarg in
      let (id, newenv) = Env.enter_exception name arg env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_exception(id, arg) :: str_rem,
       Tsig_exception(id, arg) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_module(name, smodl)} :: srem ->
      let modl = type_module env smodl in
      let (id, newenv) = Env.enter_module name modl.mod_type env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_module(id, modl) :: str_rem,
       Tsig_module(id, modl.mod_type) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_open lid; pstr_loc = loc} :: srem ->
      let (path, mty) = type_module_path env loc lid in
      let sg = extract_sig_open env loc mty in
      type_struct (Env.open_signature path sg env) srem

(* Error report *)

open Format
open Printtyp

<<function [[Typemod.report_error]]>>
@










\section{[[bytecomp/]]}


\subsection*{[[bytecomp/lambda.mli]]}


<<signature [[Lambda.const_unit]]>>=
val const_unit: structured_constant
@

<<signature [[Lambda.lambda_unit]]>>=
val lambda_unit: lambda
@

<<signature [[Lambda.name_lambda]]>>=
val name_lambda: lambda -> (Ident.t -> lambda) -> lambda
@

<<signature [[Lambda.is_guarded]]>>=
val is_guarded: lambda -> bool
@

<<signature [[Lambda.free_variables]]>>=
val free_variables: lambda -> Ident.t Set.t
@

<<signature [[Lambda.transl_path]]>>=
val transl_path: Path.t -> lambda
@


%-------------------------------------------------------------

<<bytecomp/lambda.mli>>=
<<copyright header>>

(* The "lambda" intermediate code *)

open Asttypes

<<type [[Lambda.primitive]]>>

<<type [[Lambda.comparison]]>>

<<type [[Lambda.array_kind]]>>

<<type [[Lambda.structured_constant]]>>

<<type [[Lambda.function_kind]]>>

<<type [[Lambda.let_kind]]>>

<<type [[Lambda.shared_code]]>>

<<type [[Lambda.lambda]]>>

<<type [[Lambda.lambda_switch]]>>

<<type [[Lambda.lambda_event]]>>

<<type [[Lambda.lambda_event_kind]]>>

<<signature [[Lambda.const_unit]]>>
<<signature [[Lambda.lambda_unit]]>>
<<signature [[Lambda.name_lambda]]>>
<<signature [[Lambda.is_guarded]]>>

<<signature [[Lambda.free_variables]]>>

<<signature [[Lambda.transl_path]]>>
@


\subsection*{[[bytecomp/lambda.ml]]}



<<constant [[Lambda.const_unit]]>>=
let const_unit = Const_pointer 0
@

<<constant [[Lambda.lambda_unit]]>>=
let lambda_unit = Lconst const_unit
@

<<function [[Lambda.name_lambda]]>>=
let name_lambda arg fn =
  match arg with
    Lvar id -> fn id
  | _ -> let id = Ident.create "let" in Llet(Strict, id, arg, fn id)
@

<<function [[Lambda.free_variables]]>>=
let free_variables l =
  let fv = ref IdentSet.empty in
  let rec freevars = function
    Lvar id ->
      fv := IdentSet.add id !fv
  | Lconst sc -> ()
  | Lapply(fn, args) ->
      freevars fn; List.iter freevars args
  | Lfunction(kind, params, body) ->
      freevars body;
      List.iter (fun param -> fv := IdentSet.remove param !fv) params
  | Llet(str, id, arg, body) ->
      freevars arg; freevars body; fv := IdentSet.remove id !fv
  | Lletrec(decl, body) ->
      freevars body;
      List.iter (fun (id, exp) -> freevars exp) decl;
      List.iter (fun (id, exp) -> fv := IdentSet.remove id !fv) decl
  | Lprim(p, args) ->
      List.iter freevars args
  | Lswitch(arg, sw) ->
      freevars arg; 
      List.iter (fun (key, case) -> freevars case) sw.sw_consts;
      List.iter (fun (key, case) -> freevars case) sw.sw_blocks
  | Lstaticfail -> ()
  | Lcatch(e1, e2) ->
      freevars e1; freevars e2
  | Ltrywith(e1, exn, e2) ->
      freevars e1; freevars e2; fv := IdentSet.remove exn !fv
  | Lifthenelse(e1, e2, e3) ->
      freevars e1; freevars e2; freevars e3
  | Lsequence(e1, e2) ->
      freevars e1; freevars e2
  | Lwhile(e1, e2) ->
      freevars e1; freevars e2
  | Lfor(v, e1, e2, dir, e3) -> 
      freevars e1; freevars e2; freevars e3; fv := IdentSet.remove v !fv
  | Lassign(id, e) ->
      fv := IdentSet.add id !fv; freevars e
  | Levent (lam, evt) ->
      freevars lam
  in freevars l; !fv
@

<<constant [[Lambda.is_guarded]]>>=
(* Check if an action has a "when" guard *)

let rec is_guarded = function
    Lifthenelse(cond, body, Lstaticfail) -> true
  | Llet(str, id, lam, body) -> is_guarded body
  | Levent(lam, ev) -> is_guarded lam
  | _ -> false
@

<<constant [[Lambda.transl_path]]>>=
let rec transl_path = function
    Pident id ->
      if Ident.global id 
      then Lprim(Pgetglobal id, []) 
      else Lvar id
  | Pdot(p, s, pos) ->
      Lprim(Pfield pos, [transl_path p])
@

<<signature [[Ident.global]]>>=
val global: t -> bool
@
<<function [[Ident.global]]>>=
let global i =
  i.global
@


%-------------------------------------------------------------

<<bytecomp/lambda.ml>>=
<<copyright header>>

open Misc
open Path
open Asttypes

<<type [[Lambda.primitive]]>>

<<type [[Lambda.comparison]]>>

<<type [[Lambda.array_kind]]>>

<<type [[Lambda.structured_constant]]>>

<<type [[Lambda.function_kind]]>>

<<type [[Lambda.let_kind]]>>

<<type [[Lambda.shared_code]]>>

<<type [[Lambda.lambda]]>>

<<type [[Lambda.lambda_switch]]>>

<<type [[Lambda.lambda_event]]>>

<<type [[Lambda.lambda_event_kind]]>>

<<constant [[Lambda.const_unit]]>>

<<constant [[Lambda.lambda_unit]]>>

<<function [[Lambda.name_lambda]]>>

module IdentSet = Set

<<function [[Lambda.free_variables]]>>

<<constant [[Lambda.is_guarded]]>>

<<constant [[Lambda.transl_path]]>>
@


\subsection*{[[bytecomp/printlambda.mli]]}

%-------------------------------------------------------------

<<bytecomp/printlambda.mli>>=
<<copyright header>>

open Lambda

<<signature [[Printlambda.structured_constant]]>>
<<signature [[Printlambda.lambda]]>>
@


\subsection*{[[bytecomp/printlambda.ml]]}

%-------------------------------------------------------------

<<bytecomp/printlambda.ml>>=
<<copyright header>>

open Format
open Asttypes
open Primitive
open Types
open Lambda


<<function [[Printlambda.structured_constant]]>>

<<function [[Printlambda.primitive]]>>

<<function [[Printlambda.lambda]]>>
@

\subsection*{[[bytecomp/meta.mli]]}

<<type [[Meta.closure]]>>=
type closure = unit -> Obj.t
@


%-------------------------------------------------------------

<<bytecomp/meta.mli>>=
<<copyright header>>

(* To control the runtime system and bytecode interpreter *)

external global_data : unit -> Obj.t array = "get_global_data"
external realloc_global_data : int -> unit = "realloc_global"
external static_alloc : int -> string = "static_alloc"
external static_free : string -> unit = "static_free"
<<type [[Meta.closure]]>>
external reify_bytecode : string -> int -> closure = "reify_bytecode"
external available_primitives : unit -> string array = "available_primitives"
@


\subsection*{[[bytecomp/meta.ml]]}

<<type Meta.closure (./bytecomp/meta.ml)>>=
type closure = unit -> Obj.t
@


%-------------------------------------------------------------

<<bytecomp/meta.ml>>=
<<copyright header>>

external global_data : unit -> Obj.t array = "get_global_data"
external realloc_global_data : int -> unit = "realloc_global"
external static_alloc : int -> string = "static_alloc"
external static_free : string -> unit = "static_free"
<<type Meta.closure (./bytecomp/meta.ml)>>
external reify_bytecode : string -> int -> closure = "reify_bytecode"
external available_primitives : unit -> string array = "available_primitives"
@


\subsection*{[[bytecomp/runtimedef.mli]]}

<<signature [[Runtimedef.builtin_exceptions]]>>=
(* Values and functions known and/or provided by the runtime system *)

val builtin_exceptions: string array
@

<<signature [[Runtimedef.builtin_primitives]]>>=
val builtin_primitives: string array
@


%-------------------------------------------------------------

<<bytecomp/runtimedef.mli>>=
<<copyright header>>

<<signature [[Runtimedef.builtin_exceptions]]>>
<<signature [[Runtimedef.builtin_primitives]]>>
@


\subsection*{[[bytecomp/instruct.mli]]}


%-------------------------------------------------------------

<<bytecomp/instruct.mli>>=
<<copyright header>>

(* The type of the instructions of the abstract machine *)

open Lambda

<<type [[Instruct.compilation_env]]>>

(* The ce_stack component gives locations of variables residing 
   in the stack. The locations are offsets w.r.t. the origin of the
   stack frame.
   The ce_heap component gives the positions of variables residing in the
   heap-allocated environment. *)

(* Debugging events *)

<<type [[Instruct.debug_event]]>>

<<type [[Instruct.debug_event_kind]]>>

<<type [[Instruct.debug_event_info]]>>

<<type [[Instruct.debug_event_repr]]>>

<<type [[Instruct.label]]>>

<<type [[Instruct.instruction]]>>

<<signature [[Instruct.immed_min]]>>
<<signature [[Instruct.immed_max]]>>
@


\subsection*{[[bytecomp/instruct.ml]]}



%-------------------------------------------------------------

<<bytecomp/instruct.ml>>=
<<copyright header>>

open Lambda

<<type [[Instruct.compilation_env]]>>


<<type [[Instruct.debug_event]]>>

<<type [[Instruct.debug_event_kind]]>>

<<type [[Instruct.debug_event_info]]>>

<<type [[Instruct.debug_event_repr]]>>

<<type [[Instruct.label]]>>

<<type [[Instruct.instruction]]>>

let immed_min = -0x40000000
and immed_max = 0x3FFFFFFF

(* Actually the abstract machine accomodates -0x80000000 to 0x7FFFFFFF,
   but these numbers overflow the Caml type int if the compiler runs on
   a 32-bit processor. *)
@


\subsection*{[[bytecomp/printinstr.mli]]}

%-------------------------------------------------------------

<<bytecomp/printinstr.mli>>=
<<copyright header>>

(* Pretty-print lists of instructions *)

open Instruct

<<signature [[Printinstr.instruction]]>>
<<signature [[Printinstr.instrlist]]>>
@


\subsection*{[[bytecomp/printinstr.ml]]}


%-------------------------------------------------------------

<<bytecomp/printinstr.ml>>=
<<copyright header>>

(* Pretty-print lists of instructions *)

open Format
open Lambda
open Instruct


<<constant [[Printinstr.instruction]]>>

<<constant [[Printinstr.instruction_list]]>>
 
<<function [[Printinstr.instrlist]]>>
@


\subsection*{[[bytecomp/simplif.mli]]}



%-------------------------------------------------------------

<<bytecomp/simplif.mli>>=
<<copyright header>>

(* Elimination of useless Llet(Alias) bindings *)

open Lambda

<<signature [[Simplif.simplify_lambda]]>>
@


\subsection*{[[bytecomp/simplif.ml]]}

<<exception [[Simplif.Real_reference]]>>=
(* To transform let-bound references into variables *)

exception Real_reference
@

<<function [[Simplif.eliminate_ref]]>>=
let rec eliminate_ref id = function
    Lvar v as lam ->
      if Ident.same v id then raise Real_reference else lam
  | Lconst cst as lam -> lam
  | Lapply(e1, el) -> 
      Lapply(eliminate_ref id e1, List.map (eliminate_ref id) el)
  | Lfunction(kind, params, body) as lam ->
      if IdentSet.mem id (free_variables lam)
      then raise Real_reference
      else lam
  | Llet(str, v, e1, e2) ->
      Llet(str, v, eliminate_ref id e1, eliminate_ref id e2)
  | Lletrec(idel, e2) ->
      Lletrec(List.map (fun (v, e) -> (v, eliminate_ref id e)) idel,
              eliminate_ref id e2)
  | Lprim(Pfield 0, [Lvar v]) when Ident.same v id ->
      Lvar id
  | Lprim(Psetfield(0, _), [Lvar v; e]) when Ident.same v id ->
      Lassign(id, eliminate_ref id e)
  | Lprim(Poffsetref delta, [Lvar v]) when Ident.same v id ->
      Lassign(id, Lprim(Poffsetint delta, [Lvar id]))
  | Lprim(p, el) ->
      Lprim(p, List.map (eliminate_ref id) el)
  | Lswitch(e, sw) ->
      Lswitch(eliminate_ref id e,
        {sw_numconsts = sw.sw_numconsts;
         sw_consts =
            List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_consts;
         sw_numblocks = sw.sw_numblocks;
         sw_blocks =
            List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_blocks;
         sw_checked = sw.sw_checked})
  | Lstaticfail ->
      Lstaticfail
  | Lcatch(e1, e2) ->
      Lcatch(eliminate_ref id e1, eliminate_ref id e2)
  | Ltrywith(e1, v, e2) ->
      Ltrywith(eliminate_ref id e1, v, eliminate_ref id e2)
  | Lifthenelse(e1, e2, e3) ->
      Lifthenelse(eliminate_ref id e1,
                  eliminate_ref id e2,
                  eliminate_ref id e3)
  | Lsequence(e1, e2) ->
      Lsequence(eliminate_ref id e1, eliminate_ref id e2)
  | Lwhile(e1, e2) ->
      Lwhile(eliminate_ref id e1, eliminate_ref id e2)
  | Lfor(v, e1, e2, dir, e3) ->
      Lfor(v, eliminate_ref id e1, eliminate_ref id e2,
           dir, eliminate_ref id e3)
  | Lassign(v, e) ->
      Lassign(v, eliminate_ref id e)
  | Levent(l, ev) ->
      Levent(eliminate_ref id l, ev)
@

<<function [[Simplif.simplify_lambda]]>>=
(* Simplification of lets *)

let simplify_lambda lam =
  (* First pass: count the occurrences of all identifiers *)
  let occ = Hashtbl.create 83 in
  let count_var v =
    try
      !(Hashtbl.find occ v)
    with Not_found ->
      0 in
  let rec count = function
    Lvar v ->
      begin try
        incr(Hashtbl.find occ v)
      with Not_found ->
        Hashtbl.add occ v (ref 1)
      end
  | Lconst cst -> ()
  | Lapply(l1, ll) -> count l1; List.iter count ll
  | Lfunction(kind, params, l) -> count l
  | Llet(str, v, Lvar w, l2) ->
      (* v will be replaced by w in l2, so each occurrence of v in l2
         increases w's refcount *)
      count l2;
      let vc = count_var v in
      begin try
        let r = Hashtbl.find occ w in r := !r + vc
      with Not_found ->
        Hashtbl.add occ w (ref vc)
      end
  | Llet(str, v, l1, l2) ->
      count l2;
      (* If v is unused, l1 will be removed, so don't count its variables *)
      if str = Strict or count_var v > 0 then count l1
  | Lletrec(bindings, body) ->
      List.iter (fun (v, l) -> count l) bindings;
      count body
  | Lprim(p, ll) -> List.iter count ll
  | Lswitch(l, sw) ->
      count l;
      List.iter (fun (n, l) -> count l) sw.sw_consts;
      List.iter (fun (n, l) -> count l) sw.sw_blocks
  | Lstaticfail -> ()
  | Lcatch(l1, l2) -> count l1; count l2
  | Ltrywith(l1, v, l2) -> count l1; count l2
  | Lifthenelse(l1, l2, l3) -> count l1; count l2; count l3
  | Lsequence(l1, l2) -> count l1; count l2
  | Lwhile(l1, l2) -> count l1; count l2
  | Lfor(v, l1, l2, dir, l3) -> count l1; count l2; count l3
  | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refcount *)
      count l
  | Levent(l, ev) -> count l
  in
  count lam;
  (* Second pass: remove Lalias bindings of unused variables,
     and substitute the bindings of variables used exactly once. *)
  let subst = Hashtbl.create 83 in
  let rec simplif = function
    Lvar v as l ->
      begin try
        Hashtbl.find subst v
      with Not_found ->
        l
      end
  | Lconst cst as l -> l
  | Lapply(l1, ll) -> Lapply(simplif l1, List.map simplif ll)
  | Lfunction(kind, params, l) -> Lfunction(kind, params, simplif l)
  | Llet(str, v, Lvar w, l2) ->
      Hashtbl.add subst v (simplif (Lvar w));
      simplif l2
  | Llet(Strict, v, Lprim(Pmakeblock(0, Mutable), [linit]), lbody)
    when not !Clflags.debug ->
      let slinit = simplif linit in
      let slbody = simplif lbody in
      begin try
        Llet(Strict, v, slinit, eliminate_ref v slbody)
      with Real_reference ->
        Llet(Strict, v, Lprim(Pmakeblock(0, Mutable), [slinit]), slbody)
      end
  | Llet(Strict, v, l1, l2) -> Llet(Strict, v, simplif l1, simplif l2)
  | Llet(Alias, v, l1, l2) ->
      begin match count_var v with
        0 -> simplif l2
      | 1 -> Hashtbl.add subst v (simplif l1); simplif l2
      | n -> Llet(Alias, v, simplif l1, simplif l2)
      end
  | Llet(StrictOpt, v, l1, l2) ->
      begin match count_var v with
        0 -> simplif l2
      | n -> Llet(Alias, v, simplif l1, simplif l2)
      end
  | Lletrec(bindings, body) ->
      Lletrec(List.map (fun (v, l) -> (v, simplif l)) bindings, simplif body)
  | Lprim(p, ll) -> Lprim(p, List.map simplif ll)
  | Lswitch(l, sw) ->
      Lswitch(simplif l,
        {sw_numconsts = sw.sw_numconsts;
         sw_consts = List.map (fun (n, e) -> (n, simplif e)) sw.sw_consts;
         sw_numblocks = sw.sw_numblocks;
         sw_blocks = List.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks;
         sw_checked = sw.sw_checked})
  | Lstaticfail -> Lstaticfail
  | Lcatch(l1, l2) -> Lcatch(simplif l1, simplif l2)
  | Ltrywith(l1, v, l2) -> Ltrywith(simplif l1, v, simplif l2)
  | Lifthenelse(l1, l2, l3) -> Lifthenelse(simplif l1, simplif l2, simplif l3)
  | Lsequence(l1, l2) -> Lsequence(simplif l1, simplif l2)
  | Lwhile(l1, l2) -> Lwhile(simplif l1, simplif l2)
  | Lfor(v, l1, l2, dir, l3) ->
      Lfor(v, simplif l1, simplif l2, dir, simplif l3)
  | Lassign(v, l) -> Lassign(v, simplif l)
  | Levent(l, ev) -> Levent(simplif l, ev)
  in
  simplif lam
@


%-------------------------------------------------------------

<<bytecomp/simplif.ml>>=
<<copyright header>>

(* Elimination of useless Llet(Alias) bindings.
   Also transform let-bound references into variables. *)

open Asttypes
open Lambda

<<exception [[Simplif.Real_reference]]>>

module IdentSet = Set

<<function [[Simplif.eliminate_ref]]>>

<<function [[Simplif.simplify_lambda]]>>
@


\subsection*{[[bytecomp/matching.mli]]}


<<exception [[Matching.Cannot_flatten]]>>=
exception Cannot_flatten
@

<<signature [[Matching.flatten_pattern]]>>=
val flatten_pattern: int -> pattern -> pattern list
@


%-------------------------------------------------------------

<<bytecomp/matching.mli>>=
<<copyright header>>

(* Compilation of pattern-matching *)

open Typedtree
open Lambda

<<signature [[Matching.for_function]]>>
<<signature [[Matching.for_trywith]]>>
<<signature [[Matching.for_let]]>>
<<signature [[Matching.for_multiple_match]]>>
<<signature [[Matching.for_tupled_function]]>>

<<exception [[Matching.Cannot_flatten]]>>

<<signature [[Matching.flatten_pattern]]>>
@


\subsection*{[[bytecomp/matching.ml]]}

<<type [[Matching.pattern_matching]]>>=
(*  See Peyton-Jones, "The Implementation of functional programming
    languages", chapter 5. *)

type pattern_matching =
  { mutable cases : (pattern list * lambda) list;
    args : (lambda * let_kind) list }
@

<<function [[Matching.add_line]]>>=
(* To group lines of patterns with identical keys *)

let add_line patl_action pm =
  pm.cases <- patl_action :: pm.cases; pm
@

<<function [[Matching.add]]>>=
let add make_matching_fun division key patl_action args =
  try
    let pm = List.assoc key division in
    pm.cases <- patl_action :: pm.cases;
    division
  with Not_found ->
    let pm = make_matching_fun args in
    pm.cases <- patl_action :: pm.cases;
    (key, pm) :: division
@

<<function [[Matching.name_pattern]]>>=
(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    (pat :: patl, action) :: rem ->
      begin match pat.pat_desc with
        Tpat_var id -> id
      | Tpat_alias(p, id) -> id
      | _ -> name_pattern default rem
      end
  | _ -> Ident.create default
@

<<constant [[Matching.any_pat]]>>=
(* To remove aliases and bind named components *)

let any_pat =
  {pat_desc = Tpat_any; pat_loc = Location.none; pat_type = Ctype.none}
@

<<function [[Matching.simplify_matching]]>>=
let simplify_matching m =
  match m.args with
    [] -> m
  | (arg, mut) :: argl ->
      let rec simplify = function
        (pat :: patl, action as patl_action) :: rem ->
          begin match pat.pat_desc with
            Tpat_var id ->
              (any_pat :: patl, Llet(Alias, id, arg, action)) ::
              simplify rem
          | Tpat_alias(p, id) ->
              simplify ((p :: patl, Llet(Alias, id, arg, action)) :: rem)
          | _ ->
              patl_action :: simplify rem
          end
      | cases -> cases in
    { args = m.args; cases = simplify m.cases }
@

<<constant [[Matching.make_constant_matching]]>>=
(* Matching against a constant *)

let make_constant_matching = function
    [] -> fatal_error "Matching.make_constant_matching"
  | (arg :: argl) -> {cases = []; args = argl}
@

<<function [[Matching.divide_constant]]>>=
let divide_constant {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_constant cst} :: patl, action) :: rem ->
        let (constants, others) = divide rem in
        (add make_constant_matching constants cst (patl, action) al, others)
    | cl ->
      ([], {cases = cl; args = al})
  in divide cl
@

<<function [[Matching.make_constr_matching]]>>=
(* Matching against a constructor *)

let make_constr_matching cstr = function
    [] -> fatal_error "Matching.make_constr_matching"
  | ((arg, mut) :: argl) ->
      let (first_pos, last_pos) =
        match cstr.cstr_tag with
          Cstr_constant _ | Cstr_block _ -> (0, cstr.cstr_arity - 1)
        | Cstr_exception _ -> (1, cstr.cstr_arity) in
      let rec make_args pos =
        if pos > last_pos
        then argl
        else (Lprim(Pfield pos, [arg]), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args first_pos}
@

<<function [[Matching.divide_constructor]]>>=
let divide_constructor {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_construct(cstr, args)} :: patl, action) :: rem ->
        let (constructs, others) = divide rem in
        (add (make_constr_matching cstr) constructs
             cstr.cstr_tag (args @ patl, action) al,
         others)
    | cl ->
      ([], {cases = cl; args = al})
  in divide cl
@

<<function [[Matching.divide_var]]>>=
(* Matching against a variable *)

let divide_var {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (vars, others) = divide rem in
        (add_line (patl, action) vars, others)
    | cl ->
        (make_constant_matching al, {cases = cl; args = al})
  in divide cl
@

<<function [[Matching.make_tuple_matching]]>>=
(* Matching against a tuple pattern *)

let make_tuple_matching num_comps = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | (arg, mut) :: argl ->
      let rec make_args pos =
        if pos >= num_comps
        then argl
        else (Lprim(Pfield pos, [arg]), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args 0}
@

<<function [[Matching.divide_tuple]]>>=
let divide_tuple arity {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_tuple args} :: patl, action) :: rem ->
        let (tuples, others) = divide rem in
        (add_line (args @ patl, action) tuples, others)
    | ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (tuples, others) = divide rem in
        (add_line (replicate_list any_pat arity @ patl, action) tuples, others)
    | cl ->
        (make_tuple_matching arity al, {cases = cl; args = al})
  in divide cl
@

<<function [[Matching.make_record_matching]]>>=
(* Matching against a record pattern *)

let make_record_matching all_labels = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | ((arg, mut) :: argl) ->
      let rec make_args pos =
        if pos >= Array.length all_labels then argl else begin
          let lbl = all_labels.(pos) in
          let access =
            match lbl.lbl_repres with
              Record_regular -> Pfield lbl.lbl_pos
            | Record_float -> Pfloatfield lbl.lbl_pos in
          let str =
            match lbl.lbl_mut with
              Immutable -> Alias
            | Mutable -> StrictOpt in
          (Lprim(access, [arg]), str) :: make_args(pos + 1)
        end in
      {cases = []; args = make_args 0}
@

<<function [[Matching.divide_record]]>>=
let divide_record all_labels {cases = cl; args = al} =
  let num_fields = Array.length all_labels in
  let record_matching_line lbl_pat_list =
    let patv = Array.create num_fields any_pat in
    List.iter (fun (lbl, pat) -> patv.(lbl.lbl_pos) <- pat) lbl_pat_list;
    Array.to_list patv in
  let rec divide = function
      ({pat_desc = Tpat_record lbl_pat_list} :: patl, action) :: rem ->
        let (records, others) = divide rem in
        (add_line (record_matching_line lbl_pat_list @ patl, action) records,
         others)
    | ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (records, others) = divide rem in
        (add_line (record_matching_line [] @ patl, action) records, others)
    | cl ->
        (make_record_matching all_labels al, {cases = cl; args = al})
  in divide cl
@

<<function [[Matching.flatten_orpat_match]]>>=
(* Matching against an or pattern. *)

let rec flatten_orpat_match pat =
  match pat.pat_desc with
    Tpat_or(p1, p2) -> flatten_orpat_match p1 @ flatten_orpat_match p2
  | _ -> [[pat], lambda_unit]
@

<<constant [[Matching.divide_orpat]]>>=
let divide_orpat = function
    {cases = (orpat :: patl, act) :: casel; args = arg1 :: argl as args} ->
      ({cases = flatten_orpat_match orpat; args = [arg1]},
       {cases = [patl, act]; args = argl},
       {cases = casel; args = args})
  | _ ->
    fatal_error "Matching.divide_orpat"
@

<<function [[Matching.combine_var]]>>=
(* To combine sub-matchings together *)

let combine_var (lambda1, total1) (lambda2, total2) =
  if total1 then (lambda1, true)
  else if lambda2 = Lstaticfail then (lambda1, total1)
  else (Lcatch(lambda1, lambda2), total2)
@

<<function [[Matching.make_test_sequence]]>>=
let make_test_sequence tst arg const_lambda_list =
  List.fold_right
    (fun (c, act) rem ->
      Lifthenelse(Lprim(tst, [arg; Lconst(Const_base c)]), act, rem))
    const_lambda_list Lstaticfail
@

<<function [[Matching.make_switch_or_test_sequence]]>>=
let make_switch_or_test_sequence arg const_lambda_list int_lambda_list =
  let min_key =
    List.fold_right (fun (k, l) m -> min k m) int_lambda_list max_int in
  let max_key =
    List.fold_right (fun (k, l) m -> max k m) int_lambda_list min_int in
  (* min_key and max_key can be arbitrarily large, so watch out for
     overflow in the following comparison *)
  if List.length int_lambda_list <= 1 + max_key / 4 - min_key / 4 then
    (* Sparse matching -- use a sequence of tests
       (4 bytecode instructions per test)  *)
    make_test_sequence (Pintcomp Ceq) arg const_lambda_list
  else begin
    (* Dense matching -- use a jump table
       (2 bytecode instructions + 1 word per entry in the table) *)
    let numcases = max_key - min_key + 1 in
    let cases =
      List.map (fun (key, l) -> (key - min_key, l)) int_lambda_list in
    let offsetarg =
      if min_key = 0 then arg else Lprim(Poffsetint(-min_key), [arg]) in
    Lswitch(offsetarg,
            {sw_numconsts = numcases; sw_consts = cases;
             sw_numblocks = 0; sw_blocks = []; sw_checked = true})
  end
@

<<function [[Matching.make_bitvect_check]]>>=
let make_bitvect_check arg int_lambda_list =
  let bv = String.make 32 '\000' in
  List.iter
    (fun (n, l) ->
      bv.[n lsr 3] <- Char.chr(Char.code bv.[n lsr 3] lor (1 lsl (n land 7))))
    int_lambda_list;
  Lifthenelse(Lprim(Pbittest, [Lconst(Const_base(Const_string bv)); arg]),
              lambda_unit, Lstaticfail)
@

<<constant [[Matching.prim_string_equal]]>>=
let prim_string_equal =
  Pccall{prim_name = "string_equal";
         prim_arity = 2; prim_alloc = false;
         prim_native_name = ""; prim_native_float = false}
@

<<function [[Matching.combine_constant]]>>=
let combine_constant arg cst (const_lambda_list, total1) (lambda2, total2) =
  let lambda1 =
    match cst with
      Const_int _ ->
        let int_lambda_list =
          List.map (function Const_int n, l -> n,l | _ -> assert false)
                   const_lambda_list in
        make_switch_or_test_sequence arg const_lambda_list int_lambda_list
    | Const_char _ ->
        let int_lambda_list =
          List.map (function Const_char c, l -> (Char.code c, l)
                           | _ -> assert false)
                   const_lambda_list in
        if List.for_all (fun (c, l) -> l = lambda_unit) const_lambda_list then
          make_bitvect_check arg int_lambda_list 
        else
          make_switch_or_test_sequence arg const_lambda_list int_lambda_list
    | Const_string _ ->
        make_test_sequence prim_string_equal arg const_lambda_list
    | Const_float _ ->
        make_test_sequence (Pfloatcomp Ceq) arg const_lambda_list
  in (Lcatch(lambda1, lambda2), total2)
@

<<function [[Matching.combine_constructor]]>>=
let combine_constructor arg cstr (tag_lambda_list, total1) (lambda2, total2) =
  if cstr.cstr_consts < 0 then begin
    (* Special cases for exceptions *)
    let lambda1 =
      List.fold_right
        (fun (ex, act) rem ->
           match ex with
           | Cstr_exception path ->
               Lifthenelse(Lprim(Pintcomp Ceq, 
                                 [Lprim(Pfield 0, [arg]); transl_path path]),
                           act, rem)
           | _ -> assert false)
        tag_lambda_list Lstaticfail
    in (Lcatch(lambda1, lambda2), total2)
  end else begin
    (* Regular concrete type *)
    let rec split_cases = function
      [] -> ([], [])
    | (cstr, act) :: rem ->
        let (consts, nonconsts) = split_cases rem in
        match cstr with
          Cstr_constant n -> ((n, act) :: consts, nonconsts)
        | Cstr_block n    -> (consts, (n, act) :: nonconsts)
        | _ -> assert false in
    let (consts, nonconsts) = split_cases tag_lambda_list in
    let lambda1 =
      match (cstr.cstr_consts, cstr.cstr_nonconsts, consts, nonconsts) with
        (1, 0, [0, act], []) -> act
      | (0, 1, [], [0, act]) -> act
      | (1, 1, [0, act1], [0, act2]) ->
          Lifthenelse(arg, act2, act1)
      | (1, 1, [0, act1], []) ->
          Lifthenelse(arg, Lstaticfail, act1)
      | (1, 1, [], [0, act2]) ->
          Lifthenelse(arg, act2, Lstaticfail)
      | (_, _, _, _) ->
          Lswitch(arg, {sw_numconsts = cstr.cstr_consts;
                        sw_consts = consts;
                        sw_numblocks = cstr.cstr_nonconsts;
                        sw_blocks = nonconsts;
                        sw_checked = false}) in
    if total1
     & List.length tag_lambda_list = cstr.cstr_consts + cstr.cstr_nonconsts
    then (lambda1, true)
    else (Lcatch(lambda1, lambda2), total2)
  end
@

<<function [[Matching.combine_orpat]]>>=
let combine_orpat (lambda1, total1) (lambda2, total2) (lambda3, total3) =
  (Lcatch(Lsequence(lambda1, lambda2), lambda3), total3)
@

<<function [[Matching.event_branch]]>>=
(* Insertion of debugging events *)

let rec event_branch repr lam =
  begin match lam, repr with
    (_, None) ->
      lam
  | (Levent(lam', ev), Some r) ->
      incr r;
      Levent(lam', {lev_loc = ev.lev_loc;
                    lev_kind = ev.lev_kind;
                    lev_repr = repr;
                    lev_env = ev.lev_env})
  | (Llet(str, id, lam, body), _) ->
      Llet(str, id, lam, event_branch repr body)
  | (_, Some r) ->
(*      incr r;
      Levent(lam, {lev_loc = -1;
                   lev_kind = Lev_before;
                   lev_repr = repr;
                   lev_env = Env.Env_empty})
*)      fatal_error "Matching.event_branch"
  end
@

<<function [[Matching.compile_match]]>>=
(* The main compilation function.
   Input: a pattern matching.
   Output: a lambda term, a "total" flag (true if we're sure that the
     matching covers all cases; this is an approximation). *)

let rec compile_match repr m =

  let rec compile_list = function
    [] -> ([], true)
  | (key, pm) :: rem ->
      let (lambda1, total1) = compile_match repr pm in
      let (list2, total2) = compile_list rem in
      ((key, lambda1) :: list2, total1 & total2) in

  match m with
    { cases = [] } ->
      (Lstaticfail, false)
  | { cases = ([], action) :: rem; args = argl } ->
      if is_guarded action then begin
        let (lambda, total) =
          compile_match None { cases = rem; args = argl }
        in
        (Lcatch(event_branch repr action, lambda), total)
      end else
        (event_branch repr action, true)
  | { args = (arg, str) :: argl } ->
      let v = name_pattern "match" m.cases in
      let newarg = Lvar v in
      let pm =
        simplify_matching
          { cases = m.cases; args = (newarg, Alias) :: argl } in
      let (lam, total) =
        match pm.cases with
          (pat :: patl, action) :: _ ->
            begin match pat.pat_desc with
              Tpat_any ->
                let (vars, others) = divide_var pm in
                combine_var (compile_match repr vars)
                            (compile_match repr others)
            | Tpat_constant cst ->
                let (constants, others) = divide_constant pm in
                combine_constant newarg cst
                  (compile_list constants) (compile_match repr others)
            | Tpat_tuple patl ->
                let (tuples, others) = divide_tuple (List.length patl) pm in
                combine_var (compile_match repr tuples)
                            (compile_match repr others)
            | Tpat_construct(cstr, patl) ->
                let (constrs, others) = divide_constructor pm in
                combine_constructor newarg cstr
                  (compile_list constrs) (compile_match repr others)
            | Tpat_record((lbl, _) :: _) ->
                let (records, others) = divide_record lbl.lbl_all pm in
                combine_var (compile_match repr records)
                            (compile_match repr others)
            | Tpat_or(pat1, pat2) ->
                (* Avoid duplicating the code of the action *)
                let (or_match, remainder_line, others) = divide_orpat pm in
                combine_orpat (compile_match None or_match)
                              (compile_match repr remainder_line)
                              (compile_match repr others)
            | _ ->
                fatal_error "Matching.compile_match1"
            end
        | _ -> fatal_error "Matching.compile_match2" in
      (Llet(str, v, arg, lam), total)
  | _ -> assert false
@

<<function [[Matching.compile_matching]]>>=
(* The entry points *)

let compile_matching repr handler_fun arg pat_act_list =
  let pm =
    { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
      args = [arg, Strict] } in
  let (lambda, total) = compile_match repr pm in
  if total then lambda else Lcatch(lambda, handler_fun())
@

<<function [[Matching.partial_function]]>>=
let partial_function loc () =
  Lprim(Praise, [Lprim(Pmakeblock(0, Immutable),
          [transl_path Predef.path_match_failure;
           Lconst(Const_block(0,
              [Const_base(Const_string !Location.input_name);
               Const_base(Const_int loc.loc_start);
               Const_base(Const_int loc.loc_end)]))])])
@

<<function [[Matching.for_function]]>>=
let for_function loc repr param pat_act_list =
  compile_matching repr (partial_function loc) param pat_act_list
@

<<function [[Matching.for_trywith]]>>=
let for_trywith param pat_act_list =
  compile_matching None (fun () -> Lprim(Praise, [param])) param pat_act_list
@

<<function [[Matching.for_let]]>>=
let for_let loc param pat body =
  compile_matching None (partial_function loc) param [pat, body]
@

<<exception [[Matching.Cannot_flatten]] (./bytecomp/matching.ml)>>=
(* Handling of tupled functions and matches *)

exception Cannot_flatten
@

<<function [[Matching.flatten_pattern]]>>=
let flatten_pattern size p =
  match p.pat_desc with
    Tpat_tuple args -> args
  | Tpat_any -> replicate_list any_pat size
  | _ -> raise Cannot_flatten
@

<<function [[Matching.flatten_cases]]>>=
let flatten_cases size cases =
  List.map (function (pat :: _, act) -> (flatten_pattern size pat, act)
                   | _ -> assert false)
           cases
@

<<function [[Matching.for_tupled_function]]>>=
let for_tupled_function loc paraml pats_act_list =
  let pm =
    { cases = pats_act_list;
      args = List.map (fun id -> (Lvar id, Strict)) paraml } in
  let (lambda, total) = compile_match None pm in
  if total then lambda else Lcatch(lambda, partial_function loc ())
@

<<function [[Matching.for_multiple_match]]>>=
let for_multiple_match loc paraml pat_act_list =
  let pm1 =
    { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
      args = [Lprim(Pmakeblock(0, Immutable), paraml), Strict] } in
  let pm2 =
    simplify_matching pm1 in
  let pm3 =
    try
      { cases = flatten_cases (List.length paraml) pm2.cases;
        args = List.map (fun lam -> (lam, Strict)) paraml }
    with Cannot_flatten ->
      pm2 in
  let (lambda, total) = compile_match None pm3 in
  if total then lambda else Lcatch(lambda, partial_function loc ())
@


%-------------------------------------------------------------

<<bytecomp/matching.ml>>=
<<copyright header>>

(* Compilation of pattern matching *)

open Misc
open Location
open Asttypes
open Primitive
open Types
open Typedtree
open Lambda

<<type [[Matching.pattern_matching]]>>

<<function [[Matching.add_line]]>>

<<function [[Matching.add]]>>

<<function [[Matching.name_pattern]]>>

<<constant [[Matching.any_pat]]>>

<<function [[Matching.simplify_matching]]>>

<<constant [[Matching.make_constant_matching]]>>

<<function [[Matching.divide_constant]]>>

<<function [[Matching.make_constr_matching]]>>

<<function [[Matching.divide_constructor]]>>

<<function [[Matching.divide_var]]>>

<<function [[Matching.make_tuple_matching]]>>

<<function [[Matching.divide_tuple]]>>

<<function [[Matching.make_record_matching]]>>

<<function [[Matching.divide_record]]>>

<<function [[Matching.flatten_orpat_match]]>>

<<constant [[Matching.divide_orpat]]>>

<<function [[Matching.combine_var]]>>

<<function [[Matching.make_test_sequence]]>>

<<function [[Matching.make_switch_or_test_sequence]]>>

<<function [[Matching.make_bitvect_check]]>>

<<constant [[Matching.prim_string_equal]]>>

<<function [[Matching.combine_constant]]>>

<<function [[Matching.combine_constructor]]>>

<<function [[Matching.combine_orpat]]>>

<<function [[Matching.event_branch]]>>

<<function [[Matching.compile_match]]>>

<<function [[Matching.compile_matching]]>>

<<function [[Matching.partial_function]]>>

<<function [[Matching.for_function]]>>

<<function [[Matching.for_trywith]]>>

<<function [[Matching.for_let]]>>

<<exception [[Matching.Cannot_flatten]] (./bytecomp/matching.ml)>>

<<function [[Matching.flatten_pattern]]>>

<<function [[Matching.flatten_cases]]>>

<<function [[Matching.for_tupled_function]]>>

<<function [[Matching.for_multiple_match]]>>
@


\subsection*{[[bytecomp/translcore.mli]]}

<<signature [[Translcore.name_pattern]]>>=
val name_pattern: string -> (pattern * 'a) list -> Ident.t
@

<<signature [[Translcore.maybe_pointer]]>>=
val maybe_pointer: expression -> bool
@




%-------------------------------------------------------------

<<bytecomp/translcore.mli>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Asttypes
open Types
open Typedtree
open Lambda

<<signature [[Translcore.name_pattern]]>>
<<signature [[Translcore.maybe_pointer]]>>

<<signature [[Translcore.transl_exp]]>>
<<signature [[Translcore.transl_let]]>>
<<signature [[Translcore.transl_primitive]]>>
<<signature [[Translcore.transl_exception]]>>

<<type [[Translcore.error]]>>

<<exception [[Translcore.Error]]>>

<<signature [[Translcore.report_error]]>>
@


\subsection*{[[bytecomp/translcore.ml]]}


<<function [[Translcore.has_base_type]]>>=
(*
let has_base_type exp base_ty =
  let exp_ty =
    Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
  match (Ctype.repr exp_ty, Ctype.repr base_ty) with
    {desc = Tconstr(p1, _, _)}, {desc = Tconstr(p2, _, _)} -> Path.same p1 p2
  | (_, _) -> false
*)
@

<<function [[Translcore.maybe_pointer]]>>=
(*
let maybe_pointer arg =
  not(has_base_type arg Predef.type_int or has_base_type arg Predef.type_char)
*)
@

<<function [[Translcore.array_element_kind]]>>=
(*
let array_element_kind env ty =
  let ty = Ctype.repr (Ctype.expand_head env ty) in
  match ty.desc with
    Tvar ->
      Pgenarray
  | Tconstr(p, args, abbrev) ->
      if Path.same p Predef.path_int || Path.same p Predef.path_char then
        Pintarray
      else if Path.same p Predef.path_float then
        Pfloatarray
      else if Path.same p Predef.path_string
           || Path.same p Predef.path_array then
        Paddrarray
      else begin
        try
          match Env.find_type p env with
            {type_kind = Type_abstract} ->
              Pgenarray
          | {type_kind = Type_variant cstrs}
            when List.for_all (fun (name, args) -> args = []) cstrs ->
              Pintarray
          | {type_kind = _} ->
              Paddrarray
        with Not_found ->
          (* This can happen due to e.g. missing -I options,
             causing some .cmi files to be unavailable.
             Maybe we should emit a warning. *)
          Pgenarray
      end
  | _ ->
      Paddrarray
*)
@

<<function [[Translcore.array_kind]]>>=
(*
let array_kind arg =
  let ty = Ctype.correct_levels arg.exp_type in
  let array_ty = Ctype.expand_head arg.exp_env ty in
  match (Ctype.repr array_ty).desc with
    Tconstr(p, [elt_ty], _) when Path.same p Predef.path_array ->
      array_element_kind arg.exp_env elt_ty
  | _ ->
    fatal_error "Translcore.array_kind"
*)
@

<<constant [[Translcore.prim_makearray]]>>=
let prim_makearray =
  { prim_name = "make_vect"; prim_arity = 2; prim_alloc = true;
    prim_native_name = ""; prim_native_float = false }
@

<<function [[Translcore.transl_prim]]>>=
let transl_prim prim args =
  try
    let (gencomp, intcomp, floatcomp, stringcomp) =
      Hashtbl.find comparisons_table prim.prim_name in
    begin match args with
      [arg1; {exp_desc = Texp_construct({cstr_tag = Cstr_constant _}, _)}] ->
        intcomp
    | [{exp_desc = Texp_construct({cstr_tag = Cstr_constant _}, _)}; arg2] ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_int
                     or has_base_type arg1 Predef.type_char ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_float ->
        floatcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_string ->
        stringcomp
    | _ ->
        gencomp
    end
  with Not_found ->
  try
    let p = Hashtbl.find primitives_table prim.prim_name in
    (* Try strength reduction based on the type of the argument *)
    begin match (p, args) with
        (Psetfield(n, _), [arg1; arg2]) -> Psetfield(n, maybe_pointer arg2)
      | (Parraylength Pgenarray, [arg])   -> Parraylength(array_kind arg)
      | (Parrayrefu Pgenarray, arg1 :: _) -> Parrayrefu(array_kind arg1)
      | (Parraysetu Pgenarray, arg1 :: _) -> Parraysetu(array_kind arg1)
      | (Parrayrefs Pgenarray, arg1 :: _) -> Parrayrefs(array_kind arg1)
      | (Parraysets Pgenarray, arg1 :: _) -> Parraysets(array_kind arg1)
      | _ -> p
    end
  with Not_found ->
    Pccall prim
@

<<function [[Translcore.transl_primitive]]>>=
(* Eta-expand a primitive without knowing the types of its arguments *)

let transl_primitive p =
  let prim =
    try
      let (gencomp, intcomp, floatcomp, stringcomp) =
        Hashtbl.find comparisons_table p.prim_name in
      gencomp
    with Not_found ->
    try
      Hashtbl.find primitives_table p.prim_name
    with Not_found ->
      Pccall p in
  let rec make_params n =
    if n <= 0 then [] else Ident.create "prim" :: make_params (n-1) in
  let params = make_params p.prim_arity in
  Lfunction(Curried, params, Lprim(prim, List.map (fun id -> Lvar id) params))
@

<<function [[Translcore.check_recursive_lambda]]>>=
let check_recursive_lambda idlist lam =
  let rec check_top = function
      Lfunction(kind, params, body) as funct -> true
    | Lprim(Pmakeblock(tag, mut), args) -> List.for_all check args
    | Lprim(Pmakearray kind, args) -> List.for_all check args
    | Llet(str, id, arg, body) -> check arg & check_top body
    | Lletrec(bindings, body) ->
        List.for_all (fun (id, arg) -> check arg) bindings & check_top body
    | Levent (lam, _) -> check_top lam
    | _ -> false
  and check = function
      Lvar _ -> true
    | Lconst cst -> true
    | Lfunction(kind, params, body) -> true
    | Llet(str, id, arg, body) -> check arg & check body
    | Lletrec(bindings, body) ->
        List.for_all (fun (id, arg) -> check arg) bindings & check body
    | Lprim(Pmakeblock(tag, mut), args) -> List.for_all check args
    | Lprim(Pmakearray kind, args) -> List.for_all check args
    | Levent (lam, _) -> check lam
    | lam ->
        let fv = free_variables lam in
        List.for_all (fun id -> not(IdentSet.mem id fv)) idlist
  in check_top lam
@
% see references/progs/ocaml/mutually_recursive_record.ml 
% for example of restrictions and constructs forbidden by ocaml

<<exception [[Translcore.Not_constant]]>>=
(* To propagate structured constants *)

exception Not_constant
@

<<constant [[Translcore.extract_constant]]>>=
let extract_constant = function
    Lconst sc -> sc
  | _ -> raise Not_constant
@

<<constant [[Translcore.extract_float]]>>=
let extract_float = function
    Const_base(Const_float f) -> f
  | _ -> fatal_error "Translcore.extract_float"
@

<<function [[Translcore.name_pattern]]>>=
(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    [] -> Ident.create default
  | (p, e) :: rem ->
      match p.pat_desc with
        Tpat_var id -> id
      | Tpat_alias(p, id) -> id
      | _ -> name_pattern default rem
@

<<function [[Translcore.event_before]]>>=
(* Insertion of debugging events *)

let event_before exp lam =
  if !Clflags.debug && lam <> Lstaticfail
  then Levent(lam, {lev_loc = exp.exp_loc.Location.loc_start;
                    lev_kind = Lev_before;
                    lev_repr = None;
                    lev_env =  ()(* Env.summary exp.exp_env*)})
  else lam
@

<<function [[Translcore.event_after]]>>=
let event_after exp lam =
  if !Clflags.debug
  then Levent(lam, {lev_loc = exp.exp_loc.Location.loc_end;
                    lev_kind = Lev_after exp.exp_type;
                    lev_repr = None;
                    lev_env = () (* Env.summary exp.exp_env*)})
  else lam
@

<<function [[Translcore.event_function]]>>=
let event_function exp lam =
  if !Clflags.debug then
    let repr = Some (ref 0) in
    let (info, body) = lam repr in
    (info,
     Levent(body, {lev_loc = exp.exp_loc.Location.loc_start;
                   lev_kind = Lev_function;
                   lev_repr = repr;
                   lev_env = () (* Env.summary  exp.exp_env*)}))
  else
    lam None
@

<<function [[Translcore.transl_exception]]>>=
(* Compile an exception definition *)

let transl_exception id decl =
    Lprim(Pmakeblock(0, Immutable),
          [Lconst(Const_base(Const_string(Ident.name id)))])
@



%-------------------------------------------------------------

<<bytecomp/translcore.ml>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Misc
open Asttypes
open Primitive
open Path
open Types
open Typedtree
open Lambda

<<type [[Translcore.error]]>>

<<exception [[Translcore.Error]]>>

<<constant [[Translcore.comparisons_table]]>>

<<constant [[Translcore.primitives_table]]>>

let same_base_type ty1 ty2 =
  match (Ctype.repr ty1, Ctype.repr ty2) with
    (Tconstr(p1, []), Tconstr(p2, [])) -> Path.same p1 p2
  | (_, _) -> false

let maybe_pointer arg =
  not(same_base_type arg.exp_type Predef.type_int or
      same_base_type arg.exp_type Predef.type_char)


let array_kind arg =
  match Ctype.repr arg.exp_type with
    Tconstr(p, [ty]) when Path.same p Predef.path_array ->
      begin match Ctype.repr ty with
        Tvar v -> Pgenarray
      | Tconstr(p, _) ->
          if Path.same p Predef.path_int or Path.same p Predef.path_char then
            Pintarray
          else if Path.same p Predef.path_float then
            Pfloatarray
          else
            Paddrarray
      | _ -> Paddrarray
      end
  | _ -> Pgenarray (* This can happen with abbreviations that we can't expand
                      here because the typing environment is lost *)

let has_base_type exp base_ty = 
  same_base_type exp.exp_type base_ty

<<function [[Translcore.has_base_type]]>>

<<function [[Translcore.maybe_pointer]]>>

<<function [[Translcore.array_element_kind]]>>

<<function [[Translcore.array_kind]]>>

<<constant [[Translcore.prim_makearray]]>>

<<function [[Translcore.transl_prim]]>>

<<function [[Translcore.transl_primitive]]>>

(* To check the well-formedness of r.h.s. of "let rec" definitions *)

module IdentSet = Set

<<function [[Translcore.check_recursive_lambda]]>>

<<exception [[Translcore.Not_constant]]>>

<<constant [[Translcore.extract_constant]]>>

<<constant [[Translcore.extract_float]]>>

<<function [[Translcore.name_pattern]]>>

<<function [[Translcore.event_before]]>>

<<function [[Translcore.event_after]]>>

<<function [[Translcore.event_function]]>>

(* Translation of expressions *)
<<function [[Translcore.transl_exp]]>>

and transl_list expr_list =
  List.map transl_exp expr_list

and transl_cases pat_expr_list =
  List.map
    (fun (pat, expr) -> (pat, event_before expr (transl_exp expr)))
    pat_expr_list

and transl_tupled_cases patl_expr_list =
  List.map (fun (patl, expr) -> (patl, transl_exp expr)) patl_expr_list

<<function [[Translcore.transl_function]]>>

<<function [[Translcore.transl_let]]>>

<<function [[Translcore.transl_exception]]>>

(* Error report *)

open Format

<<constant [[Translcore.report_error]]>>
@


\subsection*{[[bytecomp/bytegen.mli]]}


<<signature [[Bytegen.compile_phrase]]>>=
val compile_phrase: lambda -> instruction list * instruction list
@


%-------------------------------------------------------------

<<bytecomp/bytegen.mli>>=
<<copyright header>>

(* Generation of bytecode from lambda terms *)

open Lambda
open Instruct

<<signature [[Bytegen.compile_implementation]]>>
<<signature [[Bytegen.compile_phrase]]>>
@


\subsection*{[[bytecomp/bytegen.ml]]}

<<constant [[Bytegen.label_counter]]>>=
(**** Label generation ****)

let label_counter = ref 0
@

<<function [[Bytegen.new_label]]>>=
let new_label () =
  incr label_counter; !label_counter
@

<<constant [[Bytegen.empty_env]]>>=
(**** Operations on compilation environments. ****)

let empty_env =
  { ce_stack = Ident.empty; ce_heap = Ident.empty }
@

<<function [[Bytegen.add_var]]>>=
(* Add a stack-allocated variable *)

let add_var id pos env =
  { ce_stack = Ident.add id pos env.ce_stack;
    ce_heap = env.ce_heap }
@

<<constant [[Bytegen.label_code]]>>=
(* Return a label to the beginning of the given continuation.
   If the sequence starts with a branch, use the target of that branch
   as the label, thus avoiding a jump to a jump. *)

let label_code = function
    Kbranch lbl :: _ as cont -> (lbl, cont)
  | Klabel lbl :: _ as cont -> (lbl, cont)
  | cont -> let lbl = new_label() in (lbl, Klabel lbl :: cont)
@

<<function [[Bytegen.make_branch]]>>=
(* Return a branch to the continuation. That is, an instruction that,
   when executed, branches to the continuation or performs what the
   continuation performs. We avoid generating branches to branches and
   branches to returns. *)

let make_branch cont =
  match cont with
    (Kbranch _ as branch) :: _ -> (branch, cont)
  | (Kreturn _ as return) :: _ -> (return, cont)
  | Kraise :: _ -> (Kraise, cont)
  | Klabel lbl :: _ -> (Kbranch lbl, cont)
  | _ -> let lbl = new_label() in (Kbranch lbl, Klabel lbl :: cont)
@

<<constant [[Bytegen.discard_dead_code]]>>=
(* Discard all instructions up to the next label.
   This function is to be applied to the continuation before adding a
   non-terminating instruction (branch, raise, return) in front of it. *)

let rec discard_dead_code = function
    [] -> []
  | (Klabel _ | Krestart | Ksetglobal _) :: _ as cont -> cont
  | _ :: cont -> discard_dead_code cont
@

<<constant [[Bytegen.is_tailcall]]>>=
(* Check if we're in tailcall position *)

let rec is_tailcall = function
    Kreturn _ :: _ -> true
  | Klabel _ :: c -> is_tailcall c
  | Kpop _ :: c -> is_tailcall c
  | _ -> false
@

<<function [[Bytegen.add_pop]]>>=
(* Add a Kpop N instruction in front of a continuation *)

let rec add_pop n cont =
  if n = 0 then cont else
    match cont with
      Kpop m :: cont -> add_pop (n + m) cont
    | Kreturn m :: cont -> Kreturn(n + m) :: cont
    | Kraise :: _ -> cont
    | _ -> Kpop n :: cont
@

<<constant [[Bytegen.add_const_unit]]>>=
(* Add the constant "unit" in front of a continuation *)

let add_const_unit = function
    (Kacc _ | Kconst _ | Kgetglobal _ | Kpush_retaddr _) :: _ as cont -> cont
  | cont -> Kconst const_unit :: cont
@

<<constant [[Bytegen.size_of_lambda]]>>=
let rec size_of_lambda = function
  | Lfunction(kind, params, body) as funct ->
      1 + IdentSet.cardinal(free_variables funct)
  | Lprim(Pmakeblock(tag, mut), args) -> List.length args
  | Lprim(Pmakearray kind, args) -> List.length args
  | Llet(str, id, arg, body) -> size_of_lambda body
  | Lletrec(bindings, body) -> size_of_lambda body
  | Levent (lam, _) -> size_of_lambda lam
  | _ -> fatal_error "Bytegen.size_of_lambda"
@

<<function [[Bytegen.copy_event]]>>=
(**** Merging consecutive events ****)

let copy_event ev kind info repr =
  { ev_pos = 0;                   (* patched in emitcode *)
    ev_module = ev.ev_module;
    ev_char = ev.ev_char;
    ev_kind = kind;
    ev_info = info;
    ev_typenv = ev.ev_typenv;
    ev_compenv = ev.ev_compenv;
    ev_stacksize = ev.ev_stacksize;
    ev_repr = repr }
@

<<function [[Bytegen.merge_infos]]>>=
let merge_infos ev ev' =
  match ev.ev_info, ev'.ev_info with
    Event_other, info -> info
  | info, Event_other -> info
  | _                 -> fatal_error "Bytegen.merge_infos"
@

<<function [[Bytegen.merge_repr]]>>=
let merge_repr ev ev' =
  match ev.ev_repr, ev'.ev_repr with
    Event_none, x -> x
  | x, Event_none -> x
  | Event_parent r, Event_child r' when r == r' && !r = 1 -> Event_none
  | _, _          -> fatal_error "Bytegen.merge_repr"
@

<<function [[Bytegen.merge_events]]>>=
let merge_events ev ev' =
  let (maj, min) =
    match ev.ev_kind, ev'.ev_kind with
    (* Discard pseudo-events *)    
      Event_pseudo,  _                              -> ev', ev
    | _,             Event_pseudo                   -> ev,  ev'
    (* Keep following event, supposedly more informative *)
    | Event_before,  (Event_after _ | Event_before) -> ev',  ev
    (* Discard following events, supposedly less informative *)
    | Event_after _, (Event_after _ | Event_before) -> ev, ev'
  in
  copy_event maj maj.ev_kind (merge_infos maj min) (merge_repr maj min)
@

<<function [[Bytegen.weaken_event]]>>=
let weaken_event ev cont =
  match ev.ev_kind with
    Event_after _ ->
      begin match cont with
        Kpush :: Kevent ({ev_repr = Event_none} as ev') :: c ->
          begin match ev.ev_info with
            Event_return _ ->
              (* Weaken event *)
              let repr = ref 1 in
              let ev =
                copy_event ev Event_pseudo ev.ev_info (Event_parent repr)
              and ev' =
                copy_event ev' ev'.ev_kind ev'.ev_info (Event_child repr)
              in
              Kevent ev :: Kpush :: Kevent ev' :: c
          | _ ->
              (* Only keep following event, equivalent *)
              cont
          end
      | _ ->
          Kevent ev :: cont
      end
  | _ ->
      Kevent ev :: cont
@

<<function [[Bytegen.add_event]]>>=
let add_event ev =
  function
    Kevent ev' :: cont -> weaken_event (merge_events ev ev') cont
  | cont               -> weaken_event ev cont
@

<<constant [[Bytegen.functions_to_compile]]>>=
(* Function bodies that remain to be compiled *)

let functions_to_compile  =
@

<<constant [[Bytegen.compunit_name]]>>=
(* Name of current compilation unit (for debugging events) *)

let compunit_name = ref ""
@

<<function [[Bytegen.comp_function]]>>=
(**** Compilation of functions ****)

let comp_function (params, fun_body, entry_lbl, free_vars) cont =
  let arity = List.length params in
  let rec pos_args pos delta = function
      [] -> Ident.empty
    | id :: rem -> Ident.add id pos (pos_args (pos+delta) delta rem) in
  let env =
    { ce_stack = pos_args arity (-1) params;
      ce_heap = pos_args 0 1 free_vars } in
  let cont1 =
    comp_expr env fun_body arity (Kreturn arity :: cont) in
  if arity > 1 then
    Krestart :: Klabel entry_lbl :: Kgrab(arity - 1) :: cont1
  else
    Klabel entry_lbl :: cont1
@

<<function [[Bytegen.comp_remainder]]>>=
let comp_remainder cont =
  let c = ref cont in
  begin try
    while true do
      c := comp_function (Stack.pop functions_to_compile) !c
    done
  with Stack.Empty ->
    ()
  end;
  !c
@

<<function [[Bytegen.compile_implementation]]>>=
(**** Compilation of a lambda phrase ****)

let compile_implementation modulename expr =
  Stack.clear functions_to_compile;
  label_counter := 0;
  lbl_staticfail := 0;
  sz_staticfail := 0;
  compunit_name := modulename;
  let init_code = comp_expr empty_env expr 0 [] in
  if Stack.length functions_to_compile > 0 then begin
    let lbl_init = new_label() in
    Kbranch lbl_init :: comp_remainder (Klabel lbl_init :: init_code)
  end else
    init_code
@

<<function [[Bytegen.compile_phrase]]>>=
let compile_phrase expr =
  Stack.clear functions_to_compile;
  label_counter := 0;
  lbl_staticfail := 0;
  sz_staticfail := 0;
  let init_code = comp_expr empty_env expr 1 [Kreturn 1] in
  let fun_code = comp_remainder [] in
  (init_code, fun_code)
@


%-------------------------------------------------------------

<<bytecomp/bytegen.ml>>=
<<copyright header>>

(*  bytegen.ml : translation of lambda terms to lists of instructions. *)

open Misc
open Asttypes
open Primitive
open Types
open Lambda
open Instruct

<<constant [[Bytegen.label_counter]]>>

<<function [[Bytegen.new_label]]>>

<<constant [[Bytegen.empty_env]]>>

<<function [[Bytegen.add_var]]>>

(**** Examination of the continuation ****)

<<constant [[Bytegen.label_code]]>>

<<function [[Bytegen.make_branch]]>>

<<constant [[Bytegen.discard_dead_code]]>>

<<constant [[Bytegen.is_tailcall]]>>

<<function [[Bytegen.add_pop]]>>

<<constant [[Bytegen.add_const_unit]]>>

(**** Auxiliary for compiling "let rec" ****)

module IdentSet = Set

<<constant [[Bytegen.size_of_lambda]]>>

<<function [[Bytegen.copy_event]]>>

<<function [[Bytegen.merge_infos]]>>

<<function [[Bytegen.merge_repr]]>>

<<function [[Bytegen.merge_events]]>>

<<function [[Bytegen.weaken_event]]>>
  
<<function [[Bytegen.add_event]]>>

(**** Compilation of a lambda expression ****)

(* The label to which Lstaticfail branches, and the stack size at that point.*)

let lbl_staticfail = ref 0
and sz_staticfail = ref 0

<<constant [[Bytegen.functions_to_compile]]>>
  (Stack.create () : (Ident.t list * lambda * label * Ident.t list) Stack.t)

<<constant [[Bytegen.compunit_name]]>>

(* Compile an expression.
   The value of the expression is left in the accumulator.
   env = compilation environment
   exp = the lambda expression to compile
   sz = current size of the stack frame
   cont = list of instructions to execute afterwards
   Result = list of instructions that evaluate exp, then perform cont. *)

let rec comp_expr env exp sz cont =
  match exp with
    Lvar id ->
      begin try
        let pos = Ident.find_same id env.ce_stack in
        Kacc(sz - pos) :: cont
      with Not_found ->
      try
        let pos = Ident.find_same id env.ce_heap in
        Kenvacc(pos) :: cont
      with Not_found ->
        Ident.print id; print_newline();
        fatal_error "Bytegen.comp_expr: var"
      end
  | Lconst cst ->
      Kconst cst :: cont
  | Lapply(func, args) ->
      let nargs = List.length args in
      if is_tailcall cont then
        comp_args env args sz
          (Kpush :: comp_expr env func (sz + nargs)
            (Kappterm(nargs, sz + nargs) :: discard_dead_code cont))
      else
        if nargs < 4 then
          comp_args env args sz
            (Kpush :: comp_expr env func (sz + nargs) (Kapply nargs :: cont))
        else begin
          let (lbl, cont1) = label_code cont in
          Kpush_retaddr lbl ::
          comp_args env args (sz + 3)
            (Kpush :: comp_expr env func (sz + 3 + nargs)
                      (Kapply nargs :: cont1))
        end
  | Lfunction(kind, params, body) -> (* assume kind = Curried *)
      let lbl = new_label() in
      let fv = IdentSet.elements(free_variables exp) in
      Stack.push (params, body, lbl, fv) functions_to_compile;
      comp_args env (List.map (fun n -> Lvar n) fv) sz
        (Kclosure(lbl, List.length fv) :: cont)
  | Llet(str, id, arg, body) ->
      comp_expr env arg sz
        (Kpush :: comp_expr (add_var id (sz+1) env) body (sz+1)
          (add_pop 1 cont))
  | Lletrec(([id, Lfunction(kind, params, funct_body)] as decl), let_body) ->
      let lbl = new_label() in
      let fv =
        IdentSet.elements (free_variables (Lletrec(decl, lambda_unit))) in
      Stack.push (params, funct_body, lbl, id :: fv) functions_to_compile;
      comp_args env (List.map (fun n -> Lvar n) fv) sz
        (Kclosurerec(lbl, List.length fv) :: Kpush ::
          (comp_expr (add_var id (sz+1) env) let_body (sz+1)
                     (add_pop 1 cont)))
  | Lletrec(decl, body) ->
      let ndecl = List.length decl in
      let decl_size =
        List.map (fun (id, exp) -> (id, exp, size_of_lambda exp)) decl in
      let rec comp_decl new_env sz i = function
          [] ->
            comp_expr new_env body sz (add_pop ndecl cont)
        | (id, exp, blocksize) :: rem ->
            comp_expr new_env exp sz
              (Kpush :: Kacc i :: Kupdate blocksize ::
               comp_decl new_env sz (i-1) rem) in
      let rec comp_init new_env sz = function
          [] ->
            comp_decl new_env sz ndecl decl_size
        | (id, exp, blocksize) :: rem ->
            Kdummy blocksize :: Kpush ::
            comp_init (add_var id (sz+1) new_env) (sz+1) rem in
      comp_init env sz decl_size
  | Lprim(Pidentity, [arg]) ->
      comp_expr env arg sz cont
  | Lprim(Pnot, [arg]) ->
      let newcont =
        match cont with
          Kbranchif lbl :: cont1 -> Kbranchifnot lbl :: cont1
        | Kbranchifnot lbl :: cont1 -> Kbranchif lbl :: cont1
        | _ -> Kboolnot :: cont in
      comp_expr env arg sz newcont
  | Lprim(Psequand, [exp1; exp2]) ->
      begin match cont with
        Kbranchifnot lbl :: _ ->
          comp_expr env exp1 sz (Kbranchifnot lbl ::
            comp_expr env exp2 sz cont)
      | Kbranchif lbl :: cont1 ->
          let (lbl2, cont2) = label_code cont1 in
          comp_expr env exp1 sz (Kbranchifnot lbl2 ::
            comp_expr env exp2 sz (Kbranchif lbl :: cont2))
      | _ ->
          let (lbl, cont1) = label_code cont in
          comp_expr env exp1 sz (Kstrictbranchifnot lbl ::
            comp_expr env exp2 sz cont1)
      end
  | Lprim(Psequor, [exp1; exp2]) ->
      begin match cont with
        Kbranchif lbl :: _ ->
          comp_expr env exp1 sz (Kbranchif lbl ::
            comp_expr env exp2 sz cont)
      | Kbranchifnot lbl :: cont1 ->
          let (lbl2, cont2) = label_code cont1 in
          comp_expr env exp1 sz (Kbranchif lbl2 ::
            comp_expr env exp2 sz (Kbranchifnot lbl :: cont2))
      | _ ->
          let (lbl, cont1) = label_code cont in
          comp_expr env exp1 sz (Kstrictbranchif lbl ::
            comp_expr env exp2 sz cont1)
      end
  | Lprim(Praise, [arg]) ->
      comp_expr env arg sz (Kraise :: discard_dead_code cont)
  | Lprim((Paddint | Psubint as prim), [arg; Lconst(Const_base(Const_int n))])
    when n >= immed_min & n <= immed_max ->
      let ofs = if prim == Paddint then n else -n in
      comp_expr env arg sz (Koffsetint ofs :: cont)
  | Lprim(p, args) ->
      let instr =
        match p with
          Pgetglobal id -> Kgetglobal id
        | Psetglobal id -> Ksetglobal id
        | Pintcomp cmp -> Kintcomp cmp
        | Pmakeblock(tag, mut) -> Kmakeblock(List.length args, tag)
        | Pfield n -> Kgetfield n
        | Psetfield(n, ptr) -> Ksetfield n
        | Pfloatfield n -> Kgetfield n
        | Psetfloatfield n -> Ksetfield n
        | Pccall p -> Kccall(p.prim_name, p.prim_arity)
        | Pnegint -> Knegint
        | Paddint -> Kaddint
        | Psubint -> Ksubint
        | Pmulint -> Kmulint
        | Pdivint -> Kdivint
        | Pmodint -> Kmodint
        | Pandint -> Kandint
        | Porint -> Korint
        | Pxorint -> Kxorint
        | Plslint -> Klslint
        | Plsrint -> Klsrint
        | Pasrint -> Kasrint
        | Poffsetint n -> Koffsetint n
        | Poffsetref n -> Koffsetref n
        | Pintoffloat -> Kccall("int_of_float", 1)
        | Pfloatofint -> Kccall("float_of_int", 1)
        | Pnegfloat -> Kccall("neg_float", 1)
        | Pabsfloat -> Kccall("abs_float", 1)
        | Paddfloat -> Kccall("add_float", 2)
        | Psubfloat -> Kccall("sub_float", 2)
        | Pmulfloat -> Kccall("mul_float", 2)
        | Pdivfloat -> Kccall("div_float", 2)
        | Pfloatcomp Ceq -> Kccall("eq_float", 2)
        | Pfloatcomp Cneq -> Kccall("neq_float", 2)
        | Pfloatcomp Clt -> Kccall("lt_float", 2)
        | Pfloatcomp Cgt -> Kccall("gt_float", 2)
        | Pfloatcomp Cle -> Kccall("le_float", 2)
        | Pfloatcomp Cge -> Kccall("ge_float", 2)
        | Pstringlength -> Kccall("ml_string_length", 1)
        | Pstringrefs -> Kccall("string_get", 2)
        | Pstringsets -> Kccall("string_set", 3)
        | Pstringrefu -> Kgetstringchar
        | Pstringsetu -> Ksetstringchar
        | Pmakearray kind -> Kmakeblock(List.length args, 0)
        | Parraylength kind -> Kvectlength
        | Parrayrefs kind -> Kccall("array_get", 2)
        | Parraysets kind -> Kccall("array_set", 3)
        | Parrayrefu kind -> Kgetvectitem
        | Parraysetu kind -> Ksetvectitem
        | Pbittest -> Kccall("bitvect_test", 2)
        | _ -> fatal_error "Bytegen.comp_expr: prim" in
      comp_args env args sz (instr :: cont)
  | Lcatch(body, Lstaticfail) ->
      comp_expr env body sz cont
  | Lcatch(body, handler) ->
      let (branch1, cont1) = make_branch cont in
      let (lbl_handler, cont2) = label_code (comp_expr env handler sz cont1) in
      let saved_lbl_staticfail = !lbl_staticfail
      and saved_sz_staticfail = !sz_staticfail in
      lbl_staticfail := lbl_handler;
      sz_staticfail := sz;
      let cont3 = comp_expr env body sz (branch1 :: cont2) in
      lbl_staticfail := saved_lbl_staticfail;
      sz_staticfail := saved_sz_staticfail;
      cont3
  | Lstaticfail ->
      add_pop (sz - !sz_staticfail)
              (Kbranch !lbl_staticfail :: discard_dead_code cont)
  | Ltrywith(body, id, handler) ->
      let (branch1, cont1) = make_branch cont in
      let lbl_handler = new_label() in
      Kpushtrap lbl_handler :: 
        comp_expr env body (sz+4) (Kpoptrap :: branch1 :: 
          Klabel lbl_handler :: Kpush ::
            comp_expr (add_var id (sz+1) env) handler (sz+1) (add_pop 1 cont1))
  | Lifthenelse(cond, ifso, ifnot) ->
      comp_binary_test env cond ifso ifnot sz cont
  | Lsequence(exp1, exp2) ->
      comp_expr env exp1 sz (comp_expr env exp2 sz cont)
  | Lwhile(cond, body) ->
      let lbl_loop = new_label() in
      let lbl_test = new_label() in
      Kbranch lbl_test :: Klabel lbl_loop :: Kcheck_signals ::
        comp_expr env body sz
          (Klabel lbl_test ::
            comp_expr env cond sz (Kbranchif lbl_loop :: add_const_unit cont))
  | Lfor(param, start, stop, dir, body) ->
      let lbl_loop = new_label() in
      let lbl_test = new_label() in
      let offset = match dir with Upto -> 1 | Downto -> -1 in
      let comp = match dir with Upto -> Cle | Downto -> Cge in
      comp_expr env start sz
        (Kpush :: comp_expr env stop (sz+1)
          (Kpush :: Kbranch lbl_test ::
           Klabel lbl_loop :: Kcheck_signals ::
           comp_expr (add_var param (sz+1) env) body (sz+2)
             (Kacc 1 :: Koffsetint offset :: Kassign 1 ::
              Klabel lbl_test ::
              Kacc 0 :: Kpush :: Kacc 2 :: Kintcomp comp ::
              Kbranchif lbl_loop ::
              add_const_unit (add_pop 2 cont))))
  | Lswitch(arg, sw) ->
      let (branch, cont1) = make_branch cont in
      let c = ref (discard_dead_code cont1) in
      let act_consts = Array.create sw.sw_numconsts Lstaticfail in
      List.iter (fun (n, act) -> act_consts.(n) <- act) sw.sw_consts;
      let act_blocks = Array.create sw.sw_numblocks Lstaticfail in
      List.iter (fun (n, act) -> act_blocks.(n) <- act) sw.sw_blocks;
      let lbl_consts = Array.create sw.sw_numconsts 0 in
      let lbl_blocks = Array.create sw.sw_numblocks 0 in
      for i = sw.sw_numblocks - 1 downto 0 do
        let (lbl, c1) =
          label_code(comp_expr env act_blocks.(i) sz (branch :: !c)) in
        lbl_blocks.(i) <- lbl;
        c := discard_dead_code c1
      done;
      for i = sw.sw_numconsts - 1 downto 0 do
        let (lbl, c1) =
          label_code(comp_expr env act_consts.(i) sz (branch :: !c)) in
        lbl_consts.(i) <- lbl;
        c := discard_dead_code c1
      done;
      if sw.sw_checked then c := comp_expr env Lstaticfail sz !c;        
      comp_expr env arg sz (Kswitch(lbl_consts, lbl_blocks) :: !c)
  | Lassign(id, expr) ->
      begin try
        let pos = Ident.find_same id env.ce_stack in
        comp_expr env expr sz (Kassign(sz - pos) :: cont)
      with Not_found ->
        fatal_error "Bytegen.comp_expr: assign"
      end
  | Levent(lam, lev) ->
      let event kind info =
        { ev_pos = 0;                   (* patched in emitcode *)
          ev_module = !compunit_name;
          ev_char = lev.lev_loc;
          ev_kind = kind;
          ev_info = info;
          ev_typenv = lev.lev_env;
          ev_compenv = env;
          ev_stacksize = sz;
          ev_repr =
            begin match lev.lev_repr with
              None ->
                Event_none
            | Some ({contents = 1} as repr) when lev.lev_kind = Lev_function ->
                Event_child repr
            | Some ({contents = 1} as repr) ->
                Event_parent repr
            | Some repr when lev.lev_kind = Lev_function ->
                Event_parent repr
            | Some repr ->
                Event_child repr
            end }
      in
      begin match lev.lev_kind with
        Lev_before ->
          let c = comp_expr env lam sz cont in
          let ev = event Event_before Event_other in
          add_event ev c
      | Lev_function ->
          let c = comp_expr env lam sz cont in
          let ev = event Event_pseudo Event_function in
          add_event ev c
      | Lev_after _ when is_tailcall cont -> (* don't destroy tail call opt *)
          comp_expr env lam sz cont
      | Lev_after ty ->
          let info =
            match lam with
              Lapply(_, args)   -> Event_return (List.length args)
            | _                 -> Event_other
          in
          let ev = event (Event_after ty) info in
          let cont1 = add_event ev cont in
          comp_expr env lam sz cont1
      end

(* Compile a list of arguments [e1; ...; eN] to a primitive operation.
   The values of eN ... e2 are pushed on the stack, e2 at top of stack,
   then e3, then ... The value of e1 is left in the accumulator. *)

and comp_args env argl sz cont =
  comp_expr_list env (List.rev argl) sz cont

and comp_expr_list env exprl sz cont =
  match exprl with
    [] -> cont
  | [exp] -> comp_expr env exp sz cont
  | exp :: rem ->
      comp_expr env exp sz (Kpush :: comp_expr_list env rem (sz+1) cont)

(* Compile an if-then-else test. *)

and comp_binary_test env cond ifso ifnot sz cont =
  let cont_cond =
    if ifnot = Lconst const_unit then begin
      let (lbl_end, cont1) = label_code cont in
      Kstrictbranchifnot lbl_end :: comp_expr env ifso sz cont1
    end else
    if ifso = Lstaticfail & sz = !sz_staticfail then
      Kbranchif !lbl_staticfail :: comp_expr env ifnot sz cont
    else
    if ifnot = Lstaticfail & sz = !sz_staticfail then
      Kbranchifnot !lbl_staticfail :: comp_expr env ifso sz cont
    else begin
      let (branch_end, cont1) = make_branch cont in
      let (lbl_not, cont2) = label_code(comp_expr env ifnot sz cont1) in
      Kbranchifnot lbl_not :: comp_expr env ifso sz (branch_end :: cont2)
    end in
  comp_expr env cond sz cont_cond

<<function [[Bytegen.comp_function]]>>

<<function [[Bytegen.comp_remainder]]>>

<<function [[Bytegen.compile_implementation]]>>

<<function [[Bytegen.compile_phrase]]>>

@


\subsection*{[[bytecomp/translmod.mli]]}




%-------------------------------------------------------------

<<bytecomp/translmod.mli>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Typedtree
open Lambda

<<signature [[Translmod.transl_implementation]]>>
<<signature [[Translmod.transl_store_implementation]]>>
<<signature [[Translmod.transl_toplevel_definition]]>>

<<signature [[Translmod.primitive_declarations]]>>
@


\subsection*{[[bytecomp/translmod.ml]]}

<<function [[Translmod.reset_labels]]>>=
let reset_labels () =
  ()
@
% (*  used_methods := [] *)

<<function [[Translmod.transl_label_init]]>>=
let transl_label_init expr =
  expr
@
%(*
%  if !used_methods = [] then
%    expr
%  else
%    let init = Ident.create "new_method" in
%    let expr' =
%      Llet(StrictOpt, init, oo_prim "new_method",
%      List.fold_right
%        (fun (lab, id) expr ->
%           Llet(StrictOpt, id, Lapply(Lvar init, [string lab]), expr))
%        !used_methods
%        expr)
%    in
%    reset_labels ();
%    expr'
%*)

<<function [[Translmod.compose_coercions]]>>=
(* Compose two coercions
   apply_coercion c1 (apply_coercion c2 e) behaves like
   apply_coercion (compose_coercions c1 c2) e. *)

let rec compose_coercions c1 c2 =
  match (c1, c2) with
    (Tcoerce_none, c2) -> c2
  | (c1, Tcoerce_none) -> c1
  | (Tcoerce_structure pc1, Tcoerce_structure pc2) ->
      let v2 = Array.of_list pc2 in
      Tcoerce_structure
        (List.map (fun (p1, c1) ->
                let (p2, c2) = v2.(p1) in (p2, compose_coercions c1 c2))
             pc1)
  | (_, _) ->
      fatal_error "Translmod.compose_coercions"
@


<<function [[Translmod.transl_implementation]]>>=
(* Compile an implementation *)

let transl_implementation module_name str cc =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  Lprim(Psetglobal module_id, [transl_label_init (transl_structure [] cc str)])
@

<<function [[Translmod.transl_store_structure]]>>=
(* A variant of transl_structure used to compile toplevel structure definitions
   for the native-code compiler. Store the defined values in the fields
   of the global as soon as they are defined, in order to reduce register
   pressure.
   "map" is a table from idents to (position in global block, coercion).
   "prim" is a list of (position in global block, primitive declaration). *)

let transl_store_structure glob map prims str =
  let rec transl_store = function
    [] ->
      lambda_unit
  | Tstr_eval expr :: rem ->
      Lsequence(transl_exp expr, transl_store rem)
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      transl_let rec_flag pat_expr_list
        (store_idents glob map (let_bound_idents pat_expr_list)
          (transl_store rem))
  | Tstr_primitive(id, descr) :: rem ->
      begin match descr.val_prim with
        Some p -> primitive_declarations :=
                        p.Primitive.prim_name :: !primitive_declarations
      | _ -> ()
      end;
      transl_store rem
  | Tstr_type(decls) :: rem ->
      transl_store rem
  | Tstr_exception(id, decl) :: rem ->
      Llet(Strict, id, transl_exception id decl,
           store_ident glob map id (transl_store rem))
  | Tstr_module(id, modl) :: rem ->
      Llet(Strict, id, transl_module Tcoerce_none modl,
           store_ident glob map id (transl_store rem))
  | Tstr_open path :: rem ->
      transl_store rem

  and store_ident glob map id cont =
    try
      let (pos, cc) = Ident.find_same id map in
      let init_val = apply_coercion cc (Lvar id) in
      Lsequence
       (Lprim(Psetfield(pos, false), [Lprim(Pgetglobal glob, []); init_val]),
        cont)
    with Not_found ->
      cont

  and store_idents glob map idlist cont =
    List.fold_right (store_ident glob map) idlist cont

  and store_primitive (pos, prim) cont =
    Lsequence(Lprim(Psetfield(pos, false),
                    [Lprim(Pgetglobal glob, []); transl_primitive prim]),
              cont)
  in
    List.fold_right store_primitive prims (transl_store str)
@

<<constant [[Translmod.defined_idents]]>>=
(* Build the list of value identifiers defined by a toplevel structure *)

let rec defined_idents = function
    [] -> []
  | Tstr_eval expr :: rem -> defined_idents rem
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      let_bound_idents pat_expr_list @ defined_idents rem
  | Tstr_primitive(id, descr) :: rem -> defined_idents rem
  | Tstr_type decls :: rem -> defined_idents rem
  | Tstr_exception(id, decl) :: rem -> id :: defined_idents rem
  | Tstr_module(id, modl) :: rem -> id :: defined_idents rem
  | Tstr_open path :: rem -> defined_idents rem
@

<<function [[Translmod.build_ident_map]]>>=
(* Transform a coercion and the list of value identifiers built above
   into a table id -> (pos, coercion), with [pos] being the position
   in the global block where the value of [id] must be stored,
   and [coercion] the coercion to be applied to it.
   A given identifier may appear several times
   in the coercion (if it occurs several times in the signature); remember
   to assign it the position of its last occurrence.
   Also buid a list of primitives and their positions in the global block,
   and the total size of the global block. *)

let build_ident_map restr idlist =
  match restr with
    Tcoerce_none ->
      let rec build_map pos map = function
        [] ->
          (map, [], pos)
      | id :: rem ->
          build_map (pos+1) (Ident.add id (pos, Tcoerce_none) map) rem
      in build_map 0 Ident.empty idlist
  | Tcoerce_structure pos_cc_list ->
      let idarray = Array.of_list idlist in
      let rec build_map pos map prims = function
        [] ->
          (map, prims, pos)
      | (source_pos, Tcoerce_primitive p) :: rem ->
          build_map (pos+1) map ((pos, p) :: prims) rem
      | (source_pos, cc) :: rem ->
          build_map (pos+1) (Ident.add idarray.(source_pos) (pos, cc) map)
                    prims rem
      in build_map 0 Ident.empty [] pos_cc_list
  | _ ->
      fatal_error "Translmod.build_ident_map"
@

<<function [[Translmod.transl_store_implementation]]>>=
(* Compile an implementation using transl_store_structure 
   (for the native-code compiler). *)

let transl_store_implementation module_name str restr =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  let (map, prims, size) = build_ident_map restr (defined_idents str) in
  (size, transl_label_init (transl_store_structure module_id map prims str))
@

<<function [[Translmod.make_sequence]]>>=
(* Compile a sequence of expressions *)

let rec make_sequence fn = function
    [] -> lambda_unit
  | [x] -> fn x
  | x::rem ->
      let lam = fn x in Lsequence(lam, make_sequence fn rem)
@

<<constant [[Translmod.transl_toplevel_item]]>>=
(* Compile a toplevel phrase *)

let transl_toplevel_item = function
    Tstr_eval expr ->
      transl_exp expr
  | Tstr_value(rec_flag, pat_expr_list) ->
      let idents = let_bound_idents pat_expr_list in
      let lam =
        transl_let rec_flag pat_expr_list
          (make_sequence (fun id -> Lprim(Psetglobal id, [Lvar id])) idents) in
      List.iter Ident.make_global idents;
      lam
  | Tstr_primitive(id, descr) ->
      lambda_unit
  | Tstr_type(decls) ->
      lambda_unit
  | Tstr_exception(id, decl) ->
      Ident.make_global id;
      Lprim(Psetglobal id, [transl_exception id decl])
  | Tstr_module(id, modl) ->
      Ident.make_global id;
      Lprim(Psetglobal id, [transl_module Tcoerce_none modl])
  | Tstr_open path ->
      lambda_unit
@

<<function [[Translmod.transl_toplevel_definition]]>>=
let transl_toplevel_definition str =
  reset_labels ();
  transl_label_init (make_sequence transl_toplevel_item str)
@


%-------------------------------------------------------------

<<bytecomp/translmod.ml>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Misc
open Asttypes
open Types
open Typedtree
open Lambda
open Translcore

<<function [[Translmod.reset_labels]]>>

<<function [[Translmod.transl_label_init]]>>

(* Compile a coercion *)

let rec apply_coercion restr arg =
  match restr with
    Tcoerce_none ->
      arg
  | Tcoerce_structure pos_cc_list ->
      name_lambda arg (fun id ->
        Lprim(Pmakeblock(0, Immutable),
              List.map (apply_coercion_field id) pos_cc_list))
  | Tcoerce_primitive p ->
      fatal_error "Translmod.apply_coercion"

and apply_coercion_field id (pos, cc) =
  match cc with
    Tcoerce_primitive p -> transl_primitive p
  | _ -> apply_coercion cc (Lprim(Pfield pos, [Lvar id]))

<<function [[Translmod.compose_coercions]]>>

<<constant [[Translmod.primitive_declarations]]>>

(* Compile a module expression *)

let rec transl_module cc mexp =
  match mexp.mod_desc with
    Tmod_ident path ->
      apply_coercion cc (transl_path path)
  | Tmod_structure str ->
      transl_structure [] cc str
  | Tmod_constraint(arg, mty, ccarg) ->
      transl_module (compose_coercions cc ccarg) arg

and transl_structure fields cc = function
    [] ->
      begin match cc with
        Tcoerce_none ->
          Lprim(Pmakeblock(0, Immutable),
                List.map (fun id -> Lvar id) (List.rev fields))
      | Tcoerce_structure pos_cc_list ->
          let v = Array.of_list (List.rev fields) in
          Lprim(Pmakeblock(0, Immutable),
                List.map
                  (fun (pos, cc) ->
                    match cc with
                      Tcoerce_primitive p -> transl_primitive p
                    | _ -> apply_coercion cc (Lvar v.(pos)))
                  pos_cc_list)
      | _ ->
          fatal_error "Translmod.transl_structure"
      end
  | Tstr_eval expr :: rem ->
      Lsequence(transl_exp expr, transl_structure fields cc rem)
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      let ext_fields = rev_let_bound_idents pat_expr_list @ fields in
      transl_let rec_flag pat_expr_list (transl_structure ext_fields cc rem)
  | Tstr_primitive(id, descr) :: rem ->
      begin match descr.val_prim with
        Some p -> primitive_declarations :=
                        p.Primitive.prim_name :: !primitive_declarations
      | _ -> ()
      end;
      transl_structure fields cc rem
  | Tstr_type(decls) :: rem ->
      transl_structure fields cc rem
  | Tstr_exception(id, decl) :: rem ->
      Llet(Strict, id, transl_exception id decl,
           transl_structure (id :: fields) cc rem)
  | Tstr_module(id, modl) :: rem ->
      Llet(Strict, id, transl_module Tcoerce_none modl,
           transl_structure (id :: fields) cc rem)
  | Tstr_open path :: rem ->
      transl_structure fields cc rem

<<function [[Translmod.transl_implementation]]>>

<<function [[Translmod.transl_store_structure]]>>

<<constant [[Translmod.defined_idents]]>>

<<function [[Translmod.build_ident_map]]>>
        
<<function [[Translmod.transl_store_implementation]]>>

<<function [[Translmod.make_sequence]]>>

<<constant [[Translmod.transl_toplevel_item]]>>

<<function [[Translmod.transl_toplevel_definition]]>>
@


\subsection*{[[bytecomp/emitcode.mli]]}


<<signature [[Emitcode.to_memory]]>>=
val to_memory: instruction list -> instruction list ->
                    string * int * (reloc_info * int) list
        (* Arguments:
             initialization code (terminated by STOP)
             function code
           Results:
             block of relocatable bytecode
             size of this block
             relocation information *)
@


%-------------------------------------------------------------

<<bytecomp/emitcode.mli>>=
<<copyright header>>

(* Generation of bytecode for .cmo files *)

open Lambda
open Instruct

<<type [[Emitcode.reloc_info]]>>

<<type [[Emitcode.compilation_unit]]>>

<<signature [[Emitcode.to_file]]>>
<<signature [[Emitcode.to_memory]]>>

@


\subsection*{[[bytecomp/emitcode.ml]]}



<<function [[Emitcode.out_word]]>>=
let out_word b1 b2 b3 b4 =
  let p = !out_position in
  if p >= String.length !out_buffer then begin
    let len = String.length !out_buffer in
    let new_buffer = String.create (2 * len) in
    String.blit !out_buffer 0 new_buffer 0 len;
    out_buffer := new_buffer
  end;
  String.unsafe_set !out_buffer p (Char.unsafe_chr b1);
  String.unsafe_set !out_buffer (p+1) (Char.unsafe_chr b2);
  String.unsafe_set !out_buffer (p+2) (Char.unsafe_chr b3);
  String.unsafe_set !out_buffer (p+3) (Char.unsafe_chr b4);
  out_position := p + 4
@

<<function [[Emitcode.out]]>>=
let out opcode =
  out_word opcode 0 0 0
@

<<function [[Emitcode.out_int]]>>=
let out_int n =
  out_word n (n asr 8) (n asr 16) (n asr 24)
@

<<type [[Emitcode.label_definition]]>>=
(* Handling of local labels and backpatching *)

type label_definition =
    Label_defined of int
  | Label_undefined of (int * int) list
@


<<function [[Emitcode.extend_label_table]]>>=
let extend_label_table needed =
  let new_size = ref(Array.length !label_table) in
  while needed >= !new_size do new_size := 2 * !new_size done;
  let new_table = Array.create !new_size (Label_undefined []) in
  Array.blit !label_table 0 new_table 0 (Array.length !label_table);
  label_table := new_table
@

<<function [[Emitcode.backpatch]]>>=
let backpatch (pos, orig) =
  let displ = (!out_position - orig) asr 2 in
  !out_buffer.[pos] <- Char.unsafe_chr displ;
  !out_buffer.[pos+1] <- Char.unsafe_chr (displ asr 8);
  !out_buffer.[pos+2] <- Char.unsafe_chr (displ asr 16);
  !out_buffer.[pos+3] <- Char.unsafe_chr (displ asr 24)
@

<<function [[Emitcode.define_label]]>>=
let define_label lbl =
  if lbl >= Array.length !label_table then extend_label_table lbl;
  match (!label_table).(lbl) with
    Label_defined _ ->
      fatal_error "Emitcode.define_label"
  | Label_undefined patchlist ->
      List.iter backpatch patchlist;
      (!label_table).(lbl) <- Label_defined !out_position
@

<<function [[Emitcode.out_label_with_orig]]>>=
let out_label_with_orig orig lbl =
  if lbl >= Array.length !label_table then extend_label_table lbl;
  match (!label_table).(lbl) with
    Label_defined def ->
      out_int((def - orig) asr 2)
  | Label_undefined patchlist ->
      (!label_table).(lbl) <-
         Label_undefined((!out_position, orig) :: patchlist);
      out_int 0
@

<<function [[Emitcode.out_label]]>>=
let out_label l = out_label_with_orig !out_position l
@


<<function [[Emitcode.enter]]>>=
let enter info =
  reloc_info := (info, !out_position) :: !reloc_info
@



<<constant [[Emitcode.emit_instr]]>>=
(* Emission of one instruction *)

let emit_instr = function
    Klabel lbl -> define_label lbl
  | Kacc n ->
      if n < 8 then out(opACC0 + n) else (out opACC; out_int n)
  | Kenvacc n ->
      if n < 4 then out(opENVACC1 + n) else (out opENVACC; out_int (n+1))
  | Kpush ->
      out opPUSH
  | Kpop n ->
      out opPOP; out_int n
  | Kassign n ->
      out opASSIGN; out_int n
  | Kpush_retaddr lbl -> out opPUSH_RETADDR; out_label lbl
  | Kapply n ->
      if n < 4 then out(opAPPLY1 + n - 1) else (out opAPPLY; out_int n)
  | Kappterm(n, sz) ->
      if n < 4 then (out(opAPPTERM1 + n - 1); out_int sz)
               else (out opAPPTERM; out_int n; out_int sz)
  | Kreturn n -> out opRETURN; out_int n
  | Krestart -> out opRESTART
  | Kgrab n -> out opGRAB; out_int n
  | Kclosure(lbl, n) -> out opCLOSURE; out_int n; out_label lbl
  | Kclosurerec(lbl, n) -> out opCLOSUREREC; out_int n; out_label lbl
  | Kgetglobal q -> out opGETGLOBAL; slot_for_getglobal q
  | Ksetglobal q -> out opSETGLOBAL; slot_for_setglobal q
  | Kconst sc ->
      begin match sc with
        Const_base(Const_int i) when i >= immed_min & i <= immed_max ->
          if i >= 0 & i <= 3
          then out (opCONST0 + i)
          else (out opCONSTINT; out_int i)
      | Const_base(Const_char c) ->
          out opCONSTINT; out_int (Char.code c)
      | Const_pointer i ->
          if i >= 0 & i <= 3
          then out (opCONST0 + i)
          else (out opCONSTINT; out_int i)
      | Const_block(t, []) ->
          if t = 0 then out opATOM0 else (out opATOM; out_int t)
      | _ ->
          out opGETGLOBAL; slot_for_literal sc
      end
  | Kmakeblock(n, t) ->
      if n = 0 then
        if t < 4 then out (opATOM0 + t) else (out opATOM; out_int t)
      else if n < 4 then (out(opMAKEBLOCK1 + n - 1); out_int t)
      else (out opMAKEBLOCK; out_int n; out_int t)
  | Kgetfield n ->
      if n < 4 then out(opGETFIELD0 + n) else (out opGETFIELD; out_int n)
  | Ksetfield n ->
      if n < 4 then out(opSETFIELD0 + n) else (out opSETFIELD; out_int n)
  | Kdummy n ->
      if n = 0 then out opATOM0 else (out opDUMMY; out_int n)
  | Kupdate n -> out opUPDATE
  | Kvectlength -> out opVECTLENGTH
  | Kgetvectitem -> out opGETVECTITEM
  | Ksetvectitem -> out opSETVECTITEM
  | Kgetstringchar -> out opGETSTRINGCHAR
  | Ksetstringchar -> out opSETSTRINGCHAR
  | Kbranch lbl -> out opBRANCH; out_label lbl
  | Kbranchif lbl -> out opBRANCHIF; out_label lbl
  | Kbranchifnot lbl -> out opBRANCHIFNOT; out_label lbl
  | Kstrictbranchif lbl -> out opBRANCHIF; out_label lbl
  | Kstrictbranchifnot lbl -> out opBRANCHIFNOT; out_label lbl
  | Kswitch(tbl_const, tbl_block) ->
      out opSWITCH;
      out_int (Array.length tbl_const + (Array.length tbl_block lsl 16));
      let org = !out_position in
      Array.iter (out_label_with_orig org) tbl_const;
      Array.iter (out_label_with_orig org) tbl_block
  | Kboolnot -> out opBOOLNOT
  | Kpushtrap lbl -> out opPUSHTRAP; out_label lbl
  | Kpoptrap -> out opPOPTRAP
  | Kraise -> out opRAISE
  | Kcheck_signals -> out opCHECK_SIGNALS
  | Kccall(name, n) ->
      if n <= 5
      then (out (opC_CALL1 + n - 1); slot_for_c_prim name)
      else (out opC_CALLN; out_int n; slot_for_c_prim name)
  | Knegint -> out opNEGINT  | Kaddint -> out opADDINT
  | Ksubint -> out opSUBINT  | Kmulint -> out opMULINT
  | Kdivint -> out opDIVINT  | Kmodint -> out opMODINT
  | Kandint -> out opANDINT  | Korint -> out opORINT
  | Kxorint -> out opXORINT  | Klslint -> out opLSLINT
  | Klsrint -> out opLSRINT  | Kasrint -> out opASRINT
  | Kintcomp Ceq -> out opEQ         | Kintcomp Cneq -> out opNEQ
  | Kintcomp Clt -> out opLTINT      | Kintcomp Cle -> out opLEINT
  | Kintcomp Cgt -> out opGTINT      | Kintcomp Cge -> out opGEINT
  | Koffsetint n -> out opOFFSETINT; out_int n
  | Koffsetref n -> out opOFFSETREF; out_int n
  | Kevent ev -> record_event ev
  | Kstop -> out opSTOP
@

<<constant [[Emitcode.emit]]>>=
(* Emission of a list of instructions. Include some peephole optimization. *)

let rec emit = function
    [] -> ()
  (* Peephole optimizations *)
  | Kpush :: Kacc n :: c ->
      if n < 8 then out(opPUSHACC0 + n) else (out opPUSHACC; out_int n);
      emit c
  | Kpush :: Kenvacc n :: c ->
      if n < 4 then out(opPUSHENVACC1 + n)
               else (out opPUSHENVACC; out_int (n+1));
      emit c
  | Kpush :: Kgetglobal id :: Kgetfield n :: c ->
      out opPUSHGETGLOBALFIELD; slot_for_getglobal id; out_int n; emit c
  | Kpush :: Kgetglobal id :: c ->
      out opPUSHGETGLOBAL; slot_for_getglobal id; emit c
  | Kpush :: Kconst sc :: c ->
      begin match sc with
        Const_base(Const_int i) when i >= immed_min & i <= immed_max ->
          if i >= 0 & i <= 3
          then out (opPUSHCONST0 + i)
          else (out opPUSHCONSTINT; out_int i)
      | Const_base(Const_char c) ->
          out opPUSHCONSTINT; out_int(Char.code c)
      | Const_pointer i ->
          if i >= 0 & i <= 3
          then out (opPUSHCONST0 + i)
          else (out opPUSHCONSTINT; out_int i)
      | Const_block(t, []) ->
          if t = 0 then out opPUSHATOM0 else (out opPUSHATOM; out_int t)
      | _ ->
          out opPUSHGETGLOBAL; slot_for_literal sc
      end;
      emit c
  | Kpush :: (Kevent {ev_kind = Event_before} as ev) ::
    (Kgetglobal _ as instr1) :: (Kgetfield _ as instr2) :: c ->
      emit (Kpush :: instr1 :: instr2 :: ev :: c)
  | Kpush :: (Kevent {ev_kind = Event_before} as ev) ::
    (Kacc _ | Kenvacc _ | Kgetglobal _ | Kconst _ as instr) :: c ->
      emit (Kpush :: instr :: ev :: c)
  | Kgetglobal id :: Kgetfield n :: c ->
      out opGETGLOBALFIELD; slot_for_getglobal id; out_int n; emit c
  (* Default case *)
  | instr :: c ->
      emit_instr instr; emit c
@


<<function [[Emitcode.to_memory]]>>=
(* Emission to a memory block *)

let to_memory init_code fun_code =
  init();
  emit init_code;
  emit fun_code;
  let code = Meta.static_alloc !out_position in
  String.unsafe_blit !out_buffer 0 code 0 !out_position;
  let reloc = List.rev !reloc_info
  and code_size = !out_position in
  init();
  (code, code_size, reloc)
@


%-------------------------------------------------------------

<<bytecomp/emitcode.ml>>=
<<copyright header>>

(* Generation of bytecode + relocation information *)

open Config
open Misc
open Asttypes
open Lambda
open Instruct
open Opcodes


<<type [[Emitcode.reloc_info]]>>

<<type [[Emitcode.compilation_unit]]>>

(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     compilation unit descriptor *)

(* Buffering of bytecode *)

let out_buffer = ref(String.create 1024)
and out_position = ref 0

<<function [[Emitcode.out_word]]>>

<<function [[Emitcode.out]]>>

<<function [[Emitcode.out_int]]>>

<<type [[Emitcode.label_definition]]>>

<<constant [[Emitcode.label_table]]>>

<<function [[Emitcode.extend_label_table]]>>

<<function [[Emitcode.backpatch]]>>

<<function [[Emitcode.define_label]]>>

<<function [[Emitcode.out_label_with_orig]]>>

<<function [[Emitcode.out_label]]>>

<<constant [[Emitcode.reloc_info]]>>

<<function [[Emitcode.enter]]>>

let slot_for_literal sc =
  enter (Reloc_literal sc);
  out_int 0
and slot_for_getglobal id =
  enter (Reloc_getglobal id);
  out_int 0
and slot_for_setglobal id =
  enter (Reloc_setglobal id);
  out_int 0
and slot_for_c_prim name =
  enter (Reloc_primitive name);
  out_int 0

<<constant [[Emitcode.events]]>>

<<function [[Emitcode.record_event]]>>

<<function [[Emitcode.init]]>>

<<constant [[Emitcode.emit_instr]]>>

<<constant [[Emitcode.emit]]>>

<<function [[Emitcode.to_file]]>>

<<function [[Emitcode.to_memory]]>>
@


\subsection*{[[bytecomp/bytelibrarian.mli]]}




%-------------------------------------------------------------

<<bytecomp/bytelibrarian.mli>>=
<<copyright header>>

(* Build libraries of .cmo files *)

<<signature [[Bytelibrarian.create_archive]]>>

<<type [[Bytelibrarian.error]]>>

<<exception [[Bytelibrarian.Error]]>>

<<signature [[Bytelibrarian.report_error]]>>
@


\subsection*{[[bytecomp/bytelibrarian.ml]]}




%-------------------------------------------------------------

<<bytecomp/bytelibrarian.ml>>=
<<copyright header>>

(* Build libraries of .cmo files *)

open Misc
open Config
open Emitcode

<<type [[Bytelibrarian.error]]>>

<<exception [[Bytelibrarian.Error]]>>

<<function [[Bytelibrarian.copy_compunit]]>>

<<function [[Bytelibrarian.copy_object_file]]>>

<<function [[Bytelibrarian.create_archive]]>>

open Format

<<constant [[Bytelibrarian.report_error]]>>

@


\subsection*{[[bytecomp/symtable.mli]]}

<<signature [[Symtable.init]]>>=
(* Functions for batch linking *)

val init: unit -> unit
@

<<signature [[Symtable.patch_object]]>>=
val patch_object: string -> (reloc_info * int) list -> unit
@

<<signature [[Symtable.require_primitive]]>>=
val require_primitive: string -> unit
@


<<signature [[Symtable.output_global_map]]>>=
val output_global_map: out_channel -> unit
@


<<signature [[Symtable.output_primitive_table]]>>=
val output_primitive_table: out_channel -> unit
@

<<signature [[Symtable.init_toplevel]]>>=
(* Functions for the toplevel *)

val init_toplevel: unit -> unit
@

<<signature [[Symtable.update_global_table]]>>=
val update_global_table: unit -> unit
@

<<signature [[Symtable.get_global_value]]>>=
val get_global_value: Ident.t -> Obj.t
@

<<signature [[Symtable.get_global_position]]>>=
val get_global_position: Ident.t -> int
@

<<signature [[Symtable.current_state]]>>=
val current_state: unit -> global_map
@

<<signature [[Symtable.restore_state]]>>=
val restore_state: global_map -> unit
@

<<signature [[Symtable.hide_additions]]>>=
val hide_additions: global_map -> unit
@

<<signature [[Symtable.filter_global_map]]>>=
val filter_global_map: (Ident.t -> bool) -> global_map -> global_map
@

<<type [[Symtable.error]]>>=
(* Error report *)

type error =
    Undefined_global of string
  | Unavailable_primitive of string
@

<<exception [[Symtable.Error]]>>=
exception Error of error
@

<<signature [[Symtable.report_error]]>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<bytecomp/symtable.mli>>=
<<copyright header>>

(* Assign locations and numbers to globals and primitives *)

open Emitcode

<<signature [[Symtable.init]]>>
<<signature [[Symtable.patch_object]]>>
<<signature [[Symtable.require_primitive]]>>
<<signature [[Symtable.initial_global_table]]>>
<<signature [[Symtable.output_global_map]]>>
<<signature [[Symtable.output_primitive_names]]>>
<<signature [[Symtable.output_primitive_table]]>>

<<signature [[Symtable.init_toplevel]]>>
<<signature [[Symtable.update_global_table]]>>
<<signature [[Symtable.get_global_value]]>>
<<signature [[Symtable.get_global_position]]>>

type global_map

<<signature [[Symtable.current_state]]>>
<<signature [[Symtable.restore_state]]>>
<<signature [[Symtable.hide_additions]]>>
<<signature [[Symtable.filter_global_map]]>>

<<type [[Symtable.error]]>>

<<exception [[Symtable.Error]]>>

<<signature [[Symtable.report_error]]>>
@


\subsection*{[[bytecomp/symtable.ml]]}

<<type [[Symtable.numtable]]>>=
(* Tables for numbering objects *)

type 'a numtable =
  { num_cnt: int;               (* The next number *)
    num_tbl: ('a, int) Tbl.t } (* The table of already numbered objects *)
@

<<constant [[Symtable.empty_numtable]]>>=
let empty_numtable = { num_cnt = 0; num_tbl = Tbl.empty }
@

<<function [[Symtable.find_numtable]]>>=
let find_numtable nt key =
  Tbl.find key nt.num_tbl
@

<<function [[Symtable.enter_numtable]]>>=
let enter_numtable nt key =
  let n = !nt.num_cnt in
  nt := { num_cnt = n + 1; num_tbl = Tbl.add key n !nt.num_tbl };
  n
@

<<function [[Symtable.incr_numtable]]>>=
let incr_numtable nt =
  let n = !nt.num_cnt in
  nt := { num_cnt = n + 1; num_tbl = !nt.num_tbl };
  n
@

<<function [[Symtable.slot_for_getglobal]]>>=
let slot_for_getglobal id =
  try
    find_numtable !global_table id
  with Not_found ->
    raise(Error(Undefined_global(Ident.name id)))
@

<<function [[Symtable.slot_for_setglobal]]>>=
let slot_for_setglobal id =
  enter_numtable global_table id
@

<<function [[Symtable.slot_for_literal]]>>=
let slot_for_literal cst =
  let n = incr_numtable global_table in
  literal_table := (n, cst) :: !literal_table;
  n
@

<<constant [[Symtable.c_prim_table]]>>=
(* The C primitives *)

let c_prim_table = ref(empty_numtable : string numtable)
@

<<function [[Symtable.num_of_prim]]>>=
let num_of_prim name =
  try
    find_numtable !c_prim_table name
  with Not_found ->
    if !Clflags.custom_runtime
    then enter_numtable c_prim_table name
    else raise(Error(Unavailable_primitive name))
@

<<function [[Symtable.require_primitive]]>>=
let require_primitive name =
  if name.[0] <> '%' then begin num_of_prim name; () end
@

<<function [[Symtable.all_primitives]]>>=
let all_primitives () =
  let prim = Array.create !c_prim_table.num_cnt "" in
  Tbl.iter (fun name number -> prim.(number) <- name) !c_prim_table.num_tbl;
  prim
@


<<function [[Symtable.output_primitive_table]]>>=
let output_primitive_table outchan =
  let prim = all_primitives() in
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "extern long %s();\n" prim.(i)
  done;
  fprintf outchan "typedef long (*primitive)();\n";
  fprintf outchan "primitive cprim[] = {\n";
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "  %s,\n" prim.(i)
  done;
  fprintf outchan "  (primitive) 0 };\n";
  fprintf outchan "char * names_of_cprim[] = {\n";
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "  \"%s\",\n" prim.(i)
  done;
  fprintf outchan "  (char *) 0 };\n"
@

<<function [[Symtable.init]]>>=
(* Initialization for batch linking *)

let init () =
  (* Enter the predefined exceptions *)
  Array.iter 
    (fun name -> 
      let id =
        try List.assoc name Predef.builtin_values
        with Not_found -> fatal_error "Symtable.init" in
      let c = slot_for_setglobal id in
      let cst = Const_block(0, [Const_base(Const_string name)]) in
      literal_table := (c, cst) :: !literal_table)
    Runtimedef.builtin_exceptions;
  (* Enter the known C primitives *)
  Array.iter (fun x -> enter_numtable c_prim_table x; ())
             Runtimedef.builtin_primitives
@

<<function [[Symtable.patch_int]]>>=
(* Must use the unsafe String.set here because the block may be
   a "fake" string as returned by Meta.static_alloc. *)

let patch_int buff pos n =
  String.unsafe_set buff pos (Char.unsafe_chr n);
  String.unsafe_set buff (pos + 1) (Char.unsafe_chr (n asr 8));
  String.unsafe_set buff (pos + 2) (Char.unsafe_chr (n asr 16));
  String.unsafe_set buff (pos + 3) (Char.unsafe_chr (n asr 24))
@

<<function [[Symtable.patch_object]]>>=
let patch_object buff patchlist = 
  List.iter
    (function
        (Reloc_literal sc, pos) ->
          patch_int buff pos (slot_for_literal sc)
      | (Reloc_getglobal id, pos) ->
          patch_int buff pos (slot_for_getglobal id)
      | (Reloc_setglobal id, pos) ->
          patch_int buff pos (slot_for_setglobal id)
      | (Reloc_primitive name, pos) ->
          patch_int buff pos (num_of_prim name))
    patchlist
@

<<constant [[Symtable.transl_const]]>>=
(* Translate structured constants *)

let rec transl_const = function
    Const_base(Const_int i) -> Obj.repr i
  | Const_base(Const_char c) -> Obj.repr c
  | Const_base(Const_string s) -> Obj.repr s
  | Const_base(Const_float f) -> Obj.repr(float_of_string f)
  | Const_pointer i -> Obj.repr i
  | Const_block(tag, fields) ->
      let block = Obj.new_block tag (List.length fields) in
      let pos = ref 0 in
      List.iter
        (fun c -> Obj.set_field block !pos (transl_const c); incr pos)
        fields;
      block
  | Const_float_array fields ->
      transl_const
        (Const_block(0, List.map (fun f -> Const_base(Const_float f)) fields))
@



<<function [[Symtable.update_global_table]]>>=
(* Update the in-core table of globals *)

let update_global_table () =
  let ng = !global_table.num_cnt in
  if ng > Array.length(Meta.global_data()) then Meta.realloc_global_data ng;
  let glob = Meta.global_data() in
  List.iter
    (fun (slot, cst) -> glob.(slot) <- transl_const cst)
    !literal_table;
  literal_table := []
@

<<function [[Symtable.init_toplevel]]>>=
(* Initialize the linker for toplevel use *)

let init_toplevel () =
  (* Read back the known global symbols from the executable file *)
  let ic = open_in Sys.argv.(0) in
  let pos_trailer =
    in_channel_length ic - 20 - String.length Config.exec_magic_number in
  seek_in ic pos_trailer;
  let code_size = input_binary_int ic in
  let prim_size = input_binary_int ic in
  let data_size = input_binary_int ic in
  let symbol_size = input_binary_int ic in
  let debug_size = input_binary_int ic in
  seek_in ic (pos_trailer - debug_size - symbol_size);
  global_table := (input_value ic : Ident.t numtable);
  close_in ic;
  (* Enter the known C primitives *)
  Array.iter (fun x -> enter_numtable c_prim_table x; ())
             (Meta.available_primitives())
@

<<function [[Symtable.get_global_position]]>>=
(* @Scheck: used by the debugger *)
let get_global_position id = slot_for_getglobal id
@

<<function [[Symtable.get_global_value]]>>=
let get_global_value id =
@

<<type [[Symtable.global_map]]>>=
(* Save and restore the current state *)

type global_map = Ident.t numtable
@

<<function [[Symtable.current_state]]>>=
let current_state () = !global_table
@

<<function [[Symtable.restore_state]]>>=
let restore_state st = global_table := st
@

<<function [[Symtable.hide_additions]]>>=
(* @Scheck: used by dynlink *)
let hide_additions st =
  if st.num_cnt > !global_table.num_cnt then
    fatal_error "Symtable.hide_additions";
  global_table :=
    { num_cnt = !global_table.num_cnt;
      num_tbl = st.num_tbl }
@

<<function [[Symtable.filter_global_map]]>>=
(* "Filter" the global map according to some predicate.
   Used to expunge the global map for the toplevel. *)

let filter_global_map p gmap =
  let newtbl = ref Tbl.empty in
  Tbl.iter
    (fun id num -> if p id then newtbl := Tbl.add id num !newtbl)
    gmap.num_tbl;
  {num_cnt = gmap.num_cnt; num_tbl = !newtbl}
@

<<constant [[Symtable.report_error]]>>=
let report_error = function
    Undefined_global s ->
      print_string "Reference to undefined global `"; print_string s;
      print_string "'"
  | Unavailable_primitive s ->
      print_string "The external function `"; print_string s;
      print_string "' is not available"
@


%-------------------------------------------------------------

<<bytecomp/symtable.ml>>=
<<copyright header>>

(* To assign numbers to globals and primitives *)

open Misc
open Asttypes
open Lambda
open Emitcode


<<type [[Symtable.error]]>>

<<exception [[Symtable.Error]]>>

<<type [[Symtable.numtable]]>>

<<constant [[Symtable.empty_numtable]]>>

<<function [[Symtable.find_numtable]]>>

<<function [[Symtable.enter_numtable]]>>

<<function [[Symtable.incr_numtable]]>>

(* Global variables *)

let global_table = ref(empty_numtable : Ident.t numtable)
and literal_table = ref([] : (int * structured_constant) list)

<<function [[Symtable.slot_for_getglobal]]>>

<<function [[Symtable.slot_for_setglobal]]>>

<<function [[Symtable.slot_for_literal]]>>

<<constant [[Symtable.c_prim_table]]>>

<<function [[Symtable.num_of_prim]]>>

<<function [[Symtable.require_primitive]]>>

<<function [[Symtable.all_primitives]]>>

<<function [[Symtable.output_primitive_names]]>>

open Printf

<<function [[Symtable.output_primitive_table]]>>

<<function [[Symtable.init]]>>

(* Relocate a block of object bytecode *)

<<function [[Symtable.patch_int]]>>

<<function [[Symtable.patch_object]]>>

<<constant [[Symtable.transl_const]]>>

<<function [[Symtable.initial_global_table]]>>

<<function [[Symtable.output_global_map]]>>

(* Functions for toplevel use *)

<<function [[Symtable.update_global_table]]>>

<<function [[Symtable.init_toplevel]]>>

(* Find the value of a global identifier *)

<<function [[Symtable.get_global_position]]>>

<<function [[Symtable.get_global_value]]>>
  (Meta.global_data()).(slot_for_getglobal id)

<<type [[Symtable.global_map]]>>

<<function [[Symtable.current_state]]>>

<<function [[Symtable.restore_state]]>>

<<function [[Symtable.hide_additions]]>>

<<function [[Symtable.filter_global_map]]>>

(* Error report *)

open Format

<<constant [[Symtable.report_error]]>>
@


\subsection*{[[bytecomp/bytelink.mli]]}





%-------------------------------------------------------------

<<bytecomp/bytelink.mli>>=
<<copyright header>>

<<signature [[Bytelink.link]]>>

<<signature [[Bytelink.check_consistency]]>>

<<type [[Bytelink.error]]>>

<<exception [[Bytelink.Error]]>>

<<signature [[Bytelink.report_error]]>>
@


\subsection*{[[bytecomp/bytelink.ml]]}


<<constant [[Bytelink.missing_globals]]>>=
let missing_globals = ref IdentSet.empty
@

<<function [[Bytelink.is_required]]>>=
let is_required (rel, pos) =
  match rel with
    Reloc_setglobal id ->
      IdentSet.mem id !missing_globals
  | _ -> false
@

<<function [[Bytelink.add_required]]>>=
let add_required (rel, pos) =
  match rel with
    Reloc_getglobal id ->
      missing_globals := IdentSet.add id !missing_globals
  | _ -> ()
@

<<function [[Bytelink.remove_required]]>>=
let remove_required (rel, pos) =
  match rel with
    Reloc_setglobal id ->
      missing_globals := IdentSet.remove id !missing_globals
  | _ -> ()
@









<<constant [[Bytelink.output_code_string_counter]]>>=
(* Output a string as a C array of unsigned ints *)

let output_code_string_counter = ref 0
@

<<function [[Bytelink.output_code_string]]>>=
let output_code_string outchan code =
  let pos = ref 0 in
  let len = String.length code in
  while !pos < len do
    let c1 = Char.code(code.[!pos]) in
    let c2 = Char.code(code.[!pos + 1]) in
    let c3 = Char.code(code.[!pos + 2]) in
    let c4 = Char.code(code.[!pos + 3]) in
    pos := !pos + 4;
    Printf.fprintf outchan "0x%02x%02x%02x%02x, " c4 c3 c2 c1;
    incr output_code_string_counter;
    if !output_code_string_counter >= 6 then begin
      output_char outchan '\n';
      output_code_string_counter := 0
    end
  done
@

<<function [[Bytelink.output_data_string]]>>=
(* Output a string as a C string *)

let output_data_string outchan data =
  let counter = ref 0 in
  output_string outchan "\"";
  for i = 0 to String.length data - 1 do
    Printf.fprintf outchan "\\%03o" (Char.code(data.[i]));
    incr counter;
    if !counter >= 16 then begin
      output_string outchan "\\\n";
      counter := 0
    end
  done;
  output_string outchan "\";\n\n"
@


<<function [[Bytelink.extract]]>>=
(* Build a custom runtime *)

let rec extract suffix l =
  match l with
  | [] -> []
  | h::t when Filename.check_suffix h suffix -> h :: (extract suffix t)
  | h::t -> extract suffix t
@


%-------------------------------------------------------------

<<bytecomp/bytelink.ml>>=
<<copyright header>>

(* Link a set of .cmo files and produce a bytecode executable. *)

open Sys
open Misc
open Config
open Instruct
open Emitcode

<<type [[Bytelink.error]]>>

<<exception [[Bytelink.Error]]>>

<<type [[Bytelink.link_action]]>>

(* First pass: determine which units are needed *)

module IdentSet = Set

<<constant [[Bytelink.missing_globals]]>>

<<function [[Bytelink.is_required]]>>

<<function [[Bytelink.add_required]]>>

<<function [[Bytelink.remove_required]]>>

<<function [[Bytelink.scan_file]]>>

(* Second pass: link in the required units *)

<<constant [[Bytelink.debug_info]]>>

<<constant [[Bytelink.crc_interfaces]]>>

<<function [[Bytelink.check_consistency]]>>

<<function [[Bytelink.link_compunit]]>>

<<function [[Bytelink.output_debug_info]]>>


<<function [[Bytelink.link_object]]>>

<<function [[Bytelink.link_archive]]>>

<<function [[Bytelink.link_file]]>>

<<function [[Bytelink.link_bytecode]]>>

<<constant [[Bytelink.output_code_string_counter]]>>

<<function [[Bytelink.output_code_string]]>>

<<function [[Bytelink.output_data_string]]>>

<<function [[Bytelink.link_bytecode_as_c]]>>

let link_bytecode_as_c_bis objfiles outfile =
  let tolink = List.fold_right scan_file objfiles [] in
  let outchan = open_out outfile in
  try
    (* The bytecode *)
    output_string outchan "static int caml_code[] = {\n";
    Symtable.init();
    Hashtbl.clear crc_interfaces;
    let output_fun = output_code_string outchan
    and currpos_fun () = fatal_error "Bytelink.link_bytecode_as_c_bis" in
    List.iter (link_file output_fun currpos_fun) tolink;
    (* The final STOP instruction *)
    Printf.fprintf outchan "\n0x%x};\n\n" Opcodes.opSTOP;
    (* The table of global data *)
    output_string outchan "static char * caml_data =\n";
    output_data_string outchan
      (Marshal.to_string (Symtable.initial_global_table()) []);
    (* The table of primitives *)
    Symtable.output_primitive_table outchan;
    (* The entry point *)
    output_string outchan "\n
void caml_startup_code(int* code, int code_size, char *data, char **argv);

void caml_startup(char **argv)
{
  caml_startup_code(caml_code, sizeof(caml_code), caml_data, argv);
}\n";
    close_out outchan
  with x ->
    close_out outchan;
    raise x



<<function [[Bytelink.extract]]>>
;;

<<function [[Bytelink.build_custom_runtime]]>>

<<function [[Bytelink.append_bytecode_and_cleanup]]>>

<<function [[Bytelink.fix_exec_name]]>>

<<function [[Bytelink.link]]>>

(* Error report *)

open Format

<<constant [[Bytelink.report_error]]>>
@


\section{[[driver/]]}

\subsection*{[[driver/compile.mli]]}


%-------------------------------------------------------------

<<driver/compile.mli>>=
<<copyright header>>

(* Compile a .ml or .mli file *)

<<signature [[Compile.interface]]>>
<<signature [[Compile.implementation]]>>
<<signature [[Compile.c_file]]>>

<<signature [[Compile.initial_env]]>>
<<signature [[Compile.init_path]]>>
@


\subsection*{[[driver/compile.ml]]}

<<function [[Compile.init_path]]>>=
(* Initialize the search path.
   The current directory is always searched first,
   then the directories specified with the -I option (in command-line order),
   then the standard library directory. *)

let init_path () =
  let dirs =
    if !Clflags.thread_safe then
     Filename.concat Config.standard_library "threads" :: !Clflags.include_dirs
    else
     !Clflags.include_dirs in
  load_path := "" :: List.rev (Config.standard_library :: dirs);
  Env.reset_cache()
@
% so will look for a different stdlib.cma! from the threads/ library
% and will also look for a different pervasives.cmi

<<signature [[Env.reset_cache]]>>=
(* Reset the cache of in-core module interfaces.
   To be called in particular when load_path changes. *)
val reset_cache: unit -> unit
@
% init_path | -> <> ??
<<function [[Env.reset_cache]]>>=
let reset_cache() =
  Hashtbl.clear persistent_structures;
  imported_units := []
@


<<function [[Compile.initial_env]]>>=
(* Return the initial environment in which compilation proceeds. *)

let initial_env () =
  try
    if !Clflags.nopervasives
    then Env.initial
    else Env.open_pers_signature "Pervasives" Env.initial
  with Not_found ->
    fatal_error "cannot open Pervasives.cmi"
@

<<signature [[Env.open_pers_signature]]>>=
val open_pers_signature: string -> t -> t
@

<<function [[Env.open_pers_signature]]>>=
(* Open a signature from a file *)

let open_pers_signature name env =
  let ps = find_pers_struct name in
  open_signature (Pident(Ident.create_persistent name)) ps.ps_sig env
@


<<exception [[Compile.Outdated_version]]>>=
(* Parse a file or get a dumped syntax tree in it *)

exception Outdated_version
@

<<function [[Compile.print_if]]>>=
(* Compile a .ml file *)

let print_if flag printer arg =
  if !flag then begin printer arg; print_newline() end;
  arg
@




%-------------------------------------------------------------

<<driver/compile.ml>>=
<<copyright header>>

(* The batch compiler *)

open Misc
open Config
open Format
open Typedtree

<<function [[Compile.init_path]]>>

<<function [[Compile.initial_env]]>>

<<function [[Compile.preprocess]]>>

<<function [[Compile.remove_preprocessed]]>>

<<exception [[Compile.Outdated_version]]>>

<<function [[Compile.parse_file]]>>

<<function [[Compile.interface]]>>

<<function [[Compile.print_if]]>>

<<function [[Compile.implementation]]>>

<<function [[Compile.c_file]]>>
@


\subsection*{[[driver/errors.mli]]}



%-------------------------------------------------------------

<<driver/errors.mli>>=
<<copyright header>>

<<signature [[Errors.report_error]]>>
@


\subsection*{[[driver/errors.ml]]}

%-------------------------------------------------------------

<<driver/errors.ml>>=
<<copyright header>>

(* Error report *)

open Format
open Location

<<function [[Errors.report_error]]>>
@


\subsection*{[[driver/main.ml]]}


%-------------------------------------------------------------

<<driver/main.ml>>=
<<copyright header>>

open Config
open Clflags

<<function [[Main.process_interface_file]]>>

<<function [[Main.process_implementation_file]]>>

<<function [[Main.process_file]]>>

<<function [[Main.print_version_number]]>>

<<constant [[Main.usage]]>>

<<function [[Main.main]]>>

<<toplevel [[Main._1]]>>
@





%\part{C CODE START}

\section{[[byterun/]]}

% seems to sort #include alphabetically

\subsection*{[[byterun/config.h]]}

<<function [[bcopy]]>>=
//TODO PB on LINUX #define bcopy(src,dst,len) memmove((dst), (src), (len))
@





<<constant [[Heap_chunk_min]]>>=
/* Minimum size increment when growing the heap (words).
   Must be a multiple of [Page_size / sizeof (value)]. */
#define Heap_chunk_min (2 * Page_size / sizeof (value))
@

<<constant [[Heap_chunk_max]]>>=
/* Maximum size of a contiguous piece of the heap (words).
   Must be greater than or equal to [Heap_chunk_min].
   Must be greater than or equal to [Bhsize_wosize (Max_wosize)]. */
#define Heap_chunk_max (Bhsize_wosize (Max_wosize))
@

<<constant [[Heap_chunk_def]]>>=
/* Default size increment when growing the heap. (words)
   Must be a multiple of [Page_size / sizeof (value)]. */
#define Heap_chunk_def (62 * 1024)
@

<<constant [[Init_heap_def]]>>=
/* Default initial size of the major heap (words);
   same constraints as for Heap_chunk_def. */
#define Init_heap_def (62 * 1024)
@

<<constant [[Percent_free_def]]>>=
/* Default speed setting for the major GC.  The heap will grow until
   the dead objects and the free list represent this percentage of the
   heap size.  The rest of the heap is live objects. */
#define Percent_free_def 42
@

<<constant [[Max_percent_free_def]]>>=
/* Default setting for the compacter: off */
#define Max_percent_free_def 1000000
@


%-------------------------------------------------------------

<<byterun/config.h>>=
<<copyright header C xavier and damien>>

#ifndef _config_
#define _config_


#include "../config/m.h"
#include "../config/s.h"

/* Library dependencies */

<<function [[bcopy]]>>

/* We use threaded code interpretation if the compiler provides labels
   as first-class values (GCC 2.x).
   Macintosh 68k also uses threaded code, with the assembly-language
   bytecode interpreter (THREADED_CODE defined in config/sm-Mac.h).
*/

#if defined(__GNUC__) && __GNUC__ >= 2 && !defined(DEBUG)
<<constant [[THREADED_CODE]]>>
#endif

/* Signed char type */

typedef signed char schar;

<<constant [[Page_size]]>>

/* Memory model parameters */

<<constant [[Page_log]]>>

<<constant [[Stack_size]]>>

<<constant [[Stack_threshold]]>>

<<constant [[Max_stack_def]]>>


<<constant [[Max_young_wosize]]>>


<<constant [[Minor_heap_min]]>>

<<constant [[Minor_heap_max]]>>

<<constant [[Minor_heap_def]]>>


<<constant [[Heap_chunk_min]]>>

<<constant [[Heap_chunk_max]]>>

<<constant [[Heap_chunk_def]]>>

<<constant [[Init_heap_def]]>>


<<constant [[Percent_free_def]]>>

<<constant [[Max_percent_free_def]]>>


#endif /* _config_ */
@


\subsection*{[[byterun/instruct.h]]}


%-------------------------------------------------------------

<<byterun/instruct.h>>=
<<copyright header C xavier>>

<<enum [[instructions]]>>
@


\subsection*{[[byterun/mlvalues.h]]}

<<function [[Hd_op]]>>=
#define Hd_op(op) (Hd_val (op))                        /* Also an l-value. */
@

<<function [[Hd_bp]]>>=
#define Hd_bp(bp) (Hd_val (bp))                        /* Also an l-value. */
@

<<function [[Hd_hp]]>>=
#define Hd_hp(hp) (* ((header_t *) (hp)))              /* Also an l-value. */
@

<<function [[Hp_val]]>>=
#define Hp_val(val) ((char *) (((header_t *) (val)) - 1))
@

<<function [[Hp_op]]>>=
#define Hp_op(op) (Hp_val (op))
@

<<function [[Hp_bp]]>>=
#define Hp_bp(bp) (Hp_val (bp))
@

<<function [[Val_op]]>>=
#define Val_op(op) ((value) (op))
@


<<function [[Op_hp]]>>=
#define Op_hp(hp) ((value *) Val_hp (hp))
@

<<function [[Bp_hp]]>>=
#define Bp_hp(hp) ((char *) Val_hp (hp))
@

<<constant [[Num_tags]]>>=
#define Num_tags (1 << 8)
@




<<function [[Wosize_op]]>>=
#define Wosize_op(op) (Wosize_val (op))
@

<<function [[Wosize_bp]]>>=
#define Wosize_bp(bp) (Wosize_val (bp))
@

<<function [[Wosize_hp]]>>=
#define Wosize_hp(hp) (Wosize_hd (Hd_hp (hp)))
@

<<function [[Whsize_wosize]]>>=
#define Whsize_wosize(sz) ((sz) + 1)
@

<<function [[Wosize_whsize]]>>=
#define Wosize_whsize(sz) ((sz) - 1)
@

<<function [[Wosize_bhsize]]>>=
#define Wosize_bhsize(sz) ((sz) / sizeof (value) - 1)
@

<<function [[Bsize_wsize]]>>=
#define Bsize_wsize(sz) ((sz) * sizeof (value))
@

<<function [[Wsize_bsize]]>>=
#define Wsize_bsize(sz) ((sz) / sizeof (value))
@

<<function [[Bhsize_wosize]]>>=
#define Bhsize_wosize(sz) (Bsize_wsize (Whsize_wosize (sz)))
@

<<function [[Bhsize_bosize]]>>=
#define Bhsize_bosize(sz) ((sz) + sizeof (header_t))
@

<<function [[Bosize_val]]>>=
#define Bosize_val(val) (Bsize_wsize (Wosize_val (val)))
@

<<function [[Bosize_op]]>>=
#define Bosize_op(op) (Bosize_val (Val_op (op)))
@

<<function [[Bosize_bp]]>>=
#define Bosize_bp(bp) (Bosize_val (Val_bp (bp)))
@

<<function [[Bosize_hd]]>>=
#define Bosize_hd(hd) (Bsize_wsize (Wosize_hd (hd)))
@

<<function [[Whsize_hp]]>>=
#define Whsize_hp(hp) (Whsize_wosize (Wosize_hp (hp)))
@

<<function [[Whsize_val]]>>=
#define Whsize_val(val) (Whsize_hp (Hp_val (val)))
@

<<function [[Whsize_bp]]>>=
#define Whsize_bp(bp) (Whsize_val (Val_bp (bp)))
@

<<function [[Whsize_hd]]>>=
#define Whsize_hd(hd) (Whsize_wosize (Wosize_hd (hd)))
@

<<function [[Bhsize_hp]]>>=
#define Bhsize_hp(hp) (Bsize_wsize (Whsize_hp (hp)))
@

<<function [[Bhsize_hd]]>>=
#define Bhsize_hd(hd) (Bsize_wsize (Whsize_hd (hd)))
@


<<function [[Tag_hp]] (ifdef [[ARCH_BIG_ENDIAN]])>>=
#define Tag_hp(hp) (((unsigned char *) (hp)) [sizeof(value)-1])
@

<<function [[Tag_val]] little endian>>=
#define Tag_val(val) (((unsigned char *) (val)) [-sizeof(value)])
@

<<function [[Tag_hp]] little endian>>=
#define Tag_hp(hp) (((unsigned char *) (hp)) [0])
@


<<function [[Op_val]]>>=
/* Pointer to the first field. */
#define Op_val(x) ((value *) (x))
@





<<function [[Infix_offset_hd]]>>=
#define Infix_offset_hd(hd) (Bosize_hd(hd))
@

<<function [[Infix_offset_val]]>>=
#define Infix_offset_val(v) Infix_offset_hd(Hd_val(v))
@



<<function [[Bp_val]]>>=
/* Pointer to the first byte */
#define Bp_val(v) ((char *) (v))
@

<<function [[Val_bp]]>>=
#define Val_bp(p) ((value) (p))
@

<<function [[Byte]]>>=
/* Bytes are numbered from 0. */
#define Byte(x, i) (((char *) (x)) [i])            /* Also an l-value. */
@

<<function [[Byte_u]]>>=
#define Byte_u(x, i) (((unsigned char *) (x)) [i]) /* Also an l-value. */
@


<<function [[String_val]]>>=
#define String_val(x) ((char *) Bp_val(x))
@


<<constant [[Double_wosize]]>>=
#define Double_wosize ((sizeof(double) / sizeof(value)))
@

<<macro [[Double_val]]>>=
#define Double_val(v) (* (double *)(v))
@

<<macro [[Store_double_val]]>>=
#define Store_double_val(v,d) (* (double *)(v) = (d))
@


<<function [[Double_field]]>>=
#define Double_field(v,i) Double_val((value)((double *)(v) + (i)))
@

<<function [[Store_double_field]]>>=
#define Store_double_field(v,i,d) \
  Store_double_val((value)((double *)(v) + (i)),d)
@


<<function [[Final_fun]]>>=
#define Final_fun(val) (((final_fun *) (val)) [0]) /* Also an l-value. */
@




<<function [[Val_not]]>>=
#define Val_not(x) (4 - (x))
@


%-------------------------------------------------------------

<<byterun/mlvalues.h>>=
<<copyright header C xavier and damien>>

#ifndef _mlvalues_
#define _mlvalues_

#include "config.h"
#include "misc.h"

<<mlvalues.h top comment>>

<<typedef [[value]]>>
<<typedef [[header_t]]>>
typedef unsigned long mlsize_t;
<<typedef [[tag_t]]>>
<<typedef [[color_t]]>>

typedef unsigned long mark_t;

typedef int int32;            /* Not portable, but checked by autoconf. */
typedef unsigned int uint32;  /* Seems like a reasonable assumption anyway. */

<<function [[Is_long]]>>
<<function [[Is_block]]>>

/* Conversion macro names are always of the form  "to_from". */
<<function [[Val_long]]>>
<<function [[Long_val]]>>
<<constant [[Max_long]]>>
<<constant [[Min_long]]>>
<<constant [[Val_int]]>>
<<function [[Int_val]]>>

<<toplevel comment on header format>>
<<function [[Tag_hd]]>>
<<function [[Wosize_hd]]>>

<<function [[Hd_val]]>>
<<function [[Hd_op]]>>
<<function [[Hd_bp]]>>
<<function [[Hd_hp]]>>
<<function [[Hp_val]]>>
<<function [[Hp_op]]>>
<<function [[Hp_bp]]>>
<<function [[Val_op]]>>
<<function [[Val_hp]]>>
<<function [[Op_hp]]>>
<<function [[Bp_hp]]>>

<<constant [[Num_tags]]>>
#ifdef ARCH_SIXTYFOUR
<<constant [[Max_wosize]] (ifdef [[ARCH_SIXTYFOUR]])>>
#else
<<constant [[Max_wosize]] (ifndef [[ARCH_SIXTYFOUR]])>>
#endif

<<function [[Wosize_val]]>>
<<function [[Wosize_op]]>>
<<function [[Wosize_bp]]>>
<<function [[Wosize_hp]]>>
<<function [[Whsize_wosize]]>>
<<function [[Wosize_whsize]]>>
<<function [[Wosize_bhsize]]>>
<<function [[Bsize_wsize]]>>
<<function [[Wsize_bsize]]>>
<<function [[Bhsize_wosize]]>>
<<function [[Bhsize_bosize]]>>
<<function [[Bosize_val]]>>
<<function [[Bosize_op]]>>
<<function [[Bosize_bp]]>>
<<function [[Bosize_hd]]>>
<<function [[Whsize_hp]]>>
<<function [[Whsize_val]]>>
<<function [[Whsize_bp]]>>
<<function [[Whsize_hd]]>>
<<function [[Bhsize_hp]]>>
<<function [[Bhsize_hd]]>>

#ifdef ARCH_BIG_ENDIAN
<<function [[Tag_val]] (ifdef [[ARCH_BIG_ENDIAN]])>>
                                                 /* Also an l-value. */
<<function [[Tag_hp]] (ifdef [[ARCH_BIG_ENDIAN]])>>
                                                 /* Also an l-value. */
#else
<<function [[Tag_val]] little endian>>
                                                 /* Also an l-value. */
<<function [[Tag_hp]] little endian>>
                                                 /* Also an l-value. */
#endif

<<constant [[No_scan_tag]]>>


/* 1- If tag < No_scan_tag : a tuple of fields.  */

<<function [[Op_val]]>>
<<function [[Field]]>>

<<typedef [[opcode_t]]>>
<<typedef [[code_t]]>>

<<constant [[Closure_tag]]>>
<<function [[Code_val]]>>

/* If tag == Infix_tag : an infix header inside a closure */
/* Infix_tag must be odd so that the infix header is scanned as an integer */
<<constant [[Infix_tag]]>>
<<function [[Infix_offset_hd]]>>
<<function [[Infix_offset_val]]>>

<<constant [[Object_tag]]>>
<<function [[Class_val]]>>
<<function [[Oid_val]]>>

/* 2- If tag > No_scan_tag : a sequence of bytes. */

<<function [[Bp_val]]>>
<<function [[Val_bp]]>>
<<function [[Byte]]>>
<<function [[Byte_u]]>>

<<constant [[Abstract_tag]]>>

<<constant [[String_tag]]>>
<<function [[String_val]]>>
extern mlsize_t string_length (value v);   /* size in bytes */

<<constant [[Double_tag]]>>
<<constant [[Double_wosize]]>>

#ifndef ARCH_ALIGN_DOUBLE
<<macro [[Double_val]]>>
<<macro [[Store_double_val]]>>
#else
double Double_val (value);
void Store_double_val (value,double);
#endif

<<constant [[Double_array_tag]]>>
<<function [[Double_field]]>>
<<function [[Store_double_field]]>>

<<constant [[Final_tag]]>>
typedef void (*final_fun) (value);
<<function [[Final_fun]]>>


/* 3- Atoms are 0-tuples.  They are statically allocated once and for all. */

extern header_t atom_table[];
<<function [[Atom]]>>

/* Is_atom tests whether a well-formed block is statically allocated
   outside the heap. For the bytecode system, only zero-sized block (Atoms)
   fall in this class. For the native-code generator, data
   emitted by the code generator (as described in the table
   caml_data_segments) are also atoms. */

#ifndef NATIVE_CODE
<<function [[Is_atom]]>>
#else
extern char * static_data_start, * static_data_end;
<<function [[Is_atom]] (ifdef [[NATIVE_CODE]])>>
#endif

<<function [[Val_bool]]>>
<<function [[Bool_val]]>>
<<constant [[Val_false]]>>
<<constant [[Val_true]]>>
<<function [[Val_not]]>>

<<constant [[Val_unit]]>>

/* The table of global identifiers */

extern value global_data;


#endif /* _mlvalues_ */
@


\subsection*{[[byterun/exec.h]]}

%-------------------------------------------------------------

<<byterun/exec.h>>=
<<copyright header C xavier>>

/* exec.h : format of executable bytecode files */

#ifndef _exec_
#define _exec_

<<exec.h toplevel comment>>

<<constant [[TRAILER_SIZE]]>>

<<struct [[exec_trailer]]>>

<<constant [[EXEC_MAGIC]]>>

#endif

@


\subsection*{[[byterun/prims.h]]}

%-------------------------------------------------------------

<<byterun/prims.h>>=
<<copyright header C xavier>>

/* Interface with C primitives. */

#ifndef _prims_
#define _prims_

typedef value (*c_primitive)();

extern c_primitive cprim[];
extern char * names_of_cprim[];

#endif /* _prims_ */
@


\subsection*{[[byterun/memory.h]]}



%-------------------------------------------------------------

<<byterun/memory.h>>=
<<copyright header C damien>>

/* Allocation macros and functions */

#ifndef _memory_
#define _memory_


#include "config.h"
/* <private> */
#include "gc.h"
#include "major_gc.h"
#include "minor_gc.h"
/* </private> */
#include "misc.h"
#include "mlvalues.h"

value alloc_shr (mlsize_t, tag_t);
void adjust_gc_speed (mlsize_t, mlsize_t);
void modify (value *, value);
void initialize (value *, value);
value check_urgent_gc (value);
void * stat_alloc (asize_t);              /* Size in bytes. */
void stat_free (void *);
void * stat_resize (void *, asize_t);     /* Size in bytes. */

/* void shrink_heap (char *);        Only used in compact.c */

#ifdef NATIVE_CODE
<<constant [[Garbage_collection_function]] (ifdef [[NATIVE_CODE]])>>
#else
<<constant [[Garbage_collection_function]]>>
#endif

/* <private> */

<<function [[Alloc_small]]>>

<<function [[Modify]]>>

/* </private> */

<<struct [[caml__roots_block]]>>

extern struct caml__roots_block *local_roots;  /* defined in roots.c */



/* The following macros are used to declare C local variables and
   function parameters of type [value].

   The function body must start with one of the [CAMLparam] macros.
   If the function has no parameter of type [value], use [CAMLparam0].
   If the function has 1 to 5 [value] parameters, use the corresponding
   [CAMLparam] with the parameters as arguments.
   If the function has more than 5 [value] parameters, use [CAMLparam5]
   for the first 5 parameters, and one or more calls to the [CAMLxparam]
   macros for the others.

   If you need local variables of type [value], declare them with one
   or more calls to the [CAMLlocal] macros.
   Use [CAMLlocalN] to declare an array of [value]s.

   Your function may raise and exception or return a [value] with the
   [CAMLreturn] macro.  Its argument is simply the [value] returned by
   your function.  Do NOT directly return a [value] with the [return]
   keyword.

   All the identifiers beginning with "caml__" are reserved by Caml.
   Do not use them for anything (local or global variables, struct or
   union tags, macros, etc.)
*/

#define CAMLparam0() \
  struct caml__roots_block *caml__frame = local_roots

#define CAMLparam1(x) \
  CAMLparam0 (); \
  CAMLxparam1 (x)

#define CAMLparam2(x, y) \
  CAMLparam0 (); \
  CAMLxparam2 (x, y)

#define CAMLparam3(x, y, z) \
  CAMLparam0 (); \
  CAMLxparam3 (x, y, z)

#define CAMLparam4(x, y, z, t) \
  CAMLparam0 (); \
  CAMLxparam4 (x, y, z, t)

#define CAMLparam5(x, y, z, t, u) \
  CAMLparam0 (); \
  CAMLxparam4 (x, y, z, t, u)

#if defined (__GNUC__) && (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 7))
  #define CAMLunused __attribute__ ((unused))
#else
  #define CAMLunused
#endif

#define CAMLxparam1(x) \
  struct caml__roots_block caml__roots_##x; \
  CAMLunused void *caml__dummy_##x = ( \
    caml__frame, \
    (caml__roots_##x.next = local_roots), \
    (local_roots = &caml__roots_##x), \
    (caml__roots_##x.nitems = 1), \
    (caml__roots_##x.ntables = 1), \
    (caml__roots_##x.tables [0] = &x), \
    NULL)

#define CAMLxparam2(x, y) \
  struct caml__roots_block caml__roots_##x; \
  CAMLunused void *caml__dummy_##x = ( \
    caml__frame, \
    (caml__roots_##x.next = local_roots), \
    (local_roots = &caml__roots_##x), \
    (caml__roots_##x.nitems = 1), \
    (caml__roots_##x.ntables = 2), \
    (caml__roots_##x.tables [0] = &x), \
    (caml__roots_##x.tables [1] = &y), \
    NULL)

#define CAMLxparam3(x, y, z) \
  struct caml__roots_block caml__roots_##x; \
  CAMLunused void *caml__dummy_##x = ( \
    caml__frame, \
    (caml__roots_##x.next = local_roots), \
    (local_roots = &caml__roots_##x), \
    (caml__roots_##x.nitems = 1), \
    (caml__roots_##x.ntables = 3), \
    (caml__roots_##x.tables [0] = &x), \
    (caml__roots_##x.tables [1] = &y), \
    (caml__roots_##x.tables [2] = &z), \
    NULL)

#define CAMLxparam4(x, y, z, t) \
  struct caml__roots_block caml__roots_##x; \
  CAMLunused void *caml__dummy_##x = ( \
    caml__frame, \
    (caml__roots_##x.next = local_roots), \
    (local_roots = &caml__roots_##x), \
    (caml__roots_##x.nitems = 1), \
    (caml__roots_##x.ntables = 4), \
    (caml__roots_##x.tables [0] = &x), \
    (caml__roots_##x.tables [1] = &y), \
    (caml__roots_##x.tables [2] = &z), \
    (caml__roots_##x.tables [3] = &t), \
    NULL)

#define CAMLxparam5(x, y, z, t, u) \
  struct caml__roots_block caml__roots_##x; \
  CAMLunused void *caml__dummy_##x = ( \
    caml__frame, \
    (caml__roots_##x.next = local_roots), \
    (local_roots = &caml__roots_##x), \
    (caml__roots_##x.nitems = 1), \
    (caml__roots_##x.ntables = 5), \
    (caml__roots_##x.tables [0] = &x), \
    (caml__roots_##x.tables [1] = &y), \
    (caml__roots_##x.tables [2] = &z), \
    (caml__roots_##x.tables [3] = &t), \
    (caml__roots_##x.tables [4] = &u), \
    NULL)

#define CAMLlocal1(x) \
  value x = Val_unit; \
  CAMLxparam1 (x)

#define CAMLlocal2(x, y) \
  value x = Val_unit, y = Val_unit; \
  CAMLxparam2 (x, y)

#define CAMLlocal3(x, y, z) \
  value x = Val_unit, y = Val_unit, z = Val_unit; \
  CAMLxparam3 (x, y, z)

#define CAMLlocal4(x, y, z, t) \
  value x = Val_unit, y = Val_unit, z = Val_unit, t = Val_unit; \
  CAMLxparam4 (x, y, z, t)

#define CAMLlocal5(x, y, z, t, u) \
  value x = Val_unit, y = Val_unit, z = Val_unit, t = Val_unit, u = Val_unit; \
  CAMLxparam5 (x, y, z, t, u)

#define CAMLlocalN(x, size) \
  value x [(size)] = { NULL }; \
  struct caml__roots_block caml__roots_##x; \
  CAMLunused void *caml__dummy_##x = ( \
  caml_frame, \
  (caml_roots_##x.next = local_roots), \
  (local_roots = &caml__roots_##x), \
  (caml__roots_##x.nitems = (size)), \
  (caml__roots_##x.ntables = 1), \
  (caml__roots_##x.tables [0] = &(x [0])), \
  NULL)

#define CAMLreturn0 do{ \
  local_roots = caml__frame; \
  return; \
}while (0)

#define CAMLreturn(x) do{ \
  local_roots = caml__frame; \
  return (x); \
}while(0)


/* convenience macro */
#define Store_field(block, offset, val) modify (&Field (block, offset), val)


/*
    NOTE: [Begin_roots] and [End_roots] are superseded by [CAMLparam]*,
    [CAMLxparam]*, [CAMLlocal]*, [CAMLreturn].
*/



<<constant [[Begin_root]]>>

<<macro [[Begin_roots1]]>>

#define Begin_roots2(r0, r1) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 2; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1);

#define Begin_roots3(r0, r1, r2) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 3; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1); \
  caml__roots_block.tables[2] = &(r2);

#define Begin_roots4(r0, r1, r2, r3) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 4; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1); \
  caml__roots_block.tables[2] = &(r2); \
  caml__roots_block.tables[3] = &(r3);

#define Begin_roots5(r0, r1, r2, r3, r4) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 5; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1); \
  caml__roots_block.tables[2] = &(r2); \
  caml__roots_block.tables[3] = &(r3); \
  caml__roots_block.tables[4] = &(r4);

#define Begin_roots_block(table, size) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = (size); \
  caml__roots_block.ntables = 1; \
  caml__roots_block.tables[0] = (table);

<<macro [[End_roots]]>>


/* [register_global_root] registers a global C variable as a memory root
   for the duration of the program, or until [remove_global_root] is
   called. */

void register_global_root (value *);

/* [remove_global_root] removes a memory root registered on a global C
   variable with [register_global_root]. */

void remove_global_root (value *);


#endif /* _memory_ */

@


\subsection*{[[byterun/memory.c]]}


<<function [[shrink_heap]]>>=
/* Remove the heap chunk [chunk] from the heap and give the memory back
   to [malloc].
*/
void shrink_heap (char *chunk)
{
  char **cp;
  int i;

  /* Never deallocate the first block, because heap_start is both the
     first block and the base address for page numbers, and we don't
     want to shift the page table, it's too messy (see above).
     It will never happen anyway, because of the way compaction works.
     (see compact.c)
  */
  if (chunk == heap_start) return;

  stat_heap_size -= Chunk_size (chunk);
  gc_message ("Shrinking heap to %luk bytes\n", stat_heap_size / 1024);

#ifdef DEBUG
  {
    mlsize_t i;
    for (i = 0; i < Wsize_bsize (Chunk_size (chunk)); i++){
      ((value *) chunk) [i] = not_random ();
    }
  }
#endif

  /* Remove [chunk] from the list of chunks. */
  cp = &heap_start;
  while (*cp != chunk) cp = &(Chunk_next (*cp));
  *cp = Chunk_next (chunk);

  /* Remove the pages of [chunk] from the page table. */
  for (i = Page (chunk); i < Page (chunk + Chunk_size (chunk)); i++){
    page_table [i] = Not_in_heap;
  }

  /* Free the [malloc]ed block that contains [chunk]. */
  free (Chunk_block (chunk));
}
@

%shr for shared block
<<function [[alloc_shr]]>>=
value alloc_shr (mlsize_t wosize, tag_t tag)
{
  char *hp, *new_block;

  hp = fl_allocate (wosize);
  if (hp == NULL){
    new_block = expand_heap (wosize);
    if (new_block == NULL) {
      if (in_minor_collection)
        fatal_error ("Fatal error: out of memory.\n");
      else
        raise_out_of_memory ();
    }
    fl_add_block (new_block);
    hp = fl_allocate (wosize);
  }

  Assert (Is_in_heap (Val_hp (hp)));

  if (gc_phase == Phase_mark
      || (gc_phase == Phase_sweep && (addr)hp >= (addr)gc_sweep_hp)){
    Hd_hp (hp) = Make_header (wosize, tag, Black);
  }else{
    Assert (gc_phase == Phase_idle
            || (gc_phase == Phase_sweep && (addr)hp < (addr)gc_sweep_hp));
    Hd_hp (hp) = Make_header (wosize, tag, White);
  }
  allocated_words += Whsize_wosize (wosize);
  if (allocated_words > Wsize_bsize (minor_heap_size)) urge_major_slice ();
  return Val_hp (hp);
}
@

<<function [[adjust_gc_speed]]>>=
/* Use this function to tell the major GC to speed up when you use
   finalized objects to automatically deallocate extra-heap objects.
   The GC will do at least one cycle every [max] allocated words;
   [mem] is the number of words allocated this time.
   Note that only [mem/max] is relevant.  You can use numbers of bytes
   (or kilobytes, ...) instead of words.  You can change units between
   calls to [adjust_collector_speed].
*/
void adjust_gc_speed (mlsize_t mem, mlsize_t max)
{
  if (max == 0) max = 1;
  if (mem > max) mem = max;
  extra_heap_memory += ((float) mem / max) * stat_heap_size;
  if (extra_heap_memory > stat_heap_size){
    extra_heap_memory = stat_heap_size;
  }
  if (extra_heap_memory > Wsize_bsize (minor_heap_size) / 2) 
    urge_major_slice ();
}
@

<<function [[initialize]]>>=
/* You must use [initialize] to store the initial value in a field of
   a shared block, unless you are sure the value is not a young block.
   A block value [v] is a shared block if and only if [Is_in_heap (v)]
   is true.
*/
/* [initialize] never calls the GC, so you may call it while an object is
   unfinished (i.e. just after a call to [alloc_shr].) */
void initialize (value *fp, value val)
{
  *fp = val;
  if (Is_in_heap (fp) && Is_block (val) && Is_young (val)){
    *ref_table_ptr++ = fp;
    if (ref_table_ptr >= ref_table_limit){
      realloc_ref_table ();
    }
  }
}
@




<<function [[stat_alloc]]>>=
void * stat_alloc (asize_t sz)
{
  void * result = malloc (sz);

  if (result == NULL) raise_out_of_memory ();
  return result;
}
@
% static alloc?

<<function [[stat_free]]>>=
void stat_free (void * blk)
{
  free (blk);
}
@

<<function [[stat_resize]]>>=
void * stat_resize (void * blk, asize_t sz)
{
  void * result = realloc (blk, sz);

  if (result == NULL) raise_out_of_memory ();
  return result;
}
@


%-------------------------------------------------------------

<<byterun/memory.c>>=
<<copyright header C damien>>

#include "config.h"

#ifndef OS_PLAN9
#include <stdlib.h>
#include <string.h>
#endif

#include "fail.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "signals.h"

<<function [[expand_heap]]>>

<<function [[shrink_heap]]>>

<<function [[alloc_shr]]>>

<<function [[adjust_gc_speed]]>>

<<function [[initialize]]>>

<<function [[modify]]>>

<<function [[stat_alloc]]>>

<<function [[stat_free]]>>

<<function [[stat_resize]]>>

@


\subsection*{[[byterun/freelist.h]]}


%-------------------------------------------------------------

<<byterun/freelist.h>>=
<<copyright header C damien>>

/* Free lists of heap blocks. */

#ifndef _freelist_
#define _freelist_

#include "misc.h"
#include "mlvalues.h"

extern asize_t fl_cur_size;

char *fl_allocate (mlsize_t);
void fl_init_merge (void);
void fl_reset (void);
char *fl_merge_block (char *);
void fl_add_block (char *);


#endif /* _freelist_ */
@


\subsection*{[[byterun/freelist.c]]}

<<global [[sentinel]]>>=
/* The sentinel can be located anywhere in memory, but it must not be
   adjacent to any heap object. */
static struct {
  value filler1; /* Make sure the sentinel is never adjacent to any block. */
  header_t h;
  value first_bp;
  value filler2; /* Make sure the sentinel is never adjacent to any block. */
} sentinel = {0, Make_header (0, 0, Blue), 0, 0};
@

<<constant [[Fl_head]]>>=
#define Fl_head ((char *) (&(sentinel.first_bp)))
@

<<global [[fl_prev]]>>=
static char *fl_prev = Fl_head;  /* Current allocation pointer. */
@

<<global [[fl_last]]>>=
static char *fl_last = NULL;     /* Last block in the list.  Only valid
                                    just after fl_allocate returned NULL. */
@

<<global [[fl_merge]]>>=
char *fl_merge = Fl_head;        /* Current insertion pointer.  Managed
                                    jointly with [sweep_slice]. */
@

<<global [[fl_cur_size]]>>=
asize_t fl_cur_size = 0;         /* How many free words were added since
                                    the latest fl_init_merge. */
@

<<function [[Next]]>>=
#define Next(b) (((block *) (b))->next_bp)
@

<<function [[fl_check]]>>=
void fl_check (void)
{
  char *cur, *prev;
  int prev_found = 0, merge_found = 0;

  prev = Fl_head;
  cur = Next (prev);
  while (cur != NULL){
    Assert (Is_in_heap (cur));
    if (cur == fl_prev) prev_found = 1;
    if (cur == fl_merge) merge_found = 1;
    prev = cur;
    cur = Next (prev);
  }
  Assert (prev_found || fl_prev == Fl_head);
  Assert (merge_found || fl_merge == Fl_head);
}
@

<<function [[allocate_block]]>>=
/* [allocate_block] is called by [fl_allocate].  Given a suitable free
   block and the desired size, it allocates a new block from the free
   block.  There are three cases:
   0. The free block has the desired size.  Detach the block from the
      free-list and return it.
   1. The free block is 1 word longer than the desired size.  Detach
      the block from the free list.  The remaining word cannot be linked:
      turn it into an empty block (header only), and return the rest.
   2. The free block is big enough.  Split it in two and return the right
      block.
   In all cases, the allocated block is right-justified in the free block:
   it is located in the high-address words of the free block.  This way,
   the linking of the free-list does not change in case 2.
*/
static char *allocate_block (mlsize_t wh_sz, char *prev, char *cur)
{
  header_t h = Hd_bp (cur);
                                             Assert (Whsize_hd (h) >= wh_sz);
  if (Wosize_hd (h) < wh_sz + 1){                        /* Cases 0 and 1. */
    Next (prev) = Next (cur);
                    Assert (Is_in_heap (Next (prev)) || Next (prev) == NULL);
    if (fl_merge == cur) fl_merge = prev;
#ifdef DEBUG
    fl_last = NULL;
#endif
      /* In case 1, the following creates the empty block correctly.
         In case 0, it gives an invalid header to the block.  The function
         calling [fl_allocate] will overwrite it. */
    Hd_op (cur) = Make_header (0, 0, White);
  }else{                                                        /* Case 2. */
    Hd_op (cur) = Make_header (Wosize_hd (h) - wh_sz, 0, Blue);
  }
  fl_prev = prev;
  return cur + Bosize_hd (h) - Bsize_wsize (wh_sz);
}  
@

<<function [[fl_allocate]]>>=
/* [fl_allocate] does not set the header of the newly allocated block.
   The calling function must do it before any GC function gets called.
   [fl_allocate] returns a head pointer.
*/
char *fl_allocate (mlsize_t wo_sz)
{
  char *cur, *prev;
                                  Assert (sizeof (char *) == sizeof (value));
                                  Assert (fl_prev != NULL);
                                  Assert (wo_sz >= 1);
    /* Search from [fl_prev] to the end of the list. */
  prev = fl_prev;
  cur = Next (prev);
  while (cur != NULL){                             Assert (Is_in_heap (cur));
    if (Wosize_bp (cur) >= wo_sz){
      return allocate_block (Whsize_wosize (wo_sz), prev, cur);
    }
    prev = cur;
    cur = Next (prev);
  }
  fl_last = prev;
    /* Search from the start of the list to [fl_prev]. */
  prev = Fl_head;
  cur = Next (prev);
  while (prev != fl_prev){
    if (Wosize_bp (cur) >= wo_sz){
      return allocate_block (Whsize_wosize (wo_sz), prev, cur);
    }
    prev = cur;
    cur = Next (prev);
  }
    /* No suitable block was found. */
  return NULL;
}
@

<<global [[last_fragment]]>>=
static char *last_fragment;
@

<<function [[fl_init_merge]]>>=
void fl_init_merge (void)
{
  last_fragment = NULL;
  fl_merge = Fl_head;
  fl_cur_size = 0;
#ifdef DEBUG
  fl_check ();
#endif
}
@

<<function [[fl_reset]]>>=
/* This is called by compact_heap. */
void fl_reset (void)
{
  Next (Fl_head) = 0;
  fl_prev = Fl_head;
  fl_init_merge ();
}
@

<<function [[fl_merge_block]]>>=
/* [fl_merge_block] returns the head pointer of the next block after [bp],
   because merging blocks may change the size of [bp]. */
char *fl_merge_block (char *bp)
{
  char *prev, *cur, *adj;
  header_t hd = Hd_bp (bp);

  fl_cur_size += Whsize_hd (hd);
  
#ifdef DEBUG
  {
    mlsize_t i;
    for (i = 0; i < Wosize_hd (hd); i++){
      Field (Val_bp (bp), i) = not_random ();
    }
  }
#endif
  prev = fl_merge;
  cur = Next (prev);
  /* The sweep code makes sure that this is the right place to insert
     this block: */
  Assert (prev < bp || prev == Fl_head);
  Assert (cur > bp || cur == NULL);

  /* If [last_fragment] and [bp] are adjacent, merge them. */
  if (last_fragment == Hp_bp (bp)){
    hd = Make_header (Whsize_bp (bp), 0, White);
    bp = last_fragment;
    Hd_bp (bp) = hd;
    fl_cur_size += Whsize_wosize (0);
  }

  /* If [bp] and [cur] are adjacent, remove [cur] from the free-list
     and merge them. */
  adj = bp + Bosize_hd (hd);
  if (adj == Hp_bp (cur)){
    char *next_cur = Next (cur);
    long cur_whsz = Whsize_bp (cur);

    Next (prev) = next_cur;
    if (fl_prev == cur) fl_prev = prev;
    hd = Make_header (Wosize_hd (hd) + cur_whsz, 0, Blue);
    Hd_bp (bp) = hd;
    adj = bp + Bosize_hd (hd);
#ifdef DEBUG
    fl_last = NULL;
    Next (cur) = (char *) not_random ();
    Hd_bp (cur) = not_random ();
#endif
    cur = next_cur;
  }
  /* If [prev] and [bp] are adjacent merge them, else insert [bp] into
     the free-list if it is big enough. */
  if (prev + Bosize_bp (prev) == Hp_bp (bp)){
    Hd_bp (prev) = Make_header (Wosize_bp (prev) + Whsize_hd (hd), 0, Blue);
#ifdef DEBUG
    Hd_bp (bp) = not_random ();
#endif
    Assert (fl_merge == prev);
  }else if (Wosize_hd (hd) != 0){
    Hd_bp (bp) = Bluehd_hd (hd);
    Next (bp) = cur;
    Next (prev) = bp;
    fl_merge = bp;
  }else{
    /* This is a fragment.  Leave it in white but remember it for eventual
       merging with the next block. */
    last_fragment = bp;
  }
  return adj;
}
@

<<function [[fl_add_block]]>>=
/* This is a heap extension.  We have to insert it in the right place
   in the free-list.
   [fl_add_block] can only be called just after a call to [fl_allocate]
   that returned NULL.
   Most of the heap extensions are expected to be at the end of the
   free list.  (This depends on the implementation of [malloc].)
*/
void fl_add_block (char *bp)
{
                                                   Assert (fl_last != NULL);
                                            Assert (Next (fl_last) == NULL);
#ifdef DEBUG
  {
    mlsize_t i;
    for (i = 0; i < Wosize_bp (bp); i++){
      Field (Val_bp (bp), i) = not_random ();
    }
  }
#endif
  if (bp > fl_last){
    Next (fl_last) = bp;
    Next (bp) = NULL;
  }else{
    char *cur, *prev;

    prev = Fl_head;
    cur = Next (prev);
    while (cur != NULL && cur < bp){   Assert (prev < bp || prev == Fl_head);
      prev = cur;
      cur = Next (prev);
    }                                  Assert (prev < bp || prev == Fl_head);
                                            Assert (cur > bp || cur == NULL);
    Next (bp) = cur;
    Next (prev) = bp;
    /* When inserting a block between fl_merge and gc_sweep_hp, we must
       advance fl_merge to the new block, so that fl_merge is always the
       last free-list block before gc_sweep_hp. */
    if (prev == fl_merge && bp <= gc_sweep_hp) fl_merge = bp;
  }
}
@


%-------------------------------------------------------------

<<byterun/freelist.c>>=
<<copyright header C damien>>

#include "config.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "misc.h"
#include "mlvalues.h"

/* The free-list is kept sorted by increasing addresses.
   This makes the merging of adjacent free blocks possible.
   (See [fl_merge_block].)
*/

typedef struct {
  char *next_bp;   /* Pointer to the first byte of the next block. */
} block;

<<global [[sentinel]]>>

<<constant [[Fl_head]]>>
<<global [[fl_prev]]>>
<<global [[fl_last]]>>
<<global [[fl_merge]]>>
<<global [[fl_cur_size]]>>

<<function [[Next]]>>

#ifdef DEBUG
<<function [[fl_check]]>>
#endif

<<function [[allocate_block]]>>

<<function [[fl_allocate]]>>

<<global [[last_fragment]]>>

<<function [[fl_init_merge]]>>

<<function [[fl_reset]]>>

<<function [[fl_merge_block]]>>

<<function [[fl_add_block]]>>
@


\subsection*{[[byterun/alloc.h]]}

%-------------------------------------------------------------

<<byterun/alloc.h>>=
<<copyright header C xavier and damien>>

#ifndef _alloc_
#define _alloc_


#include "misc.h"
#include "mlvalues.h"

value alloc (mlsize_t, tag_t);
value alloc_small (mlsize_t, tag_t);
value alloc_tuple (mlsize_t);
value alloc_string (mlsize_t);
value alloc_final (mlsize_t, final_fun, mlsize_t, mlsize_t);
value copy_string (char *);
value copy_string_array (char **);
value copy_double (double);
value alloc_array (value (*funct) (char *), char ** array);
int convert_flag_list (value, int *);


#endif /* _alloc_ */
@


\subsection*{[[byterun/alloc.c]]}

<<constant [[Setup_for_gc]]>>=
#define Setup_for_gc
@

<<constant [[Restore_after_gc]]>>=
#define Restore_after_gc
@


<<function [[alloc_tuple]]>>=
value alloc_tuple(mlsize_t n)
{
  return alloc(n, 0);
}
@

<<function [[alloc_string]]>>=
value alloc_string (mlsize_t len)
{
  value result;
  mlsize_t offset_index;
  mlsize_t wosize = (len + sizeof (value)) / sizeof (value);

  if (wosize <= Max_young_wosize) {
    Alloc_small (result, wosize, String_tag);
  }else{
    result = alloc_shr (wosize, String_tag);
    result = check_urgent_gc (result);
  }
  Field (result, wosize - 1) = 0;
  offset_index = Bsize_wsize (wosize) - 1;
  Byte (result, offset_index) = offset_index - len;
  return result;
}
@

<<function [[alloc_final]]>>=
value alloc_final (mlsize_t len, final_fun fun, mlsize_t mem, mlsize_t max)
{
  value result = alloc_shr (len, Final_tag);

  Field (result, 0) = (value) fun;
  adjust_gc_speed (mem, max);
  result = check_urgent_gc (result);
  return result;
}
@

<<function [[copy_string]]>>=
value copy_string(char *s)
{
  int len;
  value res;

  len = strlen(s);
  res = alloc_string(len);
  bcopy(s, String_val(res), len);
  return res;
}
@

<<function [[alloc_array]]>>=
value alloc_array(value (*funct)(char *), char ** arr)
{
  mlsize_t nbr, n;
  value v, result;

  nbr = 0;
  while (arr[nbr] != 0) nbr++;
  if (nbr == 0) {
    return Atom(0);
  } else {
    result = alloc (nbr, 0);
    Begin_root(result);
      for (n = 0; n < nbr; n++) {
    /* The two statements below must be separate because of evaluation
           order. */
    v = funct(arr[n]);
    modify(&Field(result, n), v);
      }
    End_roots();
    return result;
  }
}
@

<<function [[copy_string_array]]>>=
value copy_string_array(char **arr)
{
  return alloc_array(copy_string, arr);
}
@

<<function [[convert_flag_list]]>>=
int convert_flag_list(value list, int *flags)
{
  int res;
  res = 0;
  while (list != Val_int(0)) {
    res |= flags[Int_val(Field(list, 0))];
    list = Field(list, 1);
  }
  return res;
}
@


%-------------------------------------------------------------

<<byterun/alloc.c>>=
<<copyright header C xavier and damien>>

/* 1. Allocation functions doing the same work as the macros in the
      case where [Setup_for_gc] and [Restore_after_gc] are no-ops.
   2. Convenience functions related to allocation.
*/

#include "config.h"
#ifndef OS_PLAN9
#include <string.h>
#else
#endif

#include "alloc.h"
#include "major_gc.h"
#include "memory.h"
#include "mlvalues.h"
#include "stacks.h"

<<constant [[Setup_for_gc]]>>
<<constant [[Restore_after_gc]]>>

<<function [[alloc]]>>

<<function [[alloc_tuple]]>>

<<function [[alloc_string]]>>

<<function [[alloc_final]]>>

<<function [[copy_string]]>>

<<function [[alloc_array]]>>

<<function [[copy_string_array]]>>

<<function [[convert_flag_list]]>>
@


\subsection*{[[byterun/interp.h]]}


%-------------------------------------------------------------

<<byterun/interp.h>>=
<<copyright header C xavier>>

/* The bytecode interpreter */

#ifndef _interp_
#define _interp_

#include "misc.h"
#include "mlvalues.h"

<<signature function interprete>>

#endif
@


\subsection*{[[byterun/interp.c]]}


<<constant [[Jumptbl_base]]>>=
#    define Jumptbl_base ((char *) &&lbl_ACC0)
@

<<constant [[Jumptbl_base]]([[(byterun/interp.c)]])>>=
#    define Jumptbl_base ((char *) 0)
@

<<constant [[jumptbl_base]]>>=
#    define jumptbl_base ((char *) 0)
@

<<constant [[Setup_for_gc]]([[(byterun/interp.c)]])>>=
/* GC interface */

#define Setup_for_gc { sp -= 2; sp[0] = accu; sp[1] = env; extern_sp = sp; }
@

<<constant [[Restore_after_gc]]([[(byterun/interp.c)]])>>=
#define Restore_after_gc { accu = sp[0]; env = sp[1]; sp += 2; }
@






%-------------------------------------------------------------

<<byterun/interp.c>>=
<<copyright header C xavier>>

/* The bytecode interpreter */

#include "alloc.h"
#include "backtrace.h"
#include "callback.h"
#include "debugger.h"
#include "fail.h"
#include "fix_code.h"
#include "instrtrace.h"
#include "instruct.h"
#include "interp.h"
#include "major_gc.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"
#include "signals.h"
#include "stacks.h"
#include "str.h"

<<interp.c toplevel comment>>

/* Instruction decoding */

#ifdef THREADED_CODE
<<macro [[Instruct]] for [[THREADED_CODE]]>>
#  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
<<constant [[Jumptbl_base]]>>
#  else
<<constant [[Jumptbl_base]]([[(byterun/interp.c)]])>>
<<constant [[jumptbl_base]]>>
#  endif
#  ifdef DEBUG
<<macro [[Next]] for [[THREADED_CODE]] ifdef [[DEBUG]]>>
#  else
<<macro [[Next]] for [[THREADED_CODE]]>>
#  endif
#else
<<macro [[Instruct]]>>
<<macro [[Next]]>>
#endif

<<constant [[Setup_for_gc]]([[(byterun/interp.c)]])>>
<<constant [[Restore_after_gc]]([[(byterun/interp.c)]])>>
<<constant [[Setup_for_c_call]]>>
<<constant [[Restore_after_c_call]]>>

<<constant [[Setup_for_debugger]]>>
<<constant [[Restore_after_debugger]]>>

#ifdef THREADED_CODE
<<macro [[Restart_curr_instr]] (if [[THREADED_CODE]])>>
#else
<<macro [[Restart_curr_instr]]>>
#endif

/* Register optimization.
   Some compilers underestimate the use of the local variables representing
   the abstract machine registers, and don't put them in hardware registers,
   which slows down the interpreter considerably.
   For GCC, I have hand-assigned hardware registers for several architectures.
*/

#if defined(__GNUC__) && !defined(DEBUG)
#ifdef __i386__
#define PC_REG asm("%esi")
#define SP_REG asm("%edi")
#define ACCU_REG asm("%ebx")
#endif
#endif

/* The interpreter itself */

<<function [[interpreter]]>>
@


\subsection*{[[byterun/gc.h]]}

<<function [[Color_hd]]>>=
#define Color_hd(hd) ((color_t) ((hd) & Black))
@

<<function [[Color_hp]]>>=
#define Color_hp(hp) Color_hd (Hd_hp (hp))
@

<<function [[Is_white_hd]]>>=
#define Is_white_hd(hd) (Color_hd (hd) == White)
@

<<function [[Is_gray_hd]]>>=
#define Is_gray_hd(hd) (Color_hd (hd) == Gray)
@

<<function [[Is_blue_hd]]>>=
#define Is_blue_hd(hd) (Color_hd (hd) == Blue)
@

<<function [[Is_black_hd]]>>=
#define Is_black_hd(hd) (Color_hd (hd) == Black)
@

<<function [[Whitehd_hd]]>>=
#define Whitehd_hd(hd) (((hd)  & ~Black)/*| White*/)
@

<<function [[Grayhd_hd]]>>=
#define Grayhd_hd(hd)  (((hd)  & ~Black)  | Gray)
@

<<function [[Blackhd_hd]]>>=
#define Blackhd_hd(hd) (((hd)/*& ~Black*/)| Black)
@

<<function [[Bluehd_hd]]>>=
#define Bluehd_hd(hd)  (((hd)  & ~Black)  | Blue)
@


<<function [[Color_val]]>>=
#define Color_val(val) (Color_hd (Hd_val (val)))
@

<<function [[Is_white_val]]>>=
#define Is_white_val(val) (Color_val(val) == White)
@

<<function [[Is_gray_val]]>>=
#define Is_gray_val(val) (Color_val(val) == Gray)
@

<<function [[Is_blue_val]]>>=
#define Is_blue_val(val) (Color_val(val) == Blue)
@

<<function [[Is_black_val]]>>=
#define Is_black_val(val) (Color_val(val) == Black)
@


%-------------------------------------------------------------

<<byterun/gc.h>>=
<<copyright header C damien>>

#ifndef _gc_
#define _gc_


#include "mlvalues.h"

<<constant [[White]]>>
<<constant [[Gray]]>>
<<constant [[Blue]]>>
<<constant [[Black]]>>

<<function [[Color_hd]]>>
<<function [[Color_hp]]>>

<<function [[Is_white_hd]]>>
<<function [[Is_gray_hd]]>>
<<function [[Is_blue_hd]]>>
<<function [[Is_black_hd]]>>

<<function [[Whitehd_hd]]>>
<<function [[Grayhd_hd]]>>
<<function [[Blackhd_hd]]>>
<<function [[Bluehd_hd]]>>

<<function [[Make_header]]>>

<<function [[Color_val]]>>

<<function [[Is_white_val]]>>
<<function [[Is_gray_val]]>>
<<function [[Is_blue_val]]>>
<<function [[Is_black_val]]>>


#endif /* _gc_ */
@


\subsection*{[[byterun/gc_ctrl.h]]}

%-------------------------------------------------------------

<<byterun/gc_ctrl.h>>=
<<copyright header C damien>>

#ifndef _gc_ctrl_
#define _gc_ctrl_

#include "misc.h"

extern long
     stat_minor_words,
     stat_promoted_words,
     stat_major_words,
     stat_minor_collections,
     stat_major_collections,
     stat_heap_size,
     stat_compactions;

void init_gc (unsigned long, unsigned long, unsigned long,
              unsigned long, unsigned long, unsigned long);


#endif /* _gc_ctrl_ */
@


\subsection*{[[byterun/gc_ctrl.c]]}

<<function [[Next]]([[(byterun/gc_ctrl.c)]])>>=
#define Next(hp) ((hp) + Bhsize_hp (hp))
@

<<function [[gc_stat]]>>=
/* This will also thoroughly verify the heap if compiled in DEBUG mode. */

value gc_stat(value v) /* ML */
{
  value res;
  long live_words = 0, live_blocks = 0,
       free_words = 0, free_blocks = 0, largest_free = 0,
       fragments = 0, heap_chunks = 0;
  char *chunk = heap_start, *chunk_end;
  char *cur_hp, *prev_hp;
  header_t cur_hd;

  Assert (v == Val_unit);

  while (chunk != NULL){
    ++ heap_chunks;
    chunk_end = chunk + Chunk_size (chunk);
    prev_hp = NULL;
    cur_hp = chunk;
    while (cur_hp < chunk_end){
      cur_hd = Hd_hp (cur_hp);
      switch (Color_hd (cur_hd)){
      case White:
        if (Wosize_hd (cur_hd) == 0){
          ++fragments;
          Assert (prev_hp == NULL
                  || (Color_hp (prev_hp) != Blue
                      && Wosize_hp (prev_hp) > 0)
          || cur_hp == gc_sweep_hp);
          Assert (Next (cur_hp) == chunk_end
                  || (Color_hp (Next (cur_hp)) != Blue
                      && Wosize_hp (Next (cur_hp)) > 0)
          || Next (cur_hp) == gc_sweep_hp);
          break;
        }
        /* FALLTHROUGH */
      case Gray: case Black:
        Assert (Wosize_hd (cur_hd) > 0);
        ++ live_blocks;
        live_words += Whsize_hd (cur_hd);
        break;
      case Blue:
        Assert (Wosize_hd (cur_hd) > 0);
        ++ free_blocks;
        free_words += Whsize_hd (cur_hd);
        if (Whsize_hd (cur_hd) > largest_free){
          largest_free = Whsize_hd (cur_hd);
        }
        Assert (prev_hp == NULL
                || (Color_hp (prev_hp) != Blue
                    && Wosize_hp (prev_hp) > 0)
        || cur_hp == gc_sweep_hp);
        Assert (Next (cur_hp) == chunk_end
                || (Color_hp (Next (cur_hp)) != Blue
                    && Wosize_hp (Next (cur_hp)) > 0)
        || Next (cur_hp) == gc_sweep_hp);
        break;
      }
      prev_hp = cur_hp;
      cur_hp = Next (cur_hp);
    }                                          Assert (cur_hp == chunk_end);
    chunk = Chunk_next (chunk);
  }
  
  Assert (live_words + free_words + fragments == Wsize_bsize (stat_heap_size));

  res = alloc_small (14, 0);
  Field (res, 0) = Val_long (stat_minor_words
                             + Wsize_bsize (young_end - young_ptr));
  Field (res, 1) = Val_long (stat_promoted_words);
  Field (res, 2) = Val_long (stat_major_words + allocated_words);
  Field (res, 3) = Val_long (stat_minor_collections);
  Field (res, 4) = Val_long (stat_major_collections);
  Field (res, 5) = Val_long (Wsize_bsize (stat_heap_size));
  Field (res, 6) = Val_long (heap_chunks);
  Field (res, 7) = Val_long (live_words);
  Field (res, 8) = Val_long (live_blocks);
  Field (res, 9) = Val_long (free_words);
  Field (res, 10) = Val_long (free_blocks);
  Field (res, 11) = Val_long (largest_free);
  Field (res, 12) = Val_long (fragments);
  Field (res, 13) = Val_long (stat_compactions);
  return res;
}
@

<<function [[gc_get]]>>=
value gc_get(value v) /* ML */
{
  value res;

  Assert (v == Val_unit);
  res = alloc_small (6, 0);
  Field (res, 0) = Wsize_bsize (Val_long (minor_heap_size));
  Field (res, 1) = Wsize_bsize (Val_long (major_heap_increment));
  Field (res, 2) = Val_long (percent_free);
  Field (res, 3) = Val_bool (verb_gc);
  Field (res, 4) = Val_long (percent_max);
#ifndef NATIVE_CODE
  Field (res, 5) = Val_long (max_stack_size);
#else
  Field (res, 5) = 0;
#endif
  return res;
}
@

<<function [[Max]]>>=
#define Max(x,y) ((x) < (y) ? (y) : (x))
@

<<function [[norm_pfree]]>>=
static unsigned long norm_pfree (long unsigned int p)
{
  return Max (p, 1);
}
@

<<function [[norm_pmax]]>>=
static unsigned long norm_pmax (long unsigned int p)
{
  return p;
}
@

<<function [[norm_heapincr]]>>=
static long norm_heapincr (long unsigned int i)
{
#define Psv (Wsize_bsize (Page_size))
  i = ((i + Psv - 1) / Psv) * Psv;
  if (i < Heap_chunk_min) i = Heap_chunk_min;
  if (i > Heap_chunk_max) i = Heap_chunk_max;
  return i;
}
@

<<function [[norm_minsize]]>>=
static long norm_minsize (long int s)
{
  if (s < Minor_heap_min) s = Minor_heap_min;
  if (s > Minor_heap_max) s = Minor_heap_max;
  return s;
}
@

<<function [[gc_set]]>>=
value gc_set(value v) /* ML */
{
  unsigned long newpf, newpm;
  asize_t newheapincr;
  asize_t newminsize;

  verb_gc = Bool_val (Field (v, 3));

#ifndef NATIVE_CODE
  change_max_stack_size (Long_val (Field (v, 5)));
#endif

  newpf = norm_pfree (Long_val (Field (v, 2)));
  if (newpf != percent_free){
    percent_free = newpf;
    gc_message ("New space overhead: %d%%\n", percent_free);
  }

  newpm = norm_pmax (Long_val (Field (v, 4)));
  if (newpm != percent_max){
    percent_max = newpm;
    gc_message ("New max overhead: %d%%\n", percent_max);
  }

  newheapincr = norm_heapincr (Bsize_wsize (Long_val (Field (v, 1))));
  if (newheapincr != major_heap_increment){
    major_heap_increment = newheapincr;
    gc_message ("New heap increment size: %luk bytes\n",
                major_heap_increment/1024);
  }

    /* Minor heap size comes last because it will trigger a minor collection
       (thus invalidating [v]) and it can raise [Out_of_memory]. */
  newminsize = norm_minsize (Bsize_wsize (Long_val (Field (v, 0))));
  if (newminsize != minor_heap_size){
    gc_message ("New minor heap size: %luk bytes\n", newminsize/1024);
    set_minor_heap_size (newminsize);
  }
  return Val_unit;
}
@

<<function [[gc_minor]]>>=
value gc_minor(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  return Val_unit;
}
@

<<function [[gc_major]]>>=
value gc_major(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  finish_major_cycle ();
  return Val_unit;
}
@

<<function [[gc_full_major]]>>=
value gc_full_major(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  finish_major_cycle ();
  finish_major_cycle ();
  return Val_unit;
}
@

<<function [[gc_compaction]]>>=
value gc_compaction(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  finish_major_cycle ();
  finish_major_cycle ();
  compact_heap ();
  return Val_unit;
}
@

<<function [[init_gc]]>>=
void init_gc (long unsigned int minor_size, long unsigned int major_size, long unsigned int major_incr, long unsigned int percent_fr, long unsigned int percent_m, long unsigned int verb)
{
  unsigned long major_heap_size = Bsize_wsize (norm_heapincr (major_size));
#ifdef DEBUG
  verb_gc = 1;
  gc_message ("*** O'Caml runtime: debug mode ***\n", 0);
#endif
  verb_gc = verb;
  set_minor_heap_size (Bsize_wsize (norm_minsize (minor_size)));
  major_heap_increment = Bsize_wsize (norm_heapincr (major_incr));
  percent_free = norm_pfree (percent_fr);
  percent_max = norm_pmax (percent_m);
  init_major_heap (major_heap_size);
  gc_message ("Initial minor heap size: %luk bytes\n", minor_heap_size / 1024);
  gc_message ("Initial major heap size: %luk bytes\n", major_heap_size / 1024);
  gc_message ("Initial space overhead: %lu%%\n", percent_free);
  gc_message ("Initial max overhead: %lu%%\n", percent_max);
  gc_message ("Initial heap increment: %luk bytes\n",
              major_heap_increment / 1024);
}
@


%-------------------------------------------------------------

<<byterun/gc_ctrl.c>>=
<<copyright header C damien>>

#include "alloc.h"
#include "compact.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "stacks.h"

#ifndef NATIVE_CODE
extern unsigned long max_stack_size;    /* defined in stacks.c */
#endif

long stat_minor_words = 0,
     stat_promoted_words = 0,
     stat_major_words = 0,
     stat_minor_collections = 0,
     stat_major_collections = 0,
     stat_heap_size = 0,           /* bytes */
     stat_compactions = 0;

extern long major_heap_increment;  /* bytes; cf. major_gc.c */
extern unsigned long percent_free;    /*        cf. major_gc.c */
extern unsigned long percent_max;     /*        cf. compact.c */

<<function [[Next]]([[(byterun/gc_ctrl.c)]])>>

<<function [[gc_stat]]>>

<<function [[gc_get]]>>

<<function [[Max]]>>

<<function [[norm_pfree]]>>

<<function [[norm_pmax]]>>

<<function [[norm_heapincr]]>>

<<function [[norm_minsize]]>>

<<function [[gc_set]]>>

<<function [[gc_minor]]>>

<<function [[gc_major]]>>

<<function [[gc_full_major]]>>

<<function [[gc_compaction]]>>

<<function [[init_gc]]>>
@


\subsection*{[[byterun/roots.h]]}

<<constant [[_roots_]]>>=
#define _roots_
@


%-------------------------------------------------------------

<<byterun/roots.h>>=
<<copyright header C xavier and damien>>

#ifndef _roots_
<<constant [[_roots_]]>>

#include "misc.h"
#include "memory.h"

typedef void (*scanning_action) (value, value *);

void oldify_local_roots (void);
void darken_all_roots (void);
void do_roots (scanning_action);
#ifndef NATIVE_CODE
void do_local_roots (scanning_action, value *, value *,
                     struct caml__roots_block *);
#else
void do_local_roots(scanning_action f, char * bottom_of_stack,
                    unsigned long last_retaddr, value * gc_regs,
                    struct caml__roots_block * local_roots);
#endif

extern void (*scan_roots_hook) (scanning_action);

#endif /* _roots_ */
@


\subsection*{[[byterun/roots.c]]}

<<global [[local_roots]]>>=
struct caml__roots_block *local_roots = NULL;
@

<<struct [[global_root]]>>=
struct global_root {
  value * root;
  struct global_root * next;
};
@

<<global [[global_roots]]>>=
static struct global_root * global_roots = NULL;
@

<<global [[scan_roots_hook]]>>=
void (*scan_roots_hook) (scanning_action f) = NULL;
@

<<function [[register_global_root]]>>=
/* Register a global C root */

void register_global_root(value *r)
{
  struct global_root * gr;
  gr = (struct global_root *) stat_alloc(sizeof(struct global_root));
  gr->root = r;
  gr->next = global_roots;
  global_roots = gr;
}
@

<<function [[remove_global_root]]>>=
/* Un-register a global C root */

void remove_global_root(value *r)
{
  struct global_root ** gp, * gr;
  for (gp = &global_roots; *gp != NULL; gp = &(*gp)->next) {
    gr = *gp;
    if (gr->root == r) {
      *gp = gr->next;
      stat_free(gr);
      return;
    }
  }
}
@

<<function [[oldify_local_roots]]>>=
/* Call [oldify] on all roots except [global_data] */

void oldify_local_roots (void)
{
  register value * sp;
  struct global_root * gr;
  struct caml__roots_block *lr;
  long i, j;

  /* The stack */
  for (sp = extern_sp; sp < stack_high; sp++) {
    oldify (*sp, sp);
  }
  /* Local C roots */
  for (lr = local_roots; lr != NULL; lr = lr->next) {
    for (i = 0; i < lr->ntables; i++){
      for (j = 0; j < lr->nitems; j++){
        sp = &(lr->tables[i][j]);
        oldify (*sp, sp);
      }
    }
  }
  /* Global C roots */
  for (gr = global_roots; gr != NULL; gr = gr->next) {
    oldify(*(gr->root), gr->root);
  }
  /* Hook */
  if (scan_roots_hook != NULL) (*scan_roots_hook)(oldify);
}
@

<<function [[darken_all_roots]]>>=
/* Call [darken] on all roots */

void darken_all_roots (void)
{
  do_roots (darken);
}
@

<<function [[do_roots]]>>=
void do_roots (scanning_action f)
{
  struct global_root * gr;

  /* Global variables */
  f(global_data, &global_data);

  /* The stack and the local C roots */
  do_local_roots(f, extern_sp, stack_high, local_roots);

  /* Global C roots */
  for (gr = global_roots; gr != NULL; gr = gr->next) {
    f (*(gr->root), gr->root);
  }
  /* Hook */
  if (scan_roots_hook != NULL) (*scan_roots_hook)(f);
}
@

<<function [[do_local_roots]]>>=
void do_local_roots (scanning_action f, value *stack_low, value *stack_high, struct caml__roots_block *local_roots)
{
  register value * sp;
  struct caml__roots_block *lr;
  int i, j;

  for (sp = stack_low; sp < stack_high; sp++) {
    f (*sp, sp);
  }
  for (lr = local_roots; lr != NULL; lr = lr->next) {
    for (i = 0; i < lr->ntables; i++){
      for (j = 0; j < lr->nitems; j++){
        sp = &(lr->tables[i][j]);
        f (*sp, sp);
      }
    }
  }
}
@


%-------------------------------------------------------------

<<byterun/roots.c>>=
<<copyright header C xavier and damien>>

/* To walk the memory roots for garbage collection */

#include "memory.h"
#include "major_gc.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "stacks.h"

<<global [[local_roots]]>>

<<struct [[global_root]]>>

<<global [[global_roots]]>>

<<global [[scan_roots_hook]]>>

<<function [[register_global_root]]>>

<<function [[remove_global_root]]>>

<<function [[oldify_local_roots]]>>

<<function [[darken_all_roots]]>>

<<function [[do_roots]]>>

<<function [[do_local_roots]]>>

@


\subsection*{[[byterun/major_gc.h]]}

<<constant [[_major_gc_]]>>=
#define _major_gc_
@

<<function [[Chunk_size]]>>=
#define Chunk_size(c) (((heap_chunk_head *) (c)) [-1]).size
@

<<function [[Chunk_alloc]]>>=
#define Chunk_alloc(c) (((heap_chunk_head *) (c)) [-1]).alloc
@

<<function [[Chunk_next]]>>=
#define Chunk_next(c) (((heap_chunk_head *) (c)) [-1]).next
@

<<function [[Chunk_block]]>>=
#define Chunk_block(c) (((heap_chunk_head *) (c)) [-1]).block
@

<<constant [[Phase_mark]]>>=
#define Phase_mark 0
@

<<constant [[Phase_sweep]]>>=
#define Phase_sweep 1
@

<<constant [[Phase_idle]]>>=
#define Phase_idle 2
@

<<constant [[In_heap]]>>=
#define In_heap 1
@

<<constant [[Not_in_heap]]>>=
#define Not_in_heap 0
@

<<function [[Page]]>>=
#define Page(p) (((addr) (p) - (addr) heap_start) >> Page_log)
@

<<function [[Is_in_heap]]>>=
#define Is_in_heap(p) \
  ((addr)(p) >= (addr)heap_start && (addr)(p) < (addr)heap_end \
   && page_table [Page (p)])
@


%-------------------------------------------------------------

<<byterun/major_gc.h>>=
<<copyright header C damien>>

#ifndef _major_gc_
<<constant [[_major_gc_]]>>


#include "freelist.h"
#include "misc.h"

typedef struct {
  void *block;           /* address of the malloced block this chunk live in */
  asize_t alloc;         /* in bytes, used for compaction */
  asize_t size;          /* in bytes */
  char *next;
} heap_chunk_head;

<<function [[Chunk_size]]>>
<<function [[Chunk_alloc]]>>
<<function [[Chunk_next]]>>
<<function [[Chunk_block]]>>

extern int gc_phase;
extern unsigned long allocated_words;
extern unsigned long extra_heap_memory;

<<constant [[Phase_mark]]>>
<<constant [[Phase_sweep]]>>
<<constant [[Phase_idle]]>>

typedef char page_table_entry;

extern char *heap_start;
extern char *heap_end;
extern unsigned long total_heap_size;
extern page_table_entry *page_table;
extern asize_t page_table_size;
extern char *gc_sweep_hp;

<<constant [[In_heap]]>>
<<constant [[Not_in_heap]]>>
<<function [[Page]]>>
<<function [[Is_in_heap]]>>

void init_major_heap (asize_t);
asize_t round_heap_chunk_size (asize_t);
void darken (value, value *);
void major_collection_slice (void);
void major_collection (void);
void finish_major_cycle (void);


#endif /* _major_gc_ */
@


\subsection*{[[byterun/major_gc.c]]}

<<constant [[LONG_MAX]]>>=
#define LONG_MAX 0x7FFFFFFFFFFFFFFF
@

<<constant [[LONG_MAX]]([[(byterun/major_gc.c)]])>>=
#define LONG_MAX 0x7FFFFFFF
@

<<global [[percent_free]]>>=
unsigned long percent_free;
@

<<global [[major_heap_increment]]>>=
long major_heap_increment;
@

<<global [[page_table]]>>=
page_table_entry *page_table;
@

<<global [[page_table_size]]>>=
asize_t page_table_size;
@

<<global [[gc_sweep_hp]]>>=
char *gc_sweep_hp;
@

<<global [[gc_phase]]>>=
int gc_phase;
@

<<global [[gray_vals]]>>=
static value *gray_vals;
@

<<global [[gray_vals_size]]>>=
static asize_t gray_vals_size;
@

<<global [[heap_is_pure]]>>=
static int heap_is_pure;   /* The heap is pure if the only gray objects
                              below [markhp] are also in [gray_vals]. */
@

<<global [[allocated_words]]>>=
unsigned long allocated_words;
@

<<global [[extra_heap_memory]]>>=
unsigned long extra_heap_memory;
@

<<function [[realloc_gray_vals]]>>=
static void realloc_gray_vals (void)
{
  value *new;

  Assert (gray_vals_cur == gray_vals_end);
  if (gray_vals_size < stat_heap_size / 128){
    gc_message ("Growing gray_vals to %luk bytes\n",
                (long) gray_vals_size * sizeof (value) / 512);
    new = (value *) realloc ((char *) gray_vals,
                             2 * gray_vals_size * sizeof (value));
    if (new == NULL){
      gc_message ("No room for growing gray_vals\n", 0);
      gray_vals_cur = gray_vals;
      heap_is_pure = 0;
    }else{
      gray_vals = new;
      gray_vals_cur = gray_vals + gray_vals_size;
      gray_vals_size *= 2;
      gray_vals_end = gray_vals + gray_vals_size;
    }
  }else{
    gray_vals_cur = gray_vals + gray_vals_size / 2;
    heap_is_pure = 0;
  }
}
@

<<function [[darken]]>>=
void darken (value v, value *p)
             
                /* not used */
{
  if (Is_block (v) && Is_in_heap (v)) {
    if (Tag_val(v) == Infix_tag) v -= Infix_offset_val(v);
    if (Is_white_val (v)){
      Hd_val (v) = Grayhd_hd (Hd_val (v));
      *gray_vals_cur++ = v;
      if (gray_vals_cur >= gray_vals_end) realloc_gray_vals ();
    }
  }
}
@

<<function [[start_cycle]]>>=
static void start_cycle (void)
{
  Assert (gc_phase == Phase_idle);
  Assert (gray_vals_cur == gray_vals);
  darken_all_roots();
  gc_phase = Phase_mark;
  markhp = NULL;
}
@

<<function [[mark_slice]]>>=
static void mark_slice (long int work)
{
  value *gray_vals_ptr;  /* Local copy of gray_vals_cur */
  value v, child;
  header_t hd;
  mlsize_t size, i;

  gray_vals_ptr = gray_vals_cur;
  while (work > 0){
    if (gray_vals_ptr > gray_vals){
      v = *--gray_vals_ptr;
      hd = Hd_val(v);
      Assert (Is_gray_hd (hd));
      Hd_val (v) = Blackhd_hd (hd);
      size = Wosize_hd(hd);
      if (Tag_hd (hd) < No_scan_tag){
        for (i = 0; i < size; i++){
          child = Field (v, i);
          if (Is_block (child) && Is_in_heap (child)) {
            hd = Hd_val(child);
            if (Tag_hd(hd) == Infix_tag) {
              child -= Infix_offset_val(child);
              hd = Hd_val(child);
            }
            if (Is_white_hd (hd)){
              Hd_val (child) = Grayhd_hd (hd);
              *gray_vals_ptr++ = child;
              if (gray_vals_ptr >= gray_vals_end) {
                gray_vals_cur = gray_vals_ptr;
                realloc_gray_vals ();
                gray_vals_ptr = gray_vals_cur;
              }
            }
          }
        }
      }
      work -= Whsize_wosize(size);
    }else if (markhp != NULL){
      if (markhp == limit){
        chunk = Chunk_next (chunk);
        if (chunk == NULL){
          markhp = NULL;
        }else{
          markhp = chunk;
          limit = chunk + Chunk_size (chunk);
        }
      }else{
        if (Is_gray_val (Val_hp (markhp))){
          Assert (gray_vals_ptr == gray_vals);
          *gray_vals_ptr++ = Val_hp (markhp);
        }
        markhp += Bhsize_hp (markhp);
      }
    }else if (!heap_is_pure){
      heap_is_pure = 1;
      chunk = heap_start;
      markhp = chunk;
      limit = chunk + Chunk_size (chunk);
    }else{
      /* Marking is done. */

      update_weak_pointers ();
      
      /* Initialise the sweep phase. */
      gray_vals_cur = gray_vals_ptr;
      gc_sweep_hp = heap_start;
      fl_init_merge ();
      gc_phase = Phase_sweep;
      chunk = heap_start;
      gc_sweep_hp = chunk;
      limit = chunk + Chunk_size (chunk);
      work = 0;
    }
  }
  gray_vals_cur = gray_vals_ptr;
}
@

<<function [[update_weak_pointers]]>>=
/* Walk through the linked list of weak arrays.
   Arrays that are white are removed from this list.
   For the other arrays, pointers to white objects are erased.
*/
static void update_weak_pointers (void)
{
  value *prev = &weak_list_head;
  value *cur = (value *) *prev;
  mlsize_t sz, i;

  while (cur != NULL){
    if (Color_val (cur) == White){
      *prev = Field (cur, 0);
      cur = (value *) *prev;
    }else{
      value curfield;

      sz = Wosize_val (cur);
      for (i = 1; i < sz; i++){
        curfield = Field (cur, i);
        if (curfield != 0 && Is_block (curfield) && Is_white_val (curfield)){
          Field (cur, i) = 0;
        }
      }
      prev = &Field (cur, 0);
      cur = (value *) *prev;
    }
  }
}
@

<<function [[sweep_slice]]>>=
static void sweep_slice (long int work)
{
  char *hp;
  header_t hd;

  while (work > 0){
    if (gc_sweep_hp < limit){
      hp = gc_sweep_hp;
      hd = Hd_hp (hp);
      work -= Whsize_hd (hd);
      gc_sweep_hp += Bhsize_hd (hd);
      switch (Color_hd (hd)){
      case White:
        if (Tag_hd (hd) == Final_tag){
          Final_fun (Val_hp (hp)) (Val_hp (hp));
        }
        gc_sweep_hp = fl_merge_block (Bp_hp (hp));
        break;
      case Blue:
        /* Only the blocks of the free-list are blue.  See [freelist.c]. */
        fl_merge = Bp_hp (hp);
        break;
      default:          /* Gray or Black */
        Assert(Color_hd(hd) == Black);
        Hd_hp (hp) = Whitehd_hd (hd);
        break;
      }
      Assert (gc_sweep_hp <= limit);
    }else{
      chunk = Chunk_next (chunk);
      if (chunk == NULL){
        /* Sweeping is done. */
        ++ stat_major_collections;
        work = 0;
        gc_phase = Phase_idle;
      }else{
        gc_sweep_hp = chunk;
        limit = chunk + Chunk_size (chunk);
      }
    }
  }
}
@

<<function [[major_collection_slice]]>>=
/* The main entry point for the GC.  Called at each minor GC. */
void major_collection_slice (void)
{
  /* 
     Free memory at the start of the GC cycle (garbage + free list) (assumed):
                 FM = stat_heap_size * percent_free / (100 + percent_free)
     Garbage at the start of the GC cycle:
                 G = FM * 2/3
     Proportion of free memory consumed since the previous slice:
                 PH = allocated_words / G
     Proportion of extra-heap memory consumed since the previous slice:
                 PE = extra_heap_memory / stat_heap_size
     Proportion of total work to do in this slice:
                 P  = PH + PE
     Amount of marking work for the GC cycle:
                 MW = stat_heap_size * 100 / (100 + percent_free)
     Amount of sweeping work for the GC cycle:
                 SW = stat_heap_size
     Amount of marking work for this slice:
                 MS = MW * P
                 MS = 3/2 * 100 * allocated_words / percent_free
                      + extra_heap_memory * 100 / (100 + percent_free)
     Amount of sweeping work for this slice:
                 SS = SW * P
                 SS = 3/2 * (100 + percent_free)/percent_free * allocated_words
                      + extra_heap_memory
     This slice will either mark 2*MS words or sweep 2*SS words.
  */

#define Margin 100  /* Make it a little faster to be on the safe side. */

  if (gc_phase == Phase_idle) start_cycle ();

  if (gc_phase == Phase_mark){
    mark_slice (300 * (allocated_words / percent_free + 1)
                + 200 * (extra_heap_memory / (100 + percent_free) + 1)
        + Margin);
    gc_message ("!", 0);
  }else{
    Assert (gc_phase == Phase_sweep);
    sweep_slice (3 * (100 + percent_free) * (allocated_words / percent_free + 1)
                 + 2 * extra_heap_memory
                 + Margin);
    gc_message ("$", 0);
  }

  if (gc_phase == Phase_idle) compact_heap_maybe ();

  stat_major_words += allocated_words;
  allocated_words = 0;
  extra_heap_memory = 0;
}
@
%$

<<function [[finish_major_cycle]]>>=
/* This does not call compact_heap_maybe because the estimations of
   free and live memory are only valid for a cycle done incrementally.
   Besides, this function is called by compact_heap_maybe.
*/
void finish_major_cycle (void)
{
  if (gc_phase == Phase_idle) start_cycle ();
  if (gc_phase == Phase_mark) mark_slice (LONG_MAX);
  Assert (gc_phase == Phase_sweep);
  sweep_slice (LONG_MAX);
  Assert (gc_phase == Phase_idle);
  stat_major_words += allocated_words;
  allocated_words = 0;
}
@

<<function [[round_heap_chunk_size]]>>=
asize_t round_heap_chunk_size (asize_t request)
{                            Assert (major_heap_increment >= Heap_chunk_min);
  if (request < major_heap_increment){
                              Assert (major_heap_increment % Page_size == 0);
    return major_heap_increment;
  }else if (request <= Heap_chunk_max){
    return ((request + Page_size - 1) >> Page_log) << Page_log;
  }else{
    raise_out_of_memory ();
    /* not reached */ return 0;
  }
}
@

<<function [[init_major_heap]]>>=
void init_major_heap (asize_t heap_size)
{
  asize_t i;
  void *block;

  stat_heap_size = round_heap_chunk_size (heap_size);
  Assert (stat_heap_size % Page_size == 0);
  heap_start = aligned_malloc (stat_heap_size + sizeof (heap_chunk_head),
                               sizeof (heap_chunk_head), &block);
  if (heap_start == NULL)
    fatal_error ("Fatal error: not enough memory for the initial heap.\n");
  heap_start += sizeof (heap_chunk_head);
  Assert ((unsigned long) heap_start % Page_size == 0);
  Chunk_size (heap_start) = stat_heap_size;
  Chunk_next (heap_start) = NULL;
  Chunk_block (heap_start) = block;
  heap_end = heap_start + stat_heap_size;
  Assert ((unsigned long) heap_end % Page_size == 0);
  page_table_size = 4 * stat_heap_size / Page_size;
  page_table = 
    (page_table_entry *) malloc (page_table_size * sizeof(page_table_entry));
  if (page_table == NULL)
    fatal_error ("Fatal error: not enough memory for the initial heap.\n");
  for (i = 0; i < page_table_size; i++){
    page_table [i] = Not_in_heap;
  }
  for (i = Page (heap_start); i < Page (heap_end); i++){
    page_table [i] = In_heap;
  }
  Hd_hp (heap_start) = Make_header (Wosize_bhsize (stat_heap_size), 0, Blue);
  fl_init_merge ();
  fl_merge_block (Bp_hp (heap_start));
  gc_phase = Phase_idle;
  gray_vals_size = 2048;
  gray_vals = (value *) malloc (gray_vals_size * sizeof (value));
  if (gray_vals == NULL)
    fatal_error ("Fatal error: not enough memory for the initial heap.\n");
  gray_vals_cur = gray_vals;
  gray_vals_end = gray_vals + gray_vals_size;
  heap_is_pure = 1;
  allocated_words = 0;
  extra_heap_memory = 0;
}
@


%-------------------------------------------------------------

<<byterun/major_gc.c>>=
<<copyright header C damien>>

#include "config.h"

#ifndef OS_PLAN9
// LONG_MAX
#include <limits.h>
#else
#endif

#include "compact.h"
#include "fail.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "weak.h"

<<global [[percent_free]]>>
<<global [[major_heap_increment]]>>
char *heap_start, *heap_end;
<<global [[page_table]]>>
<<global [[page_table_size]]>>
<<global [[gc_sweep_hp]]>>
<<global [[gc_phase]]>>
<<global [[gray_vals]]>>
value *gray_vals_cur, *gray_vals_end;
<<global [[gray_vals_size]]>>
<<global [[heap_is_pure]]>>
<<global [[allocated_words]]>>
<<global [[extra_heap_memory]]>>
extern char *fl_merge;  /* Defined in freelist.c. */

static char *markhp, *chunk, *limit;

static void update_weak_pointers (void);

<<function [[realloc_gray_vals]]>>

<<function [[darken]]>>

<<function [[start_cycle]]>>

<<function [[mark_slice]]>>

<<function [[update_weak_pointers]]>>

<<function [[sweep_slice]]>>

<<function [[major_collection_slice]]>>

/* The minor heap must be empty when this function is called. */
<<function [[finish_major_cycle]]>>

<<function [[round_heap_chunk_size]]>>

<<function [[init_major_heap]]>>
@


\subsection*{[[byterun/minor_gc.h]]}



%-------------------------------------------------------------

<<byterun/minor_gc.h>>=
<<copyright header C damien>>

#ifndef _minor_gc_
#define _minor_gc_

#include "misc.h"

extern char *young_start, *young_ptr, *young_end, *young_limit;
extern value **ref_table_ptr, **ref_table_limit;
extern asize_t minor_heap_size;
extern int in_minor_collection;

<<function [[Is_young]]>>

extern void set_minor_heap_size (asize_t);
extern void minor_collection (void);
extern void garbage_collection (void); /* for the native-code system */
extern void realloc_ref_table (void);
extern void oldify (value, value *);

#endif /* _minor_gc_ */
@


\subsection*{[[byterun/minor_gc.c]]}

<<global [[minor_heap_size]]>>=
asize_t minor_heap_size;
@

<<global [[in_minor_collection]]>>=
int in_minor_collection = 0;
@

<<function [[set_minor_heap_size]]>>=
void set_minor_heap_size (asize_t size)
{
  char *new_heap;
  value **new_table;

  Assert (size >= Minor_heap_min);
  Assert (size <= Minor_heap_max);
  Assert (size % sizeof (value) == 0);
  if (young_ptr != young_end) minor_collection ();
                                           Assert (young_ptr == young_end);
  new_heap = (char *) stat_alloc (size);
  if (young_start != NULL){
    stat_free (young_start);
  }
  young_start = new_heap;
  young_end = new_heap + size;
  young_limit = young_start;
  young_ptr = young_end;
  minor_heap_size = size;

  ref_table_size = minor_heap_size / sizeof (value) / 8;
  ref_table_reserve = 256;
  new_table = (value **) stat_alloc ((ref_table_size + ref_table_reserve)
                                     * sizeof (value *));
  if (ref_table != NULL) stat_free (ref_table);
  ref_table = new_table;
  ref_table_ptr = ref_table;
  ref_table_threshold = ref_table + ref_table_size;
  ref_table_limit = ref_table_threshold;
  ref_table_end = ref_table + ref_table_size + ref_table_reserve;
}
@

<<function [[oldify]]>>=
void oldify (value v, value *p)
{
  value result, field0;
  header_t hd;
  mlsize_t sz, i;
  int tag;

 tail_call:
  if (Is_block (v) && Is_young (v)){
    Assert (Hp_val (v) >= young_ptr);
    hd = Hd_val (v);
    tag = Tag_hd (hd);
    if (Is_blue_hd (hd)){    /* Already forwarded ? */
      *p = Field (v, 0);     /* Then the forward pointer is the first field. */
    }else if (tag == Infix_tag) {
      mlsize_t offset = Infix_offset_hd (hd);
      oldify(v - offset, p);
      *p += offset;
    }else if (tag >= No_scan_tag){
      sz = Wosize_hd (hd);
      result = alloc_shr (sz, tag);
      for (i = 0; i < sz; i++) Field(result, i) = Field(v, i);
      Hd_val (v) = Bluehd_hd (hd);            /* Put the forward flag. */
      Field (v, 0) = result;                  /* And the forward pointer. */
      *p = result;
    }else{
      /* We can do recursive calls before all the fields are filled, because
         we will not be calling the major GC. */
      sz = Wosize_hd (hd);
      result = alloc_shr (sz, tag);
      *p = result;
      field0 = Field (v, 0);
      Hd_val (v) = Bluehd_hd (hd);            /* Put the forward flag. */
      Field (v, 0) = result;                  /* And the forward pointer. */
      if (sz == 1) {
        p = &Field (result, 0);
        v = field0;
        goto tail_call;
      } else {
        oldify (field0, &Field (result, 0));
        for (i = 1; i < sz - 1; i++){
          oldify (Field(v, i), &Field (result, i));
        }
        p = &Field (result, i);
        v = Field (v, i);
        goto tail_call;
      }
    }
  }else{
    *p = v;
  }
}
@


<<function [[check_urgent_gc]]>>=
value check_urgent_gc (value extra_root)
{
  if (force_major_slice) {
    Begin_root(extra_root);
      minor_collection();
    End_roots();
  }
  return extra_root;
}
@

<<function [[realloc_ref_table]]>>=
void realloc_ref_table (void)
{                                 Assert (ref_table_ptr == ref_table_limit);
                                  Assert (ref_table_limit <= ref_table_end);
                            Assert (ref_table_limit >= ref_table_threshold);

  if (ref_table_limit == ref_table_threshold){
    gc_message ("ref_table threshold crossed\n", 0);
    ref_table_limit = ref_table_end;
    urge_major_slice ();
  }else{ /* This will almost never happen with the bytecode interpreter. */
    asize_t sz;
    asize_t cur_ptr = ref_table_ptr - ref_table;
                                                  Assert (force_major_slice);

    ref_table_size *= 2;
    sz = (ref_table_size + ref_table_reserve) * sizeof (value *);
    gc_message ("Growing ref_table to %ldk bytes\n", (long) sz / 1024);
    ref_table = (value **) realloc ((char *) ref_table, sz);
    if (ref_table == NULL) fatal_error ("Fatal error: ref_table overflow\n");
    ref_table_end = ref_table + ref_table_size + ref_table_reserve;
    ref_table_threshold = ref_table + ref_table_size;
    ref_table_ptr = ref_table + cur_ptr;
    ref_table_limit = ref_table_end;
  }
}
@


%-------------------------------------------------------------

<<byterun/minor_gc.c>>=
<<copyright header C damien>>

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#endif

#include "fail.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "signals.h"

<<global [[minor_heap_size]]>>
char *young_start = NULL;
char *young_end = NULL;

char *young_ptr = NULL;
char *young_limit = NULL;

static value **ref_table = NULL;
static value **ref_table_end;
static value **ref_table_threshold;

value **ref_table_ptr = NULL;
value **ref_table_limit;

static asize_t ref_table_size;
static asize_t ref_table_reserve;

<<global [[in_minor_collection]]>>

<<function [[set_minor_heap_size]]>>

<<function [[oldify]]>>

<<function [[minor_collection]]>>

<<function [[check_urgent_gc]]>>

<<function [[realloc_ref_table]]>>
@


\subsection*{[[byterun/compact.h]]}


%-------------------------------------------------------------

<<byterun/compact.h>>=
<<copyright header C damien>>

#ifndef _compact_
#define _compact_

#include "config.h"
#include "misc.h"

void compact_heap (void);
void compact_heap_maybe (void);


#endif /* _compact_ */
@


\subsection*{[[byterun/compact.c]]}

<<function [[Make_ehd]]>>=
/* Encoded headers: the color is stored in the 2 least significant bits.
   (For pointer inversion, we need to distinguish headers from pointers.)
   s is a Wosize, t is a tag, and c is a color (a two-bit number)

   For the purpose of compaction, "colors" are:
   0: pointers (direct or inverted)
   1: integer or (unencoded) infix header
   2: inverted pointer for infix header
   3: integer or encoded (noninfix) header
*/
#define Make_ehd(s,t,c) (((s) << 10) | (t) << 2 | (c))
@

<<function [[Whsize_ehd]]>>=
#define Whsize_ehd(h) Whsize_hd (h)
@

<<function [[Wosize_ehd]]>>=
#define Wosize_ehd(h) Wosize_hd (h)
@

<<function [[Tag_ehd]]>>=
#define Tag_ehd(h) (((h) >> 2) & 0xFF)
@

<<function [[Ecolor]]>>=
#define Ecolor(w) ((w) & 3)
@

<<function [[invert_root]]>>=
static void invert_root (value v, value *p)
{
  invert_pointer_at ((word *) p);
}
@

<<global [[compact_fl]]>>=
static char *compact_fl;
@

<<function [[init_compact_allocate]]>>=
static void init_compact_allocate (void)
{
  char *ch = heap_start;
  while (ch != NULL){
    Chunk_alloc (ch) = 0;
    ch = Chunk_next (ch);
  }
  compact_fl = heap_start;
}
@

<<function [[compact_allocate]]>>=
static char *compact_allocate (mlsize_t size)
                                      /* in bytes, including header */
{
  char *chunk, *adr;

  while (Chunk_size (compact_fl) - Chunk_alloc (compact_fl) <= Bhsize_wosize (3)
         && Chunk_size (Chunk_next (compact_fl))
            - Chunk_alloc (Chunk_next (compact_fl))
            <= Bhsize_wosize (3)){
    compact_fl = Chunk_next (compact_fl);
  }
  chunk = compact_fl;
  while (Chunk_size (chunk) - Chunk_alloc (chunk) < size){
    chunk = Chunk_next (chunk);                         Assert (chunk != NULL);
  }
  adr = chunk + Chunk_alloc (chunk);
  Chunk_alloc (chunk) += size;
  return adr;
}
@

<<function [[compact_heap]]>>=
void compact_heap (void)
{
  char *ch, *chend;
                                               Assert (gc_phase == Phase_idle);
  gc_message ("Compacting heap...\n", 0);
  /* First pass: encode all noninfix headers. */
  {
    ch = heap_start;
    while (ch != NULL){
      header_t *p = (header_t *) ch;

      chend = ch + Chunk_size (ch);
      while ((char *) p < chend){
        header_t hd = Hd_hp (p);
        mlsize_t sz = Wosize_hd (hd);

        if (Is_blue_hd (hd)){
          /* Free object.  Give it a string tag. */
          Hd_hp (p) = Make_ehd (sz, String_tag, 3);
        }else{                                      Assert (Is_white_hd (hd));
          /* Live object.  Keep its tag. */
          Hd_hp (p) = Make_ehd (sz, Tag_hd (hd), 3);
        }
        p += Whsize_wosize (sz);
      }
      ch = Chunk_next (ch);
    }
  }


  /* Second pass: invert pointers.
     Link infix headers in each block in an inverted list of inverted lists.
     Don't forget roots and weak pointers. */
  {
    ch = heap_start;
    while (ch != NULL){
      word *p = (word *) ch;
      chend = ch + Chunk_size (ch);

      while ((char *) p < chend){
        word q = *p;
        size_t sz, i;
        tag_t t;
        word *infixes;

        while (Ecolor (q) == 0) q = * (word *) q;
        sz = Whsize_ehd (q);
        t = Tag_ehd (q);
        
        if (t == Infix_tag){
          /* Get the original header of this block. */
          infixes = p + sz;
          q = *infixes;
          while (Ecolor (q) != 3) q = * (word *) (q & ~(unsigned long)3);
          sz = Whsize_ehd (q);
          t = Tag_ehd (q);
        }

        if (t < No_scan_tag){
          for (i = 1; i < sz; i++) invert_pointer_at (&(p[i]));
        }
        p += sz;
      }
      ch = Chunk_next (ch);
    }
    /* Invert weak pointers. */
    {
      value *pp = &weak_list_head;
      value p;
      word q;
      size_t sz, i;

      while (1){
        p = *pp;
        if (p == (value) NULL) break;
        q = Hd_val (p);
        while (Ecolor (q) == 0) q = * (word *) q;
        sz = Wosize_ehd (q);
        for (i = 1; i < sz; i++){
          if (Field (p,i) != 0) invert_pointer_at ((word *) &(Field (p,i)));
        }
        invert_pointer_at ((word *) pp);
        pp = &Field (p, 0);
      }
    }
    /* Invert roots */
    do_roots (invert_root);
  }


  /* Third pass: reallocate virtually; revert pointers; decode headers.
     Rebuild infix headers. */
  {
    init_compact_allocate ();
    ch = heap_start;
    while (ch != NULL){
      word *p = (word *) ch;
      
      chend = ch + Chunk_size (ch);
      while ((char *) p < chend){
        word q = *p;
        
        if (Ecolor (q) == 0 || Tag_ehd (q) == Infix_tag){
          /* There were (normal or infix) pointers to this block. */
          size_t sz;
          tag_t t;
          char *newadr;
          word *infixes = NULL;
          
          while (Ecolor (q) == 0) q = * (word *) q;
          sz = Whsize_ehd (q);
          t = Tag_ehd (q);

          if (t == Infix_tag){
            /* Get the original header of this block. */
            infixes = p + sz;
            q = *infixes;                             Assert (Ecolor (q) == 2);
            while (Ecolor (q) != 3) q = * (word *) (q & ~(unsigned long)3);
            sz = Whsize_ehd (q);
            t = Tag_ehd (q);
          }

          newadr = compact_allocate (Bsize_wsize (sz));
          q = *p;
          while (Ecolor (q) == 0){
            word next = * (word *) q;
            * (word *) q = (word) Val_hp (newadr);
            q = next;
          }
          *p = Make_header (Wosize_whsize (sz), t, White);

          if (infixes != NULL){
            /* Rebuild the infix headers and revert the infix pointers. */
            while (Ecolor ((word) infixes) != 3){
              infixes = (word *) ((word) infixes & ~(unsigned long) 3);
              q = *infixes;
              while (Ecolor (q) == 2){
                word next;
                q = (word) q & ~(unsigned long) 3;
                next = * (word *) q;
                * (word *) q = (word) Val_hp ((word *) newadr + (infixes - p));
                q = next;
              }                    Assert (Ecolor (q) == 1 || Ecolor (q) == 3);
              *infixes = Make_header (infixes - p, Infix_tag, White);
              infixes = (word *) q;
            }
          }
          p += sz;
        }else{                                        Assert (Ecolor (q) == 3);
          /* This is guaranteed only if compact_heap was called after a
             nonincremental major GC:       Assert (Tag_ehd (q) == String_tag);
          */
          /* No pointers to the header and no infix header:
             the object was free. */
          *p = Make_header (Wosize_ehd (q), Tag_ehd (q), Blue);
          p += Whsize_ehd (q);
        }
      }
      ch = Chunk_next (ch);
    }
  }


  /* Fourth pass: reallocate and move objects.
     Use the exact same allocation algorithm as pass 3. */
  {
    init_compact_allocate ();
    ch = heap_start;
    while (ch != NULL){
      word *p = (word *) ch;

      chend = ch + Chunk_size (ch);
      while ((char *) p < chend){
        word q = *p;
        if (Color_hd (q) == White){
          size_t sz = Bhsize_hd (q);
          char *newadr = compact_allocate (sz);  Assert (newadr <= (char *)p);
          /* bcopy (source, destination, length) */
          bcopy (p, newadr, sz);
          p += Wsize_bsize (sz);
        }else{
          Assert (Color_hd (q) == Blue);
          p += Whsize_hd (q);
        }
      }
      ch = Chunk_next (ch);
    }
  }

  /* Shrink the heap if needed. */
  {
    /* Find the amount of live data and the unshrinkable free space. */
    asize_t live = 0;
    asize_t free = 0;
    asize_t wanted;

    ch = heap_start;
    while (ch != NULL){
      if (Chunk_alloc (ch) != 0){
        live += Wsize_bsize (Chunk_alloc (ch));
        free += Wsize_bsize (Chunk_size (ch) - Chunk_alloc (ch));
      }
      ch = Chunk_next (ch);
    }

    /* Add up the empty chunks until there are enough, then remove the
       other empty chunks. */
    wanted = percent_free * (live / 100 + 1);
    ch = heap_start;
    while (ch != NULL){
      char *next_chunk = Chunk_next (ch);  /* Chunk_next (ch) will be erased */

      if (Chunk_alloc (ch) == 0){
        if (free < wanted){
          free += Wsize_bsize (Chunk_size (ch));
        }else{
          shrink_heap (ch);
        }
      }
      ch = next_chunk;
    }
  }

  /* Rebuild the free list. */
  {
    ch = heap_start;
    fl_reset ();
    while (ch != NULL){
      if (Chunk_size (ch) > Chunk_alloc (ch)){
        header_t *p = (header_t *) (ch + Chunk_alloc (ch));
        *p = Make_header (Wosize_bhsize (Chunk_size (ch) - Chunk_alloc (ch)),
                          0, White);
        fl_merge_block (Bp_hp (p));
      }
      ch = Chunk_next (ch);
    }
  }
  ++ stat_compactions;
  gc_message ("done.\n", 0);
}
@

<<global [[percent_max]]>>=
unsigned long percent_max;
@

<<function [[compact_heap_maybe]]>>=
void compact_heap_maybe (void)
{
  /* Estimated free words in the heap: FW = 1.5 * fl_cur_size
     Estimated live words: LW = stat_heap_size - FW
     We compact the heap if FW > percent_max / 100 * LW
  */
  float fw;
                                               Assert (gc_phase == Phase_idle);
  if (percent_max >= 1000000) return;
  switch (percent_max){
  case 0:
    finish_major_cycle ();
    compact_heap ();
    break;
  default:
    fw = 1.5 * fl_cur_size;
    if (fw > 0.01 * percent_max * (Wsize_bsize (stat_heap_size) - fw)){
      finish_major_cycle ();
      compact_heap ();
    }
    break;
  }
}
@


%-------------------------------------------------------------

<<byterun/compact.c>>=
<<copyright header C damien>>

#include "config.h"
#ifndef OS_PLAN9
#include <string.h>
#else
#endif

#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "memory.h"
#include "mlvalues.h"
#include "roots.h"
#include "weak.h"

extern unsigned long percent_free;             /* major_gc.c */
extern void shrink_heap (char *);              /* memory.c */

<<function [[Make_ehd]]>>
<<function [[Whsize_ehd]]>>
<<function [[Wosize_ehd]]>>
<<function [[Tag_ehd]]>>
<<function [[Ecolor]]>>

typedef unsigned long word;

static void invert_pointer_at (word *p)
{
  word q = *p;

  /* Use Ecolor (q) == 0 instead of Is_block (q) because q could be an
     inverted pointer for an infix header (with Ecolor == 2). */
  if (Ecolor (q) == 0 && Is_in_heap (q)){
    switch (Ecolor (Hd_val (q))){
    case 0:
    case 3: /* Pointer or header: insert in inverted list. */
      *p = Hd_val (q);
      Hd_val (q) = (header_t) p;
      break;
    case 1: /* Infix header: make inverted infix list. */
      /* Double inversion: the last of the inverted infix list points to
         the next infix header in this block.  The last of the last list
         contains the original block header. */
      {
        /* This block as a value. */
        value val = (value) q - Infix_offset_val (q);
        /* Get the block header. */
        word *hp = (word *) Hp_val (val);
        while (Ecolor (*hp) == 0) hp = (word *) *hp;
                                                   Assert (Ecolor (*hp) == 3);
        if (Tag_ehd (*hp) == Closure_tag){
          /* This is the first infix found in this block. */
          /* Save original header. */
          *p = *hp;
          /* Link inverted infix list. */
          Hd_val (q) = (header_t) ((word) p | 2);
          /* Change block header's tag to Infix_tag, and change its size
             to point to the infix list. */
          *hp = Make_ehd (Wosize_bhsize (q - val), Infix_tag, 3);
        }else{                            Assert (Tag_ehd (*hp) == Infix_tag);
          /* Point the last of this infix list to the current first infix
             list of the block. */
          *p = (word) &Field (val, Wosize_ehd (*hp)) | 1;
          /* Point the head of this infix list to the above. */
          Hd_val (q) = (header_t) ((word) p | 2);
          /* Change block header's size to point to this infix list. */
          *hp = Make_ehd (Wosize_bhsize (q - val), Infix_tag, 3);
        }
      }
      break;
    case 2: /* Inverted infix list: insert. */
      *p = Hd_val (q);
      Hd_val (q) = (header_t) ((word) p | 2);
      break;
    }
  }
}

<<function [[invert_root]]>>

<<global [[compact_fl]]>>

<<function [[init_compact_allocate]]>>

<<function [[compact_allocate]]>>

<<function [[compact_heap]]>>

<<global [[percent_max]]>>

<<function [[compact_heap_maybe]]>>
@


\subsection*{[[byterun/hash.c]]}

<<global [[hash_accu]]>>=
static unsigned long hash_accu;
@

<<function [[hash_univ_param]]>>=
value hash_univ_param(value count, value limit, value obj) /* ML */
{
  hash_univ_limit = Long_val(limit);
  hash_univ_count = Long_val(count);
  hash_accu = 0;
  hash_aux(obj);
  return Val_long(hash_accu & 0x3FFFFFFF);
  /* The & has two purposes: ensure that the return value is positive
     and give the same result on 32 bit and 64 bit architectures. */
}
@

<<constant [[Alpha]]>>=
#define Alpha 65599
@

<<constant [[Beta]]>>=
#define Beta 19
@

<<function [[Combine]]>>=
#define Combine(new)  (hash_accu = hash_accu * Alpha + (new))
@

<<function [[Combine_small]]>>=
#define Combine_small(new) (hash_accu = hash_accu * Beta + (new))
@


%-------------------------------------------------------------

<<byterun/hash.c>>=
<<copyright header C xavier>>

/* The generic hashing primitive */

#include "mlvalues.h"
#include "memory.h"
#include "str.h"

<<global [[hash_accu]]>>
static long hash_univ_limit, hash_univ_count;

static void hash_aux(value obj);

<<function [[hash_univ_param]]>>

<<constant [[Alpha]]>>
<<constant [[Beta]]>>
<<function [[Combine]]>>
<<function [[Combine_small]]>>

static void hash_aux(value obj)
{
  unsigned char * p;
  mlsize_t i, j;
  tag_t tag;

  hash_univ_limit--;
  if (hash_univ_count < 0 || hash_univ_limit < 0) return;

  if (Is_long(obj)) {
    hash_univ_count--;
    Combine(Long_val(obj));
    return;
  }

  /* Pointers into the heap are well-structured blocks. So are atoms.
     We can inspect the block contents. */
  
  if (Is_atom(obj) || Is_young(obj) || Is_in_heap(obj)) {
    tag = Tag_val(obj);
    switch (tag) {
    case String_tag:
      hash_univ_count--;
      i = string_length(obj);
      for (p = &Byte_u(obj, 0); i > 0; i--, p++)
        Combine_small(*p);
      break;
    case Double_tag:
      /* For doubles, we inspect their binary representation, LSB first.
         The results are consistent among all platforms with IEEE floats. */
      hash_univ_count--;
#ifdef ARCH_BIG_ENDIAN
      for (p = &Byte_u(obj, sizeof(double) - 1), i = sizeof(double);
           i > 0;
           p--, i--)
#else
      for (p = &Byte_u(obj, 0), i = sizeof(double);
           i > 0;
           p++, i--)
#endif
        Combine_small(*p);
      break;
    case Double_array_tag:
      hash_univ_count--;
      for (j = 0; j < Bosize_val(obj); j += sizeof(double)) {
#ifdef ARCH_BIG_ENDIAN
      for (p = &Byte_u(obj, j + sizeof(double) - 1), i = sizeof(double);
           i > 0;
           p--, i--)
#else
      for (p = &Byte_u(obj, j), i = sizeof(double);
           i > 0;
           p++, i--)
#endif
        Combine_small(*p);
      }
      break;
    case Abstract_tag:
    case Final_tag:
      /* We don't know anything about the contents of the block.
         Better do nothing. */
      break;
    case Infix_tag:
      hash_aux(obj - Infix_offset_val(obj));
      break;
    case Object_tag:
      hash_univ_count--;
      Combine(Oid_val(obj));
      break;
    default:
      hash_univ_count--;
      Combine_small(tag);
      i = Wosize_val(obj);
      while (i != 0) {
        i--;
        hash_aux(Field(obj, i));
      }
      break;
    }
    return;
  }

  /* Otherwise, obj is a pointer outside the heap, to an object with
     a priori unknown structure. Use its physical address as hash key. */
  Combine((long) obj);
}
@


\subsection*{[[byterun/array.c]]}

%-------------------------------------------------------------

<<byterun/array.c>>=
<<copyright header C xavier>>

/* Operations on arrays */

#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"

<<function [[array_get]]>>

<<function [[array_set]]>>

<<function [[make_vect]]>>
@


\subsection*{[[byterun/stacks.h]]}



%-------------------------------------------------------------

<<byterun/stacks.h>>=
<<copyright header C xavier>>

/* structure of the stacks */

#ifndef _stacks_
#define _stacks_

#include "misc.h"
#include "mlvalues.h"
#include "memory.h"

extern value * stack_low;
extern value * stack_high;
extern value * stack_threshold;
extern value * extern_sp;
extern value * trapsp;
extern value * trap_barrier;

<<function [[Trap_pc]]>>
<<function [[Trap_link]]>>

void reset_roots (void);
void init_stack (unsigned long init_max_size);
void realloc_stack (void);
void change_max_stack_size (unsigned long new_max_size);


#endif /* _stacks_ */

@


\subsection*{[[byterun/stacks.c]]}

<<global [[trap_barrier]]>>=
value * trap_barrier;
@


%-------------------------------------------------------------

<<byterun/stacks.c>>=
<<copyright header C xavier>>

/* To initialize and resize the stacks */

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#endif

#include "fail.h"
#include "misc.h"
#include "mlvalues.h"
#include "stacks.h"

<<global [[stack_low]]>>
<<global [[stack_high]]>>
<<global [[stack_threshold]]>>
<<global [[extern_sp]]>>
<<global [[trapsp]]>>
<<global [[trap_barrier]]>>
<<global [[global_data]]>>

<<global [[max_stack_size]]>>

<<function [[init_stack]]>>

<<function [[realloc_stack]]>>

<<function [[change_max_stack_size]]>>
@


\subsection*{[[byterun/callback.h]]}


%-------------------------------------------------------------

<<byterun/callback.h>>=
<<copyright header C xavier>>

/* Callbacks from C to Caml */

#ifndef _callback_
#define _callback_

#include "mlvalues.h"

value callback (value closure, value arg);
value callback2 (value closure, value arg1, value arg2);
value callback3 (value closure, value arg1, value arg2, value arg3);
extern int callback_depth;

value * caml_named_value (char * name);

void caml_main (char ** argv);
void caml_startup (char ** argv);

#endif
@


\subsection*{[[byterun/callback.c]]}

<<global [[callback_depth]]>>=
int callback_depth = 0;
@

<<global [[callback1_code]]>>=
static opcode_t callback1_code[] = { ACC1, APPLY1, POP, 1, STOP };
@

<<global [[callback2_code]]>>=
static opcode_t callback2_code[] = { ACC2, APPLY2, POP, 1, STOP };
@

<<global [[callback3_code]]>>=
static opcode_t callback3_code[] = { ACC3, APPLY3, POP, 1, STOP };
@

<<global [[callback_code_threaded]]>>=
static int callback_code_threaded = 0;
@

<<function [[thread_callback]]>>=
static void thread_callback(void)
{
  thread_code(callback1_code, sizeof(callback1_code));
  thread_code(callback2_code, sizeof(callback2_code));
  thread_code(callback3_code, sizeof(callback3_code));
  callback_code_threaded = 1;
}
@

<<function [[Init_callback]]>>=
#define Init_callback()
@

<<function [[callback]]>>=
value callback(value closure, value arg)
{
  value res;
  Init_callback();
  extern_sp -= 2;
  extern_sp[0] = arg;
  extern_sp[1] = closure;
  callback_depth++;
  res = interprete(callback1_code, sizeof(callback1_code));
  callback_depth--;
  return res;
}
@

<<function [[callback2]]>>=
value callback2(value closure, value arg1, value arg2)
{
  value res;
  Init_callback();
  extern_sp -= 3;
  extern_sp[0] = arg1;
  extern_sp[1] = arg2;
  extern_sp[2] = closure;
  callback_depth++;
  res = interprete(callback2_code, sizeof(callback2_code));
  callback_depth--;
  return res;
}
@

<<function [[callback3]]>>=
value callback3(value closure, value arg1, value arg2, value arg3)
{
  value res;
  Init_callback();
  extern_sp -= 4;
  extern_sp[0] = arg1;
  extern_sp[1] = arg2;
  extern_sp[2] = arg3;
  extern_sp[3] = closure;
  callback_depth++;
  res = interprete(callback3_code, sizeof(callback3_code));
  callback_depth--;
  return res;
}
@

<<struct [[named_value]]>>=
/* Naming of Caml values */

struct named_value {
  value val;
  struct named_value * next;
  char name[1];
};
@

<<constant [[Named_value_size]]>>=
#define Named_value_size 13
@

<<global [[named_value_table]]>>=
static struct named_value * named_value_table[Named_value_size] = { NULL, };
@

<<function [[hash_value_name]]>>=
static unsigned int hash_value_name(char *name)
{
  unsigned int h;
  for (h = 0; *name != 0; name++) h = h * 19 + *name;
  return h % Named_value_size;
}
@

<<function [[register_named_value]]>>=
value register_named_value(value vname, value val) /* ML */
{
  struct named_value * nv;
  char * name = String_val(vname);
  unsigned int h = hash_value_name(name);

  nv = (struct named_value *)
         stat_alloc(sizeof(struct named_value) + strlen(name));
  strcpy(nv->name, name);
  nv->val = val;
  nv->next = named_value_table[h];
  named_value_table[h] = nv;
  register_global_root(&nv->val);
  return Val_unit;
}
@

<<function [[caml_named_value]]>>=
value * caml_named_value(char *name)
{
  struct named_value * nv;
  for (nv = named_value_table[hash_value_name(name)];
       nv != NULL;
       nv = nv->next) {
    if (strcmp(name, nv->name) == 0) return &nv->val;
  }
  return NULL;
}
@


%-------------------------------------------------------------

<<byterun/callback.c>>=
<<copyright header C xavier>>

/* Callbacks from C to Caml */

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#else
#endif

#include "callback.h"
#include "memory.h"
#include "mlvalues.h"

/* Bytecode callbacks (implemented in asm for the native code compiler) */

#ifndef NATIVE_CODE

#include "interp.h"
#include "instruct.h"
#include "fix_code.h"
#include "stacks.h"

<<global [[callback_depth]]>>

<<global [[callback1_code]]>>
<<global [[callback2_code]]>>
<<global [[callback3_code]]>>

#ifdef THREADED_CODE

<<global [[callback_code_threaded]]>>

<<function [[thread_callback]]>>

#define Init_callback() if (!callback_code_threaded) thread_callback()

#else

<<function [[Init_callback]]>>

#endif

<<function [[callback]]>>

<<function [[callback2]]>>

<<function [[callback3]]>>

#endif

<<struct [[named_value]]>>

<<constant [[Named_value_size]]>>

<<global [[named_value_table]]>>

<<function [[hash_value_name]]>>

<<function [[register_named_value]]>>

<<function [[caml_named_value]]>>
@


\subsection*{[[byterun/compare.c]]}

<<function [[compare_val]]>>=
/* Structural comparison on trees.
   May loop on cyclic structures. */

static long compare_val(value v1, value v2)
{
  tag_t t1, t2;

 tailcall:
  if (v1 == v2) return 0;
  if (Is_long(v1)) {
    if (Is_long(v2))
      return Long_val(v1) - Long_val(v2);
    else
      return -1;
  }
  if (Is_long(v2)) return 1;
  /* If one of the objects is outside the heap (but is not an atom),
     use address comparison. Since both addresses are 2-aligned,
     shift lsb off to avoid overflow in subtraction. */
  if ((!Is_atom(v1) && !Is_young(v1) && !Is_in_heap(v1)) ||
      (!Is_atom(v2) && !Is_young(v2) && !Is_in_heap(v2)))
      return (v1 >> 1) - (v2 >> 1);
  t1 = Tag_val(v1);
  t2 = Tag_val(v2);
  if (t1 != t2) return (long)t1 - (long)t2;
  switch(t1) {
  case String_tag: {
    mlsize_t len1, len2, len;
    unsigned char * p1, * p2;
    len1 = string_length(v1);
    len2 = string_length(v2);
    for (len = (len1 <= len2 ? len1 : len2),
         p1 = (unsigned char *) String_val(v1),
         p2 = (unsigned char *) String_val(v2);
         len > 0;
         len--, p1++, p2++)
      if (*p1 != *p2) return (long)*p1 - (long)*p2;
    return len1 - len2;
  }
  case Double_tag: {
    double d1 = Double_val(v1);
    double d2 = Double_val(v2);
    if (d1 < d2) return -1; else if (d1 > d2) return 1; else return 0;
  }
  case Double_array_tag: {
    mlsize_t sz1 = Wosize_val(v1) / Double_wosize;
    mlsize_t sz2 = Wosize_val(v2) / Double_wosize;
    mlsize_t i;
    if (sz1 != sz2) return sz1 - sz2;
    for (i = 0; i < sz1; i++) {
      double d1 = Double_field(v1, i);
      double d2 = Double_field(v2, i);
      if (d1 < d2) return -1; else if (d1 > d2) return 1;
    }
    return 0;
  }
  case Abstract_tag:
  case Final_tag:
    invalid_argument("equal: abstract value");
  case Closure_tag:
  case Infix_tag:
    invalid_argument("equal: functional value");
  case Object_tag:
    return (Oid_val(v1) - Oid_val(v2));
  default: {
    mlsize_t sz1 = Wosize_val(v1);
    mlsize_t sz2 = Wosize_val(v2);
    value * p1, * p2;
    long res;
    if (sz1 != sz2) return sz1 - sz2;
    if (sz1 == 0) return 0;
    for(p1 = Op_val(v1), p2 = Op_val(v2);
        sz1 > 1;
        sz1--, p1++, p2++) {
      res = compare_val(*p1, *p2);
      if (res != 0) return res;
    }
    v1 = *p1;
    v2 = *p2;
    goto tailcall;
  }
  }
}
@

<<function [[compare]]>>=
value compare(value v1, value v2)           /* ML */
{
  long res = compare_val(v1, v2);
  if (res < 0) 
    return Val_int(-1);
  else if (res > 0)
    return Val_int(1);
  else
    return Val_int(0);
}
@

<<function [[equal]]>>=
value equal(value v1, value v2)            /* ML */
{
  return Val_int(compare_val(v1, v2) == 0);
}
@

<<function [[notequal]]>>=
value notequal(value v1, value v2)            /* ML */
{
  return Val_int(compare_val(v1, v2) != 0);
}
@

<<function [[lessthan]]>>=
value lessthan(value v1, value v2)            /* ML */
{
  return Val_int(compare_val(v1, v2) < 0);
}
@

<<function [[lessequal]]>>=
value lessequal(value v1, value v2)          /* ML */
{
  return Val_int(compare_val(v1, v2) <= 0);
}
@

<<function [[greaterthan]]>>=
value greaterthan(value v1, value v2)        /* ML */
{
  return Val_int(compare_val(v1, v2) > 0);
}
@

<<function [[greaterequal]]>>=
value greaterequal(value v1, value v2)       /* ML */
{
  return Val_int(compare_val(v1, v2) >= 0);
}
@


%-------------------------------------------------------------

<<byterun/compare.c>>=
<<copyright header C xavier>>

#include "config.h"

#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "str.h"

<<function [[compare_val]]>>

<<function [[compare]]>>

<<function [[equal]]>>

<<function [[notequal]]>>

<<function [[lessthan]]>>

<<function [[lessequal]]>>

<<function [[greaterthan]]>>

<<function [[greaterequal]]>>
@


\subsection*{[[byterun/debugger.h]]}


%-------------------------------------------------------------

<<byterun/debugger.h>>=
<<copyright header C xavier>>

/* Interface with the debugger */

#ifndef _debugger_
#define _debugger_

#include "misc.h"
#include "mlvalues.h"

extern int debugger_in_use;
extern unsigned long event_count;

<<enum [[event_kind]]>>

void debugger_init (void);
void debugger (enum event_kind event);

/* Communication protocol */

<<enum [[debugger_request]]>>

<<enum [[debugger_reply]]>>

#endif


@


\subsection*{[[byterun/debugger.c]]}

<<global [[debugger_in_use]]>>=
int debugger_in_use = 0;
@


<<function [[debugger_init]] (ifndef [[HAS_SOCKETS]])>>=
void debugger_init(void)
{
}
@

<<function debugger (ifndef [[HAS_SOCKETS]])>>=
void debugger(enum event_kind event)
{
}
@




<<global [[sock_domain]]>>=
static int sock_domain;         /* Socket domain for the debugger */
@

<<global [[sock_addr]]>>=
static union {                  /* Socket address for the debugger */
  struct sockaddr s_gen;
  struct sockaddr_un s_unix;
  struct sockaddr_in s_inet;
} sock_addr;
@

<<global [[sock_addr_len]]>>=
static int sock_addr_len;       /* Length of sock_addr */
@

<<global [[dbg_socket]]>>=
static int dbg_socket = -1;     /* The socket connected to the debugger */
@

<<global [[dbg_in]]>>=
static struct channel * dbg_in; /* Input channel on the socket */
@

<<global [[dbg_out]]>>=
static struct channel * dbg_out;/* Output channel on the socket */
@

<<function [[open_connection]]>>=
static void open_connection(void)
{
  dbg_socket = socket(sock_domain, SOCK_STREAM, 0);
  if (dbg_socket == -1 ||
      connect(dbg_socket, &sock_addr.s_gen, sock_addr_len) == -1)
    fatal_error("cannot connect to debugger");
  dbg_in = open_descriptor(dbg_socket);
  dbg_out = open_descriptor(dbg_socket);
  if (!debugger_in_use) putword(dbg_out, -1); /* first connection */
  putword(dbg_out, getpid());
  flush(dbg_out);
}
@

<<function [[close_connection]]>>=
static void close_connection(void)
{
  close_channel(dbg_in);
  close_channel(dbg_out);
  dbg_socket = -1;              /* was closed by close_channel */
}
@

<<function [[debugger_init]]>>=
void debugger_init(void)
{
  char * address;
  char * port, * p;
  struct hostent * host;
  int n;

  address = getenv("CAML_DEBUG_SOCKET");
  if (address == NULL) return;

  /* Parse the address */
  port = NULL;
  for (p = address; *p != 0; p++) {
    if (*p == ':') { *p = 0; port = p+1; break; }
  }
  if (port == NULL) {
    /* Unix domain */
    sock_domain = PF_UNIX;
    sock_addr.s_unix.sun_family = AF_UNIX;
    strncpy(sock_addr.s_unix.sun_path, address,
            sizeof(sock_addr.s_unix.sun_path));
    sock_addr_len = 
      ((char *)&(sock_addr.s_unix.sun_path) - (char *)&(sock_addr.s_unix))
        + strlen(address);
  } else {
    /* Internet domain */
    sock_domain = PF_INET;
    for (p = (char *) &sock_addr.s_inet, n = sizeof(sock_addr.s_inet);
         n > 0; n--) *p++ = 0;
    sock_addr.s_inet.sin_family = AF_INET;
    sock_addr.s_inet.sin_addr.s_addr = inet_addr(address);
    if (sock_addr.s_inet.sin_addr.s_addr == -1) {
      host = gethostbyname(address);
      if (host == NULL)
        fatal_error_arg("Unknown debugging host %s\n", address);
      bcopy(host->h_addr, &sock_addr.s_inet.sin_addr, host->h_length);
    }
    sock_addr.s_inet.sin_port = htons(atoi(port));
    sock_addr_len = sizeof(sock_addr.s_inet);
  }
  open_connection();
  debugger_in_use = 1;
  trap_barrier = stack_high;
}
@

<<function [[getval]]>>=
static value getval(struct channel *chan)
{
  value res;
  if (really_getblock(chan, (char *) &res, sizeof(res)) == 0)
    raise_end_of_file(); /* Bad, but consistent with getword */
  return res;
}
@

<<function [[putval]]>>=
static void putval(struct channel *chan, value val)
{
  really_putblock(chan, (char *) &val, sizeof(val));
}
@

<<function [[safe_output_value]]>>=
static void safe_output_value(struct channel *chan, value val)
{
  struct longjmp_buffer raise_buf, * saved_external_raise;

  /* Catch exceptions raised by output_val */
  saved_external_raise = external_raise;
  if (sigsetjmp(raise_buf.buf, 1) == 0) {
    external_raise = &raise_buf;
    output_val(chan, val, Val_unit);
  } else {
    /* Send wrong magic number, will cause input_value to fail */
    really_putblock(chan, "\000\000\000\000", 4);
  }
  external_raise = saved_external_raise;
}
@

<<function [[Pc]]>>=
#define Pc(sp) ((code_t)(sp[0]))
@

<<function [[Env]]>>=
#define Env(sp) (sp[1])
@

<<function [[Extra_args]]>>=
#define Extra_args(sp) (Long_val((sp[2])))
@

<<function [[Locals]]>>=
#define Locals(sp) (sp + 3)
@



%-------------------------------------------------------------

<<byterun/debugger.c>>=
<<copyright header C xavier>>

/* Interface with the debugger */

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#else
#endif

#include "debugger.h"
#include "fail.h"
#include "fix_code.h"
#include "instruct.h"
#include "intext.h"
#include "io.h"
#include "misc.h"
#include "mlvalues.h"
#include "stacks.h"
#include "sys.h"

<<global [[debugger_in_use]]>>
<<global [[event_count]]>>

#ifndef HAS_SOCKETS
<<function [[debugger_init]] (ifndef [[HAS_SOCKETS]])>>
<<function debugger (ifndef [[HAS_SOCKETS]])>>
#else

#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

<<global [[sock_domain]]>>
<<global [[sock_addr]]>>
<<global [[sock_addr_len]]>>

<<global [[dbg_socket]]>>
<<global [[dbg_in]]>>
<<global [[dbg_out]]>>

<<function [[open_connection]]>>

<<function [[close_connection]]>>

<<function [[debugger_init]]>>

<<function [[getval]]>>

<<function [[putval]]>>

<<function [[safe_output_value]]>>

<<function [[Pc]]>>
<<function [[Env]]>>
<<function [[Extra_args]]>>
<<function [[Locals]]>>

<<function [[debugger]]>>

#endif
@


\subsection*{[[byterun/instrtrace.h]]}

%-------------------------------------------------------------

<<byterun/instrtrace.h>>=
<<copyright header C xavier>>

/* Trace the instructions executed */

#ifndef _instrtrace_
#define _instrtrace_

#include "mlvalues.h"
#include "misc.h"

extern int trace_flag;
extern long icount;
void stop_here (void);

void disasm_instr (code_t pc);

#endif
@


\subsection*{[[byterun/instrtrace.c]]}


%-------------------------------------------------------------

<<byterun/instrtrace.c>>=
<<copyright header C xavier>>

/* Trace the instructions executed */

#ifdef DEBUG

#include <stdio.h>

#include "instruct.h"
#include "misc.h"
#include "mlvalues.h"
#include "opnames.h"

extern code_t start_code;
extern char * names_of_cprim[];

<<global [[icount]]>>

<<function [[stop_here]]>>

<<global [[trace_flag]]>>

<<function [[disasm_instr]]>>

#endif
@


\subsection*{[[byterun/extern.c]]}

<<struct [[extern_obj]]>>=
struct extern_obj {
  byteoffset_t ofs;
  value obj;
};
@

<<global [[initial_ofs]]>>=
static byteoffset_t initial_ofs = 1; /* Initial value of object offsets */
@

<<global [[extern_table]]>>=
static struct extern_obj * extern_table = NULL;
@

<<global [[extern_table_size]]>>=
static unsigned long extern_table_size;
@

<<global [[obj_counter]]>>=
static byteoffset_t obj_counter;    /* Number of objects emitted so far */
@

<<function [[Hash]] (ifdef [[ARCH_SIXTYFOUR]])>>=
#define Hash(v) (((unsigned long) ((v) >> 3)) % extern_table_size)
@

<<function [[Hash]]>>=
#define Hash(v) (((unsigned long) ((v) >> 2)) % extern_table_size)
@

<<function [[alloc_extern_table]]>>=
/* Allocate a new extern table */
static void alloc_extern_table(void)
{
  asize_t i;
  extern_table = (struct extern_obj *)
                 stat_alloc(extern_table_size * sizeof(struct extern_obj));
  for (i = 0; i < extern_table_size; i++) extern_table[i].ofs = 0;
}
@

<<function [[resize_extern_table]]>>=
/* Grow the extern table */
static void resize_extern_table(void)
{
  asize_t oldsize;
  struct extern_obj * oldtable;
  value obj;
  byteoffset_t ofs;
  asize_t i, h;

  oldsize = extern_table_size;
  oldtable = extern_table;
  extern_table_size = 2 * extern_table_size;
  alloc_extern_table();
  for (i = 0; i < oldsize; i++) {
    ofs = oldtable[i].ofs;
    if (ofs >= initial_ofs) {
      obj = oldtable[i].obj;
      h = Hash(obj);
      while (extern_table[h].ofs >= initial_ofs) {
        h++;
        if (h >= extern_table_size) h = 0;
      }
      extern_table[h].ofs = ofs;
      extern_table[h].obj = obj;
    }
  }
  stat_free(oldtable);
}
@

<<function [[free_extern_table]]>>=
/* Free the extern table. We keep it around for next call if
   it's still small (we did not grow it) and the initial offset
   does not risk running over next time. */
static void free_extern_table(void)
{
  if (extern_table_size > INITIAL_EXTERN_TABLE_SIZE ||
      initial_ofs >= INITIAL_OFFSET_MAX) {
    stat_free(extern_table);
    extern_table = NULL;
  }
}
@

<<global [[extern_block_malloced]]>>=
static int extern_block_malloced;
@

<<function [[alloc_extern_block]]>>=
static void alloc_extern_block(void)
{
  extern_block = stat_alloc(INITIAL_EXTERN_BLOCK_SIZE);
  extern_limit = extern_block + INITIAL_EXTERN_BLOCK_SIZE;
  extern_ptr = extern_block;
  extern_block_malloced = 1;
}
@

<<function [[resize_extern_block]]>>=
static void resize_extern_block(int required)
{
  long curr_pos, size, reqd_size;

  if (! extern_block_malloced) {
    initial_ofs += obj_counter;
    free_extern_table();
    failwith("Marshal.to_buffer: buffer overflow");
  }
  curr_pos = extern_ptr - extern_block;
  size = extern_limit - extern_block;
  reqd_size = curr_pos + required;
  while (size <= reqd_size) size *= 2;
  extern_block = stat_resize(extern_block, size);
  extern_limit = extern_block + size;
  extern_ptr = extern_block + curr_pos;
}
@

<<function [[writeblock]]>>=
static void writeblock(char *data, long int len)
{
  if (extern_ptr + len > extern_limit) resize_extern_block(len);
  bcopy(data, extern_ptr, len);
  extern_ptr += len;
}
@

<<function [[writecode8]]>>=
static void writecode8(int code, long int val)
{
  if (extern_ptr + 2 > extern_limit) resize_extern_block(2);
  extern_ptr[0] = code;
  extern_ptr[1] = val;
  extern_ptr += 2;
}
@

<<function [[writecode16]]>>=
static void writecode16(int code, long int val)
{
  if (extern_ptr + 3 > extern_limit) resize_extern_block(3);
  extern_ptr[0] = code;
  extern_ptr[1] = val >> 8;
  extern_ptr[2] = val;
  extern_ptr += 3;
}
@

<<function [[write32]]>>=
static void write32(long int val)
{
  if (extern_ptr + 4 > extern_limit) resize_extern_block(4);
  extern_ptr[0] = val >> 24;
  extern_ptr[1] = val >> 16;
  extern_ptr[2] = val >> 8;
  extern_ptr[3] = val;
  extern_ptr += 4;
}
@

<<function [[writecode32]]>>=
static void writecode32(int code, long int val)
{
  if (extern_ptr + 5 > extern_limit) resize_extern_block(5);
  extern_ptr[0] = code;
  extern_ptr[1] = val >> 24;
  extern_ptr[2] = val >> 16;
  extern_ptr[3] = val >> 8;
  extern_ptr[4] = val;
  extern_ptr += 5;
}
@

<<function [[writecode64]]>>=
static void writecode64(int code, long val)
{
  int i;
  if (extern_ptr + 9 > extern_limit) resize_extern_block(9);
  *extern_ptr ++ = code;
  for (i = 64 - 8; i >= 0; i -= 8) *extern_ptr++ = val >> i;
}
@

<<global [[size_32]]>>=
/* Marshal the given value in the output buffer */

static unsigned long size_32;  /* Size in words of 32-bit block for struct. */
@

<<global [[size_64]]>>=
static unsigned long size_64;  /* Size in words of 64-bit block for struct. */
@

<<global [[extern_ignore_sharing]]>>=
static int extern_ignore_sharing; /* Flag to ignore sharing */
@

<<global [[extern_closures]]>>=
static int extern_closures;     /* Flag to allow externing code pointers */
@

<<function [[extern_invalid_argument]]>>=
static void extern_invalid_argument(char *msg)
{
  if (extern_block_malloced) stat_free(extern_block);
  initial_ofs += obj_counter;
  free_extern_table();
  invalid_argument(msg);
}
@

<<function [[extern_rec]]>>=
static void extern_rec(value v)
{
 tailcall:
  if (Is_long(v)) {
    long n = Long_val(v);
    if (n >= 0 && n < 0x40) {
      Write(PREFIX_SMALL_INT + n);
    } else if (n >= -(1 << 7) && n < (1 << 7)) {
      writecode8(CODE_INT8, n);
    } else if (n >= -(1 << 15) && n < (1 << 15)) {
      writecode16(CODE_INT16, n);
#ifdef ARCH_SIXTYFOUR
    } else if (n < -(1L << 31) || n >= (1L << 31)) {
      writecode64(CODE_INT64, n);
#endif
    } else
      writecode32(CODE_INT32, n);
    return;
  }
  if (Is_young(v) || Is_in_heap(v) || Is_atom(v)) {
    header_t hd = Hd_val(v);
    tag_t tag = Tag_hd(hd);
    mlsize_t sz = Wosize_hd(hd);
    asize_t h;
    /* Atoms are treated specially for two reasons: they are not allocated
       in the externed block, and they are automatically shared. */
    if (sz == 0) {
      if (tag < 16) {
        Write(PREFIX_SMALL_BLOCK + tag);
      } else {
        writecode32(CODE_BLOCK32, hd);
      }
      return;
    }
    /* Check if already seen */
    if (! extern_ignore_sharing) {
      if (2 * obj_counter >= extern_table_size) resize_extern_table();
      h = Hash(v);
      while (extern_table[h].ofs >= initial_ofs) {
        if (extern_table[h].obj == v) {
          byteoffset_t d = obj_counter - (extern_table[h].ofs - initial_ofs);
          if (d < 0x100) {
            writecode8(CODE_SHARED8, d);
          } else if (d < 0x10000) {
            writecode16(CODE_SHARED16, d);
          } else {
            writecode32(CODE_SHARED32, d);
          }
          return;
        }
        h++;
        if (h >= extern_table_size) h = 0;
      }
      /* Not seen yet. Record the object */
      extern_table[h].ofs = initial_ofs + obj_counter;
      extern_table[h].obj = v;
      obj_counter++;
    }
    /* Output the contents of the object */
    switch(tag) {
    case String_tag: {
      mlsize_t len = string_length(v);
      if (len < 0x20) {
        Write(PREFIX_SMALL_STRING + len);
      } else if (len < 0x100) {
        writecode8(CODE_STRING8, len);
      } else {
        writecode32(CODE_STRING32, len);
      }
      writeblock(String_val(v), len);
      size_32 += 1 + (len + 4) / 4;
      size_64 += 1 + (len + 8) / 8;
      break;
    }
    case Double_tag: {
      if (sizeof(double) != 8)
        extern_invalid_argument("output_value: non-standard floats");
      Write(CODE_DOUBLE_NATIVE);
      writeblock((char *) v, 8);
      size_32 += 1 + 2;
      size_64 += 1 + 1;
      break;
    }
    case Double_array_tag: {
      mlsize_t nfloats;
      if (sizeof(double) != 8)
        extern_invalid_argument("output_value: non-standard floats");
      nfloats = Wosize_val(v) / Double_wosize;
      if (nfloats < 0x100) {
        writecode8(CODE_DOUBLE_ARRAY8_NATIVE, nfloats);
      } else {
        writecode32(CODE_DOUBLE_ARRAY32_NATIVE, nfloats);
      }
      writeblock((char *) v, Bosize_val(v));
      size_32 += 1 + nfloats * 2;
      size_64 += 1 + nfloats;
      break;
    }
    case Abstract_tag:
    case Final_tag:
      extern_invalid_argument("output_value: abstract value");
      break;
    case Infix_tag:
      writecode32(CODE_INFIXPOINTER, Infix_offset_hd(hd));
      extern_rec(v - Infix_offset_hd(hd));
      break;
    case Object_tag:
      extern_invalid_argument("output_value: object value");
      break;
    default: {
      mlsize_t i;
      if (tag < 16 && sz < 8) {
        Write(PREFIX_SMALL_BLOCK + tag + (sz << 4));
      } else {
        writecode32(CODE_BLOCK32, hd & ~Black);
      }
      size_32 += 1 + sz;
      size_64 += 1 + sz;
      for (i = 0; i < sz - 1; i++) extern_rec(Field(v, i));
      v = Field(v, i);
      goto tailcall;
      }
    }
    return;
  }
  if ((char *) v >= code_area_start && (char *) v < code_area_end) {
    if (!extern_closures)
      extern_invalid_argument("output_value: functional value");
    writecode32(CODE_CODEPOINTER, (char *) v - code_area_start);
    writeblock((char *) code_checksum(), 16);
    return;
  }
  extern_invalid_argument("output_value: abstract value");
}
@

<<enum [[_anon_]]>>=
enum { NO_SHARING = 1, CLOSURES = 2 };
@

<<global [[extern_flags]]>>=
static int extern_flags[] = { NO_SHARING, CLOSURES };
@

<<function [[extern_value]]>>=
static long extern_value(value v, value flags)
{
  long res_len;
  int fl;
  /* Parse flag list */
  fl = convert_flag_list(flags, extern_flags);
  extern_ignore_sharing = fl & NO_SHARING;
  extern_closures = fl & CLOSURES;
  /* Allocate hashtable of objects already seen, if needed */
  extern_table_size = INITIAL_EXTERN_TABLE_SIZE;
  if (extern_table == NULL) {
    alloc_extern_table();
    initial_ofs = 1;
  }
  obj_counter = 0;
  size_32 = 0;
  size_64 = 0;
  /* Write magic number */
  write32(Intext_magic_number);
  /* Set aside space for the sizes */
  extern_ptr += 4*4;
  /* Marshal the object */
  extern_rec(v);
  /* Update initial offset for next call to extern_value(),
     if we decide to keep the table of shared objects. */
  initial_ofs += obj_counter;
  /* Free the table of shared objects (if needed) */
  free_extern_table();
  /* Write the sizes */
#ifdef ARCH_SIXTYFOUR
  if (size_32 >= (1L << 32) || size_64 >= (1L << 32)) {
    /* The object is so big its size cannot be written in the header.
       Besides, some of the block sizes or string lengths or shared offsets
       it contains may have overflowed the 32 bits used to write them. */
    failwith("output_value: object too big");
  }
#endif
  res_len = extern_ptr - extern_block;
  extern_ptr = extern_block + 4;
  write32(res_len - 5*4);
  write32(obj_counter);
  write32(size_32);
  write32(size_64);
  /* Result is res_len bytes starting at extern_block */
  return res_len;
}
@

<<function [[output_val]]>>=
void output_val(struct channel *chan, value v, value flags)
{
  long len;
  alloc_extern_block();
  len = extern_value(v, flags);
  really_putblock(chan, extern_block, len);
  stat_free(extern_block);
}
@

<<function [[output_value_to_string]]>>=
value output_value_to_string(value v, value flags) /* ML */
{
  long len;
  value res;
  alloc_extern_block();
  len = extern_value(v, flags);
  res = alloc_string(len);
  bcopy(extern_block, String_val(res), len);
  stat_free(extern_block);
  return res;
}
@

<<function [[output_value_to_buffer]]>>=
value output_value_to_buffer(value buf, value ofs, value len, value v, value flags) /* ML */
{
  long len_res;
  extern_block = &Byte(buf, Long_val(ofs));
  extern_limit = extern_block + Long_val(len);
  extern_ptr = extern_block;
  extern_block_malloced = 0;
  len_res = extern_value(v, flags);
  return Val_long(len_res);
}
@


%-------------------------------------------------------------

<<byterun/extern.c>>=
<<copyright header C xavier>>

/* Structured output */

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#else
#endif

#include "alloc.h"
#include "fail.h"
#include "gc.h"
#include "intext.h"
#include "io.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "reverse.h"
#include "str.h"

/* To keep track of sharing in externed objects */

typedef unsigned long byteoffset_t;

<<struct [[extern_obj]]>>

<<global [[initial_ofs]]>>
<<global [[extern_table]]>>
<<global [[extern_table_size]]>>
<<global [[obj_counter]]>>

#ifdef ARCH_SIXTYFOUR
<<function [[Hash]] (ifdef [[ARCH_SIXTYFOUR]])>>
#else
<<function [[Hash]]>>
#endif

<<function [[alloc_extern_table]]>>

<<function [[resize_extern_table]]>>

<<function [[free_extern_table]]>>

/* To buffer the output */

static char * extern_block;
static char * extern_ptr;
static char * extern_limit;
<<global [[extern_block_malloced]]>>

<<function [[alloc_extern_block]]>>

<<function [[resize_extern_block]]>>

/* Write characters, integers, and blocks in the output buffer */

#define Write(c) \
  if (extern_ptr >= extern_limit) resize_extern_block(1); \
  *extern_ptr++ = (c)

<<function [[writeblock]]>>

<<function [[writecode8]]>>

<<function [[writecode16]]>>

<<function [[write32]]>>

<<function [[writecode32]]>>

#ifdef ARCH_SIXTYFOUR
<<function [[writecode64]]>>
#endif

<<global [[size_32]]>>
<<global [[size_64]]>>

<<global [[extern_ignore_sharing]]>>
<<global [[extern_closures]]>>

<<function [[extern_invalid_argument]]>>

<<function [[extern_rec]]>>

<<enum [[_anon_]]>>
<<global [[extern_flags]]>>

<<function [[extern_value]]>>

<<function [[output_val]]>>

<<function [[output_value]]>>

<<function [[output_value_to_string]]>>

<<function [[output_value_to_buffer]]>>

@


\subsection*{[[byterun/fail.h]]}




%-------------------------------------------------------------

<<byterun/fail.h>>=
<<copyright header C xavier>>

#ifndef _fail_
#define _fail_

#ifndef OS_PLAN9
#include <setjmp.h>
#else
#endif

#include "misc.h"
#include "mlvalues.h"

<<constant [[OUT_OF_MEMORY_EXN]]>>
<<constant [[SYS_ERROR_EXN]]>>
<<constant [[FAILURE_EXN]]>>
<<constant [[INVALID_EXN]]>>
<<constant [[END_OF_FILE_EXN]]>>
<<constant [[ZERO_DIVIDE_EXN]]>>
<<constant [[NOT_FOUND_EXN]]>>
<<constant [[MATCH_FAILURE_EXN]]>>
<<constant [[STACK_OVERFLOW_EXN]]>>

#ifdef POSIX_SIGNALS
<<struct [[longjmp_buffer]]>>
#else
struct longjmp_buffer {
  jmp_buf buf;
};
#define sigsetjmp(buf,save) setjmp(buf)
#define siglongjmp(buf,val) longjmp(buf,val)
#endif

extern struct longjmp_buffer * external_raise;
extern value exn_bucket;

void mlraise (value bucket) Noreturn;
void raise_constant (value tag) Noreturn;
void raise_with_arg (value tag, value arg) Noreturn;
void raise_with_string (value tag, char * msg) Noreturn;
void failwith (char *) Noreturn;
void invalid_argument (char *) Noreturn;
void raise_out_of_memory (void) Noreturn;
void raise_stack_overflow (void) Noreturn;
void raise_sys_error (value) Noreturn;
void raise_end_of_file (void) Noreturn;
void raise_zero_divide (void) Noreturn;
void raise_not_found (void) Noreturn;
void fatal_uncaught_exception (value) Noreturn;

#endif /* _fail_ */
@


\subsection*{[[byterun/fail.c]]}



<<function [[raise_constant]]>>=
void raise_constant(value tag)
{
  value bucket;
  Begin_root (tag);
    bucket = alloc_small (1, 0);
    Field(bucket, 0) = tag;
  End_roots ();
  mlraise(bucket);
}
@

<<function [[raise_with_arg]]>>=
void raise_with_arg(value tag, value arg)
{
  value bucket;
  Begin_roots2 (tag, arg);
    bucket = alloc_small (2, 0);
    Field(bucket, 0) = tag;
    Field(bucket, 1) = arg;
  End_roots ();
  mlraise(bucket);
}
@

<<function [[raise_with_string]]>>=
void raise_with_string(value tag, char *msg)
{
  value vmsg;
  Begin_root(tag);
    vmsg = copy_string(msg);
  End_roots();
  raise_with_arg(tag, vmsg);
}
@

<<global [[out_of_memory_bucket]]>>=
/* Problem: we can't use raise_constant, because it allocates and
   we're out of memory... The following is a terrible hack that works
   because global_data[OUT_OF_MEMORY_EXN] is in the old generation
   (because global_data was read with intern_val), hence stays at
   a fixed address */

static struct {
  header_t hdr;
  value exn;
} out_of_memory_bucket;
@

<<function [[raise_out_of_memory]]>>=
void raise_out_of_memory(void)
{
  out_of_memory_bucket.hdr = Make_header(1, 0, White);
  out_of_memory_bucket.exn = Field(global_data, OUT_OF_MEMORY_EXN);
  mlraise((value) &(out_of_memory_bucket.exn));
}
@

<<function [[raise_stack_overflow]]>>=
void raise_stack_overflow(void)
{
  raise_constant(Field(global_data, STACK_OVERFLOW_EXN));
}
@

<<function [[raise_sys_error]]>>=
void raise_sys_error(value msg)
{
  raise_with_arg(Field(global_data, SYS_ERROR_EXN), msg);
}
@

<<function [[raise_end_of_file]]>>=
void raise_end_of_file(void)
{
  raise_constant(Field(global_data, END_OF_FILE_EXN));
}
@

<<function [[raise_zero_divide]]>>=
void raise_zero_divide(void)
{
  raise_constant(Field(global_data, ZERO_DIVIDE_EXN));
}
@

<<function [[raise_not_found]]>>=
void raise_not_found(void)
{
  raise_constant(Field(global_data, NOT_FOUND_EXN));
}
@


%-------------------------------------------------------------

<<byterun/fail.c>>=
<<copyright header C xavier>>

/* Raising exceptions from C. */

#include "alloc.h"
#include "fail.h"
#include "io.h"
#include "gc.h"
#include "memory.h"
#include "mlvalues.h"
#include "signals.h"
#include "stacks.h"

<<global [[external_raise]]>>
<<global [[exn_bucket]]>>

<<function [[mlraise]]>>

<<function [[raise_constant]]>>

<<function [[raise_with_arg]]>>

<<function [[raise_with_string]]>>

<<function [[failwith]]>>

<<function [[invalid_argument]]>>

<<global [[out_of_memory_bucket]]>>

<<function [[raise_out_of_memory]]>>

<<function [[raise_stack_overflow]]>>

<<function [[raise_sys_error]]>>

<<function [[raise_end_of_file]]>>

<<function [[raise_zero_divide]]>>

<<function [[raise_not_found]]>>

@


\subsection*{[[byterun/fix_code.h]]}


%-------------------------------------------------------------

<<byterun/fix_code.h>>=
<<copyright header C xavier>>

/* Handling of blocks of bytecode (endianness switch, threading). */

#ifndef _fix_code_
#define _fix_code_


#include "config.h"
#include "misc.h"
#include "mlvalues.h"

extern code_t start_code;
extern asize_t code_size;
extern unsigned char * saved_code;
extern unsigned char code_md5[16];

void load_code (int fd, asize_t len);
void fixup_endianness (code_t code, asize_t len);
void set_instruction (code_t pos, opcode_t instr);
int is_instruction (opcode_t instr1, opcode_t instr2);

#ifdef THREADED_CODE
extern char ** instr_table;
extern char * instr_base;
void thread_code (code_t code, asize_t len);
#endif

#endif
@


\subsection*{[[byterun/fix_code.c]]}

<<global [[start_code]]>>=
code_t start_code;
@

<<global [[code_size]]>>=
asize_t code_size;
@

<<global [[saved_code]]>>=
unsigned char * saved_code;
@

<<global [[code_md5]]>>=
unsigned char code_md5[16];
@

<<function [[load_code]]>>=
/* Read the main bytecode block from a file */

void load_code(int fd, asize_t len)
{
  int i;
  struct MD5Context ctx;

  code_size = len;
  start_code = (code_t) stat_alloc(code_size);
  if (read(fd, (char *) start_code, code_size) != code_size)
    fatal_error("Fatal error: truncated bytecode file.\n");
  MD5Init(&ctx);
  MD5Update(&ctx, (unsigned char *) start_code, code_size);
  MD5Final(code_md5, &ctx);
#ifdef ARCH_BIG_ENDIAN
  fixup_endianness(start_code, code_size);
#endif
  if (debugger_in_use) {
    len /= sizeof(opcode_t);
    saved_code = (unsigned char *) stat_alloc(len);
    for (i = 0; i < len; i++) saved_code[i] = start_code[i];
  }
#ifdef THREADED_CODE
  /* Better to thread now than at the beginning of interprete(),
     since the debugger interface needs to perform SET_EVENT requests
     on the code. */
  thread_code(start_code, code_size);
#endif
}
@

<<function [[fixup_endianness]]>>=
void fixup_endianness(code_t code, asize_t len)
{
  code_t p;
  len /= sizeof(opcode_t);
  for (p = code; p < code + len; p++) {
    Reverse_int32(p);
  }
}
@

<<global [[instr_table]]>>=
char ** instr_table;
@

<<global [[instr_base]]>>=
char * instr_base;
@

<<function [[thread_code]]>>=
void thread_code (code_t code, asize_t len)
{
  code_t p;
  int l [STOP + 1];
  int i;
  
  for (i = 0; i <= STOP; i++) {
    l [i] = 0;
  }
  /* Instructions with one operand */
  l[PUSHACC] = l[ACC] = l[POP] = l[ASSIGN] =
  l[PUSHENVACC] = l[ENVACC] = l[PUSH_RETADDR] = l[APPLY] =
  l[APPTERM1] = l[APPTERM2] = l[APPTERM3] = l[RETURN] =
  l[GRAB] = l[PUSHGETGLOBAL] = l[GETGLOBAL] = l[SETGLOBAL] =
  l[PUSHATOM] = l[ATOM] = l[MAKEBLOCK1] = l[MAKEBLOCK2] =
  l[MAKEBLOCK3] = l[GETFIELD] = l[SETFIELD] = l[DUMMY] =
  l[BRANCH] = l[BRANCHIF] = l[BRANCHIFNOT] = l[PUSHTRAP] =
  l[C_CALL1] = l[C_CALL2] = l[C_CALL3] = l[C_CALL4] = l[C_CALL5] =
  l[CONSTINT] = l[PUSHCONSTINT] = l[OFFSETINT] = l[OFFSETREF] = 1;

  /* Instructions with two operands */
  l[APPTERM] = l[CLOSURE] = l[CLOSUREREC] = l[PUSHGETGLOBALFIELD] =
  l[GETGLOBALFIELD] = l[MAKEBLOCK] = l[C_CALLN] = 2;

  len /= sizeof(opcode_t);
  for (p = code; p < code + len; /*nothing*/) {
    opcode_t instr = *p;
    if (instr < 0 || instr > STOP){
      fatal_error_arg ("Fatal error in fix_code: bad opcode (%lx)\n",
                       (char *)(long)instr);
    }
    *p++ = (opcode_t)(instr_table[instr] - instr_base);
    if (instr == SWITCH) {
      uint32 sizes = *p++;
      uint32 const_size = sizes & 0xFFFF;
      uint32 block_size = sizes >> 16;
      p += const_size + block_size;
    } else {
      p += l[instr];
    }
  }
  Assert(p == code + len);
}
@

<<function [[set_instruction]]>>=
void set_instruction(code_t pos, opcode_t instr)
{
#ifdef THREADED_CODE
  *pos = (opcode_t)(instr_table[instr] - instr_base);
#else
  *pos = instr;
#endif
}
@


%-------------------------------------------------------------

<<byterun/fix_code.c>>=
<<copyright header C xavier>>

/* Handling of blocks of bytecode (endianness switch, threading). */

#include "config.h"

#ifndef OS_PLAN9
#include <unistd.h>
#endif

#include "debugger.h"
#include "fix_code.h"
#include "instruct.h"
#include "md5.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "reverse.h"

<<global [[start_code]]>>
<<global [[code_size]]>>
<<global [[saved_code]]>>
<<global [[code_md5]]>>

<<function [[load_code]]>>

/* This code is needed only if the processor is big endian */

#ifdef ARCH_BIG_ENDIAN

<<function [[fixup_endianness]]>>

#endif

/* This code is needed only if we're using threaded code */

#ifdef THREADED_CODE

<<global [[instr_table]]>>
<<global [[instr_base]]>>

<<function [[thread_code]]>>

#endif /* THREADED_CODE */

<<function [[set_instruction]]>>

int is_instruction(opcode_t instr1, opcode_t instr2)
{
#ifdef THREADED_CODE
  return instr1 == (opcode_t)(instr_table[instr2] - instr_base);
#else
  return instr1 == instr2;
#endif
}

@


\subsection*{[[byterun/intext.h]]}

<<constant [[Intext_magic_number]]>>=
/* Magic number */

#define Intext_magic_number 0x8495A6BE
@

<<constant [[PREFIX_SMALL_BLOCK]]>>=
/* Codes for the compact format */

#define PREFIX_SMALL_BLOCK 0x80
@

<<constant [[PREFIX_SMALL_INT]]>>=
#define PREFIX_SMALL_INT 0x40
@

<<constant [[PREFIX_SMALL_STRING]]>>=
#define PREFIX_SMALL_STRING 0x20
@

<<constant [[CODE_INT8]]>>=
#define CODE_INT8 0x0
@

<<constant [[CODE_INT16]]>>=
#define CODE_INT16 0x1
@

<<constant [[CODE_INT32]]>>=
#define CODE_INT32 0x2
@

<<constant [[CODE_INT64]]>>=
#define CODE_INT64 0x3
@

<<constant [[CODE_SHARED8]]>>=
#define CODE_SHARED8 0x4
@

<<constant [[CODE_SHARED16]]>>=
#define CODE_SHARED16 0x5
@

<<constant [[CODE_SHARED32]]>>=
#define CODE_SHARED32 0x6
@

<<constant [[CODE_BLOCK32]]>>=
#define CODE_BLOCK32 0x8
@

<<constant [[CODE_STRING8]]>>=
#define CODE_STRING8 0x9
@

<<constant [[CODE_STRING32]]>>=
#define CODE_STRING32 0xA
@

<<constant [[CODE_DOUBLE_BIG]]>>=
#define CODE_DOUBLE_BIG 0xB
@

<<constant [[CODE_DOUBLE_LITTLE]]>>=
#define CODE_DOUBLE_LITTLE 0xC
@

<<constant [[CODE_DOUBLE_ARRAY8_BIG]]>>=
#define CODE_DOUBLE_ARRAY8_BIG 0xD
@

<<constant [[CODE_DOUBLE_ARRAY8_LITTLE]]>>=
#define CODE_DOUBLE_ARRAY8_LITTLE 0xE
@

<<constant [[CODE_DOUBLE_ARRAY32_BIG]]>>=
#define CODE_DOUBLE_ARRAY32_BIG 0xF
@

<<constant [[CODE_DOUBLE_ARRAY32_LITTLE]]>>=
#define CODE_DOUBLE_ARRAY32_LITTLE 0x7
@

<<constant [[CODE_CODEPOINTER]]>>=
#define CODE_CODEPOINTER 0x10
@

<<constant [[CODE_INFIXPOINTER]]>>=
#define CODE_INFIXPOINTER 0x11
@

<<constant [[CODE_DOUBLE_NATIVE]]>>=
#define CODE_DOUBLE_NATIVE CODE_DOUBLE_BIG
@

<<constant [[CODE_DOUBLE_ARRAY8_NATIVE]]>>=
#define CODE_DOUBLE_ARRAY8_NATIVE CODE_DOUBLE_ARRAY8_BIG
@

<<constant [[CODE_DOUBLE_ARRAY32_NATIVE]]>>=
#define CODE_DOUBLE_ARRAY32_NATIVE CODE_DOUBLE_ARRAY32_BIG
@

<<constant [[CODE_DOUBLE_NATIVE]]([[(byterun/intext.h)]])>>=
#define CODE_DOUBLE_NATIVE CODE_DOUBLE_LITTLE
@

<<constant [[CODE_DOUBLE_ARRAY8_NATIVE]]([[(byterun/intext.h)]])>>=
#define CODE_DOUBLE_ARRAY8_NATIVE CODE_DOUBLE_ARRAY8_LITTLE
@

<<constant [[CODE_DOUBLE_ARRAY32_NATIVE]]([[(byterun/intext.h)]])>>=
#define CODE_DOUBLE_ARRAY32_NATIVE CODE_DOUBLE_ARRAY32_LITTLE
@

<<constant [[INITIAL_EXTERN_BLOCK_SIZE]]>>=
#define INITIAL_EXTERN_BLOCK_SIZE 8192
@

<<constant [[INITIAL_EXTERN_TABLE_SIZE]]>>=
#define INITIAL_EXTERN_TABLE_SIZE 2039
@

<<constant [[INITIAL_OFFSET_MAX]]>>=
/* Maximal value of initial_ofs above which we should start again with
   initial_ofs = 1. Should be low enough to prevent rollover of initial_ofs
   next time we extern a structure. Since a structure contains at most 
   2^N / (2 * sizeof(value)) heap objects (N = 32 or 64 depending on target),
   any value below 2^N - (2^N / (2 * sizeof(value))) suffices.
   We just take 2^(N-1) for simplicity. */

#define INITIAL_OFFSET_MAX ((unsigned long)1 << (8 * sizeof(value) - 1))
@

<<constant [[code_area_start]]>>=
#define code_area_start ((char *) start_code)
@

<<constant [[code_area_end]]>>=
#define code_area_end ((char *) start_code + code_size)
@


%-------------------------------------------------------------

<<byterun/intext.h>>=
<<copyright header C xavier>>

/* Structured input/output */

#ifndef _intext_
#define _intext_

#include "misc.h"
#include "mlvalues.h"
#include "io.h"

<<constant [[Intext_magic_number]]>>

<<constant [[PREFIX_SMALL_BLOCK]]>>
<<constant [[PREFIX_SMALL_INT]]>>
<<constant [[PREFIX_SMALL_STRING]]>>
<<constant [[CODE_INT8]]>>
<<constant [[CODE_INT16]]>>
<<constant [[CODE_INT32]]>>
<<constant [[CODE_INT64]]>>
<<constant [[CODE_SHARED8]]>>
<<constant [[CODE_SHARED16]]>>
<<constant [[CODE_SHARED32]]>>
<<constant [[CODE_BLOCK32]]>>
<<constant [[CODE_STRING8]]>>
<<constant [[CODE_STRING32]]>>
<<constant [[CODE_DOUBLE_BIG]]>>
<<constant [[CODE_DOUBLE_LITTLE]]>>
<<constant [[CODE_DOUBLE_ARRAY8_BIG]]>>
<<constant [[CODE_DOUBLE_ARRAY8_LITTLE]]>>
<<constant [[CODE_DOUBLE_ARRAY32_BIG]]>>
<<constant [[CODE_DOUBLE_ARRAY32_LITTLE]]>>
<<constant [[CODE_CODEPOINTER]]>>
<<constant [[CODE_INFIXPOINTER]]>>

#ifdef ARCH_BIG_ENDIAN
<<constant [[CODE_DOUBLE_NATIVE]]>>
<<constant [[CODE_DOUBLE_ARRAY8_NATIVE]]>>
<<constant [[CODE_DOUBLE_ARRAY32_NATIVE]]>>
#else
<<constant [[CODE_DOUBLE_NATIVE]]([[(byterun/intext.h)]])>>
<<constant [[CODE_DOUBLE_ARRAY8_NATIVE]]([[(byterun/intext.h)]])>>
<<constant [[CODE_DOUBLE_ARRAY32_NATIVE]]([[(byterun/intext.h)]])>>
#endif

/* Initial sizes of data structures for extern */

#ifndef INITIAL_EXTERN_BLOCK_SIZE
<<constant [[INITIAL_EXTERN_BLOCK_SIZE]]>>
#endif

#ifndef INITIAL_EXTERN_TABLE_SIZE
<<constant [[INITIAL_EXTERN_TABLE_SIZE]]>>
#endif

<<constant [[INITIAL_OFFSET_MAX]]>>

/* The entry points */

void output_val (struct channel * chan, value v, value flags);
value input_val (struct channel * chan);
value input_val_from_string (value str, long ofs);

/* Auxiliary stuff for sending code pointers */
unsigned char * code_checksum (void);

#ifndef NATIVE_CODE
#include "fix_code.h"
<<constant [[code_area_start]]>>
<<constant [[code_area_end]]>>
#else
extern char * code_area_start, * code_area_end;
#endif


#endif

@


\subsection*{[[byterun/intern.c]]}

<<global [[intern_input_malloced]]>>=
static int intern_input_malloced;
@

<<global [[intern_dest]]>>=
static header_t * intern_dest;
@

<<global [[obj_counter]]([[(byterun/intern.c)]])>>=
static asize_t obj_counter;
@

<<global [[intern_obj_table]]>>=
static value * intern_obj_table;
@

<<global [[intern_color]]>>=
static unsigned int intern_color;
@

<<global [[intern_header]]>>=
static header_t intern_header;
@

<<global [[intern_block]]>>=
static value intern_block;
@

<<constant [[Sign_extend_shift]]>>=
#define Sign_extend_shift ((sizeof(long) - 1) * 8)
@

<<function [[Sign_extend]]>>=
#define Sign_extend(x) (((long)(x) << Sign_extend_shift) >> Sign_extend_shift)
@

<<function [[read8u]]>>=
#define read8u() (*intern_src++)
@

<<function [[read8s]]>>=
#define read8s() Sign_extend(*intern_src++)
@

<<function [[read16u]]>>=
#define read16u() \
  (intern_src += 2, \
   (intern_src[-2] << 8) + intern_src[-1])
@

<<function [[read16s]]>>=
#define read16s() \
  (intern_src += 2, \
   (Sign_extend(intern_src[-2]) << 8) + intern_src[-1])
@

<<function [[read32u]]>>=
#define read32u() \
  (intern_src += 4, \
   (intern_src[-4] << 24) + (intern_src[-3] << 16) + \
   (intern_src[-2] << 8) + intern_src[-1])
@

<<function [[read32s]]>>=
#define read32s() \
  (intern_src += 4, \
   (Sign_extend(intern_src[-4]) << 24) + (intern_src[-3] << 16) + \
   (intern_src[-2] << 8) + intern_src[-1])
@

<<function [[read64s]]>>=
static long read64s(void)
{
  long res;
  int i;
  res = 0;
  for (i = 0; i < 8; i++) res = (res << 8) + intern_src[i];
  intern_src += 8;
  return res;
}
@

<<function [[readblock]]>>=
#define readblock(dest,len) \
  (bcopy(intern_src, dest, len), intern_src += len)
@

<<function [[intern_cleanup]]>>=
static void intern_cleanup(void)
{
  if (intern_input_malloced) stat_free(intern_input);
  if (intern_obj_table != NULL) stat_free(intern_obj_table);
  Hd_val(intern_block) = intern_header; /* Don't confuse the GC */
}
@

<<function [[intern_alloc]]>>=
static void intern_alloc(mlsize_t whsize, mlsize_t num_objects)
{
  mlsize_t wosize;

  if (whsize == 0) {
    intern_obj_table = NULL;
  } else {
    wosize = Wosize_whsize(whsize);
    if (wosize > Max_wosize) failwith("intern: structure too big");

    intern_block = alloc(wosize, String_tag);
    intern_header = Hd_val(intern_block);
    intern_color = Color_hd(intern_header);
    Assert (intern_color == White || intern_color == Black);
    intern_dest = (header_t *) Hp_val(intern_block);
    obj_counter = 0;
    if (num_objects > 0)
      intern_obj_table = (value *) stat_alloc(num_objects * sizeof(value));
    else
      intern_obj_table = NULL;
  }
}
@

<<function [[input_val]]>>=
value input_val(struct channel *chan)
{
  uint32 magic;
  mlsize_t block_len, num_objects, size_32, size_64, whsize;
  value res;

  magic = getword(chan);
  if (magic != Intext_magic_number) failwith("input_value: bad object");
  block_len = getword(chan);
  num_objects = getword(chan);
  size_32 = getword(chan);
  size_64 = getword(chan);
  /* Read block from channel */
  intern_input = (unsigned char *) stat_alloc(block_len);
  intern_input_malloced = 1;
  if (really_getblock(chan, (char *)intern_input, block_len) == 0) {
    stat_free(intern_input);
    failwith("input_value: truncated object");
  }
  intern_src = intern_input;
  /* Allocate result */
#ifdef ARCH_SIXTYFOUR
  whsize = size_64;
#else
  whsize = size_32;
#endif
  intern_alloc(whsize, num_objects);
  /* Fill it in */
  intern_rec(&res);
  /* Free everything */
  stat_free(intern_input);
  if (intern_obj_table != NULL) stat_free(intern_obj_table);
  return res;
}
@

<<function [[input_val_from_string]]>>=
value input_val_from_string(value str, long int ofs)
{
  mlsize_t num_objects, size_32, size_64, whsize;
  value obj;

  intern_src = &Byte_u(str, ofs + 2*4);
  intern_input_malloced = 0;
  num_objects = read32u();
  size_32 = read32u();
  size_64 = read32u();
  /* Allocate result */
#ifdef ARCH_SIXTYFOUR
  whsize = size_64;
#else
  whsize = size_32;
#endif
  Begin_root(str);
    intern_alloc(whsize, num_objects);
  End_roots();
  intern_src = &Byte_u(str, ofs + 5*4); /* If a GC occurred */
  /* Fill it in */
  intern_rec(&obj);
  /* Free everything */
  if (intern_obj_table != NULL) stat_free(intern_obj_table);
  return obj;
}
@

<<function [[input_value_from_string]]>>=
value input_value_from_string(value str, value ofs) /* ML */
{
  return input_val_from_string(str, Long_val(ofs));
}
@

<<function [[marshal_data_size]]>>=
value marshal_data_size(value buff, value ofs) /* ML */
{
  uint32 magic;
  mlsize_t block_len;

  intern_src = &Byte_u(buff, Long_val(ofs));
  intern_input_malloced = 0;
  magic = read32u();
  if (magic != Intext_magic_number) failwith("Marshal.data_size: bad object");
  block_len = read32u();
  return Val_long(block_len);
}
@

<<function [[code_checksum]]>>=
unsigned char * code_checksum()
{
  static unsigned char checksum[16];
  static int checksum_computed = 0;

  if (! checksum_computed) {
    struct MD5Context ctx;
    MD5Init(&ctx);
    MD5Update(&ctx,
              (unsigned char *) code_area_start,
              code_area_end - code_area_start);
    MD5Final(checksum, &ctx);
    checksum_computed = 1;
  }
  return checksum;
}
@

<<function [[code_checksum]]([[(byterun/intern.c)]])>>=
unsigned char * code_checksum(void)
{
  return code_md5;
}
@


%-------------------------------------------------------------

<<byterun/intern.c>>=
<<copyright header C xavier>>

/* Structured input, compact format */

#include "config.h"
#ifndef OS_PLAN9
#include <string.h>
#endif

#include "alloc.h"
#include "fail.h"
#include "gc.h"
#include "intext.h"
#include "io.h"
#include "memory.h"
#include "mlvalues.h"
#include "misc.h"
#include "reverse.h"

static unsigned char * intern_input;
static unsigned char * intern_src;
<<global [[intern_input_malloced]]>>
<<global [[intern_dest]]>>
<<global [[obj_counter]]([[(byterun/intern.c)]])>>
<<global [[intern_obj_table]]>>
<<global [[intern_color]]>>
<<global [[intern_header]]>>
<<global [[intern_block]]>>

<<constant [[Sign_extend_shift]]>>
<<function [[Sign_extend]]>>

<<function [[read8u]]>>
<<function [[read8s]]>>
<<function [[read16u]]>>
<<function [[read16s]]>>
<<function [[read32u]]>>
<<function [[read32s]]>>

#ifdef ARCH_SIXTYFOUR
<<function [[read64s]]>>
#endif

<<function [[readblock]]>>

<<function [[intern_cleanup]]>>

static void intern_rec(value *dest)
{
  unsigned int code;
  tag_t tag;
  mlsize_t size, len, ofs_ind;
  value v, clos;
  asize_t ofs;
  header_t header;
  char cksum[16];

 tailcall:
  code = read8u();
  if (code >= PREFIX_SMALL_INT) {
    if (code >= PREFIX_SMALL_BLOCK) {
      /* Small block */
      tag = code & 0xF;
      size = (code >> 4) & 0x7;
    read_block:
      if (size == 0) {
        v = Atom(tag);
      } else {
        v = Val_hp(intern_dest);
        *dest = v;
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        dest = (value *) (intern_dest + 1);
        *intern_dest = Make_header(size, tag, intern_color);
        intern_dest += 1 + size;
        for(/*nothing*/; size > 1; size--, dest++)
          intern_rec(dest);
        goto tailcall;
      }
    } else {
      /* Small integer */
      v = Val_int(code & 0x3F);
    }
  } else {
    if (code >= PREFIX_SMALL_STRING) {
      /* Small string */
      len = (code & 0x1F);
    read_string:
      size = (len + sizeof(value)) / sizeof(value);
      v = Val_hp(intern_dest);
      if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
      *intern_dest = Make_header(size, String_tag, intern_color);
      intern_dest += 1 + size;
      Field(v, size - 1) = 0;
      ofs_ind = Bsize_wsize(size) - 1;
      Byte(v, ofs_ind) = ofs_ind - len;
      readblock(String_val(v), len);
    } else {
      switch(code) {
      case CODE_INT8:
        v = Val_long(read8s());
        break;
      case CODE_INT16:
        v = Val_long(read16s());
        break;
      case CODE_INT32:
        v = Val_long(read32s());
        break;
      case CODE_INT64:
#ifdef ARCH_SIXTYFOUR
        v = Val_long(read64s());
        break;
#else
        intern_cleanup();
        failwith("input_value: integer too large");
        break;
#endif
      case CODE_SHARED8:
        ofs = read8u();
      read_shared:
        Assert(ofs > 0 && ofs <= obj_counter && intern_obj_table != NULL); 
        v = intern_obj_table[obj_counter - ofs];
        break;
      case CODE_SHARED16:
        ofs = read16u();
        goto read_shared;
      case CODE_SHARED32:
        ofs = read32u();
        goto read_shared;
      case CODE_BLOCK32:
        header = (header_t) read32u();
        tag = Tag_hd(header);
        size = Wosize_hd(header);
        goto read_block;
      case CODE_STRING8:
        len = read8u();
        goto read_string;
      case CODE_STRING32:
        len = read32u();
        goto read_string;
      case CODE_DOUBLE_LITTLE:
      case CODE_DOUBLE_BIG:
        if (sizeof(double) != 8) {
          intern_cleanup();
          invalid_argument("input_value: non-standard floats");
        }
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(Double_wosize, Double_tag, intern_color);
        intern_dest += 1 + Double_wosize;
        readblock((char *) v, 8);
        if (code != CODE_DOUBLE_NATIVE) Reverse_double(v);
        break;
      case CODE_DOUBLE_ARRAY8_LITTLE:
      case CODE_DOUBLE_ARRAY8_BIG:
        len = read8u();
      read_double_array:
#ifdef NATIVE_CODE
        if (sizeof(double) != 8) {
          intern_cleanup();
          invalid_argument("input_value: non-standard floats");
        }
        size = len * Double_wosize;
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(size, Double_array_tag, intern_color);
        intern_dest += 1 + size;
        readblock((char *) v, len * 8);
        if (code != CODE_DOUBLE_ARRAY8_NATIVE && 
            code != CODE_DOUBLE_ARRAY32_NATIVE) {
          mlsize_t i;
          for (i = 0; i < len; i++) Reverse_double((value)((double *)v + i));
        }
#else
        intern_cleanup();
        failwith("input_value: cannot read float array");
#endif
        break;
      case CODE_DOUBLE_ARRAY32_LITTLE:
      case CODE_DOUBLE_ARRAY32_BIG:
        len = read32u();
        goto read_double_array;
      case CODE_CODEPOINTER:
        ofs = read32u();
        readblock(cksum, 16);
        if (memcmp(cksum, code_checksum(), 16) != 0) {
          intern_cleanup();
          failwith("input_value: code mismatch");
        }
        v = (value) (code_area_start + ofs);
        break;
      case CODE_INFIXPOINTER:
        ofs = read32u();
        intern_rec(&clos);
        v = clos + ofs;
        break;
      default:
        intern_cleanup();
        failwith("input_value: ill-formed message");
      }
    }
  }
  *dest = v;
}

<<function [[intern_alloc]]>>

<<function [[input_val]]>>

<<function [[input_value]]>>

<<function [[input_val_from_string]]>>

<<function [[input_value_from_string]]>>

<<function [[marshal_data_size]]>>

/* Return an MD5 checksum of the code area */

#ifdef NATIVE_CODE

#include "md5.h"

<<function [[code_checksum]]>>

#else

#include "fix_code.h"

<<function [[code_checksum]]([[(byterun/intern.c)]])>>

#endif
@


\subsection*{[[byterun/ints.c]]}

<<function [[int_of_string]]>>=
value int_of_string(value s)          /* ML */
{
  long res;
  int sign;
  int base;
  char * p;
  int c, d;

  p = String_val(s);
  if (*p == 0) failwith("int_of_string");
  sign = 1;
  if (*p == '-') {
    sign = -1;
    p++;
  }
  base = 10;
  if (*p == '0') {
    switch (p[1]) {
    case 'x': case 'X':
      base = 16; p += 2; break;
    case 'o': case 'O':
      base = 8; p += 2; break;
    case 'b': case 'B':
      base = 2; p += 2; break;
    }
  }
  res = 0;
  while (1) {
    c = *p;
    if (c >= '0' && c <= '9')
      d = c - '0';
    else if (c >= 'A' && c <= 'F')
      d = c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
      d = c - 'a' + 10;
    else
      break;
    if (d >= base) break;
    res = base * res + d;
    p++;
  }
  if (*p != 0)
    failwith("int_of_string");
  return Val_long(sign < 0 ? -res : res);
}
@

<<function [[format_int]]>>=
value format_int(value fmt, value arg)      /* ML */
{
  char format_string[32], format_buffer[32];
  int prec;
  char * p;
  char * dest;
  mlsize_t len;
  value res;

  prec = 32;
  for (p = String_val(fmt); *p != 0; p++) {
    if (*p >= '0' && *p <= '9') {
      prec = atoi(p) + 5;
      break;
    }
  }
  if (prec <= sizeof(format_buffer)) {
    dest = format_buffer;
  } else {
    dest = stat_alloc(prec);
  }
  len = string_length(fmt);
  if (len >= sizeof(format_string) - 1)
    invalid_argument("format_int: format too long");
  bcopy(String_val(fmt), format_string, len);
  format_string[len + 1] = 0;
  format_string[len] = format_string[len - 1];
  format_string[len - 1] = 'l';
  sprintf(dest, format_string, Long_val(arg));
  res = copy_string(dest);
  if (dest != format_buffer) {
    stat_free(dest);
  }
  return res;
}
@


%-------------------------------------------------------------

<<byterun/ints.c>>=
<<copyright header C xavier>>

#include "config.h"

#ifndef OS_PLAN9
#include <stdio.h>
#include <string.h>
#else
#endif

#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "str.h"

<<function [[int_of_string]]>>

<<function [[format_int]]>>
@


\subsection*{[[byterun/floats.c]]}

<<function [[Double_val]]>>=
double Double_val(value val)
{
  union { value v[2]; double d; } buffer;

  Assert(sizeof(double) == 2 * sizeof(value));
  buffer.v[0] = Field(val, 0);
  buffer.v[1] = Field(val, 1);
  return buffer.d;
}
@

<<function [[Store_double_val]]>>=
void Store_double_val(value val, double dbl)
{
  union { value v[2]; double d; } buffer;

  Assert(sizeof(double) == 2 * sizeof(value));
  buffer.d = dbl;
  Field(val, 0) = buffer.v[0];
  Field(val, 1) = buffer.v[1];
}
@

<<function [[copy_double]]>>=
value copy_double(double d)
{
  value res;

#define Setup_for_gc
#define Restore_after_gc
  Alloc_small(res, Double_wosize, Double_tag);
#undef Setup_for_gc
#undef Restore_after_gc
  Store_double_val(res, d);
  return res;
}
@

<<function [[format_float]]>>=
value format_float(value fmt, value arg)    /* ML */
{
#define MAX_DIGITS 350
/* Max number of decimal digits in a "natural" (not artificially padded)
   representation of a float. Can be quite big for %f format.
   Max exponent for IEEE format is 308 decimal digits.
   Rounded up for good measure. */
  char format_buffer[MAX_DIGITS + 20];
  int prec, i;
  char * p;
  char * dest;
  value res;

  prec = MAX_DIGITS;
  for (p = String_val(fmt); *p != 0; p++) {
    if (*p >= '0' && *p <= '9') {
      i = atoi(p) + MAX_DIGITS;
      if (i > prec) prec = i;
      break;
    }
  }
  for( ; *p != 0; p++) {
    if (*p == '.') {
      i = atoi(p+1) + MAX_DIGITS;
      if (i > prec) prec = i;
      break;
    }
  }
  if (prec <= sizeof(format_buffer)) {
    dest = format_buffer;
  } else {
    dest = stat_alloc(prec);
  }
  sprintf(dest, String_val(fmt), Double_val(arg));
  res = copy_string(dest);
  if (dest != format_buffer) {
    stat_free(dest);
  }
  return res;
}
@

<<function [[float_of_string]]>>=
value float_of_string(value s)        /* ML */
{
  return copy_double(atof(String_val(s)));
}
@

<<function [[int_of_float]]>>=
value int_of_float(value f)           /* ML */
{
  return Val_long((long) Double_val(f));
}
@

<<function [[float_of_int]]>>=
value float_of_int(value n)           /* ML */
{
  return copy_double((double) Long_val(n));
}
@

<<function [[neg_float]]>>=
value neg_float(value f)              /* ML */
{
  return copy_double(- Double_val(f));
}
@

<<function [[abs_float]]>>=
value abs_float(value f)              /* ML */
{
  return copy_double(fabs(Double_val(f)));
}
@

<<function [[add_float]]>>=
value add_float(value f, value g)         /* ML */
{
  return copy_double(Double_val(f) + Double_val(g));
}
@

<<function [[sub_float]]>>=
value sub_float(value f, value g)         /* ML */
{
  return copy_double(Double_val(f) - Double_val(g));
}
@

<<function [[mul_float]]>>=
value mul_float(value f, value g)         /* ML */
{
  return copy_double(Double_val(f) * Double_val(g));
}
@

<<function [[div_float]]>>=
value div_float(value f, value g)         /* ML */
{
  double dg = Double_val(g);
  return copy_double(Double_val(f) / dg);
}
@

<<function [[exp_float]]>>=
value exp_float(value f)              /* ML */
{
  return copy_double(exp(Double_val(f)));
}
@

<<function [[floor_float]]>>=
value floor_float(value f)              /* ML */
{
  return copy_double(floor(Double_val(f)));
}
@

<<function [[fmod_float]]>>=
value fmod_float(value f1, value f2)              /* ML */
{
  return copy_double(fmod(Double_val(f1), Double_val(f2)));
}
@

<<function [[frexp_float]]>>=
value frexp_float(value f)              /* ML */
{
  int exponent;
  value res;
  value mantissa = copy_double(frexp (Double_val(f), &exponent));

  Begin_root(mantissa);
    res = alloc_tuple(2);
    Field(res, 0) = mantissa;
    Field(res, 1) = Val_int(exponent);
  End_roots();
  return res;
}
@

<<function [[ldexp_float]]>>=
value ldexp_float(value f, value i)              /* ML */
{
  return copy_double(ldexp(Double_val(f), Int_val(i)));
}
@

<<function [[log_float]]>>=
value log_float(value f)              /* ML */
{
  return copy_double(log(Double_val(f)));
}
@

<<function [[log10_float]]>>=
value log10_float(value f)              /* ML */
{
  return copy_double(log10(Double_val(f)));
}
@

<<function [[modf_float]]>>=
value modf_float(value f)              /* ML */
{
  double frem;
  value res;
  value quo = Val_unit, rem = Val_unit;

  Begin_roots2(quo,rem);
    quo = copy_double(modf (Double_val(f), &frem));
    rem = copy_double(frem);
    res = alloc_tuple(2);
    Field(res, 0) = quo;
    Field(res, 1) = rem;
  End_roots();
  return res;
}
@

<<function [[sqrt_float]]>>=
value sqrt_float(value f)             /* ML */
{
  return copy_double(sqrt(Double_val(f)));
}
@

<<function [[power_float]]>>=
value power_float(value f, value g)         /* ML */
{
  return copy_double(pow(Double_val(f), Double_val(g)));
}
@

<<function [[sin_float]]>>=
value sin_float(value f)              /* ML */
{
  return copy_double(sin(Double_val(f)));
}
@

<<function [[sinh_float]]>>=
value sinh_float(value f)              /* ML */
{
  return copy_double(sinh(Double_val(f)));
}
@

<<function [[cos_float]]>>=
value cos_float(value f)              /* ML */
{
  return copy_double(cos(Double_val(f)));
}
@

<<function [[cosh_float]]>>=
value cosh_float(value f)              /* ML */
{
  return copy_double(cosh(Double_val(f)));
}
@

<<function [[tan_float]]>>=
value tan_float(value f)              /* ML */
{
  return copy_double(tan(Double_val(f)));
}
@

<<function [[tanh_float]]>>=
value tanh_float(value f)              /* ML */
{
  return copy_double(tanh(Double_val(f)));
}
@

<<function [[asin_float]]>>=
value asin_float(value f)             /* ML */
{
  return copy_double(asin(Double_val(f)));
}
@

<<function [[acos_float]]>>=
value acos_float(value f)             /* ML */
{
  return copy_double(acos(Double_val(f)));
}
@

<<function [[atan_float]]>>=
value atan_float(value f)             /* ML */
{
  return copy_double(atan(Double_val(f)));
}
@

<<function [[atan2_float]]>>=
value atan2_float(value f, value g)        /* ML */
{
  return copy_double(atan2(Double_val(f), Double_val(g)));
}
@

<<function [[ceil_float]]>>=
value ceil_float(value f)              /* ML */
{
  return copy_double(ceil(Double_val(f)));
}
@

<<function [[eq_float]]>>=
value eq_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) == Double_val(g));
}
@

<<function [[neq_float]]>>=
value neq_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) != Double_val(g));
}
@

<<function [[le_float]]>>=
value le_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) <= Double_val(g));
}
@

<<function [[lt_float]]>>=
value lt_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) < Double_val(g));
}
@

<<function [[ge_float]]>>=
value ge_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) >= Double_val(g));
}
@

<<function [[gt_float]]>>=
value gt_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) > Double_val(g));
}
@

<<function [[init_ieee_floats]]>>=
void init_ieee_floats(void)
{
#ifdef __i386__
#ifdef __FreeBSD__
  fpsetmask(0);
#endif
#endif
}
@


%-------------------------------------------------------------

<<byterun/floats.c>>=
<<copyright header C xavier>>

#include "config.h"

#ifndef OS_PLAN9
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#else
#endif

#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "mlvalues.h"
#include "misc.h"
#include "stacks.h"

#ifdef ARCH_ALIGN_DOUBLE

<<function [[Double_val]]>>

<<function [[Store_double_val]]>>

#endif

<<function [[copy_double]]>>

<<function [[format_float]]>>

<<function [[float_of_string]]>>

<<function [[int_of_float]]>>

<<function [[float_of_int]]>>

<<function [[neg_float]]>>

<<function [[abs_float]]>>

<<function [[add_float]]>>

<<function [[sub_float]]>>

<<function [[mul_float]]>>

<<function [[div_float]]>>

<<function [[exp_float]]>>

<<function [[floor_float]]>>

<<function [[fmod_float]]>>

<<function [[frexp_float]]>>

<<function [[ldexp_float]]>>

<<function [[log_float]]>>

<<function [[log10_float]]>>

<<function [[modf_float]]>>

<<function [[sqrt_float]]>>

<<function [[power_float]]>>

<<function [[sin_float]]>>

<<function [[sinh_float]]>>

<<function [[cos_float]]>>

<<function [[cosh_float]]>>

<<function [[tan_float]]>>

<<function [[tanh_float]]>>

<<function [[asin_float]]>>

<<function [[acos_float]]>>

<<function [[atan_float]]>>

<<function [[atan2_float]]>>

<<function [[ceil_float]]>>

<<function [[eq_float]]>>

<<function [[neq_float]]>>

<<function [[le_float]]>>

<<function [[lt_float]]>>

<<function [[ge_float]]>>

<<function [[gt_float]]>>

/* The init_ieee_float function should initialize floating-point hardware
   so that it behaves as much as possible like the IEEE standard.
   In particular, return special numbers like Infinity and NaN instead
   of signalling exceptions. So far, only the Intel 386 under
   FreeBSD is not in IEEE mode at program startup.  */

#ifdef __i386__
#ifdef __FreeBSD__
#include <floatingpoint.h>
#endif
#endif

<<function [[init_ieee_floats]]>>
@


\subsection*{[[byterun/io.h]]}

<<constant [[IO_BUFFER_SIZE]]>>=
#define IO_BUFFER_SIZE 4096
@

<<struct [[channel]]>>=
struct channel {
  int fd;                       /* Unix file descriptor */
  long offset;                  /* Absolute position of fd in the file */
  char * end;                   /* Physical end of the buffer */
  char * curr;                  /* Current position in the buffer */
  char * max;                   /* Logical end of the buffer (for input) */
  void * mutex;                 /* Placeholder for mutex (for systhreads) */
  char buff[IO_BUFFER_SIZE];    /* The buffer itself */
};
@

<<function [[putch]]>>=
/* Functions and macros that can be called from C.  Take arguments of
   type struct channel *.  No locking is performed. */

#define putch(channel, ch)                                                  \
  { if ((channel)->curr >= (channel)->end) flush_partial(channel);          \
    *((channel)->curr)++ = (ch); }
@

<<function [[getch]]>>=
#define getch(channel)                                                      \
  ((channel)->curr >= (channel)->max                                        \
   ? refill(channel)                                                        \
   : (unsigned char) *((channel))->curr++)
@

<<function [[Channel]]>>=
/* Extract a struct channel * from the heap object representing it */

#define Channel(v) ((struct channel *) Field(v, 1))
@


%-------------------------------------------------------------

<<byterun/io.h>>=
<<copyright header C xavier>>

/* Buffered input/output */

#ifndef _io_
#define _io_

#include "misc.h"
#include "mlvalues.h"

#ifndef IO_BUFFER_SIZE
<<constant [[IO_BUFFER_SIZE]]>>
#endif

<<struct [[channel]]>>

/* For an output channel:
     [offset] is the absolute position of the beginning of the buffer [buff].
   For an input channel:
     [offset] is the absolute position of the logical end of the buffer, [max].
*/

<<function [[putch]]>>

<<function [[getch]]>>

struct channel * open_descriptor (int);
void close_channel (struct channel *);

int flush_partial (struct channel *);
void flush (struct channel *);
void putword (struct channel *, uint32);
int putblock (struct channel *, char *, long);
void really_putblock (struct channel *, char *, long);

unsigned char refill (struct channel *);
uint32 getword (struct channel *);
int getblock (struct channel *, char *, long);
int really_getblock (struct channel *, char *, long);

<<function [[Channel]]>>

/* The locking machinery */

extern void (*channel_mutex_free) (struct channel *);
extern void (*channel_mutex_lock) (struct channel *);
extern void (*channel_mutex_unlock) (struct channel *);
extern void (*channel_mutex_unlock_exn) (void);

#define Lock(channel) \
  if (channel_mutex_lock != NULL) (*channel_mutex_lock)(channel)
#define Unlock(channel) \
  if (channel_mutex_unlock != NULL) (*channel_mutex_unlock)(channel)
#define Unlock_exn() \
  if (channel_mutex_unlock_exn != NULL) (*channel_mutex_unlock_exn)()

#endif /* _io_ */
@


\subsection*{[[byterun/io.c]]}

<<global [[channel_mutex_free]]>>=
/* Hooks for locking channels */

void (*channel_mutex_free) (struct channel *) = NULL;
@

<<global [[channel_mutex_lock]]>>=
void (*channel_mutex_lock) (struct channel *) = NULL;
@

<<global [[channel_mutex_unlock]]>>=
void (*channel_mutex_unlock) (struct channel *) = NULL;
@

<<global [[channel_mutex_unlock_exn]]>>=
void (*channel_mutex_unlock_exn) (void) = NULL;
@

<<function [[open_descriptor]]>>=
/* Basic functions over type struct channel *.
   These functions can be called directly from C.
   No locking is performed. */

struct channel * open_descriptor(int fd)
{
  struct channel * channel;

  channel = (struct channel *) stat_alloc(sizeof(struct channel));
  channel->fd = fd;
  channel->offset = 0;
  channel->curr = channel->max = channel->buff;
  channel->end = channel->buff + IO_BUFFER_SIZE;
  channel->mutex = NULL;
  return channel;
}
@

<<function [[close_channel]]>>=
void close_channel(struct channel *channel)
{
  close(channel->fd);
  if (channel_mutex_free != NULL) (*channel_mutex_free)(channel);
  stat_free(channel);
}  
@

<<function [[channel_size]]>>=
long channel_size(struct channel *channel)
{
  long end;

  end = lseek(channel->fd, 0, SEEK_END);
  if (end == -1 ||
      lseek(channel->fd, channel->offset, SEEK_SET) != channel->offset) {
    sys_error(NO_ARG);
  }
  return end;
}
@

<<constant [[EINTR]]>>=
#define EINTR (-1)
@

<<constant [[EAGAIN]]>>=
#define EAGAIN (-1)
@

<<constant [[EWOULDBLOCK]]>>=
#define EWOULDBLOCK (-1)
@

<<function [[do_write]]>>=
static int do_write(int fd, char *p, int n)
{
  int retcode;

  Assert(!Is_young(p));
again:
  enter_blocking_section();
  retcode = write(fd, p, n);
  leave_blocking_section();
  if (retcode == -1) {
    if (errno == EINTR) goto again;
    if (errno == EAGAIN 
#ifdef EWOULDBLOCK
       || errno == EWOULDBLOCK
#endif
) {
      /* We couldn't do a partial write here, probably because
         n <= PIPE_BUF and POSIX says that writes of less than
         PIPE_BUF characters must be atomic.
         So, we force a partial write of 1 character.
         This should always succeed if we've done a select
         on writing just before. */
      if (n > 1) { n = 1; goto again; }
    }
  }
  if (retcode == -1) sys_error(NO_ARG);
  return retcode;
}
@

<<function [[flush_partial]]>>=
/* Attempt to flush the buffer. This will make room in the buffer for
   at least one character. Returns true if the buffer is empty at the
   end of the flush, or false if some data remains in the buffer. */

int flush_partial(struct channel *channel)
{
  int towrite, written;

  Lock(channel);
  towrite = channel->curr - channel->buff;
  if (towrite > 0) {
    written = do_write(channel->fd, channel->buff, towrite);
    channel->offset += written;
    if (written < towrite)
      bcopy(channel->buff + written, channel->buff, towrite - written);
    channel->curr -= written;
  }
  Unlock(channel);
  return (channel->curr == channel->buff);
}
@

<<function [[flush]]>>=
/* Flush completely the buffer. */

void flush(struct channel *channel)
{
  while (! flush_partial(channel)) /*nothing*/;
}
@

<<function [[putword]]>>=
/* Output data */

void putword(struct channel *channel, uint32 w)
{
  putch(channel, w >> 24);
  putch(channel, w >> 16);
  putch(channel, w >> 8);
  putch(channel, w);
}
@

<<function [[putblock]]>>=
int putblock(struct channel *channel, char *p, long int len)
{
  int n, free, towrite, written;

  n = len >= INT_MAX ? INT_MAX : (int) len;
  free = channel->end - channel->curr;
  if (n <= free) {
    /* Write request small enough to fit in buffer: transfer to buffer. */
    bcopy(p, channel->curr, n);
    channel->curr += n;
    return n;
  } else {
    /* Write request overflows buffer: transfer whatever fits to buffer
       and write the buffer */
    bcopy(p, channel->curr, free);
    towrite = channel->end - channel->buff;
    written = do_write(channel->fd, channel->buff, towrite);
    if (written < towrite)
      bcopy(channel->buff + written, channel->buff, towrite - written);
    channel->offset += written;
    channel->curr = channel->end - written;
    channel->max = channel->end - written;
    return free;
  }
}
@

<<function [[really_putblock]]>>=
void really_putblock(struct channel *channel, char *p, long int len)
{
  int written;
  while (len > 0) {
    written = putblock(channel, p, len);
    p += written;
    len -= written;
  }
}
@

<<function [[seek_out]]>>=
void seek_out(struct channel *channel, long int dest)
{
  flush(channel);
  if (lseek(channel->fd, dest, 0) != dest) sys_error(NO_ARG);
  channel->offset = dest;
}
@

<<function [[pos_out]]>>=
long pos_out(struct channel *channel)
{
  return channel->offset + channel->curr - channel->buff;
}
@

<<function [[do_read]]>>=
/* Input */

static int do_read(int fd, char *p, unsigned int n)
{
  int retcode;

  Assert(!Is_young(p));
  enter_blocking_section();
  do { retcode = read(fd, p, n); } while (retcode == -1 && errno == EINTR);
  leave_blocking_section();
  if (retcode == -1) sys_error(NO_ARG);
  return retcode;
}
@

<<function [[refill]]>>=
unsigned char refill(struct channel *channel)
{
  int n;

  n = do_read(channel->fd, channel->buff, IO_BUFFER_SIZE);
  if (n == 0) raise_end_of_file();
  channel->offset += n;
  channel->max = channel->buff + n;
  channel->curr = channel->buff + 1;
  return (unsigned char)(channel->buff[0]);
}
@

<<function [[getword]]>>=
uint32 getword(struct channel *channel)
{
  int i;
  uint32 res;

  res = 0;
  for(i = 0; i < 4; i++) {
    res = (res << 8) + getch(channel);
  }
  return res;
}
@

<<function [[getblock]]>>=
int getblock(struct channel *channel, char *p, long int len)
{
  int n, avail, nread;

  n = len >= INT_MAX ? INT_MAX : (int) len;
  avail = channel->max - channel->curr;
  if (n <= avail) {
    bcopy(channel->curr, p, n);
    channel->curr += n;
    return n;
  } else if (avail > 0) {
    bcopy(channel->curr, p, avail);
    channel->curr += avail;
    return avail;
  } else if (n < IO_BUFFER_SIZE) {
    nread = do_read(channel->fd, channel->buff, IO_BUFFER_SIZE);
    channel->offset += nread;
    channel->max = channel->buff + nread;
    if (n > nread) n = nread;
    bcopy(channel->buff, p, n);
    channel->curr = channel->buff + n;
    return n;
  } else {
    nread = do_read(channel->fd, p, n);
    channel->offset += nread;
    return nread;
  }
}
@

<<function [[really_getblock]]>>=
int really_getblock(struct channel *chan, char *p, long int n)
{
  int r;
  while (n > 0) {
    r = getblock(chan, p, n);
    if (r == 0) break;
    p += r;
    n -= r;
  }
  return (n == 0);
}
@

<<function [[seek_in]]>>=
void seek_in(struct channel *channel, long int dest)
{
  if (dest >= channel->offset - (channel->max - channel->buff) &&
      dest <= channel->offset) {
    channel->curr = channel->max - (channel->offset - dest);
  } else {
    if (lseek(channel->fd, dest, SEEK_SET) != dest) sys_error(NO_ARG);
    channel->offset = dest;
    channel->curr = channel->max = channel->buff;
  }
}
@

<<function [[pos_in]]>>=
long pos_in(struct channel *channel)
{
  return channel->offset - (channel->max - channel->curr);
}
@

<<function [[input_scan_line]]>>=
long input_scan_line(struct channel *channel)
{
  char * p;
  int n;

  p = channel->curr;
  do {
    if (p >= channel->max) {
      /* No more characters available in the buffer */
      if (channel->curr > channel->buff) {
        /* Try to make some room in the buffer by shifting the unread
           portion at the beginning */
        bcopy(channel->curr, channel->buff, channel->max - channel->curr);
        n = channel->curr - channel->buff;
        channel->curr -= n;
        channel->max -= n;
        p -= n;
      }
      if (channel->max >= channel->end) {
        /* Buffer is full, no room to read more characters from the input.
           Return the number of characters in the buffer, with negative
           sign to indicate that no newline was encountered. */
        return -(channel->max - channel->curr);
      }
      /* Fill the buffer as much as possible */
      n = do_read(channel->fd, channel->max, channel->end - channel->max);
      if (n == 0) {
        /* End-of-file encountered. Return the number of characters in the
           buffer, with negative sign since we haven't encountered 
           a newline. */
        return -(channel->max - channel->curr);
      }
      channel->offset += n;
      channel->max += n;
    }
  } while (*p++ != '\n');
  /* Found a newline. Return the length of the line, newline included. */
  return (p - channel->curr);
}
@

<<function [[finalize_channel]]>>=
/* Caml entry points for the I/O functions.  Wrap struct channel *
   objects into a heap-allocated, finalized object.  Perform locking
   and unlocking around the I/O operations. */

static void finalize_channel(value vchan)
{
  struct channel * chan = Channel(vchan);
  if (channel_mutex_free != NULL) (*channel_mutex_free)(chan);
  stat_free(chan);
}
@

<<function [[alloc_channel]]>>=
static value alloc_channel(struct channel *chan)
{
  value res = alloc_final(2, finalize_channel, 1, 32);
  Field(res, 1) = (value) chan;
  return res;
}
@

<<function [[caml_open_descriptor]]>>=
value caml_open_descriptor(value fd)       /* ML */
{
  return alloc_channel(open_descriptor(Int_val(fd)));
}
@

<<function [[channel_descriptor]]>>=
value channel_descriptor(value vchannel)   /* ML */
{
  return Val_long(Channel(vchannel)->fd);
}
@

<<function [[caml_close_channel]]>>=
value caml_close_channel(value vchannel)      /* ML */
{
  /* For output channels, must have flushed before */
  struct channel * channel = Channel(vchannel);
  close(channel->fd);
  channel->fd = -1;
  return Val_unit;
}
@

<<function [[caml_channel_size]]>>=
value caml_channel_size(value vchannel)      /* ML */
{
  return Val_long(channel_size(Channel(vchannel)));
}
@

<<function [[caml_flush_partial]]>>=
value caml_flush_partial(value vchannel)            /* ML */
{
  return Val_bool(flush_partial(Channel(vchannel)));
}
@

<<function [[caml_flush]]>>=
value caml_flush(value vchannel)            /* ML */
{
  flush(Channel(vchannel));
  return Val_unit;
}
@

<<function [[caml_output_char]]>>=
value caml_output_char(value vchannel, value ch)  /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  putch(channel, Long_val(ch));
  Unlock(channel);
  return Val_unit;
}
@

<<function [[caml_output_int]]>>=
value caml_output_int(value vchannel, value w)    /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  putword(channel, Long_val(w));
  Unlock(channel);
  return Val_unit;
}
@

<<function [[caml_seek_out]]>>=
value caml_seek_out(value vchannel, value pos)    /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  seek_out(channel, Long_val(pos));
  Unlock(channel);
  return Val_unit;
}
@

<<function [[caml_pos_out]]>>=
value caml_pos_out(value vchannel)          /* ML */
{
  return Val_long(pos_out(Channel(vchannel)));
}
@

<<function [[caml_input_char]]>>=
value caml_input_char(value vchannel)       /* ML */
{
  struct channel * channel = Channel(vchannel);
  unsigned char c;

  Lock(channel);
  c = getch(channel);
  Unlock(channel);
  return Val_long(c);
}
@

<<function [[caml_input_int]]>>=
value caml_input_int(value vchannel)        /* ML */
{
  struct channel * channel = Channel(vchannel);
  long i;

  Lock(channel);
  i = getword(channel);
  Unlock(channel);
#ifdef ARCH_SIXTYFOUR
  i = (i << 32) >> 32;          /* Force sign extension */
#endif
  return Val_long(i);
}
@

<<function [[caml_seek_in]]>>=
value caml_seek_in(value vchannel, value pos)     /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  seek_in(channel, Long_val(pos));
  Unlock(channel);
  return Val_unit;
}
@

<<function [[caml_pos_in]]>>=
value caml_pos_in(value vchannel)           /* ML */
{
  return Val_long(pos_in(Channel(vchannel)));
}
@

<<function [[caml_input_scan_line]]>>=
value caml_input_scan_line(value vchannel)       /* ML */
{
  struct channel * channel = Channel(vchannel);
  long res;

  Lock(channel);
  res = input_scan_line(channel);
  Unlock(channel);
  return Val_long(res);
}
@


%-------------------------------------------------------------

<<byterun/io.c>>=
<<copyright header C xavier>>

/* Buffered input/output. */

#include "config.h"

#ifndef OS_PLAN9
// EINTR, EAGAIN, EWOULDBLOCK
#include <errno.h>
#include <fcntl.h>
#include <string.h>
// SEEK_xxx
#include <unistd.h>
// INT_MAX
#include <limits.h>
#else
#endif

#include "alloc.h"
#include "fail.h"
#include "io.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "signals.h"
#include "sys.h"

<<global [[channel_mutex_free]]>>
<<global [[channel_mutex_lock]]>>
<<global [[channel_mutex_unlock]]>>
<<global [[channel_mutex_unlock_exn]]>>

<<function [[open_descriptor]]>>

<<function [[close_channel]]>>

<<function [[channel_size]]>>

/* Output */

<<function [[do_write]]>>

<<function [[flush_partial]]>>

<<function [[flush]]>>

<<function [[putword]]>>

<<function [[putblock]]>>

<<function [[really_putblock]]>>

<<function [[seek_out]]>>

<<function [[pos_out]]>>

<<function [[do_read]]>>

<<function [[refill]]>>

<<function [[getword]]>>

<<function [[getblock]]>>

<<function [[really_getblock]]>>

<<function [[seek_in]]>>

<<function [[pos_in]]>>

<<function [[input_scan_line]]>>

<<function [[finalize_channel]]>>

<<function [[alloc_channel]]>>

<<function [[caml_open_descriptor]]>>

<<function [[channel_descriptor]]>>

<<function [[caml_close_channel]]>>

<<function [[caml_channel_size]]>>

<<function [[caml_flush_partial]]>>

<<function [[caml_flush]]>>

<<function [[caml_output_char]]>>

<<function [[caml_output_int]]>>

value caml_output_partial(value vchannel, value buff, value start, value length) /* ML */
{
  struct channel * channel = Channel(vchannel);
  int res;
  Begin_root(buff)
    Lock(channel);
    res = putblock(channel, &Byte(buff, Long_val(start)), Long_val(length));
    Unlock(channel);
  End_roots();
  return Val_int(res);
}

<<function [[caml_output]]>>

<<function [[caml_seek_out]]>>

<<function [[caml_pos_out]]>>

<<function [[caml_input_char]]>>

<<function [[caml_input_int]]>>

<<function [[caml_input]]>>

<<function [[caml_seek_in]]>>

<<function [[caml_pos_in]]>>

<<function [[caml_input_scan_line]]>>

@


\subsection*{[[byterun/lexing.c]]}

<<struct [[lexer_buffer]]>>=
struct lexer_buffer {
  value refill_buff;
  value lex_buffer;
  value lex_buffer_len;
  value lex_abs_pos;
  value lex_start_pos;
  value lex_curr_pos;
  value lex_last_pos;
  value lex_last_action;
  value lex_eof_reached;
};
@

<<struct [[lexing_table]]>>=
struct lexing_table {
  value lex_base;
  value lex_backtrk;
  value lex_default;
  value lex_trans;
  value lex_check;
};
@

<<function [[Short]] (ifdef [[ARCH_BIG_ENDIAN]])>>=
#define Short(tbl,n) \
  (*((unsigned char *)((tbl) + (n) * sizeof(short))) + \
          (*((schar *)((tbl) + (n) * sizeof(short) + 1)) << 8))
@

<<function [[Short]]>>=
#define Short(tbl,n) (((short *)(tbl))[n])
@

<<function [[lex_engine]]>>=
value lex_engine(struct lexing_table *tbl, value start_state, struct lexer_buffer *lexbuf)     /* ML */
{
  int state, base, backtrk, c;

  state = Int_val(start_state);
  if (state >= 0) {
    /* First entry */
    lexbuf->lex_last_pos = lexbuf->lex_start_pos = lexbuf->lex_curr_pos;
    lexbuf->lex_last_action = Val_int(-1);
  } else {
    /* Reentry after refill */
    state = -state - 1;
  }
  while(1) {
    /* Lookup base address or action number for current state */
    base = Short(tbl->lex_base, state);
    if (base < 0) return Val_int(-base-1);
    /* See if it's a backtrack point */
    backtrk = Short(tbl->lex_backtrk, state);
    if (backtrk >= 0) {
      lexbuf->lex_last_pos = lexbuf->lex_curr_pos;
      lexbuf->lex_last_action = Val_int(backtrk);
    }
    /* See if we need a refill */
    if (lexbuf->lex_curr_pos >= lexbuf->lex_buffer_len){
      if (lexbuf->lex_eof_reached == Val_bool (0)){
        return Val_int(-state - 1);
      }else{
        c = 256;
      }
    }else{
      /* Read next input char */
      c = Byte_u(lexbuf->lex_buffer, Long_val(lexbuf->lex_curr_pos));
      lexbuf->lex_curr_pos += 2;
    }
    /* Determine next state */
    if (Short(tbl->lex_check, base + c) == state)
      state = Short(tbl->lex_trans, base + c);
    else
      state = Short(tbl->lex_default, state);
    /* If no transition on this char, return to last backtrack point */
    if (state < 0) {
      lexbuf->lex_curr_pos = lexbuf->lex_last_pos;
      if (lexbuf->lex_last_action == Val_int(-1)) {
        failwith("lexing: empty token");
      } else {
        return lexbuf->lex_last_action;
      }
    }else{
      /* Erase the EOF condition only if the EOF pseudo-character was
         consumed by the automaton (i.e. there was no backtrack above)
       */
      if (c == 256) lexbuf->lex_eof_reached = Val_bool (0);
    }
  }
}
@


%-------------------------------------------------------------

<<byterun/lexing.c>>=
<<copyright header C xavier>>

/* The table-driven automaton for lexers generated by camllex. */

#include "config.h"

#include "fail.h"
#include "mlvalues.h"
#include "stacks.h"
#include "str.h"

<<struct [[lexer_buffer]]>>

<<struct [[lexing_table]]>>

#ifdef ARCH_BIG_ENDIAN
<<function [[Short]] (ifdef [[ARCH_BIG_ENDIAN]])>>
#else
<<function [[Short]]>>
#endif

<<function [[lex_engine]]>>

@


\subsection*{[[byterun/md5.h]]}

<<struct [[MD5Context]]>>=
struct MD5Context {
        uint32 buf[4];
        uint32 bits[2];
        unsigned char in[64];
};
@


%-------------------------------------------------------------

<<byterun/md5.h>>=
/* MD5 message digest */

#ifndef _md5
#define _md5

#include "mlvalues.h"
#include "io.h"

value md5_string (value str, value ofs, value len);
value md5_chan (value vchan, value len);

<<struct [[MD5Context]]>>

void MD5Init (struct MD5Context *context);
void MD5Update (struct MD5Context *context, unsigned char *buf, unsigned len);
void MD5Final (unsigned char *digest, struct MD5Context *ctx);
void MD5Transform (uint32 *buf, uint32 *in);


#endif
@


\subsection*{[[byterun/md5.c]]}

<<function [[md5_string]]>>=
/* MD5 message digest */

value md5_string(value str, value ofs, value len) /* ML */
{
  struct MD5Context ctx;
  value res;
  MD5Init(&ctx);
  MD5Update(&ctx, &Byte_u(str, Long_val(ofs)), Long_val(len));
  res = alloc_string(16);
  MD5Final(&Byte_u(res, 0), &ctx);
  return res;
}
@

<<function [[md5_chan]]>>=
value md5_chan(value vchan, value len)       /* ML */
{
  struct channel * chan = Channel(vchan);
  struct MD5Context ctx;
  value res;
  long toread, read;
  char buffer[4096];

  Lock(chan);
  MD5Init(&ctx);
  toread = Long_val(len);
  while (toread > 0) {
    read = getblock(chan, buffer,
                    toread > sizeof(buffer) ? sizeof(buffer) : toread);
    if (read == 0) raise_end_of_file();
    MD5Update(&ctx, (unsigned char *) buffer, read);
    toread -= read;
  }
  res = alloc_string(16);
  MD5Final(&Byte_u(res, 0), &ctx);
  Unlock(chan);
  return res;
}
@

<<macro [[byteReverse]]>>=
#define byteReverse(buf, len)   /* Nothing */
@

<<function [[byteReverse]]>>=
static void byteReverse(unsigned char * buf, unsigned longs)
{
    uint32 t;
    do {
        t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
            ((unsigned) buf[1] << 8 | buf[0]);
        *(uint32 *) buf = t;
        buf += 4;
    } while (--longs);
}
@

<<function [[MD5Init]]>>=
/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}
@

<<function [[MD5Update]]>>=
/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned int len)
{
    uint32 t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
        ctx->bits[1]++;         /* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if (t) {
        unsigned char *p = (unsigned char *) ctx->in + t;

        t = 64 - t;
        if (len < t) {
            memcpy(p, buf, len);
            return;
        }
        memcpy(p, buf, t);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);
        buf += t;
        len -= t;
    }
    /* Process data in 64-byte chunks */

    while (len >= 64) {
        memcpy(ctx->in, buf, 64);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);
        buf += 64;
        len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}
@

<<function [[MD5Final]]>>=
/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void MD5Final(unsigned char *digest, struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
        /* Two lots of padding:  Pad the first block to 64 bytes */
        memset(p, 0, count);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);

        /* Now fill the next block with 56 bytes */
        memset(ctx->in, 0, 56);
    } else {
        /* Pad block to 56 bytes */
        memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
}
@

<<function [[F1]]>>=
/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
@

<<function [[F2]]>>=
#define F2(x, y, z) F1(z, x, y)
@

<<function [[F3]]>>=
#define F3(x, y, z) (x ^ y ^ z)
@

<<function [[F4]]>>=
#define F4(x, y, z) (y ^ (x | ~z))
@

<<function [[MD5STEP]]>>=
/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
@

<<function [[MD5Transform]]>>=
/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
void MD5Transform(uint32 *buf, uint32 *in)
{
    register uint32 a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}
@


%-------------------------------------------------------------

<<byterun/md5.c>>=
<<copyright header C xavier>>

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#endif

#include "alloc.h"
#include "fail.h"
#include "md5.h"
#include "mlvalues.h"
#include "io.h"
#include "reverse.h"

<<function [[md5_string]]>>

<<function [[md5_chan]]>>

/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

#ifndef ARCH_BIG_ENDIAN
<<macro [[byteReverse]]>>
#else
<<function [[byteReverse]]>>
#endif

<<function [[MD5Init]]>>

<<function [[MD5Update]]>>

<<function [[MD5Final]]>>

/* The four core functions - F1 is optimized somewhat */

<<function [[F1]]>>
<<function [[F2]]>>
<<function [[F3]]>>
<<function [[F4]]>>

<<function [[MD5STEP]]>>

<<function [[MD5Transform]]>>

@


\subsection*{[[byterun/meta.c]]}

<<function [[get_global_data]]>>=
value get_global_data(value unit)     /* ML */
{
  return global_data;
}
@

<<function [[reify_bytecode]]>>=
value reify_bytecode(value prog, value len) /* ML */
{
  value clos;
#ifdef ARCH_BIG_ENDIAN
  fixup_endianness((code_t) prog, (asize_t) Long_val(len));
#endif
#ifdef THREADED_CODE
  thread_code((code_t) prog, (asize_t) Long_val(len));
#endif
  clos = alloc_small (1, Closure_tag);
  Code_val(clos) = (code_t) prog;
  return clos;
}
@

<<function [[realloc_global]]>>=
value realloc_global(value size)      /* ML */
{
  mlsize_t requested_size, actual_size, i;
  value new_global_data;

  requested_size = Long_val(size);
  actual_size = Wosize_val(global_data);
  if (requested_size >= actual_size) {
    requested_size = (requested_size + 0x100) & 0xFFFFFF00;
    gc_message ("Growing global data to %lu entries.\n", requested_size);
    new_global_data = alloc_shr(requested_size, 0);
    for (i = 0; i < actual_size; i++)
      initialize(&Field(new_global_data, i), Field(global_data, i));
    for (i = actual_size; i < requested_size; i++){
      Field (new_global_data, i) = Val_long (0);
    }
    global_data = new_global_data;
  }
  return Val_unit;
}
@

<<function [[available_primitives]]>>=
value available_primitives(value unit)    /* ML */
{
  return copy_string_array(names_of_cprim);
}
@

<<function [[get_current_environment]]>>=
value get_current_environment(value unit) /* ML */
{
  return *extern_sp;
}
@

<<function [[get_global_data]]([[(byterun/meta.c)]])>>=
/* Dummy definitions to support compilation of ocamlc.opt */

value get_global_data(value unit)
{
  invalid_argument("Meta.get_global_data");
}
@

<<function [[realloc_global]]([[(byterun/meta.c)]])>>=
value realloc_global(value size)
{
  invalid_argument("Meta.realloc_global");
}
@

<<function [[available_primitives]]([[(byterun/meta.c)]])>>=
value available_primitives(value unit)
{
  invalid_argument("Meta.available_primitives");
}
@


%-------------------------------------------------------------

<<byterun/meta.c>>=
<<copyright header C xavier>>

/* Primitives for the toplevel */

#include "alloc.h"
#include "config.h"
#include "fail.h"
#include "fix_code.h"
#include "interp.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"
#include "stacks.h"

#ifndef NATIVE_CODE

<<function [[get_global_data]]>>

<<function [[reify_bytecode]]>>

<<function [[realloc_global]]>>
    
<<function [[available_primitives]]>>

<<function [[get_current_environment]]>>

#else

<<function [[get_global_data]]([[(byterun/meta.c)]])>>

<<function [[realloc_global]]([[(byterun/meta.c)]])>>
    
<<function [[available_primitives]]([[(byterun/meta.c)]])>>

#endif
@


\subsection*{[[byterun/misc.h]]}

%less: rename compatibility.h?

<<constant [[Noreturn]]>>=
/* Works only in GCC 2.5 and later */
#define Noreturn __attribute ((noreturn))
@

<<constant [[Noreturn]]([[(byterun/misc.h)]])>>=
#define Noreturn
@

<<function [[Assert]]>>=
#define Assert(x)
@


%-------------------------------------------------------------

<<byterun/misc.h>>=
<<copyright header C xavier and damien>>

/* Miscellaneous macros and variables. */

#ifndef _misc_
#define _misc_


#include "config.h"

/* Standard definitions */

#ifndef OS_PLAN9
#include <stddef.h>
#include <stdlib.h>
#else
#endif

/* Basic types and constants */

typedef size_t asize_t;

typedef char * addr;

#ifdef __GNUC__
<<constant [[Noreturn]]>>
#else
<<constant [[Noreturn]]([[(byterun/misc.h)]])>>
#endif

/* Assertions */

#ifdef DEBUG
#define Assert(x) if (!(x)) failed_assert ( #x , __FILE__, __LINE__)
#else
<<function [[Assert]]>>
#endif

void failed_assert (char *, char *, int) Noreturn;
void fatal_error (char *) Noreturn;
void fatal_error_arg (char *, char *) Noreturn;

/* GC flags and messages */

extern int verb_gc;
void gc_message (char *, unsigned long);

/* Memory routines */

void memmov (char *, char *, unsigned long);
char *aligned_malloc (asize_t, int, void **);

#ifdef DEBUG
unsigned long not_random (void);
#endif


#endif /* _misc_ */
@


\subsection*{[[byterun/misc.c]]}

<<function [[failed_assert]]>>=
void failed_assert (char * expr, char * file, int line)
{
  fprintf (stderr, "Assertion failed: %s; file %s; line %d\n",
           expr, file, line);
  exit (100);
}
@

<<global [[seed]]>>=
static unsigned long seed = 0x12345;
@

<<function [[not_random]]>>=
unsigned long not_random (void)
{
  seed = seed * 65537 + 12345;
  return seed;
}
@


<<function [[fatal_error]]>>=
void fatal_error (char *msg)
{
  fprintf (stderr, "%s", msg);
  exit(2);
}
@

<<function [[fatal_error_arg]]>>=
void fatal_error_arg (char *fmt, char *arg)
{
  fprintf (stderr, fmt, arg);
  exit(2);
}
@

%<<function memmov>>=
%/* This should work on 64-bit machines as well as 32-bit machines.
%   It assumes a long is the natural size for memory reads and writes.
%*/
%void memmov (char * dst, char * src, unsigned long length)
%{
%  unsigned long i;
%
%  if ((unsigned long) dst <= (unsigned long) src){
%
%      /* Copy in ascending order. */
%    if (((unsigned long) src - (unsigned long) dst) % sizeof (long) != 0){
%
%        /* The pointers are not equal modulo sizeof (long).
%           Copy byte by byte. */
%      for (; length != 0; length--){
%        *dst++ = *src++;
%      }
%    }else{
%
%        /* Copy the first few bytes. */
%      i = (unsigned long) dst % sizeof (long);
%      if (i != 0){
%        i = sizeof (long) - i;              /* Number of bytes to copy. */
%        if (i > length) i = length;         /* Never copy more than length.*/
%        for (; i != 0; i--){
%          *dst++ = *src++; --length;
%        }
%      }                    Assert ((unsigned long) dst % sizeof (long) == 0);
%                           Assert ((unsigned long) src % sizeof (long) == 0);
%
%      /* Then copy as many entire words as possible. */
%      for (i = length / sizeof (long); i > 0; i--){
%        *(long *) dst = *(long *) src;
%        dst += sizeof (long); src += sizeof (long);
%      }
%
%      /* Then copy the last few bytes. */
%      for (i = length % sizeof (long); i > 0; i--){
%        *dst++ = *src++;
%      }
%    }
%  }else{                                       /* Copy in descending order. */
%    src += length; dst += length;
%    if (((unsigned long) dst - (unsigned long) src) % sizeof (long) != 0){
%
%        /* The pointers are not equal modulo sizeof (long).
%           Copy byte by byte. */
%      for (; length > 0; length--){
%        *--dst = *--src;
%      }
%    }else{
%
%        /* Copy the first few bytes. */
%      i = (unsigned long) dst % sizeof (long);
%      if (i > length) i = length;           /* Never copy more than length. */
%      for (; i > 0; i--){
%        *--dst = *--src; --length;
%      }
%
%        /* Then copy as many entire words as possible. */
%      for (i = length / sizeof (long); i > 0; i--){
%        dst -= sizeof (long); src -= sizeof (long);
%        *(long *) dst = *(long *) src;
%      }
%
%        /* Then copy the last few bytes. */
%      for (i = length % sizeof (long); i > 0; i--){
%        *--dst = *--src;
%      }
%    }
%  }
%}
%@

<<function [[aligned_malloc]]>>=
char *aligned_malloc (asize_t size, int modulo, void **block)
                  
                
                        /* output */
{
  char *raw_mem;
  unsigned long aligned_mem;
                                                 Assert (modulo < Page_size);
  raw_mem = (char *) malloc (size + Page_size);
  if (raw_mem == NULL) return NULL;
  *block = raw_mem;
  raw_mem += modulo;                /* Address to be aligned */
  aligned_mem = (((unsigned long) raw_mem / Page_size + 1) * Page_size);
  return (char *) (aligned_mem - modulo);
}
@


%-------------------------------------------------------------

<<byterun/misc.c>>=
<<copyright header C xavier and damien>>

#include "config.h"

#ifndef OS_PLAN9
#include <stdio.h>
#else
#endif

#include "misc.h"

#ifdef DEBUG

<<function [[failed_assert]]>>

<<global [[seed]]>>

<<function [[not_random]]>>

#endif

<<global [[verb_gc]]>>

<<function [[gc_message]]>>

<<function [[fatal_error]]>>

<<function [[fatal_error_arg]]>>

<<function [[aligned_malloc]]>>
@


\subsection*{[[byterun/obj.c]]}

<<function [[static_alloc]]>>=
value static_alloc(value size)        /* ML */
{
  return (value) stat_alloc((asize_t) Long_val(size));
}
@

<<function [[static_free]]>>=
value static_free(value blk)          /* ML */
{
  stat_free((void *) blk);
  return Val_unit;
}
@

<<function [[static_resize]]>>=
value static_resize(value blk, value new_size) /* ML */
{
  return (value) stat_resize((char *) blk, (asize_t) Long_val(new_size));
}
@



<<function [[obj_block]]>>=
value obj_block(value tag, value size) /* ML */
{
  value res;
  mlsize_t sz, i;
  tag_t tg;

  sz = Long_val(size);
  tg = Long_val(tag);
  if (sz == 0) return Atom(tg);
  res = alloc(sz, tg);
  for (i = 0; i < sz; i++)
    Field(res, i) = Val_long(0);

  return res;
}
@


%-------------------------------------------------------------

<<byterun/obj.c>>=
<<copyright header C xavier>>

/* Operations on objects */

#include "alloc.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"

<<function [[static_alloc]]>>

<<function [[static_free]]>>

<<function [[static_resize]]>>

<<function [[obj_is_block]]>>

<<function [[obj_tag]]>>

<<function [[obj_block]]>>

@


\subsection*{[[byterun/parsing.c]]}

<<constant [[ERRCODE]]>>=
#define ERRCODE 256
@

<<struct [[parser_tables]]>>=
struct parser_tables {    /* Mirrors parse_tables in ../stdlib/parsing.mli */
  value actions;
  value transl_const;
  value transl_block;
  char * lhs;
  char * len;
  char * defred;
  char * dgoto;
  char * sindex;
  char * rindex;
  char * gindex;
  value tablesize;
  char * table;
  char * check;
  value error_function;
};
@

<<struct [[parser_env]]>>=
struct parser_env {       /* Mirrors parser_env in ../stdlib/parsing.ml */
  value s_stack;
  value v_stack;
  value symb_start_stack;
  value symb_end_stack;
  value stacksize;
  value stackbase;
  value curr_char;
  value lval;
  value symb_start;
  value symb_end;
  value asp;
  value rule_len;
  value rule_number;
  value sp;
  value state;
  value errflag;
};
@

<<function [[Short]]([[(byterun/parsing.c)]])>>=
#define Short(tbl,n) \
  (*((unsigned char *)((tbl) + (n) * sizeof(short))) + \
          (*((schar *)((tbl) + (n) * sizeof(short) + 1)) << 8))
@

<<function Short (byterun/parsing.c)2>>=
#define Short(tbl,n) (((short *)(tbl))[n])
@

<<global [[parser_trace]]>>=
int parser_trace = 0;
@

<<function [[Trace]]>>=
#define Trace(act) if(parser_trace) act
@

<<function [[Trace]]([[(byterun/parsing.c)]])>>=
#define Trace(act)
@

<<constant [[START]]>>=
/* Mirrors parser_input in ../stdlib/parsing.ml */
#define START 0
@

<<constant [[TOKEN_READ]]>>=
#define TOKEN_READ 1
@

<<constant [[STACKS_GROWN_1]]>>=
#define STACKS_GROWN_1 2
@

<<constant [[STACKS_GROWN_2]]>>=
#define STACKS_GROWN_2 3
@

<<constant [[SEMANTIC_ACTION_COMPUTED]]>>=
#define SEMANTIC_ACTION_COMPUTED 4
@

<<constant [[ERROR_DETECTED]]>>=
#define ERROR_DETECTED 5
@

<<constant [[READ_TOKEN]]>>=
/* Mirrors parser_output in ../stdlib/parsing.ml */
#define READ_TOKEN Val_int(0) 
@

<<constant [[RAISE_PARSE_ERROR]]>>=
#define RAISE_PARSE_ERROR Val_int(1)
@

<<constant [[GROW_STACKS_1]]>>=
#define GROW_STACKS_1 Val_int(2)
@

<<constant [[GROW_STACKS_2]]>>=
#define GROW_STACKS_2 Val_int(3)
@

<<constant [[COMPUTE_SEMANTIC_ACTION]]>>=
#define COMPUTE_SEMANTIC_ACTION Val_int(4)
@

<<constant [[CALL_ERROR_FUNCTION]]>>=
#define CALL_ERROR_FUNCTION Val_int(5)
@

<<constant [[SAVE]]>>=
/* To preserve local variables when communicating with the ML code */

#define SAVE \
  env->sp = Val_int(sp), \
  env->state = Val_int(state), \
  env->errflag = Val_int(errflag)
@

<<constant [[RESTORE]]>>=
#define RESTORE \
  sp = Int_val(env->sp), \
  state = Int_val(env->state), \
  errflag = Int_val(env->errflag)
@

<<function [[parse_engine]]>>=
/* The pushdown automata */

value parse_engine(struct parser_tables *tables, struct parser_env *env, value cmd, value arg) /* ML */
{
  int state;
  mlsize_t sp, asp;
  int errflag;
  int n, n1, n2, m, state1;

  switch(Int_val(cmd)) {

  case START:
    state = 0;
    sp = Int_val(env->sp);
    errflag = 0;

  loop:
    Trace(printf("Loop %d\n", state));
    n = Short(tables->defred, state);
    if (n != 0) goto reduce;
    if (Int_val(env->curr_char) >= 0) goto testshift;
    SAVE;
    return READ_TOKEN;
                                /* The ML code calls the lexer and updates */
                                /* symb_start and symb_end */
  case TOKEN_READ:
    RESTORE;
    if (Is_block(arg)) {
      env->curr_char = Field(tables->transl_block, Tag_val(arg));
      modify(&env->lval, Field(arg, 0));
    } else {
      env->curr_char = Field(tables->transl_const, Int_val(arg));
      modify(&env->lval, Val_long(0));
    }
    Trace(printf("Token %d (0x%lx)\n", Int_val(env->curr_char), env->lval));
    
  testshift:
    n1 = Short(tables->sindex, state);
    n2 = n1 + Int_val(env->curr_char);
    if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
        Short(tables->check, n2) == Int_val(env->curr_char)) goto shift;
    n1 = Short(tables->rindex, state);
    n2 = n1 + Int_val(env->curr_char);
    if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
        Short(tables->check, n2) == Int_val(env->curr_char)) {
      n = Short(tables->table, n2);
      goto reduce;
    }
    if (errflag > 0) goto recover;
    SAVE;
    return CALL_ERROR_FUNCTION;
                                /* The ML code calls the error function */
  case ERROR_DETECTED:
    RESTORE;
  recover:
    if (errflag < 3) {
      errflag = 3;
      while (1) {
        state1 = Int_val(Field(env->s_stack, sp));
        n1 = Short(tables->sindex, state1);
        n2 = n1 + ERRCODE;
        if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
            Short(tables->check, n2) == ERRCODE) {
          Trace(printf("Recovering in state %d\n", state1));
          goto shift_recover;
        } else {
          Trace(printf("Discarding state %d\n", state1));
          if (sp <= Int_val(env->stackbase)) {
            Trace(printf("Fallen off bottom\n"));
            return RAISE_PARSE_ERROR; /* The ML code raises Parse_error */
          }
          sp--;
        }
      }
    } else {
      if (Int_val(env->curr_char) == 0)
        return RAISE_PARSE_ERROR; /* The ML code raises Parse_error */
      Trace(printf("Discarding token %d (0x%lx)\n",
                   Int_val(env->curr_char), env->lval));
      env->curr_char = Val_int(-1);
      goto loop;
    }
    
  shift:
    env->curr_char = Val_int(-1);
    if (errflag > 0) errflag--;
  shift_recover:
    state = Short(tables->table, n2);
    Trace(printf("Shift %d\n", state));
    sp++;
    if (sp < Long_val(env->stacksize)) goto push;
    SAVE;
    return GROW_STACKS_1;
                                 /* The ML code resizes the stacks */
  case STACKS_GROWN_1:
    RESTORE;
  push:
    Field(env->s_stack, sp) = Val_int(state);
    modify(&Field(env->v_stack, sp), env->lval);
    Field(env->symb_start_stack, sp) = env->symb_start;
    Field(env->symb_end_stack, sp) = env->symb_end;
    goto loop;

  reduce:
    Trace(printf("Reduce %d\n", n));
    m = Short(tables->len, n);
    env->asp = Val_int(sp);
    env->rule_number = Val_int(n);
    env->rule_len = Val_int(m);
    sp = sp - m + 1;
    m = Short(tables->lhs, n);
    state1 = Int_val(Field(env->s_stack, sp - 1));
    n1 = Short(tables->gindex, m);
    n2 = n1 + state1;
    if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
        Short(tables->check, n2) == state1) {
      state = Short(tables->table, n2);
    } else {
      state = Short(tables->dgoto, m);
    }
    if (sp < Long_val(env->stacksize)) goto semantic_action;
    SAVE;
    return GROW_STACKS_2;
                                /* The ML code resizes the stacks */
  case STACKS_GROWN_2:
    RESTORE;
  semantic_action:
    SAVE;
    return COMPUTE_SEMANTIC_ACTION;
                                /* The ML code calls the semantic action */
  case SEMANTIC_ACTION_COMPUTED:
    RESTORE;
    Field(env->s_stack, sp) = Val_int(state);
    modify(&Field(env->v_stack, sp), arg);
    asp = Int_val(env->asp);
    Field(env->symb_end_stack, sp) = Field(env->symb_end_stack, asp);
    if (sp > asp) {
      /* This is an epsilon production. Take symb_start equal to symb_end. */
      Field(env->symb_start_stack, sp) = Field(env->symb_end_stack, asp);
    }
    goto loop;

  default:                      /* Should not happen */
    Assert(0);
    return RAISE_PARSE_ERROR;   /* Keeps gcc -Wall happy */
  }
  
}
@


%-------------------------------------------------------------

<<byterun/parsing.c>>=
<<copyright header C xavier>>

/* The PDA automaton for parsers generated by camlyacc */

#include "config.h"

#ifndef OS_PLAN9
#include <stdio.h>
#endif

#include "mlvalues.h"
#include "memory.h"
#include "alloc.h"

<<constant [[ERRCODE]]>>

<<struct [[parser_tables]]>>

<<struct [[parser_env]]>>

#ifdef ARCH_BIG_ENDIAN
<<function [[Short]]([[(byterun/parsing.c)]])>>
#else
<<function Short (byterun/parsing.c)2>>
#endif

#ifdef DEBUG
<<global [[parser_trace]]>>
<<function [[Trace]]>>
#else
<<function [[Trace]]([[(byterun/parsing.c)]])>>
#endif

/* Input codes */
<<constant [[START]]>>
<<constant [[TOKEN_READ]]>>
<<constant [[STACKS_GROWN_1]]>>
<<constant [[STACKS_GROWN_2]]>>
<<constant [[SEMANTIC_ACTION_COMPUTED]]>>
<<constant [[ERROR_DETECTED]]>>

/* Output codes */
<<constant [[READ_TOKEN]]>>
<<constant [[RAISE_PARSE_ERROR]]>>
<<constant [[GROW_STACKS_1]]>>
<<constant [[GROW_STACKS_2]]>>
<<constant [[COMPUTE_SEMANTIC_ACTION]]>>
<<constant [[CALL_ERROR_FUNCTION]]>>

<<constant [[SAVE]]>>

<<constant [[RESTORE]]>>

<<function [[parse_engine]]>>
@


\subsection*{[[byterun/printexc.c]]}

<<struct [[stringbuf]]>>=
struct stringbuf {
  char * ptr;
  char * end;
  char data[256];
};
@

<<function [[add_char]]>>=
static void add_char(struct stringbuf *buf, char c)
{
  if (buf->ptr < buf->end) *(buf->ptr++) = c;
}
@

<<function [[add_string]]>>=
static void add_string(struct stringbuf *buf, char *s)
{
  int len = strlen(s);
  if (buf->ptr + len > buf->end) len = buf->end - buf->ptr;
  if (len > 0) bcopy(s, buf->ptr, len);
  buf->ptr += len;
}
@

<<function [[errprintf]]>>=
#define errprintf(fmt,arg) fprintf(stderr, fmt, arg)
@

<<function [[fatal_uncaught_exception]]>>=
void fatal_uncaught_exception(value exn)
{
  mlsize_t start, i;
  value bucket, v;
  struct stringbuf buf;
  char intbuf[64];

  buf.ptr = buf.data;
  buf.end = buf.data + sizeof(buf.data) - 1;
  add_string(&buf, String_val(Field(Field(exn, 0), 0)));
  if (Wosize_val(exn) >= 2) {
    /* Check for exceptions in the style of Match_failure and Assert_failure */
    if (Wosize_val(exn) == 2 &&
        Is_block(Field(exn, 1)) &&
        Tag_val(Field(exn, 1)) == 0) {
      bucket = Field(exn, 1);
      start = 0;
    } else {
      bucket = exn;
      start = 1;
    }
    add_char(&buf, '(');
    for (i = start; i < Wosize_val(bucket); i++) {
      if (i > start) add_string(&buf, ", ");
      v = Field(bucket, i);
      if (Is_long(v)) {
        sprintf(intbuf, "%ld", Long_val(v));
        add_string(&buf, intbuf);
      } else if (Tag_val(v) == String_tag) {
        add_char(&buf, '"');
        add_string(&buf, String_val(v));
        add_char(&buf, '"');
      } else {
        add_char(&buf, '_');
      }
    }
    add_char(&buf, ')');
  }
  *buf.ptr = 0;              /* Terminate string */
  errprintf("Fatal error: uncaught exception %s\n", buf.data);
  if (backtrace_active && !debugger_in_use) print_exception_backtrace();

  exit(2);
}
@


%-------------------------------------------------------------

<<byterun/printexc.c>>=
<<copyright header C xavier>>

/* Print an uncaught exception and abort */

#include "config.h"

#ifndef OS_PLAN9
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#else
#endif

#include "fail.h"
#include "misc.h"
#include "mlvalues.h"
#include "backtrace.h"
#include "debugger.h"

<<struct [[stringbuf]]>>

<<function [[add_char]]>>

<<function [[add_string]]>>
  
<<function [[errprintf]]>>

<<function [[fatal_uncaught_exception]]>>
@


\subsection*{[[byterun/reverse.h]]}


<<function [[Reverse_int32]]>>=
#define Reverse_int32(w) {                                                    \
  char * _p;                                                                  \
  int _a;                                                                     \
  _p = (char *) (w);                                                          \
  _a = _p[0];                                                                 \
  _p[0] = _p[3];                                                              \
  _p[3] = _a;                                                                 \
  _a = _p[1];                                                                 \
  _p[1] = _p[2];                                                              \
  _p[2] = _a;                                                                 \
}
@

<<function [[Reverse_int64]]>>=
#define Reverse_int64(d) {                                                    \
  char * _p;                                                                  \
  int _a;                                                                     \
  _p = (char *) (d);                                                          \
  _a = _p[0];                                                                 \
  _p[0] = _p[7];                                                              \
  _p[7] = _a;                                                                 \
  _a = _p[1];                                                                 \
  _p[1] = _p[6];                                                              \
  _p[6] = _a;                                                                 \
  _a = _p[2];                                                                 \
  _p[2] = _p[5];                                                              \
  _p[5] = _a;                                                                 \
  _a = _p[3];                                                                 \
  _p[3] = _p[4];                                                              \
  _p[4] = _a;                                                                 \
}
@

<<constant [[Reverse_double]]>>=
#define Reverse_double Reverse_int64
@


%-------------------------------------------------------------

<<byterun/reverse.h>>=
<<copyright header C xavier>>

/* Swap byte-order in 32-bit integers and in words */

#ifndef _reverse_
#define _reverse_

<<function [[Reverse_int32]]>>

<<function [[Reverse_int64]]>>

<<constant [[Reverse_double]]>>


#endif /* _reverse_ */
@


\subsection*{[[byterun/signals.h]]}

%-------------------------------------------------------------

<<byterun/signals.h>>=
<<copyright header C xavier and damien>>

#ifndef _signals_
#define _signals_

#include "misc.h"
#include "mlvalues.h"

extern value signal_handlers;
extern volatile int pending_signal;
extern volatile int something_to_do;
extern volatile int force_major_slice;
extern volatile int async_signal_mode;

void enter_blocking_section (void);
void leave_blocking_section (void);
void urge_major_slice (void);

extern void (*enter_blocking_section_hook)();
extern void (*leave_blocking_section_hook)();

#endif /* _signals_ */

@


\subsection*{[[byterun/signals.c]]}

<<global [[async_signal_mode]]>>=
volatile int async_signal_mode = 0;
@

<<global [[pending_signal]]>>=
volatile int pending_signal = 0;
@

<<global [[something_to_do]]>>=
volatile int something_to_do = 0;
@

<<global [[force_major_slice]]>>=
volatile int force_major_slice = 0;
@

<<global [[signal_handlers]]>>=
value signal_handlers = 0;
@

<<global [[enter_blocking_section_hook]]>>=
void (*enter_blocking_section_hook)() = NULL;
@

<<global [[leave_blocking_section_hook]]>>=
void (*leave_blocking_section_hook)() = NULL;
@

<<function [[execute_signal]]>>=
static void execute_signal(int signal_number)
{
  Assert (!async_signal_mode);
  callback(Field(signal_handlers, signal_number), Val_int(signal_number));
}
@

<<function [[handle_signal]]>>=
void handle_signal(int signal_number)
{
#ifndef POSIX_SIGNALS
#ifndef BSD_SIGNALS
  signal(signal_number, handle_signal);
#endif
#endif
  if (async_signal_mode){
    leave_blocking_section ();
    execute_signal(signal_number);
    enter_blocking_section ();
  }else{
    pending_signal = signal_number;
    something_to_do = 1;
  }
}
@

<<function [[urge_major_slice]]>>=
void urge_major_slice (void)
{
  force_major_slice = 1;
  something_to_do = 1;
}
@

<<function [[enter_blocking_section]]>>=
void enter_blocking_section(void)
{
  int temp;

  while (1){
    Assert (!async_signal_mode);
    /* If a signal arrives between the next two instructions,
       it will be lost. */
    temp = pending_signal;   pending_signal = 0;
    if (temp) execute_signal(temp);
    async_signal_mode = 1;
    if (!pending_signal) break;
    async_signal_mode = 0;
  }
  if (enter_blocking_section_hook != NULL) enter_blocking_section_hook();
}
@

<<function [[leave_blocking_section]]>>=
void leave_blocking_section(void)
{
  if (leave_blocking_section_hook != NULL) leave_blocking_section_hook();
  Assert(async_signal_mode);
  async_signal_mode = 0;
}
@

<<constant [[SIGABRT]]>>=
#define SIGABRT -1
@

<<constant [[SIGALRM]]>>=
#define SIGALRM -1
@

<<constant [[SIGFPE]]>>=
#define SIGFPE -1
@

<<constant [[SIGHUP]]>>=
#define SIGHUP -1
@

<<constant [[SIGILL]]>>=
#define SIGILL -1
@

<<constant [[SIGINT]]>>=
#define SIGINT -1
@

<<constant [[SIGKILL]]>>=
#define SIGKILL -1
@

<<constant [[SIGPIPE]]>>=
#define SIGPIPE -1
@

<<constant [[SIGQUIT]]>>=
#define SIGQUIT -1
@

<<constant [[SIGSEGV]]>>=
#define SIGSEGV -1
@

<<constant [[SIGTERM]]>>=
#define SIGTERM -1
@

<<constant [[SIGUSR1]]>>=
#define SIGUSR1 -1
@

<<constant [[SIGUSR2]]>>=
#define SIGUSR2 -1
@

<<constant [[SIGCHLD]]>>=
#define SIGCHLD -1
@

<<constant [[SIGCONT]]>>=
#define SIGCONT -1
@

<<constant [[SIGSTOP]]>>=
#define SIGSTOP -1
@

<<constant [[SIGTSTP]]>>=
#define SIGTSTP -1
@

<<constant [[SIGTTIN]]>>=
#define SIGTTIN -1
@

<<constant [[SIGTTOU]]>>=
#define SIGTTOU -1
@

<<constant [[SIGVTALRM]]>>=
#define SIGVTALRM -1
@

<<constant [[SIGPROF]]>>=
#define SIGPROF -1
@

<<global [[posix_signals]]>>=
int posix_signals[] = {
  SIGABRT, SIGALRM, SIGFPE, SIGHUP, SIGILL, SIGINT, SIGKILL, SIGPIPE,
  SIGQUIT, SIGSEGV, SIGTERM, SIGUSR1, SIGUSR2, SIGCHLD, SIGCONT,
  SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGVTALRM, SIGPROF
};
@

<<constant [[NSIG]]>>=
#define NSIG 32
@

<<function [[install_signal_handler]]>>=
value install_signal_handler(value signal_number, value action) /* ML */
{
  int sig;
  void (*act)(int signo);
#ifdef POSIX_SIGNALS
  struct sigaction sigact;
#endif

  sig = Int_val(signal_number);
  if (sig < 0) sig = posix_signals[-sig-1];
  if (sig < 0 || sig >= NSIG) 
    invalid_argument("Sys.signal: unavailable signal");
  switch(action) {
  case Val_int(0):              /* Signal_default */
    act = SIG_DFL;
    break;
  case Val_int(1):              /* Signal_ignore */
    act = SIG_IGN;
    break;
  default:                      /* Signal_handle */
    if (signal_handlers == 0) {
      int i;
      Begin_root(action);
        signal_handlers = alloc_tuple(NSIG);
      End_roots();
      for (i = 0; i < NSIG; i++) Field(signal_handlers, i) = Val_int(0);
      register_global_root(&signal_handlers);
    }
    modify(&Field(signal_handlers, sig), Field(action, 0));
    act = handle_signal;
    break;
  }
#ifdef POSIX_SIGNALS
  sigact.sa_handler = act;
  sigemptyset(&sigact.sa_mask);
  sigact.sa_flags = 0;
  sigaction(sig, &sigact, NULL);
#else
  signal(sig, act);
#endif
  return Val_unit;
}
@


%-------------------------------------------------------------

<<byterun/signals.c>>=
<<copyright header C xavier and damien>>

#include "config.h"

#ifndef OS_PLAN9
#include <signal.h>
#else
#endif

#include "alloc.h"
#include "callback.h"
#include "config.h"
#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "signals.h"

<<global [[async_signal_mode]]>>
<<global [[pending_signal]]>>
<<global [[something_to_do]]>>
<<global [[force_major_slice]]>>
<<global [[signal_handlers]]>>
<<global [[enter_blocking_section_hook]]>>
<<global [[leave_blocking_section_hook]]>>

<<function [[execute_signal]]>>

<<function [[handle_signal]]>>

<<function [[urge_major_slice]]>>

<<function [[enter_blocking_section]]>>

<<function [[leave_blocking_section]]>>

#ifndef SIGABRT
<<constant [[SIGABRT]]>>
#endif
#ifndef SIGALRM
<<constant [[SIGALRM]]>>
#endif
#ifndef SIGFPE
<<constant [[SIGFPE]]>>
#endif
#ifndef SIGHUP
<<constant [[SIGHUP]]>>
#endif
#ifndef SIGILL
<<constant [[SIGILL]]>>
#endif
#ifndef SIGINT
<<constant [[SIGINT]]>>
#endif
#ifndef SIGKILL
<<constant [[SIGKILL]]>>
#endif
#ifndef SIGPIPE
<<constant [[SIGPIPE]]>>
#endif
#ifndef SIGQUIT
<<constant [[SIGQUIT]]>>
#endif
#ifndef SIGSEGV
<<constant [[SIGSEGV]]>>
#endif
#ifndef SIGTERM
<<constant [[SIGTERM]]>>
#endif
#ifndef SIGUSR1
<<constant [[SIGUSR1]]>>
#endif
#ifndef SIGUSR2
<<constant [[SIGUSR2]]>>
#endif
#ifndef SIGCHLD
<<constant [[SIGCHLD]]>>
#endif
#ifndef SIGCONT
<<constant [[SIGCONT]]>>
#endif
#ifndef SIGSTOP
<<constant [[SIGSTOP]]>>
#endif
#ifndef SIGTSTP
<<constant [[SIGTSTP]]>>
#endif
#ifndef SIGTTIN
<<constant [[SIGTTIN]]>>
#endif
#ifndef SIGTTOU
<<constant [[SIGTTOU]]>>
#endif
#ifndef SIGVTALRM
<<constant [[SIGVTALRM]]>>
#endif
#ifndef SIGPROF
<<constant [[SIGPROF]]>>
#endif

<<global [[posix_signals]]>>

#ifndef NSIG
<<constant [[NSIG]]>>
#endif

<<function [[install_signal_handler]]>>
@


\subsection*{[[byterun/str.h]]}


%-------------------------------------------------------------

<<byterun/str.h>>=
<<copyright header C xavier>>

#ifndef _str_
#define _str_


#include "misc.h"
#include "mlvalues.h"

mlsize_t string_length (value);


#endif /* _str_ */
@


\subsection*{[[byterun/str.c]]}



<<global [[printable_chars_ascii]]>>=
static unsigned char printable_chars_ascii[] = /* 0x20-0x7E */
  "\000\000\000\000\377\377\377\377\377\377\377\377\377\377\377\177\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000";
@

<<global [[printable_chars_iso]]>>=
static unsigned char printable_chars_iso[] = /* 0x20-0x7E 0xA1-0xFF */
  "\000\000\000\000\377\377\377\377\377\377\377\377\377\377\377\177\000\000\000\000\376\377\377\377\377\377\377\377\377\377\377\377";
@

<<function [[is_printable]]>>=
value is_printable(value chr) /* ML */
{
  int c;
  unsigned char * printable_chars;

  static int iso_charset = -1;
  if (iso_charset == -1) {
    char * lc_ctype = (char *) getenv("LC_CTYPE");
    iso_charset = (lc_ctype != 0 && strcmp(lc_ctype, "iso_8859_1") == 0);
  }
  printable_chars = iso_charset ? printable_chars_iso : printable_chars_ascii;
  c = Int_val(chr);
  return Val_bool(printable_chars[c >> 3] & (1 << (c & 7)));
}
@

<<function [[bitvect_test]]>>=
value bitvect_test(value bv, value n)       /* ML */
{
  int pos = Int_val(n);
  return Val_int(Byte_u(bv, pos >> 3) & (1 << (pos & 7)));
}
@


%-------------------------------------------------------------

<<byterun/str.c>>=
<<copyright header C xavier>>

/* Operations on strings */

#include "config.h"

#ifndef OS_PLAN9
#include <string.h>
#endif

#include "alloc.h"
#include "fail.h"
#include "mlvalues.h"
#include "misc.h"

<<function [[string_length]]>>

<<function [[ml_string_length]]>>

<<function [[create_string]]>>

<<function [[string_get]]>>

<<function [[string_set]]>>

<<function [[string_equal]]>>

<<function [[string_notequal]]>>
  
<<function [[blit_string]]>>

<<function [[fill_string]]>>

<<global [[printable_chars_ascii]]>>
<<global [[printable_chars_iso]]>>

<<function [[is_printable]]>>

<<function [[bitvect_test]]>>

@


\subsection*{[[byterun/sys.h]]}

<<constant [[NO_ARG]]>>=
#define NO_ARG Val_int(0)
@


%-------------------------------------------------------------

<<byterun/sys.h>>=
<<copyright header C xavier>>

#ifndef _sys_
#define _sys_

#include "misc.h"

<<constant [[NO_ARG]]>>
extern void sys_error (value);
extern void sys_init (char **);
extern value sys_exit (value);
extern char * searchpath (char * name);

// used also by backtrace.c
extern char ** caml_main_argv;

#endif /* _sys_ */
@


\subsection*{[[byterun/sys.c]]}

<<function [[error_message]]>>=
char * error_message(void)
{
  return strerror(errno);
}
@

<<function [[sys_error]]>>=
void sys_error(value arg)
{
  char * err = error_message();
  value str;
  
  if (arg == NO_ARG) {
    str = copy_string(err);
  } else {
    int err_len = strlen(err);
    int arg_len = string_length(arg);
    Begin_root(arg);
      str = alloc_string(arg_len + 2 + err_len);
    End_roots();
    bcopy(String_val(arg), &Byte(str, 0), arg_len);
    bcopy(": ", &Byte(str, arg_len), 2);
    bcopy(err, &Byte(str, arg_len + 2), err_len);
  }
  raise_sys_error(str);
}
@

<<function [[sys_exit]]>>=
value sys_exit(value retcode)          /* ML */
{
#ifndef NATIVE_CODE
  debugger(PROGRAM_EXIT);
#endif
  exit(Int_val(retcode));
  return Val_unit;
}
@

<<global [[sys_open_flags]]>>=
static int sys_open_flags[] = {
  O_RDONLY, O_WRONLY, O_APPEND, O_CREAT, O_TRUNC, O_EXCL, O_NONBLOCK
};
@

<<function [[sys_open]]>>=
value sys_open(value path, value flags, value perm) /* ML */
{
  int ret;
  ret = open(String_val(path), convert_flag_list(flags, sys_open_flags), 
             Int_val(perm));
  if (ret == -1) sys_error(path);
  return Val_long(ret);
}
@

<<function [[sys_close]]>>=
value sys_close(value fd)             /* ML */
{
  close(Int_val(fd));
  return Val_unit;
}
@

<<function [[sys_file_exists]]>>=
value sys_file_exists(value name)     /* ML */
{
  struct stat st;
  return Val_bool(stat(String_val(name), &st) == 0);
}
@

<<function [[sys_remove]]>>=
value sys_remove(value name)          /* ML */
{
  int ret;
  ret = unlink(String_val(name));
  if (ret != 0) sys_error(name);
  return Val_unit;
}
@

<<function [[sys_rename]]>>=
value sys_rename(value oldname, value newname) /* ML */
{
  if (rename(String_val(oldname), String_val(newname)) != 0)
    sys_error(oldname);
  return Val_unit;
}
@

<<function [[sys_chdir]]>>=
value sys_chdir(value dirname)        /* ML */
{
  if (chdir(String_val(dirname)) != 0) sys_error(dirname);
  return Val_unit;
}
@

<<function [[sys_getcwd]]>>=
value sys_getcwd(value unit)          /* ML */
{
  char buff[4096];
  if (getcwd(buff, sizeof(buff)) == 0) sys_error(NO_ARG);
  return copy_string(buff);
}
@

<<function [[sys_getenv]]>>=
value sys_getenv(value var)           /* ML */
{
  char * res;

  res = getenv(String_val(var));
  if (res == 0) raise_not_found();
  return copy_string(res);
}
@

<<global [[main_argv]]>>=
char ** caml_main_argv;
@

<<function [[sys_get_argv]]>>=
value sys_get_argv(value unit)        /* ML */
{
  return copy_string_array(caml_main_argv);
}
@

<<function [[sys_init]]>>=
void sys_init(char **argv)
{
  caml_main_argv = argv;
}
@

<<function [[sys_system_command]]>>=
value sys_system_command(value command)   /* ML */
{
  int retcode = system(String_val(command));
  if (retcode == -1) sys_error(command);
  return Val_int(retcode);
}
@

<<function [[sys_get_config]]>>=
value sys_get_config(value unit)  /* ML */
{
  value result;
  value ostype;

  ostype = copy_string(OCAML_OS_TYPE);
  Begin_root(ostype);
    result = alloc_small (2, 0);
    Field(result, 0) = ostype;
    Field(result, 1) = Val_long (8 * sizeof(value));
  End_roots ();
  return result;
}
@

<<function [[S_ISREG]]>>=
#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
@

<<function [[searchpath]]>>=
char * searchpath(char * name)
{
  char * fullname;
  char * path;
  char * p;
  char * q;
  struct stat st;

  for (p = name; *p != 0; p++) {
    if (*p == '/') return name;
  }
  path = getenv("PATH");
  if (path == NULL) return 0;
  fullname = stat_alloc(strlen(name) + strlen(path) + 2);
  while(1) {
    for (p = fullname; *path != 0 && *path != ':'; p++, path++) *p = *path;
    if (p != fullname) *p++ = '/';
    for (q = name; *q != 0; p++, q++) *p = *q;
    *p = 0;
    if (stat(fullname, &st) == 0 && S_ISREG(st.st_mode)) break;
    if (*path == 0) return 0;
    path++;
  }
  return fullname;
}
@


%-------------------------------------------------------------

<<byterun/sys.c>>=
<<copyright header C xavier>>

/* Basic system calls */

#include <errno.h>
// O_NONBLOCK
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "config.h"
#include <unistd.h>

#include "alloc.h"
#include "debugger.h"
#include "fail.h"
#include "instruct.h"
#include "mlvalues.h"
#include "signals.h"
#include "stacks.h"
#include "str.h"
#include "sys.h"

extern int errno;

extern char * strerror(int);

<<function [[error_message]]>>

<<function [[sys_error]]>>

<<function [[sys_exit]]>>

<<global [[sys_open_flags]]>>

<<function [[sys_open]]>>

<<function [[sys_close]]>>

<<function [[sys_file_exists]]>>

<<function [[sys_remove]]>>

<<function [[sys_rename]]>>

<<function [[sys_chdir]]>>

<<function [[sys_getcwd]]>>

<<function [[sys_getenv]]>>

<<global [[main_argv]]>>

<<function [[sys_get_argv]]>>

<<function [[sys_init]]>>

<<function [[sys_system_command]]>>

<<function [[sys_get_config]]>>

/* Search path function */

#ifndef S_ISREG
<<function [[S_ISREG]]>>
#endif

<<function [[searchpath]]>>
@


\subsection*{[[byterun/terminfo.c]]}

<<function [[terminfo_setup]]>>=
value terminfo_setup(value unit)      /* ML */
{
  static char buffer[1024];
  if (tgetent(buffer, getenv("TERM")) != 1) failwith("Terminfo.setupterm");
  return Val_unit;
}
@

<<function [[terminfo_getstr]]>>=
value terminfo_getstr(value capa)     /* ML */
{
  char buff[1024];
  char * p = buff;
  char * s = tgetstr(String_val(capa), &p);
  if (s == NULL) raise_not_found();
  return copy_string(s);
}
@

<<function [[terminfo_getnum]]>>=
value terminfo_getnum(value capa)     /* ML */
{
  int res = tgetnum(String_val(capa));
  if (res == -1) raise_not_found();
  return Val_int(res);
}
@

<<global [[terminfo_putc_channel]]>>=
static struct channel * terminfo_putc_channel;
@

<<function [[terminfo_putc]]>>=
static int terminfo_putc(int c)
{
  putch(terminfo_putc_channel, c);
  return c;
}
@

<<function [[terminfo_puts]]>>=
value terminfo_puts(value vchan, value str, value count) /* ML */
{
  terminfo_putc_channel = Channel(vchan);
  tputs(String_val(str), Int_val(count), terminfo_putc);
  return Val_unit;
}
@

<<function [[terminfo_setup]]([[(byterun/terminfo.c)]])>>=
value terminfo_setup(value unit)
{
  failwith("Terminfo.setupterm");
  return Val_unit;
}
@

<<function [[terminfo_getstr]]([[(byterun/terminfo.c)]])>>=
value terminfo_getstr(value capa)
{
  raise_not_found();
  return Val_unit;
}
@

<<function [[terminfo_getnum]]([[(byterun/terminfo.c)]])>>=
value terminfo_getnum(value capa)
{
  raise_not_found();
  return Val_unit;
}
@

<<function [[terminfo_puts]]([[(byterun/terminfo.c)]])>>=
value terminfo_puts(value vchan, value str, value count)
{
  invalid_argument("Terminfo.puts");
  return Val_unit;
}
@


%-------------------------------------------------------------

<<byterun/terminfo.c>>=
<<copyright header C xavier>>


/* Read and output terminal commands */

#include "config.h"
#include "alloc.h"
#include "fail.h"
#include "io.h"
#include "mlvalues.h"

#ifdef HAS_TERMCAP

extern int tgetent (char * buffer, char * name);
extern char * tgetstr (char * id, char ** area);
extern int tgetnum (char * id);
extern int tputs (char * str, int count, int (*outchar)(int c));

<<function [[terminfo_setup]]>>

<<function [[terminfo_getstr]]>>

<<function [[terminfo_getnum]]>>

<<global [[terminfo_putc_channel]]>>

<<function [[terminfo_putc]]>>

<<function [[terminfo_puts]]>>

#else

<<function [[terminfo_setup]]([[(byterun/terminfo.c)]])>>

<<function [[terminfo_getstr]]([[(byterun/terminfo.c)]])>>

<<function [[terminfo_getnum]]([[(byterun/terminfo.c)]])>>

<<function [[terminfo_puts]]([[(byterun/terminfo.c)]])>>

#endif
@


\subsection*{[[byterun/weak.h]]}


%-------------------------------------------------------------

<<byterun/weak.h>>=
<<copyright header C damien 1997>>


/* Operations on weak arrays */

#include "mlvalues.h"

extern value weak_list_head;
@


\subsection*{[[byterun/weak.c]]}

<<global [[weak_list_head]]>>=
value weak_list_head = 0;
@

<<function [[weak_create]]>>=
value weak_create (value len)        /* ML */
{
  mlsize_t size, i;
  value res;

  size = Long_val (len) + 1;
  if (size > Max_wosize) invalid_argument ("Weak.create");
  res = alloc_shr (size, Abstract_tag);
  for (i = 1; i < size; i++) Field (res, i) = 0;
  Field (res, 0) = weak_list_head;
  weak_list_head = res;
  return res;
}
@

<<constant [[None_val]]>>=
#define None_val 1
@

<<constant [[Some_tag]]>>=
#define Some_tag 0
@

<<function [[weak_set]]>>=
value weak_set (value ar, value n, value el)     /* ML */
{
  mlsize_t offset = Long_val (n) + 1;
                                                   Assert (Is_in_heap (ar));
  if (offset < 1 || offset >= Wosize_val (ar)) invalid_argument ("Weak.set");
  Field (ar, offset) = 0;
  if (el != None_val){                  Assert (Wosize_val (el) == 1);
    Modify (&Field (ar, offset), Field (el, 0));
  }
  return Val_unit;
}
@

<<constant [[Setup_for_gc]]([[(byterun/weak.c)]])>>=
#define Setup_for_gc
@

<<constant [[Restore_after_gc]]([[(byterun/weak.c)]])>>=
#define Restore_after_gc
@

<<function [[weak_get]]>>=
value weak_get (value ar, value n)        /* ML */
{
  mlsize_t offset = Long_val (n) + 1;
  value res;
  value elt;
                                                   Assert (Is_in_heap (ar));
  if (offset < 1 || offset >= Wosize_val (ar)) invalid_argument ("Weak.get");
  if (Field (ar, offset) == 0){
    res = None_val;
  }else{
    elt = Field (ar, offset);
    if (gc_phase == Phase_mark) darken (elt, NULL);
    Begin_root(elt);
      res = alloc_small (1, Some_tag);
    End_roots ();
    Field (res, 0) = elt;
  }
  return res;
}
@


%-------------------------------------------------------------

<<byterun/weak.c>>=
<<copyright header C damien 1997>>

/* Operations on weak arrays */

#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "mlvalues.h"

<<global [[weak_list_head]]>>

<<function [[weak_create]]>>

<<constant [[None_val]]>>
<<constant [[Some_tag]]>>

<<function [[weak_set]]>>

<<constant [[Setup_for_gc]]([[(byterun/weak.c)]])>>
<<constant [[Restore_after_gc]]([[(byterun/weak.c)]])>>

<<function [[weak_get]]>>

#undef Setup_for_gc
#undef Restore_after_gc
@


\subsection*{[[byterun/startup.c]]}



<<function [[read_size]]>>=
/* Read the trailer of a bytecode file */

//static void fixup_endianness_trailer(uint32 * p)
//{
//#ifndef ARCH_BIG_ENDIAN
//  Reverse_32(p, p);
//#endif
//}


static unsigned long read_size(char * ptr)
{
  unsigned char * p = (unsigned char *) ptr;
  return ((unsigned long) p[0] << 24) + ((unsigned long) p[1] << 16) +
         ((unsigned long) p[2] << 8) + p[3];
}
@

<<constant [[FILE_NOT_FOUND]]>>=
@

<<constant [[TRUNCATED_FILE]]>>=
@

<<constant [[BAD_MAGIC_NUM]]>>=
@

<<function [[read_trailer]]>>=
static int read_trailer(int fd, struct exec_trailer *trail)
{
  char buffer[TRAILER_SIZE];

  lseek(fd, (long) -TRAILER_SIZE, SEEK_END);
  if (read(fd, buffer, TRAILER_SIZE) < TRAILER_SIZE) 
    return BAD_BYTECODE;
  //fixup_endianness_trailer(&trail->num_sections);
  trail->code_size = read_size(buffer);
  trail->prim_size = read_size(buffer + 4);
  trail->data_size = read_size(buffer + 8);
  trail->symbol_size = read_size(buffer + 12);
  trail->debug_size = read_size(buffer + 16);
  if (strncmp(buffer + 20, EXEC_MAGIC, 12) == 0)
    return 0;
  else
    return BAD_BYTECODE; // was BAD_MAGIC_NUM
}
@

<<function [[attempt_open]]>>=
int attempt_open(char **name, struct exec_trailer *trail, int do_open_script)
{
  char * truename;
  int fd;
  int err;
  char buf [2];

  truename = searchpath(*name);
  if (truename == 0) 
    truename = *name; 
  else 
    *name = truename;
  fd = open(truename, O_RDONLY);
  if (fd == -1) return FILE_NOT_FOUND;
  if (!do_open_script){
    err = read (fd, buf, 2);
    if ((err < 2) || (buf [0] == '#' && buf [1] == '!')) { 
      close(fd); 
      return BAD_BYTECODE; 
    }
  }
  err = read_trailer(fd, trail);
  if (err != 0) { 
    close(fd); 
    return err; 
  }
  return fd;
}
@

<<function [[check_primitives]]>>=
/* Check the primitives used by the bytecode file against the table of
   primitives linked in this interpreter */

static void check_primitives(int fd, int prim_size)
{
  char * prims = stat_alloc(prim_size);
  char * p;
  int idx;

  if (read(fd, prims, prim_size) != prim_size)
    fatal_error("Fatal error: cannot read primitive table\n");
  /* prims contains 0-terminated strings, concatenated. */
  for (p = prims, idx = 0;
       p < prims + prim_size;
       p = p + strlen(p) + 1, idx++) {
    if (names_of_cprim[idx] == NULL ||
        strcmp(p, names_of_cprim[idx]) != 0)
      fatal_error_arg("Fatal error: this bytecode file cannot run on this bytecode interpreter\nMismatch on primitive `%s'\n", p);
  }
  stat_free(prims);
}
@


<<global [[percent_free_init]]>>=
static unsigned long percent_free_init = Percent_free_def;
@

<<global [[max_percent_free_init]]>>=
static unsigned long max_percent_free_init = Max_percent_free_def;
@

<<global [[minor_heap_init]]>>=
static unsigned long minor_heap_init = Minor_heap_def;
@

<<global [[heap_chunk_init]]>>=
static unsigned long heap_chunk_init = Heap_chunk_def;
@

<<global [[heap_size_init]]>>=
static unsigned long heap_size_init = Init_heap_def;
@

<<global [[max_stack_init]]>>=
static unsigned long max_stack_init = Max_stack_def;
@





<<function [[caml_startup_code]]>>=
/* Main entry point when code is linked in as initialized data */

void caml_startup_code(code_t code, asize_t code_size, char *data, char **argv)
{
  struct longjmp_buffer raise_buf;

  init_ieee_floats();
  <<[[caml_startup_code()]] ifdef [[DEBUG]], set [[verbose_init]]>>

  parse_camlrunparam();

  /* Set up a catch-all exception handler */
  if (sigsetjmp(raise_buf.buf, 1) == 0) {
    external_raise = &raise_buf;

    /* Initialize the abstract machine */
    init_gc (minor_heap_init, heap_size_init, heap_chunk_init,
             percent_free_init, max_percent_free_init, verbose_init);
    init_stack (max_stack_init);
    init_atoms();

    /* Initialize the interpreter */
    interprete(NULL, 0);

    /* Load the code */
    start_code = code;
#ifdef THREADED_CODE
    thread_code(start_code, code_size);
#endif

    /* Load the globals */
    global_data = input_val_from_string((value)data, 0);
    /* Ensure that the globals are in the major heap. */
    oldify(global_data, &global_data);

    /* Run the code */
    sys_init(argv);
    interprete(start_code, code_size);

  } else {
    fatal_uncaught_exception(exn_bucket);
  }
}
@


%-------------------------------------------------------------

<<byterun/startup.c>>=
<<copyright header C xavier and damien>>

/* Start-up code */

#include "config.h"

#ifndef OS_PLAN9
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#else
#endif

#include "alloc.h"
#include "backtrace.h"
#include "debugger.h"
#include "exec.h"
#include "fail.h"
#include "fix_code.h"
#include "gc_ctrl.h"
#include "interp.h"
#include "intext.h"
#include "io.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"
#include "stacks.h"
#include "sys.h"
#include "startup.h"


<<global [[atom_table]]>>

<<function [[init_atoms]]>>

<<function [[read_size]]>>

<<constant [[FILE_NOT_FOUND]]>>
<<constant [[TRUNCATED_FILE]]>>
<<constant [[BAD_MAGIC_NUM]]>>

<<function [[read_trailer]]>>

<<function [[attempt_open]]>>



<<function [[check_primitives]]>>

/* Invocation of camlrun: 4 cases.

   1.  runtime + bytecode
       user types:  camlrun [options] bytecode args...
       arguments:  camlrun [options] bytecode args...

   2.  bytecode script
       user types:  bytecode args...
   2a  (kernel 1) arguments:  camlrun ./bytecode args...
   2b  (kernel 2) arguments:  bytecode bytecode args...

   3.  concatenated runtime and bytecode
       user types:  composite args...
       arguments:  composite args...

Algorithm:
  1-  If argument 0 is a valid byte-code file that does not start with #!,
      then we are in case 3 and we pass the same command line to the
      Caml Light program.
  2-  In all other cases, we parse the command line as:
        (whatever) [options] bytecode args...
      and we strip "(whatever) [options]" from the command line.

*/

<<global [[verbose_init]]>>
<<global [[percent_free_init]]>>
<<global [[max_percent_free_init]]>>
<<global [[minor_heap_init]]>>
<<global [[heap_chunk_init]]>>
<<global [[heap_size_init]]>>
<<global [[max_stack_init]]>>
extern int trace_flag;

<<function [[parse_command_line]]>>

/* Parse the CAMLRUNPARAM variable */
<<function [[scanmult]]>>

<<function [[parse_camlrunparam]]>>

extern void init_ieee_floats (void);

<<function [[caml_main]]>>

<<function [[caml_startup_code]]>>
  
@


\subsection*{[[byterun/main.c]]}


%-------------------------------------------------------------

<<byterun/main.c>>=
<<copyright header C xavier and damien>>

/* Main entry point (can be overriden by a user-provided main()
   function that calls caml_main() later. */

#include "misc.h"
#include "mlvalues.h"
#include "sys.h"

extern void caml_main (char **);

<<function [[main]]>>
@


