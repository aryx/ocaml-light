\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - found deadcode in ocaml itself :) 
%   (all.ml, codegen.ml, a few functions)
% 

%thx to codemap/codegraph/scheck:
% - use cg to to look at backward deps (but the ocaml linker enforce layers)
%   (harder to understand non layered code)
% - use scheck to remove deadcode, found some even in latest ocaml :)
%   (harder to understand big files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand OCaml?:
% - TODO how a gc works
% - TODO how values are represented at runtime, Obj
% - TODO how backend compiler works (register, liveness, etc)
% - TODO how type inference works in ocaml itself, monomorphic limitations?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, type, exception, constant
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ??

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The OCaml Light Compilers
}\\
{version 0.1}
}
% compilers, with an s

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}
% with code from Xavier Leroy and Damien Doligez

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a compiler for a high level language.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% ocaml because good compromise! functional, and imperative.
% I removed parts that were not that used:
%  - objects
%  - functors
% (indeed they were not that used in the code of ocaml itself ... hmm)

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item ML
% not active
\item Haskell
% nice but lazy, and too strict (no pun intended) forcing programmer
% to be purely functional (or to use intrusive and complex monads IO),
% but some nice things to steal (typeclasses, template haskell)
\item Scheme
% not typed, no ADT, but some nice things: macros, call/cc, eval
\item Scala
% too big, don't need objects anyway.
% implicits are nice, but controversial, just like OO they can
% lead to spaghetti code or hard to follow code more easily
\end{itemize}

% so many candidates to list here actually.


%https://rwmj.wordpress.com/2009/08/04/ocaml-internals/
%https://github.com/ocamllabs/ocaml-internals/wiki

\section{Getting started}

\section{Requirements}

% actually code presented below is written in OCaml so you
% need to understand OCaml :)

\section{About this document}
#include "docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from OCaml, so
those parts are copyright by INRIA.

<<copyright header>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

The prose is mine and is licensed under the GNU Free Documentation
License.


\section{Acknowledgments}

I would like to thank of course Xavier Leroy and Damien Doligez,
the authors of OCaml.

\chapter{Overview}

\section{High-level language principles}

%advanced features not in C, so good increment:
% - gc (no more malloc/free and bugs), which imply special bits
%   for each values
% - parametric polymorphism (no more code duplication and void* loophole)
%   which imply boxing values for certain implementation strategy
% - closures (can factorize more code, no more loop for everything)
% - ADT and pattern matching (no more enum/switch loophole)
% - type inference (less boilerplate, especially needed when have
%   polymorphism and closures and quite complicated types)

% missing: 
%  - call/cc, too advanced? too complex for mere mortal?
%    but could, see
%    http://gallium.inria.fr/~xleroy/software/ocaml-callcc-1.0.tar.gz
%    or http://okmij.org/ftp/continuations/implementations.html
%  - macros (hmm but need compile time metaprogramming though at least)
% missing on purpose: 
%  - objects (see lablgtk mess), 
%  - functors (see ocamlgraph or ocsigen mess).

% toadd: 
%  - type classes (no more + vs +., print_xxx, can factorize more code)
%  - compile time metaprogramming? (no more boilerplate, show, map, visit, etc)

\section{[[ocamlc]] services}

<<constant Main.usage>>=
let usage = "Usage: ocamlc <options> <files>\nOptions are:"
@

\section{[[calc.ml]]}

\section{Input OCaml Light language}

\section{Code organization}

% btype.ml: 
%  "basic operations on core types"
% datarepr.ml:  
%  "Compute constructor and label descriptions from type declarations, determining their representation"
% ctype.ml: 
%  "Operations on core types"

% typedecl.ml: typing of the type declarations
%  "Typing of type definitions and primitive definitions"

% matching.ml: 
%  "Compilation of pattern matching"
% emitcode.ml:
%  "Generation of bytecode for .cmo files"

%https://github.com/ocamllabs/ocaml-internals/wiki/Source-layout

\section{Software architecture}

% https://github.com/ocamllabs/ocaml-internals/wiki/Compiler-pipelines

\section{Bootstrapping}


<<constant Clflags.nopervasives>>=
let nopervasives = ref false            (* -nopervasives *)
@

% make bootstrap

%###############################################################################

\chapter{Core Data Structures}

%parsing/parsetree.mli and asttypes.mli
%typing/types.mli
%typing/typedtree.mli (and asttypes.mli)
%bytecomp/lambda.mli
%bytecomp/instruct.mli
%byterun/instruct.h

\section{Abstract syntax tree}

\subsection{Names}

<<type Longident.t>>=
(* Long identifiers, used in parsetree. *)

type t =
    Lident of string
  | Ldot of t * string
@
%note: like a list, but enforce have at least one element

<<signature Longident.flatten>>=
val flatten: t -> string list
@
% dead actually?

<<function Longident.flat>>=
let rec flat accu = function
    Lident s -> s :: accu
  | Ldot(lid, s) -> flat (s :: accu) lid
@
<<function Longident.flatten>>=
let flatten lid = flat [] lid
@

\subsection{Positions}

<<type Location.t>>=
(* Source code locations, used in parsetree *)

type t =
  { loc_start: int; loc_end: int }
@
% charpos

<<signature Location.none>>=
val none: t
@
<<constant Location.none>>=
let none = { loc_start = -1; loc_end = -1 }
@


<<signature Location.symbol_loc>>=
val symbol_loc: unit -> t
@
<<function Location.symbol_loc>>=
let symbol_loc () = 
  { loc_start = Parsing.symbol_start(); loc_end = Parsing.symbol_end() }
@
% ?? global?

<<signature Location.input_name>>=
val input_name: string ref
@
<<constant Location.input_name>>=
let input_name = ref ""
@
%alt: my info scheme, where the filaneme, charpos, and also
% line is stored in the token.






\subsection{Types}
% this is the type "system", not the declaration of the types

<<type Parsetree.core_type>>=
type core_type =
  { ptyp_desc: core_type_desc;
    ptyp_loc: Location.t }
@
%alt: my info scheme and embedded token instead of wrapper extra type.
%todo: at least could factorize? 'a wrap = 'a * Location.t  no?

<<type Parsetree.core_type_desc>>=
and core_type_desc = 
    Ptyp_any
  | Ptyp_var of string
  | Ptyp_arrow of core_type * core_type
  | Ptyp_tuple of core_type list
  | Ptyp_constr of Longident.t * core_type list
  | Ptyp_alias of core_type * string
@
% any?
% less: rename constr? it's not constructor, it's apply
% note: alias here, but should disappear at some point.

% note that there is no '_a here, because it's not representable
% by the user. It can't appear in the source code itself.

\subsection{Expressions (and statements)}

<<type Parsetree.expression>>=
type expression =
  { pexp_desc: expression_desc;
    pexp_loc: Location.t }
@

% rich, this includes also statements, locals, and so
% functions/constants/globals since ocaml is very regular

<<type Parsetree.expression_desc>>=
and expression_desc =
    Pexp_ident of Longident.t
  | Pexp_constant of constant

  | Pexp_tuple of expression list
  | Pexp_construct of Longident.t * expression option
  | Pexp_record of (Longident.t * expression) list
  | Pexp_array of expression list

  | Pexp_field of expression * Longident.t
  | Pexp_setfield of expression * Longident.t * expression

  | Pexp_apply of expression * expression list

  | Pexp_let of rec_flag * (pattern * expression) list * expression
  | Pexp_function of (pattern * expression) list
  | Pexp_match of expression * (pattern * expression) list
  | Pexp_when of expression * expression

  | Pexp_try of expression * (pattern * expression) list
  | Pexp_ifthenelse of expression * expression * expression option
  | Pexp_sequence of expression * expression
  | Pexp_while of expression * expression
  | Pexp_for of string * expression * expression * direction_flag * expression

  | Pexp_constraint of expression * core_type
@
% list for let, for mutually recursive functions or data

<<type Asttypes.rec_flag>>=
type rec_flag = Nonrecursive | Recursive
@
% actually can also have rec_flag for constants? build a cycle?


\subsection{Patterns}

<<type Parsetree.pattern>>=
type pattern =
  { ppat_desc: pattern_desc;
    ppat_loc: Location.t }
@

<<type Parsetree.pattern_desc>>=
and pattern_desc =
    Ppat_any
  | Ppat_var of string
  | Ppat_alias of pattern * string
  | Ppat_constant of constant
  | Ppat_tuple of pattern list
  | Ppat_construct of Longident.t * pattern option
  | Ppat_record of (Longident.t * pattern) list
  | Ppat_or of pattern * pattern
  | Ppat_constraint of pattern * core_type
@

\subsection{Declarations}

\subsubsection{Type declarations}


<<type Parsetree.type_declaration>>=
type type_declaration =
  { ptype_params: string list;
    ptype_cstrs: (string * core_type * Location.t) list;
    ptype_kind: type_kind;
    ptype_manifest: core_type option;
    ptype_loc: Location.t }
@
% manifest?

<<type Parsetree.type_kind>>=
and type_kind =
    Ptype_abstract
  | Ptype_variant of (string * core_type list) list
  | Ptype_record of (string * mutable_flag * core_type) list
@

<<type Asttypes.mutable_flag>>=
type mutable_flag = Immutable | Mutable
@

%  | Psig_type of (string * type_declaration) list
% list when mutually recursive!

\subsubsection{Exception declarations}

<<type Parsetree.exception_declaration>>=
type exception_declaration = core_type list
@
% ??

%  | Psig_exception of string * exception_declaration

\subsubsection{Values}

<<type Parsetree.value_description>>=
(* Value descriptions *)

type value_description =
  { pval_type: core_type;
    pval_prim: string list }
@

%    Psig_value of string * value_description

\subsection{Modules}

\subsubsection{Signatures}

<<type Parsetree.signature>>=
and signature = signature_item list
@

<<type Parsetree.signature_item>>=
and signature_item =
  { psig_desc: signature_item_desc;
    psig_loc: Location.t }
@
<<type Parsetree.signature_item_desc>>=
and signature_item_desc =
    Psig_value of string * value_description
  | Psig_type of (string * type_declaration) list
  | Psig_exception of string * exception_declaration

  | Psig_module of string * module_type
  | Psig_open of Longident.t
@


<<type Parsetree.module_type>>=
type module_type =
  { pmty_desc: module_type_desc;
    pmty_loc: Location.t }
@
<<type Parsetree.module_type_desc>>=
and module_type_desc =
    Pmty_ident of Longident.t
  | Pmty_signature of signature
@






\subsubsection{Structures}

<<type Parsetree.structure>>=
and structure = structure_item list
@

<<type Parsetree.structure_item>>=
and structure_item =
  { pstr_desc: structure_item_desc;
    pstr_loc: Location.t }
@

<<type Parsetree.structure_item_desc>>=
and structure_item_desc =
    Pstr_eval of expression
  | Pstr_value of rec_flag * (pattern * expression) list
  | Pstr_primitive of string * value_description
  | Pstr_type of (string * type_declaration) list
  | Pstr_exception of string * exception_declaration

  | Pstr_module of string * module_expr
  | Pstr_open of Longident.t
@


<<type Parsetree.module_expr>>=
type module_expr =
  { pmod_desc: module_expr_desc;
    pmod_loc: Location.t }
@

<<type Parsetree.module_expr_desc>>=
and module_expr_desc =
    Pmod_ident of Longident.t
  | Pmod_structure of structure
  | Pmod_constraint of module_expr * module_type
@


\section{Types and the Typed Tree}

% many Types.xxx are really close to Parsetree.xxx
% they actually have the same name, but core_type
% has been replaced by type_expr.

% In the same way many Pxxx become Txxx

\section{[[Lambda]] and [[Instruction]] intermediate languages}

\section{Bytecode}

% https://github.com/ocamllabs/ocaml-internals/wiki/Bytecode-compiler-pipeline

\section{Runtime values}

%https://rwmj.wordpress.com/2009/08/04/ocaml-internals/

% see also oreilly book, very good chapter on values

% blocks, will help understand elts from Lambda and Instruct


\chapter{[[main()]]}

<<toplevel Main._1>>=
let _ = Printexc.catch main ()
@

<<function Main.main>>=
let main () =
  try
    Arg.parse [
       <<[[Main.main()]] command line options>>
      ] process_file usage;

    (match () with
    | _ when !make_archive ->
        Compile.init_path();
        Bytelibrarian.create_archive (List.rev !objfiles) !archive_name
    | _ when not !compile_only & !objfiles <> [] ->
        Compile.init_path();
        Bytelink.link (List.rev !objfiles)
    | _ -> ()
    );
    exit 0
  with x ->
    Format.set_formatter_out_channel stderr;
    Errors.report_error x;
    exit 2
@

<<[[Main.main()]] command line options>>=
"-a", Arg.Set make_archive, " Build a library";
"-c", Arg.Set compile_only, " Compile only (do not link)";
"-cclib", Arg.String(fun s -> ccobjs := s :: !ccobjs),
      "<opt>  Pass option <opt> to the C linker";
"-ccopt", Arg.String(fun s -> ccopts := s :: !ccopts),
      "<opt>  Pass option <opt> to the C compiler and linker";
"-custom", Arg.Set custom_runtime, " Link in custom mode";
"-g", Arg.Set debug, " Save debugging information";
"-i", Arg.Set print_types, " Print the types";
"-I", Arg.String(fun dir -> include_dirs := dir :: !include_dirs),
      "<dir>  Add <dir> to the list of include directories";
"-impl", Arg.String process_implementation_file,
      "<file>  Compile <file> as a .ml file";
"-intf", Arg.String process_interface_file,
      "<file>  Compile <file> as a .mli file";
"-linkall", Arg.Set link_everything,
      " Link all modules, even unused ones";
"-noassert", Arg.Set noassert, " Don't compile assertion checks";
"-o", Arg.String(fun s -> exec_name := s;
                          archive_name := s;
                          object_name := s),
      "<file>  Set output file name to <file> (default a.out)";
"-output-obj", Arg.Unit(fun () -> output_c_object := true;
                                  custom_runtime := true),
      "Output a C object file instead of an executable";
"-pp", Arg.String(fun s -> preprocessor := Some s),
      "<command>  Pipe sources through preprocessor <command>";
"-thread", Arg.Set thread_safe, " Use thread-safe standard library";
"-unsafe", Arg.Set fast,
      " No bounds checking on array and string access";
"-v", Arg.Unit print_version_number, " Print compiler version number";
"-verbose", Arg.Set verbose, " Print calls to external commands";

"-nopervasives", Arg.Set nopervasives, " (undocumented)";
"-drawlambda", Arg.Set dump_rawlambda, " (undocumented)";
"-dlambda", Arg.Set dump_lambda, " (undocumented)";
"-dinstr", Arg.Set dump_instr, " (undocumented)";

"-", Arg.String process_file,
     "<file>  Treat <file> as a file name (even if it starts with `-')"
@


<<function Main.print_version_number>>=
let print_version_number () =
  print_string "The Objective Caml compiler, version ";
  print_string Config.version; print_newline();
  print_string "Standard library directory: ";
  print_string Config.standard_library; print_newline()
@

\section{[[Main.process_file()]]}

<<constant Clflags.objfiles>>=
let objfiles = ref ([] : string list)   (* .cmo and .cma files *)
@


<<function Main.process_file>>=
let process_file name =
  match () with
  | _ when Filename.check_suffix name ".ml" ->
      Compile.implementation name;
      objfiles := (Filename.chop_extension name ^ ".cmo") :: !objfiles
  | _ when Filename.check_suffix name ".mli" ->
      Compile.interface name

  | _ when Filename.check_suffix name ".cmo" 
        or Filename.check_suffix name ".cma" ->
      objfiles := name :: !objfiles
  | _ when Filename.check_suffix name ext_obj
        or Filename.check_suffix name ext_lib ->
      ccobjs := name :: !ccobjs
  | _ when Filename.check_suffix name ".c" ->
      Compile.c_file name;
      ccobjs := (Filename.chop_suffix (Filename.basename name) ".c" ^ ext_obj)
       :: !ccobjs
  | _ -> 
      raise(Arg.Bad("don't know what to do with " ^ name))
@
%old: or Filename.check_suffix name ".mlt" ??
%old: I rewrote with match () with when







\section{[[Compile.implementation()]]}

<<function Main.process_implementation_file>>=
let process_implementation_file name =
  Compile.implementation name;
  objfiles := (Filename.chop_extension name ^ ".cmo") :: !objfiles
@


<<signature Compile.implementation>>=
val implementation: string -> unit
@



<<signature Compile.initial_env>>=
val initial_env: unit -> Env.t
@

<<signature Compile.init_path>>=
val init_path: unit -> unit
@



<<function Compile.implementation>>=
let implementation sourcefile =
  init_path();
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppo") in

  let ast = parse_file inputfile Parse.implementation ast_impl_magic_number in

  let objfile = prefixname ^ ".cmo" in
  let oc = open_out_bin objfile in
  try
    let (str, sg, finalenv) =
      Typemod.type_structure (initial_env()) ast in

    if !Clflags.print_types then (Printtyp.signature sg; print_newline());
(*
    let coercion =
      if Sys.file_exists (prefixname ^ ".mli") then begin
        let intf_file =
          try find_in_path !load_path (prefixname ^ ".cmi")
          with Not_found -> prefixname ^ ".cmi" in
        let dclsig = Env.read_signature modulename intf_file in
        Includemod.compunit sourcefile sg intf_file dclsig
      end else begin
        Typemod.check_nongen_schemes finalenv str;
        Env.save_signature sg modulename (prefixname ^ ".cmi");
        Tcoerce_none
      end in
*)

    let (coercion, crc) =
      if Sys.file_exists (prefixname ^ ".mli") then begin
        let intf_file =
          try find_in_path !load_path (prefixname ^ ".cmi")
          with Not_found -> prefixname ^ ".cmi" in
        let (dclsig, crc) = Env.read_signature modulename intf_file in
        (Includemod.compunit sourcefile sg intf_file dclsig, crc)
      end else begin
        let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
        Typemod.check_nongen_schemes str;
        (Tcoerce_none, crc)
      end in

    Emitcode.to_file oc modulename
      (print_if Clflags.dump_instr Printinstr.instrlist
        (Bytegen.compile_implementation modulename
          (print_if Clflags.dump_lambda Printlambda.lambda
            (Simplif.simplify_lambda
              (print_if Clflags.dump_rawlambda Printlambda.lambda
                (Translmod.transl_implementation modulename str coercion))))));

    remove_preprocessed inputfile;
    close_out oc
  with x ->
    close_out oc;
    remove_file objfile;
    raise x
@
%less: Common.finalize

\section{[[Compile.interface()]]}

<<function Main.process_interface_file>>=
let process_interface_file name =
  Compile.interface name
@

<<signature Compile.interface>>=
val interface: string -> unit
@

<<function Compile.interface>>=
(* Compile a .mli file *)

let interface sourcefile =
  init_path();
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppi") in

  let ast = parse_file inputfile Parse.interface ast_intf_magic_number in

  let sg = Typemod.transl_signature (initial_env()) ast in
  if !Clflags.print_types then (Printtyp.signature sg; print_newline());
  Env.save_signature sg modulename (prefixname ^ ".cmi");
  remove_preprocessed inputfile
@

\chapter{Lexing}

% see also preprocessing section in advanced topics

<<signature Lexer.token>>=
(* The lexical analyzer *)

val token: Lexing.lexbuf -> Parser.token
@


\section{Comments}

\section{Keywords and identifiers}

\section{Operators}

\section{Numbers}

\subsection{Integers}

\subsection{Floats}

\section{Characters}

\section{Strings}

\chapter{Parsing}

<<signature Parse.implementation>>=
val implementation : Lexing.lexbuf -> Parsetree.structure
@

<<signature Parse.interface>>=
val interface : Lexing.lexbuf -> Parsetree.signature
@

<<function Parse.wrap>>=
let wrap parsing_fun lexbuf =
  try
    let ast = parsing_fun Lexer.token lexbuf in
    Parsing.clear_parser();
    ast
  with
    | Parsing.Parse_error | Syntaxerr.Escape_error ->
        let loc = { loc_start = Lexing.lexeme_start lexbuf;
                    loc_end = Lexing.lexeme_end lexbuf } in
        if !Location.input_name = "" 
        then maybe_skip_phrase lexbuf;
        raise(Syntaxerr.Error(Syntaxerr.Other loc))

    | Lexer.Error(Lexer.Unterminated_comment, _, _) as err -> raise err
    | Lexer.Error(Lexer.Unterminated_string, _, _) as err -> raise err
    | Lexer.Error(_, _, _) as err ->
        if !Location.input_name = "" then skip_phrase lexbuf;
        raise err
    | Syntaxerr.Error _ as err ->
        if !Location.input_name = "" then maybe_skip_phrase lexbuf;
        raise err
@


<<function Parse.implementation>>=
let implementation = wrap Parser.implementation
@

<<function Parse.interface>>=
let interface = wrap Parser.interface
@

\section{Names}

\section{Values}

%\subsection{Functions}
%\subsection{Constants}
%\subsection{Globals}

\section{Types}

\subsection{Variants}

\subsection{Records}


\section{Expressions}

\subsection{Constants}

<<type Asttypes.constant>>=
type constant =
    Const_int of int
  | Const_char of char
  | Const_string of string
  | Const_float of string
@

\section{Statements}

\subsection{Loops}

<<type Asttypes.direction_flag>>=
type direction_flag = Upto | Downto
@

\section{Signatures}
% the .mli

\section{Structures}
% the .ml

\chapter{Typing}



\chapter{Checking}


\chapter{Compiling}
% Generating

<<constant Clflags.compile_only>>=
let compile_only = ref false            (* -c *)
@


\section{Typed AST to untyped [[Lambda]] calcul}


%(* Translation from typed abstract syntax to lambda terms,
%   for the core language *)

%<<signature Translcore.transl_exp>>=
%val transl_exp: expression -> lambda
%@


\subsection{[[Lambda]]}

<<type Lambda.lambda>>=
type lambda =
    Lvar of Ident.t
  | Lconst of structured_constant
  | Lapply of lambda * lambda list
  | Lfunction of function_kind * Ident.t list * lambda
  | Llet of let_kind * Ident.t * lambda * lambda
  | Lletrec of (Ident.t * lambda) list * lambda
  | Lprim of primitive * lambda list
  | Lswitch of lambda * lambda_switch
  | Lstaticfail
  | Lcatch of lambda * lambda
  | Ltrywith of lambda * Ident.t * lambda
  | Lifthenelse of lambda * lambda * lambda
  | Lsequence of lambda * lambda
  | Lwhile of lambda * lambda
  | Lfor of Ident.t * lambda * lambda * direction_flag * lambda
  | Lassign of Ident.t * lambda
  | Levent of lambda * lambda_event
@

<<type Lambda.lambda_switch>>=
and lambda_switch =
  { sw_numconsts: int;                  (* Number of integer cases *)
    sw_consts: (int * lambda) list;     (* Integer cases *)
    sw_numblocks: int;                  (* Number of tag block cases *)
    sw_blocks: (int * lambda) list;     (* Tag block cases *)
    sw_checked: bool }                  (* True if bound checks needed *)
@


<<type Lambda.function_kind>>=
type function_kind = Curried | Tupled
@

<<type Lambda.let_kind>>=
type let_kind = Strict | Alias | StrictOpt
@

<<type Lambda.shared_code>>=
type shared_code = (int * int) list     (* stack size -> code label *)
@
% ???

\subsubsection{Primitives}

<<type Lambda.primitive>>=
type primitive =
    Pidentity

  (* Globals *)
  | Pgetglobal of Ident.t
  | Psetglobal of Ident.t

  (* Operations on heap blocks *)
  | Pmakeblock of int * mutable_flag
  | Pfield of int
  | Psetfield of int * bool
  | Pfloatfield of int
  | Psetfloatfield of int

  (* External call *)
  | Pccall of Primitive.description

  (* Exceptions *)
  | Praise

  (* Boolean operations *)
  | Psequand | Psequor | Pnot

  (* Integer operations *)
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of comparison
  | Poffsetint of int
  | Poffsetref of int

  (* Float operations *)
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of comparison

  (* String operations *)
  | Pstringlength | Pstringrefu | Pstringsetu | Pstringrefs | Pstringsets

  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind

  (* Bitvect operations *)
  | Pbittest
@

<<type Lambda.comparison>>=
and comparison =
    Ceq | Cneq | Clt | Cgt | Cle | Cge
@


\subsubsection{Structured constants}

<<type Lambda.structured_constant>>=
type structured_constant =
    Const_base of constant
  | Const_pointer of int
  | Const_block of int * structured_constant list
  | Const_float_array of string list
@



\subsection{Primitives, [[Translcore.transl_primitive()]]}

<<signature Translcore.transl_primitive>>=
val transl_primitive: Primitive.description -> lambda
@

<<signature Translcore.transl_exception>>=
val transl_exception: Ident.t -> exception_declaration -> lambda
@





<<signature Translmod.primitive_declarations>>=
val primitive_declarations: string list ref
@


<<constant Translcore.comparisons_table>>=
(* Translation of primitives *)

let comparisons_table = create_hashtable 11 [
  "%equal",
      (Pccall{prim_name = "equal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Ceq,
       Pfloatcomp Ceq,
       Pccall{prim_name = "string_equal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%notequal",
      (Pccall{prim_name = "notequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cneq,
       Pfloatcomp Cneq,
       Pccall{prim_name = "string_notequal"; prim_arity = 2;
              prim_alloc = false; prim_native_name = ""; 
              prim_native_float = false});
  "%lessthan",
      (Pccall{prim_name = "lessthan"; prim_arity = 2; prim_alloc = false; 
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Clt,
       Pfloatcomp Clt,
       Pccall{prim_name = "lessthan"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%greaterthan",
      (Pccall{prim_name = "greaterthan"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cgt,
       Pfloatcomp Cgt,
       Pccall{prim_name = "greaterthan"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%lessequal",
      (Pccall{prim_name = "lessequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cle,
       Pfloatcomp Cle,
       Pccall{prim_name = "lessequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%greaterequal",
      (Pccall{prim_name = "greaterequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cge,
       Pfloatcomp Cge,
       Pccall{prim_name = "greaterequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false})
]
@

<<constant Translcore.primitives_table>>=
let primitives_table = create_hashtable 31 [
  "%identity", Pidentity;
  "%field0", Pfield 0;
  "%field1", Pfield 1;
  "%setfield0", Psetfield(0, true);
  "%makeblock", Pmakeblock(0, Immutable);
  "%makemutable", Pmakeblock(0, Mutable);
  "%raise", Praise;
  "%sequand", Psequand;
  "%sequor", Psequor;
  "%boolnot", Pnot;
  "%negint", Pnegint;
  "%succint", Poffsetint 1;
  "%predint", Poffsetint(-1);
  "%addint", Paddint;
  "%subint", Psubint;
  "%mulint", Pmulint;
  "%divint", Pdivint;
  "%modint", Pmodint;
  "%andint", Pandint;
  "%orint", Porint;
  "%xorint", Pxorint;
  "%lslint", Plslint;
  "%lsrint", Plsrint;
  "%asrint", Pasrint;
  "%eq", Pintcomp Ceq;
  "%noteq", Pintcomp Cneq;
  "%ltint", Pintcomp Clt;
  "%leint", Pintcomp Cle;
  "%gtint", Pintcomp Cgt;
  "%geint", Pintcomp Cge;
  "%incr", Poffsetref(1);
  "%decr", Poffsetref(-1);
  "%intoffloat", Pintoffloat;
  "%floatofint", Pfloatofint;
  "%negfloat", Pnegfloat;
  "%absfloat", Pabsfloat;
  "%addfloat", Paddfloat;
  "%subfloat", Psubfloat;
  "%mulfloat", Pmulfloat;
  "%divfloat", Pdivfloat;
  "%eqfloat", Pfloatcomp Ceq;
  "%noteqfloat", Pfloatcomp Cneq;
  "%ltfloat", Pfloatcomp Clt;
  "%lefloat", Pfloatcomp Cle;
  "%gtfloat", Pfloatcomp Cgt;
  "%gefloat", Pfloatcomp Cge;
  "%string_length", Pstringlength;
  "%string_safe_get", Pstringrefs;
  "%string_safe_set", Pstringsets;
  "%string_unsafe_get", Pstringrefu;
  "%string_unsafe_set", Pstringsetu;
  "%array_length", Parraylength Pgenarray;
  "%array_safe_get", Parrayrefs Pgenarray;
  "%array_safe_set", Parraysets Pgenarray;
  "%array_unsafe_get", Parrayrefu Pgenarray;
  "%array_unsafe_set", Parraysetu Pgenarray;
  "%obj_size", Parraylength Paddrarray;
  "%obj_field", Parrayrefu Paddrarray;
  "%obj_set_field", Parraysetu Paddrarray
]
@

\subsection{Expressions, [[Translcore.transl_exp()]]}


<<signature Translcore.transl_exp>>=
val transl_exp: expression -> lambda
@

<<signature Translcore.transl_let>>=
val transl_let:
      rec_flag -> (pattern * expression) list -> lambda -> lambda
@

\subsection{Modules, [[Translmod.transl_implementation()]]}

<<signature Translmod.transl_implementation>>=
val transl_implementation: string -> structure -> module_coercion -> lambda
@

<<signature Translmod.transl_store_implementation>>=
val transl_store_implementation:
      string -> structure -> module_coercion -> int * lambda
@

<<signature Translmod.transl_toplevel_definition>>=
val transl_toplevel_definition: structure -> lambda
@

\section{Lambda simplifications}

<<signature Simplif.simplify_lambda>>=
val simplify_lambda: lambda -> lambda
@

%(* Elimination of useless Llet(Alias) bindings.
%   Also transform let-bound references into variables. *)

\section{Pattern matching compilation}

<<signature Matching.for_function>>=
val for_function:
        Location.t -> int ref option -> lambda -> (pattern * lambda) list ->
        lambda
@

<<signature Matching.for_trywith>>=
val for_trywith:
        lambda -> (pattern * lambda) list -> lambda
@

<<signature Matching.for_let>>=
val for_let:
        Location.t -> lambda -> pattern -> lambda -> lambda
@

<<signature Matching.for_multiple_match>>=
val for_multiple_match:
        Location.t -> lambda list -> (pattern * lambda) list -> lambda
@

<<signature Matching.for_tupled_function>>=
val for_tupled_function:
        Location.t -> Ident.t list -> (pattern list * lambda) list -> lambda
@


%(*  See Peyton-Jones, "The Implementation of functional programming
%    languages", chapter 5. *)


\section{[[Lambda]] calcul to bytecode}


\subsection{[[Instruction]]}

<<type Instruct.label>>=
(* Abstract machine instructions *)

type label = int                        (* Symbolic code labels *)
@

<<type Instruct.instruction>>=
type instruction =
    Klabel of label
  | Kacc of int
  | Kenvacc of int
  | Kpush
  | Kpop of int
  | Kassign of int
  | Kpush_retaddr of label
  | Kapply of int                       (* number of arguments *)
  | Kappterm of int * int               (* number of arguments, slot size *)
  | Kreturn of int                      (* slot size *)
  | Krestart
  | Kgrab of int                        (* number of arguments *)
  | Kclosure of label * int
  | Kclosurerec of label * int
  | Kgetglobal of Ident.t
  | Ksetglobal of Ident.t
  | Kconst of structured_constant
  | Kmakeblock of int * int             (* size, tag *)
  | Kgetfield of int
  | Ksetfield of int
  | Kdummy of int                       (* block size *)
  | Kupdate of int                      (* block size *)
  | Kvectlength
  | Kgetvectitem
  | Ksetvectitem
  | Kgetstringchar
  | Ksetstringchar
  | Kbranch of label
  | Kbranchif of label
  | Kbranchifnot of label
  | Kstrictbranchif of label
  | Kstrictbranchifnot of label
  | Kswitch of label array * label array
  | Kboolnot
  | Kpushtrap of label
  | Kpoptrap
  | Kraise
  | Kcheck_signals
  | Kccall of string * int
  | Knegint | Kaddint | Ksubint | Kmulint | Kdivint | Kmodint
  | Kandint | Korint | Kxorint | Klslint | Klsrint | Kasrint
  | Kintcomp of comparison
  | Koffsetint of int
  | Koffsetref of int
  | Kevent of debug_event
  | Kstop
@

<<signature Instruct.immed_min>>=
val immed_min: int
@

<<signature Instruct.immed_max>>=
val immed_max: int
@

\subsection{[[Bytegen.compile_implementation()]]}

<<signature Bytegen.compile_implementation>>=
val compile_implementation: string -> lambda -> instruction list
@

\subsection{Binary bytecode format, [[.cmo]]}

%(* Format of a .cmo file:
%     magic number (Config.cmo_magic_number)
%     absolute offset of compilation unit descriptor
%     block of relocatable bytecode
%     compilation unit descriptor *)

<<type Emitcode.reloc_info>>=
(* Relocation information *)

type reloc_info =
    Reloc_literal of structured_constant    (* structured constant *)
  | Reloc_getglobal of Ident.t              (* reference to a global *)
  | Reloc_setglobal of Ident.t              (* definition of a global *)
  | Reloc_primitive of string               (* C primitive number *)
@

<<type Emitcode.compilation_unit>>=
(* Descriptor for compilation units *)

type compilation_unit =
  { cu_name: string;                    (* Name of compilation unit *)
    mutable cu_pos: int;                (* Absolute position in file *)
    cu_codesize: int;                   (* Size of code block *)
    cu_reloc: (reloc_info * int) list;  (* Relocation information *)
    cu_imports: (string * Digest.t) list; (* Names and CRC of intfs imported *)
    cu_primitives: string list;         (* Primitives declared inside *)
    mutable cu_force_link: bool;        (* Must be linked even if unref'ed *)
    mutable cu_debug: int;              (* Position of debugging info, or 0 *)
    cu_debugsize: int }                 (* Length of debugging info *)
@


\subsection{[[Emitcode.to_file()]]}

<<signature Emitcode.to_file>>=
(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     compilation unit descriptor *)

val to_file: out_channel -> string -> instruction list -> unit
        (* Arguments:
             channel on output file
             name of compilation unit implemented
             list of instructions to emit *)
@


<<function Emitcode.to_file>>=
(* Emission to a file *)

let to_file outchan unit_name code =
  init();
  output_string outchan cmo_magic_number;
  let pos_depl = pos_out outchan in
  output_binary_int outchan 0;
  let pos_code = pos_out outchan in
  emit code;
  output outchan !out_buffer 0 !out_position;
  let (pos_debug, size_debug) =
    if !Clflags.debug then begin
      let p = pos_out outchan in
      output_value outchan !events;
      (p, pos_out outchan - p)
    end else
      (0, 0) in
  let compunit =
    { cu_name = unit_name;
      cu_pos = pos_code;
      cu_codesize = !out_position;
      cu_reloc = List.rev !reloc_info;
      cu_imports = Env.imported_units();
      cu_primitives = !Translmod.primitive_declarations;
      cu_force_link = false;
      cu_debug = pos_debug;
      cu_debugsize = size_debug } in
  init();                               (* Free out_buffer and reloc_info *)
(*  Btype.cleanup_abbrev ();*)              (* Remove any cached abbreviation
                                           expansion before saving *)
  let pos_compunit = pos_out outchan in
  output_value outchan compunit;
  seek_out outchan pos_depl;
  output_binary_int outchan pos_compunit
@


\chapter{Linking}

<<constant Clflags.ccobjs>>=
let ccobjs = ref ([] : string list)     (* .o, .a and -lxxx files *)
@


<<constant Clflags.exec_name>>=
let exec_name = ref "a.out"             (* -o *)
@

<<constant Clflags.include_dirs>>=
let include_dirs = ref ([] : string list)(* -I *)
@




<<constant Clflags.link_everything>>=
let link_everything = ref false         (* -linkall *)
@

<<constant Clflags.custom_runtime>>=
let custom_runtime = ref false          (* -custom *)
@



<<type Bytelink.link_action>>=
type link_action =
    Link_object of string * compilation_unit
      (* Name of .cmo file and descriptor of the unit *)
  | Link_archive of string * compilation_unit list
      (* Name of .cma file and descriptors of the units to be linked. *)
@

\section{Basic linking}

<<signature Bytelink.link>>=
(* Link .cmo files and produce a bytecode executable. *)

val link: string list -> unit
@




\section{Safe linking}

<<signature Bytelink.check_consistency>>=
val check_consistency: string -> Emitcode.compilation_unit -> unit
@

<<constant Bytelink.crc_interfaces>>=
(* Consistency check between interfaces *)

let crc_interfaces =
  (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)
@

<<function Bytelink.check_consistency>>=
let check_consistency file_name cu =
  List.iter
    (fun (name, crc) ->
      if name = cu.cu_name then begin
        Hashtbl.add crc_interfaces name (file_name, crc)
      end else begin
        try
          let (auth_name, auth_crc) = Hashtbl.find crc_interfaces name in
          if crc <> auth_crc then
            raise(Error(Inconsistent_import(name, file_name, auth_name)))
        with Not_found ->
          (* Can only happen for unit for which only a .cmi file was used,
             but no .cmo is provided *)
          Hashtbl.add crc_interfaces name (file_name, crc)
      end)
    cu.cu_imports
@

\section{Archives}

<<constant Clflags.make_archive>>=
let make_archive = ref false            (* -a *)
@

<<constant Clflags.archive_name>>=
let archive_name = ref "library.cma"    (* -o *)
@

<<signature Bytelibrarian.create_archive>>=
(* Format of a library file:
      magic number (Config.cma_magic_number)
      absolute offset of content table
      blocks of relocatable bytecode
      content table = list of compilation units
*)
val create_archive: string list -> string -> unit
@

\subsection{Archive format, [[.cma]]}

%(* Format of a library file:
%      magic number (Config.cma_magic_number)
%      absolute offset of content table
%      blocks of relocatable bytecode
%      content table = list of compilation units
%*)

\section{Linking with C}

<<signature Compile.c_file>>=
val c_file: string -> unit
@

<<function Compile.c_file>>=
let c_file name =
  if Ccomp.compile_file_bytecode name <> 0 then exit 2
@

\subsection{Foreign function interface}
% ffi

\subsection{C compilation}

<<signature Ccomp.command>>=
val command: string -> int
@

<<signature Ccomp.compile_file_bytecode>>=
val compile_file_bytecode: string -> int
@

<<signature Ccomp.compile_file_native>>=
val compile_file_native: string -> int
@

<<signature Ccomp.create_archive>>=
val create_archive: string -> string list -> int
@



<<function Ccomp.compile_file_bytecode>>=
let compile_file_bytecode name =
  command
   (Printf.sprintf
     "%s -c %s %s -I%s %s"
     Config.bytecomp_c_compiler
     (String.concat " " (List.rev !Clflags.ccopts))
     (String.concat " "
       (List.map (fun dir -> "-I" ^ dir) 
                 (List.rev !Clflags.include_dirs)))
     Config.standard_library
     name)
@

<<function Ccomp.compile_file_native>>=
let compile_file_native name =
  command
   (Printf.sprintf
     "%s -c %s %s -I%s %s"
     Config.native_c_compiler
     (String.concat " " (List.rev !Clflags.ccopts))
     (String.concat " "
       (List.map (fun dir -> "-I" ^ dir) 
                 (List.rev !Clflags.include_dirs)))
     Config.standard_library
     name)
@

<<function Ccomp.create_archive>>=
let create_archive archive file_list =
  Misc.remove_file archive;
  match Config.system with
    "win32" ->
      command(Printf.sprintf "lib /nologo /debugtype:cv /out:%s %s"
                                 archive (String.concat " " file_list))
  | _ ->
      let r1 =
        command(Printf.sprintf "ar rc %s %s"
                                   archive (String.concat " " file_list)) in
      if r1 <> 0 or String.length Config.ranlib = 0
      then r1
      else command(Config.ranlib ^ " " ^ archive)
@


\chapter{Interpreting}
% Running

\section{Startup}

<<constant Clflags.keep_startup_file>>=
let keep_startup_file = ref false       (* -dstartup *)
@

\section{Primitives}


\chapter{Garbage Collection}

\chapter{Native Code Generation}

<<constant Clflags.native_code>>=
let native_code = ref false             (* set to true under ocamlopt *)
@

<<constant Clflags.ccopts>>=
let ccopts = ref ([] : string list)     (* -ccopt *)
@


<<constant Clflags.inline_threshold>>=
let inline_threshold = ref 10
@

<<constant Clflags.keep_asm_file>>=
let keep_asm_file = ref false           (* -S *)
@

<<constant Clflags.object_name>>=
let object_name = ref ("camlprog" ^ Config.ext_obj) (* -o *)
@
%camlprog??

<<constant Clflags.output_c_object>>=
let output_c_object = ref false         (* -output-obj *)
@
%??

\chapter{Debugging Support}

<<constant Clflags.debug>>=
let debug = ref false                   (* -g *)
@


\section{Events}

<<constant Bytelink.debug_info>>=
(* Second pass: link in the required units *)

let debug_info = ref ([] : debug_event list list)
@



<<constant Bytelink.debug_info (./bytecomp/bytelink.ml)>>=
(* Relocate and record compilation events *)

let debug_info = ref ([] : debug_event list list)
@

<<function Bytelink.record_events>>=
let record_events orig evl =
  if evl <> [] then begin
    List.iter
      (fun ev ->
         ev.ev_pos <- orig + ev.ev_pos;
         begin match ev.ev_repr with
           Event_parent repr -> repr := ev.ev_pos
         | _                 -> ()
         end)
      evl;
    debug_info := evl :: !debug_info
  end
@

\subsection{Lambda events}

<<type Lambda.lambda_event>>=
and lambda_event =
  { lev_loc: int;
    lev_kind: lambda_event_kind;
    lev_repr: int ref option;
    lev_env: Env.summary }
@

<<type Lambda.lambda_event_kind>>=
and lambda_event_kind =
    Lev_before
  | Lev_after of Types.type_expr
  | Lev_function
@

\subsection{Instruction events}

%(* The ce_stack component gives locations of variables residing 
%   in the stack. The locations are offsets w.r.t. the origin of the
%   stack frame.
%   The ce_heap component gives the positions of variables residing in the
%   heap-allocated environment. *)

<<type Instruct.compilation_env>>=
(* Structure of compilation environments *)

type compilation_env =
  { ce_stack: int Ident.tbl; (* Positions of variables in the stack *)
    ce_heap: int Ident.tbl } (* Structure of the heap-allocated env *)
@

<<type Instruct.debug_event>>=
type debug_event =
  { mutable ev_pos: int;                (* Position in bytecode *)
    ev_module: string;                  (* Name of defining module *)
    ev_char: int;                       (* Location in source file *)
    ev_kind: debug_event_kind;          (* Before/after event *)
    ev_info: debug_event_info;          (* Extra information *)
    ev_typenv: Env.summary;             (* Typing environment *)
    ev_compenv: compilation_env;        (* Compilation environment *)
    ev_stacksize: int;                  (* Size of stack frame *)
    ev_repr: debug_event_repr }         (* Position of the representative *)
@

<<type Instruct.debug_event_kind>>=
and debug_event_kind =
    Event_before
  | Event_after of Types.type_expr
  | Event_pseudo
@

<<type Instruct.debug_event_info>>=
and debug_event_info =
    Event_function
  | Event_return of int
  | Event_other
@

<<type Instruct.debug_event_repr>>=
and debug_event_repr =
    Event_none
  | Event_parent of int ref
  | Event_child of int ref
@

\subsection{Bytecode events}

<<constant Emitcode.events>>=
(* Debugging events *)

let events = ref ([] : debug_event list)
@

<<function Emitcode.record_event>>=
let record_event ev =
  ev.ev_pos <- !out_position;
  events := ev :: !events
@


\chapter{Profiling Support}

% actually there is no flag for profiling in ocamlc?


\chapter{Advanced Features}

\section{Floats}

\section{Arrays}

<<type Lambda.array_kind>>=
and array_kind =
    Pgenarray | Paddrarray | Pintarray | Pfloatarray
@


\chapter{Advanced Topics}

<<constant Clflags.print_types>>=
let print_types = ref false             (* -i *)
@




<<constant Clflags.fast>>=
let fast = ref false                    (* -unsafe *)
@

<<constant Clflags.optimize_for_speed>>=
let optimize_for_speed = ref true       (* -compact *)
@



<<constant Clflags.noassert>>=
let noassert = ref false                (* -noassert *)
@


\section{Threads}

<<constant Clflags.thread_safe>>=
let thread_safe = ref false             (* -thread *)
@

\section{Preprocessing}

<<constant Clflags.preprocessor>>=
let preprocessor = ref(None : string option) (* -pp *)
@

<<function Compile.preprocess>>=
(* Optionally preprocess a source file *)

let preprocess sourcefile tmpfile =
  match !Clflags.preprocessor with
    None -> sourcefile
  | Some pp ->
      let comm = pp ^ " " ^ sourcefile ^ " > " ^ tmpfile in
      if Ccomp.command comm <> 0 then begin
        Printf.eprintf "Preprocessing error\n";
        flush stderr;
        exit 2
      end;
      tmpfile
@

<<function Compile.remove_preprocessed>>=
let remove_preprocessed inputfile =
  match !Clflags.preprocessor with
    None -> ()
  | Some _ -> remove_file inputfile
@


\subsection{[[#line]]}


\section{Toplevel}

<<signature Parse.toplevel_phrase>>=
val toplevel_phrase : Lexing.lexbuf -> Parsetree.toplevel_phrase
@

<<signature Parse.use_file>>=
val use_file : Lexing.lexbuf -> Parsetree.toplevel_phrase list
@

<<function Parse.skip_phrase>>=
(* Skip tokens to the end of the phrase *)
let rec skip_phrase lexbuf =
  try
    match Lexer.token lexbuf with
      Parser.SEMISEMI | Parser.EOF -> ()
    | _ -> skip_phrase lexbuf
  with
    | Lexer.Error (Lexer.Unterminated_comment, _, _) -> ()
    | Lexer.Error (Lexer.Unterminated_string, _, _) -> ()
    | Lexer.Error(_,_,_) -> skip_phrase lexbuf
@

<<function Parse.maybe_skip_phrase>>=
let maybe_skip_phrase lexbuf =
  if Parsing.is_current_lookahead Parser.SEMISEMI
  or Parsing.is_current_lookahead Parser.EOF
  then ()
  else skip_phrase lexbuf
@


<<function Parse.xxx>>=
let toplevel_phrase = wrap Parser.toplevel_phrase
let use_file = wrap Parser.use_file
@

\subsection{Phrases}

<<type Parsetree.toplevel_phrase>>=
type toplevel_phrase =
    Ptop_def of structure
  | Ptop_dir of string * directive_argument
@

<<type Parsetree.directive_argument>>=
and directive_argument =
    Pdir_none
  | Pdir_string of string
  | Pdir_int of int
  | Pdir_ident of Longident.t
@

\chapter{Conclusion}







\appendix

\chapter{Debugging}


\section{Verbose mode, [[-v]]}

<<constant Clflags.verbose>>=
let verbose = ref false                 (* -verbose *)
@

<<function Ccomp.command>>=
let command cmdline =
  if !Clflags.verbose then begin
    prerr_string "+ ";
    prerr_string cmdline;
    prerr_newline()
  end;
  Sys.command cmdline
@

\section{Dumpers, [[-dxxx]]}

%later: could be autogenerated! and save lots of boilerplate code?


\subsection{Bytecode data structures}

\subsubsection{[[-dlambda]]}

<<constant Clflags.dump_lambda>>=
let dump_lambda = ref false             (* -dlambda *)
@

<<constant Clflags.dump_rawlambda>>=
let dump_rawlambda = ref false          (* -drawlambda *)
@
% before simplify



<<signature Printlambda.lambda>>=
val lambda: lambda -> unit
@


<<function Printlambda.lambda>>=
let rec lambda = function
    Lvar id ->
      Ident.print id
  | Lconst cst ->
      structured_constant cst
  | Lapply(lfun, largs) ->
      open_box 2;
      print_string "(apply"; print_space();
      lambda lfun;
      List.iter (fun l -> print_space(); lambda l) largs;
      print_string ")";
      close_box()
  | Lfunction(kind, params, body) ->
      open_box 2;
      print_string "(function";
      begin match kind with
        Curried ->
          List.iter (fun param -> print_space(); Ident.print param) params
      | Tupled ->
          print_string " (";
          let first = ref true in
          List.iter
            (fun param ->
              if !first
              then first := false
              else begin print_string ",";print_space() end;
              Ident.print param)
            params
      end;
      print_space(); lambda body; print_string ")"; close_box()
  | Llet(str, id, arg, body) ->
      open_box 2;
      print_string "(let"; print_space();
      open_hvbox 1;
      print_string "(";
      open_box 2; Ident.print id; print_space(); lambda arg; close_box();
      letbody body;
      print_string ")";
      close_box()
  | Lletrec(id_arg_list, body) ->
      open_box 2;
      print_string "(letrec"; print_space();
      print_string "(";
      open_hvbox 1;
      let spc = ref false in
      List.iter
        (fun (id, l) ->
          if !spc then print_space() else spc := true;
          open_box 2;
          Ident.print id; print_space(); lambda l;
          close_box())
        id_arg_list;
      close_box();
      print_string ")";
      print_space(); lambda body;
      print_string ")"; close_box()
  | Lprim(prim, largs) ->
      open_box 2;
      print_string "("; primitive prim;
      List.iter (fun l -> print_space(); lambda l) largs;
      print_string ")";
      close_box()
  | Lswitch(larg, sw) ->
      open_box 1;
      print_string (if sw.sw_checked then "(switch-checked " else "(switch ");
      lambda larg; print_space();
      open_vbox 0;
      let spc = ref false in
      List.iter
        (fun (n, l) ->
          if !spc then print_space() else spc := true;
          open_hvbox 1;
          print_string "case int "; print_int n;
          print_string ":"; print_space();
          lambda l;
          close_box())
        sw.sw_consts;
      List.iter
        (fun (n, l) ->
          if !spc then print_space() else spc := true;
          open_hvbox 1;
          print_string "case tag "; print_int n;
          print_string ":"; print_space();
          lambda l;
          close_box())
        sw.sw_blocks;
      print_string ")"; close_box(); close_box()
  | Lstaticfail ->
      print_string "exit"
  | Lcatch(lbody, lhandler) ->
      open_box 2;
      print_string "(catch"; print_space();
      lambda lbody; print_break 1 (-1);
      print_string "with"; print_space(); lambda lhandler;
      print_string ")";
      close_box()
  | Ltrywith(lbody, param, lhandler) ->
      open_box 2;
      print_string "(try"; print_space();
      lambda lbody; print_break 1 (-1);
      print_string "with "; Ident.print param; print_space();
      lambda lhandler;
      print_string ")";
      close_box()
  | Lifthenelse(lcond, lif, lelse) ->
      open_box 2;
      print_string "(if"; print_space();
      lambda lcond; print_space();
      lambda lif; print_space();
      lambda lelse; print_string ")";
      close_box()
  | Lsequence(l1, l2) ->
      open_box 2;
      print_string "(seq"; print_space();
      lambda l1; print_space(); sequence l2; print_string ")";
      close_box()
  | Lwhile(lcond, lbody) ->
      open_box 2;
      print_string "(while"; print_space();
      lambda lcond; print_space();
      lambda lbody; print_string ")";
      close_box()
  | Lfor(param, lo, hi, dir, body) ->
      open_box 2;
      print_string "(for "; Ident.print param; print_space();
      lambda lo; print_space();
      print_string(match dir with Upto -> "to" | Downto -> "downto");
      print_space();
      lambda hi; print_space();
      lambda body; print_string ")";
      close_box()
  | Lassign(id, expr) ->
      open_box 2;
      print_string "(assign"; print_space();
      Ident.print id; print_space();
      lambda expr; print_string ")";
      close_box()
  | Levent(lam, ev) ->
      open_box 2;
      begin match ev.lev_kind with
        Lev_before   -> print_string "(before "
      | Lev_after _  -> print_string "(after "
      | Lev_function -> print_string "(funct-body "
      end;
      print_int ev.lev_loc;
      print_space();
      lambda lam;
      print_string ")";
      close_box()

and sequence = function
    Lsequence(l1, l2) ->
      sequence l1; print_space(); sequence l2
  | Llet(str, id, arg, body) ->
      open_box 2;
      print_string "let"; print_space();
      Ident.print id; print_space(); lambda arg;
      close_box();
      print_space();
      sequence body
  | l ->
      lambda l

and letbody = function
    Llet(str, id, arg, body) ->
      print_space();
      open_box 2; Ident.print id; print_space(); lambda arg;
      close_box();
      letbody body
  | l ->
      print_string ")";
      close_box();
      print_space();
      lambda l
@


<<signature Printlambda.structured_constant>>=
val structured_constant: structured_constant -> unit
@


<<function Printlambda.structured_constant>>=
let rec structured_constant = function
    Const_base(Const_int n) -> print_int n
  | Const_base(Const_char c) ->
      print_string "'"; print_string(Char.escaped c); print_string "'"
  | Const_base(Const_string s) ->
      print_string "\""; print_string(String.escaped s); print_string "\""
  | Const_base(Const_float s) ->
      print_string s
  | Const_pointer n -> print_int n; print_string "a"
  | Const_block(tag, []) ->
      print_string "["; print_int tag; print_string "]"
  | Const_block(tag, sc1::scl) ->
      open_box 1;
      print_string "["; print_int tag; print_string ":";
      print_space();
      open_box 0;
      structured_constant sc1;
      List.iter (fun sc -> print_space(); structured_constant sc) scl;
      close_box();
      print_string "]";
      close_box()
  | Const_float_array [] ->
      print_string "[| |]"
  | Const_float_array (f1 :: fl) ->
      open_box 1;
      print_string "[|";
      open_box 0;
      print_string f1;
      List.iter (fun f -> print_space(); print_string f) fl;
      close_box();
      print_string "|]";
      close_box()
@

<<function Printlambda.primitive>>=
let primitive = function
    Pidentity -> print_string "id"
  | Pgetglobal id -> print_string "global "; Ident.print id
  | Psetglobal id -> print_string "setglobal "; Ident.print id
  | Pmakeblock(tag, Immutable) -> print_string "makeblock "; print_int tag
  | Pmakeblock(tag, Mutable) -> print_string "makemutable "; print_int tag
  | Pfield n -> print_string "field "; print_int n
  | Psetfield(n, _) -> print_string "setfield "; print_int n
  | Pfloatfield n -> print_string "floatfield "; print_int n
  | Psetfloatfield n -> print_string "setfloatfield "; print_int n
  | Pccall p -> print_string p.prim_name
  | Praise -> print_string "raise"
  | Psequand -> print_string "&&"
  | Psequor -> print_string "||"
  | Pnot -> print_string "not"
  | Pnegint -> print_string "~"
  | Paddint -> print_string "+"
  | Psubint -> print_string "-"
  | Pmulint -> print_string "*"
  | Pdivint -> print_string "/"
  | Pmodint -> print_string "mod"
  | Pandint -> print_string "and"
  | Porint -> print_string "or"
  | Pxorint -> print_string "xor"
  | Plslint -> print_string "lsl"
  | Plsrint -> print_string "lsr"
  | Pasrint -> print_string "asr"
  | Pintcomp(Ceq) -> print_string "=="
  | Pintcomp(Cneq) -> print_string "!="
  | Pintcomp(Clt) -> print_string "<"
  | Pintcomp(Cle) -> print_string "<="
  | Pintcomp(Cgt) -> print_string ">"
  | Pintcomp(Cge) -> print_string ">="
  | Poffsetint n -> print_int n; print_string "+"
  | Poffsetref n -> print_int n; print_string "+:="
  | Pintoffloat -> print_string "int_of_float"
  | Pfloatofint -> print_string "float_of_int"
  | Pnegfloat -> print_string "~."
  | Pabsfloat -> print_string "abs."
  | Paddfloat -> print_string "+."
  | Psubfloat -> print_string "-."
  | Pmulfloat -> print_string "*."
  | Pdivfloat -> print_string "/."
  | Pfloatcomp(Ceq) -> print_string "==."
  | Pfloatcomp(Cneq) -> print_string "!=."
  | Pfloatcomp(Clt) -> print_string "<."
  | Pfloatcomp(Cle) -> print_string "<=."
  | Pfloatcomp(Cgt) -> print_string ">."
  | Pfloatcomp(Cge) -> print_string ">=."
  | Pstringlength -> print_string "string.length"
  | Pstringrefu -> print_string "string.unsafe_get"
  | Pstringsetu -> print_string "string.unsafe_set"
  | Pstringrefs -> print_string "string.get"
  | Pstringsets -> print_string "string.set"
  | Parraylength _ -> print_string "array.length"
  | Pmakearray _ -> print_string "makearray "
  | Parrayrefu _ -> print_string "array.unsafe_get"
  | Parraysetu _ -> print_string "array.unsafe_set"
  | Parrayrefs _ -> print_string "array.get"
  | Parraysets _ -> print_string "array.set"
  | Pbittest -> print_string "testbit"
@



\subsubsection{[[-dInstr]]}

<<constant Clflags.dump_instr>>=
let dump_instr = ref false              (* -dinstr *)
@


<<signature Printinstr.instruction>>=
val instruction: instruction -> unit
@

<<signature Printinstr.instrlist>>=
val instrlist: instruction list -> unit
@


<<constant Printinstr.instruction>>=
let instruction = function
    Klabel lbl -> print_string "L"; print_int lbl; print_string ":"
  | Kacc n -> print_string "\tacc "; print_int n
  | Kenvacc n -> print_string "\tenvacc "; print_int n
  | Kpush -> print_string "\tpush"
  | Kpop n -> print_string "\tpop "; print_int n
  | Kassign n -> print_string "\tassign "; print_int n
  | Kpush_retaddr lbl -> print_string "\tpush_retaddr L"; print_int lbl
  | Kapply n -> print_string "\tapply "; print_int n
  | Kappterm(n, m) ->
      print_string "\tappterm "; print_int n; print_string ", "; print_int m
  | Kreturn n -> print_string "\treturn "; print_int n
  | Krestart -> print_string "\trestart"
  | Kgrab n -> print_string "\tgrab "; print_int n
  | Kclosure(lbl, n) ->
      print_string "\tclosure L"; print_int lbl; print_string ", "; print_int n
  | Kclosurerec(lbl, n) ->
      print_string "\tclosurerec L"; print_int lbl;
      print_string ", "; print_int n
  | Kgetglobal id -> print_string "\tgetglobal "; Ident.print id
  | Ksetglobal id -> print_string "\tsetglobal "; Ident.print id
  | Kconst cst ->
      open_box 10; print_string "\tconst"; print_space();
      Printlambda.structured_constant cst; close_box()
  | Kmakeblock(n, m) ->
      print_string "\tmakeblock "; print_int n; print_string ", "; print_int m
  | Kgetfield n -> print_string "\tgetfield "; print_int n
  | Ksetfield n -> print_string "\tsetfield "; print_int n
  | Kdummy n -> print_string "\tdummy "; print_int n
  | Kupdate n -> print_string "\tupdate"; print_int n
  | Kvectlength -> print_string "\tvectlength"
  | Kgetvectitem -> print_string "\tgetvectitem"
  | Ksetvectitem -> print_string "\tsetvectitem"
  | Kgetstringchar -> print_string "\tgetstringchar"
  | Ksetstringchar -> print_string "\tsetstringchar"
  | Kbranch lbl -> print_string "\tbranch L"; print_int lbl
  | Kbranchif lbl -> print_string "\tbranchif L"; print_int lbl
  | Kbranchifnot lbl -> print_string "\tbranchifnot L"; print_int lbl
  | Kstrictbranchif lbl -> print_string "\tstrictbranchif L"; print_int lbl
  | Kstrictbranchifnot lbl ->
      print_string "\tstrictbranchifnot L"; print_int lbl
  | Kswitch(consts, blocks) ->
      open_box 10;
      print_string "\tswitch";
      Array.iter (fun lbl -> print_space(); print_int lbl) consts;
      print_string "/";
      Array.iter (fun lbl -> print_space(); print_int lbl) blocks;
      close_box()
  | Kboolnot -> print_string "\tboolnot"
  | Kpushtrap lbl -> print_string "\tpushtrap L"; print_int lbl
  | Kpoptrap -> print_string "\tpoptrap"
  | Kraise -> print_string "\traise"
  | Kcheck_signals -> print_string "\tcheck_signals"
  | Kccall(s, n) ->
      print_string "\tccall "; print_string s; print_string ", "; print_int n
  | Knegint -> print_string "\tnegint"
  | Kaddint -> print_string "\taddint"
  | Ksubint -> print_string "\tsubint"
  | Kmulint -> print_string "\tmulint"
  | Kdivint -> print_string "\tdivint"
  | Kmodint -> print_string "\tmodint"
  | Kandint -> print_string "\tandint"
  | Korint -> print_string "\torint"
  | Kxorint -> print_string "\txorint"
  | Klslint -> print_string "\tlslint"
  | Klsrint -> print_string "\tlsrint"
  | Kasrint -> print_string "\tasrint"
  | Kintcomp Ceq -> print_string "\teqint"
  | Kintcomp Cneq -> print_string "\tneqint"
  | Kintcomp Clt -> print_string "\tltint"
  | Kintcomp Cgt -> print_string "\tgtint"
  | Kintcomp Cle -> print_string "\tleint"
  | Kintcomp Cge -> print_string "\tgeint"
  | Koffsetint n -> print_string "\toffsetint "; print_int n
  | Koffsetref n -> print_string "\toffsetref "; print_int n
  | Kstop -> print_string "\tstop"
  | Kevent ev -> print_string "\tevent "; print_int ev.ev_char
@

<<constant Printinstr.instruction_list>>=
let rec instruction_list = function
    [] -> ()
  | Klabel lbl :: il ->
      print_string "L"; print_int lbl; print_string ":"; instruction_list il
  | instr :: il ->
      instruction instr; print_space(); instruction_list il
@

<<function Printinstr.instrlist>>=
let instrlist il =
  open_vbox 0;
  instruction_list il;
  close_box()
@


\subsection{Native code data structures}

<<constant Clflags.dump_cmm>>=
let dump_cmm = ref false                (* -dcmm *)
@




<<constant Clflags.dump_selection>>=
let dump_selection = ref false          (* -dsel *)
@

<<constant Clflags.dump_live>>=
let dump_live = ref false               (* -dlive *)
@

<<constant Clflags.dump_spill>>=
let dump_spill = ref false              (* -dspill *)
@

<<constant Clflags.dump_split>>=
let dump_split = ref false              (* -dsplit *)
@

<<constant Clflags.dump_scheduling>>=
let dump_scheduling = ref false         (* -dscheduling *)
@

<<constant Clflags.dump_interf>>=
let dump_interf = ref false             (* -dinterf *)
@

<<constant Clflags.dump_prefer>>=
let dump_prefer = ref false             (* -dprefer *)
@

<<constant Clflags.dump_regalloc>>=
let dump_regalloc = ref false           (* -dalloc *)
@

<<constant Clflags.dump_reload>>=
let dump_reload = ref false             (* -dreload *)
@

<<constant Clflags.dump_linear>>=
let dump_linear = ref false             (* -dlinear *)
@



\chapter{Profiling}

\chapter{Error Managment}

<<signature Errors.report_error>>=
(* Error report *)

val report_error: exn -> unit
@


% main -> <>
<<function Errors.report_error>>=
(* Report an error *)

let report_error exn =
  open_box 0;
  begin match exn with
    Lexer.Error(err, start, stop) ->
      Location.print {loc_start = start; loc_end = stop};
      Lexer.report_error err
  | Syntaxerr.Error err ->
      Syntaxerr.report_error err

  | Env.Error err ->
      Env.report_error err
  | Typecore.Error(loc, err) ->
      Location.print loc; Typecore.report_error err
  | Typetexp.Error(loc, err) ->
      Location.print loc; Typetexp.report_error err
  | Typedecl.Error(loc, err) ->
      Location.print loc; Typedecl.report_error err
  | Includemod.Error err ->
      Includemod.report_error err
  | Typemod.Error(loc, err) ->
      Location.print loc; Typemod.report_error err

  | Translcore.Error(loc, err) ->
      Location.print loc; Translcore.report_error err
  | Symtable.Error code ->
      Symtable.report_error code
  | Bytelink.Error code ->
      Bytelink.report_error code
  | Bytelibrarian.Error code ->
      Bytelibrarian.report_error code

  | Sys_error msg ->
      print_string "I/O error: "; print_string msg

  | x ->
      close_box(); raise x
  end;
  close_box(); print_newline()
@



\section{Location errors}

<<signature Location.print>>=
val print: t -> unit
@

<<signature Location.print_warning>>=
val print_warning: t -> string -> unit
@



<<constants Location.msg_xxx>>=
let (msg_file, msg_line, msg_chars, msg_to, msg_colon, warn_head) =
  match Sys.os_type with
  | _ -> ("File \"", "\", line ", ", characters ", "-", ":", "")
@

<<function Location.print>>=
let print loc =
  if String.length !input_name = 0 then
    if highlight_locations loc none then () else begin
      print_string "Characters ";
      print_int loc.loc_start; print_string "-";
      print_int loc.loc_end; print_string ":";
      force_newline()
    end
  else begin
    let (filename, linenum, linebeg) =
            Linenum.for_position !input_name loc.loc_start in
    print_string msg_file; print_string filename;
    print_string msg_line; print_int linenum;
    print_string msg_chars; print_int (loc.loc_start - linebeg);
    print_string msg_to; print_int (loc.loc_end - linebeg);
    print_string msg_colon;
    force_newline()
  end
@




<<function Location.print_warning>>=
let print_warning loc msg =
  let (f1, f2) = Format.get_formatter_output_functions() in
  if not !Sys.interactive then Format.set_formatter_out_channel stderr;
  print loc;
  print_string warn_head;
  print_string "Warning: "; print_string msg; print_newline();
  incr num_loc_lines;
  Format.set_formatter_output_functions f1 f2
@





\section{Fatal errors}

% ?? -> <>
<<signature Misc.fatal_error>>=
val fatal_error: string -> 'a
@

<<exception Misc.Fatal_error>>=
exception Fatal_error
@

<<function Misc.fatal_error>>=
let fatal_error msg =
  prerr_string ">> Fatal error: "; prerr_endline msg; raise Fatal_error
@

\section{Lexing errors}

<<type Lexer.error>>=
type error =
    Illegal_character
  | Unterminated_comment
  | Unterminated_string
@

<<exception Lexer.Error>>=
exception Error of error * int * int
@

<<signature Lexer.report_error>>=
val report_error: error -> unit
@

% in .mll

\section{Syntax errors}

<<type Syntaxerr.error>>=
(* Auxiliary type for reporting syntax errors *)

type error =
    Unclosed of Location.t * string * Location.t * string
  | Other of Location.t
@

<<exception Syntaxerr.Error>>=
exception Error of error
@

<<exception Syntaxerr.Escape_error>>=
exception Escape_error
@

<<signature Syntaxerr.report_error>>=
val report_error: error -> unit
@


<<function Syntaxerr.report_error>>=
let report_error = function
    Unclosed(opening_loc, opening, closing_loc, closing) ->
      if String.length !Location.input_name = 0
      && Location.highlight_locations opening_loc closing_loc
      then begin
        print_string "Syntax error: '";
        print_string closing;
        print_string "' expected, the highlighted '";
        print_string opening;
        print_string "' might be unmatched"
      end else begin
        Location.print closing_loc;
        print_string "Syntax error: '";
        print_string closing;
        print_string "' expected"; force_newline();
        Location.print opening_loc;
        print_string "This '";
        print_string opening;
        print_string "' might be unmatched"
      end
  | Other loc ->
      Location.print loc;
      print_string "Syntax error"
@



\section{Compilation errors}

<<type Translcore.error>>=
type error =
    Illegal_letrec_pat
  | Illegal_letrec_expr
@

<<exception Translcore.Error>>=
exception Error of Location.t * error
@

<<signature Translcore.report_error>>=
val report_error: error -> unit
@

<<constant Translcore.report_error>>=
let report_error = function
    Illegal_letrec_pat ->
      print_string
      "Only variables are allowed as left-hand side of `let rec'"
  | Illegal_letrec_expr ->
      print_string
      "This kind of expression is not allowed as right-hand side of `let rec'"
@

\section{Linking errors}

<<type Bytelink.error>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
  | Symbol_error of string * Symtable.error
  | Inconsistent_import of string * string * string
  | Custom_runtime
  | File_exists of string
@

<<exception Bytelink.Error>>=
exception Error of error
@

<<signature Bytelink.report_error>>=
val report_error: error -> unit
@



<<constant Bytelink.report_error>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Not_an_object_file name ->
      print_string "The file "; print_string name;
      print_string " is not a bytecode object file"
  | Symbol_error(name, err) ->
      print_string "Error while linking "; print_string name; print_string ":";
      print_space();
      Symtable.report_error err
  | Inconsistent_import(intf, file1, file2) ->
      open_hvbox 0;
      print_string "Files "; print_string file1; print_string " and ";
      print_string file2; print_space();
      print_string "make inconsistent assumptions over interface ";
      print_string intf;
      close_box()
  | Custom_runtime ->
      print_string "Error while building custom runtime system"
  | File_exists file ->
      print_string "Cannot overwrite existing file "; print_string file
@





<<type Bytelibrarian.error>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
@

<<exception Bytelibrarian.Error>>=
exception Error of error
@

<<signature Bytelibrarian.report_error>>=
val report_error: error -> unit
@


<<constant Bytelibrarian.report_error>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Not_an_object_file name ->
      print_string "The file "; print_string name;
      print_string " is not a bytecode object file"
@

\chapter{Standard Library}

\section{Lists}

<<signature Misc.map_end>>=
val map_end: ('a -> 'b) -> 'a list -> 'b list -> 'b list
        (* [map_end f l t] is [map f l @ t], just more efficient. *)
@

<<signature Misc.for_all2>>=
val for_all2: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
        (* Same as [List.for_all] but for a binary predicate. *)
@

<<signature Misc.filter>>=
val filter: ('a -> bool) -> 'a list -> 'a list
@


<<signature Misc.replicate_list>>=
val replicate_list: 'a -> int -> 'a list
        (* [replicate_list elem n] is the list with [n] elements
           all identical to [elem]. *)
@




<<function Misc.map_end>>=
let rec map_end f l1 l2 =
  match l1 with
    [] -> l2
  | hd::tl -> f hd :: map_end f tl l2
@

<<function Misc.for_all2>>=
let rec for_all2 pred l1 l2 =
  match (l1, l2) with
    ([], []) -> true
  | (hd1::tl1, hd2::tl2) -> pred hd1 hd2 & for_all2 pred tl1 tl2
  | (_, _) -> false
@

<<function Misc.filter>>=
let rec filter pred =
  function
    [] ->
      []
  | a::l ->
      if pred a then
        a::(filter pred l)
      else
        filter pred l
@

<<function Misc.replicate_list>>=
let rec replicate_list elem n =
  if n <= 0 then [] else elem :: replicate_list elem (n-1)
@

\section{Assocs}

<<signature Misc.mem_assq>>=
val mem_assq: 'a -> ('a * 'b) list -> bool
@

<<function Misc.mem_assq>>=
let rec mem_assq x = function
    [] -> false
  | (a,b)::l -> a == x or mem_assq x l
@

\section{Hashes}

<<signature Misc.create_hashtable>>=
val create_hashtable: int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
        (* Create a hashtable of the given size and fills it with the
           given bindings. *)
@

<<function Misc.create_hashtable>>=
let create_hashtable size init =
  let tbl = Hashtbl.create size in
  List.iter (fun (key, data) -> Hashtbl.add tbl key data) init;
  tbl
@

\section{Files}

<<signature Misc.find_in_path>>=
val find_in_path: string list -> string -> string
        (* Search a file in a list of directories. *)
@

<<signature Misc.remove_file>>=
val remove_file: string -> unit
        (* Delete the given file if it exists. Never raise an error. *)
@

<<signature Misc.copy_file>>=
val copy_file: in_channel -> out_channel -> unit
        (* [copy_file ic oc] reads the contents of file [ic] and copies
           them to [oc]. It stops when encountering EOF on [ic]. *)
@

<<signature Misc.copy_file_chunk>>=
val copy_file_chunk: in_channel -> out_channel -> int -> unit
        (* [copy_file_chunk ic oc n] reads [n] bytes from [ic] and copies
           them to [oc]. It raises [End_of_file] when encountering
           EOF on [ic]. *)
@



<<function Misc.find_in_path>>=
let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end
@

<<function Misc.remove_file>>=
let remove_file filename =
  try
    Sys.remove filename
  with Sys_error msg ->
    ()
@


<<function Misc.copy_file>>=
let copy_file ic oc =
  let buff = String.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then () else (output oc buff 0 n; copy())
  in copy()
@

<<function Misc.copy_file_chunk>>=
let copy_file_chunk ic oc len =
  let buff = String.create 0x1000 in
  let rec copy n =
    if n <= 0 then () else begin
      let r = input ic buff 0 (min n 0x1000) in
      if r = 0 then raise End_of_file else (output oc buff 0 r; copy(n-r))
    end
  in copy len
@


\section{Math}

<<signature Misc.log2>>=
val log2: int -> int
        (* [log2 n] returns [s] such that [n = 1 lsl s] 
           if [n] is a power of 2*)
@

<<signature Misc.align>>=
val align: int -> int -> int
        (* [align n a] rounds [n] upwards to a multiple of [a]
           (a power of 2). *)
@

<<signature Misc.no_overflow_add>>=
val no_overflow_add: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 + n2] does not overflow. *)
@

<<signature Misc.no_overflow_sub>>=
val no_overflow_sub: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 - n2] does not overflow. *)
@



<<function Misc.log2>>=
let rec log2 n =
  if n <= 1 then 0 else 1 + log2(n asr 1)
@

<<function Misc.align>>=
(* @Scheck: dead by nice to have *)
let align n a =
  if n >= 0 then (n + a - 1) land (-a) else n land (-a)
@

<<function Misc.no_overflow_add>>=
let no_overflow_add a b = (a lxor b) lor (a lxor (lnot (a+b))) < 0
@

<<function Misc.no_overflow_sub>>=
let no_overflow_sub a b = (a lxor (lnot b)) lor (b lxor (a-b)) < 0
@

\section{Pretty printing}

% lots of use of Format, maybe could be good to explain,
% as it's not as common as other stuff from stdlib/


\chapter{Extra Code}

\ifallcode
#include "OCaml_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

