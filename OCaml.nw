\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - found deadcode in ocaml itself :) 
%   (all.ml, codegen.ml, a few functions)
% 

%thx to codemap/codegraph/scheck:
% - use cg to to look at backward deps (but the linker already enforces layers)
%   (harder to understand non layered code)
% - use scheck to remove deadcode, found some even in latest ocaml :)
%   (harder to understand big files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand OCaml?:
% - TODO how a gc works
% - TODO how values are represented at runtime, the Obj module
% - TODO how compiler backends work (register, liveness, etc)
% - SEMI how type inference works in caml itself, monomorphic limitations?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, type, exception, constant
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - SEMI scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features, error, debug, 
%        secu
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for ??

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The OCaml Light Compilers
}\\
{version 0.1}
}
% compilers, with an s, ocamlc and ocamlopt

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}
% with code from Xavier Leroy and Damien Doligez

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a compiler for a high level language (higher than C).
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% chose ocaml because good compromise! functional, and imperative.
% I removed parts that were more complicated:
%  - objects
%  - functors
% (indeed they were not that used in the code of ocaml itself ... hmm)
% good increments over C (see section below in first chapter).

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Scheme
% not typed, no ADT, but some nice things: macros, call/cc, eval
\item SML
% not active
\item Haskell
% nice but lazy, and too strict (no pun intended) forcing programmer
% to be purely functional (or to use intrusive and complex monads IO),
% but some nice things to steal (typeclasses, deriving, monadic do)
\item Scala
% too big, don't need objects anyway.
% implicits are nice, but controversial, just like OO they can
% lead to spaghetti code or hard to follow code more easily
\item Rust
% excellent for low-level high-level language, but want here
% high-level high-level language :)
\end{itemize}

% so many candidates to list here actually.


%https://rwmj.wordpress.com/2009/08/04/ocaml-internals/
%https://github.com/ocamllabs/ocaml-internals/wiki

\section{Getting started}

\section{Requirements}

% actually code presented below is written in OCaml so you
% need to understand OCaml :)

% also help to understand target language (in addition to host),
% so that you understand the features you are implementing,
% e.g. what is a variant, a record, a closure, etc.

\section{About this document}
#include "docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from OCaml, so
those parts are copyright by INRIA.

<<copyright header>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

\ifallcode
<<copyright header C>>=
/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  Automatique.  Distributed only by permission.                      */
/*                                                                     */
/***********************************************************************/
@
\fi
% in parser.mly

\ifallcode
<<copyright header0>>=
(***********************************************************************)
(*                                                                     *)
(*                         Caml Special Light                          *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1995 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@
% for typing/
\fi

% some are also just copyright doligez, but not that many


The prose is mine and is licensed under the GNU Free Documentation
License.


\section{Acknowledgments}

I would like to thank of course Xavier Leroy
the main author of OCaml.



\chapter{Overview}

\section{High-level language principles}

%advanced features not in C, so good increment:
% - gc (no more malloc/free and bugs), which imply special bit
%   for each values (and some tricks around integer operations)
% - parametric polymorphism (no more code duplication and void* loophole)
%   which imply boxing values for certain implementation strategy
% - closures (can factorize more code, no more loop for everything)
% - ADT and pattern matching (no more enum/switch loophole)
% - type inference (less boilerplate, especially needed when have
%   polymorphism and closures and quite complicated types)

% missing: 
%  - call/cc, too advanced? too complex for mere mortal?
%    but could, see
%    http://gallium.inria.fr/~xleroy/software/ocaml-callcc-1.0.tar.gz
%    or http://okmij.org/ftp/continuations/implementations.html
%  - macros 
%    but could at least implement deriving
% missing on purpose: 
%  - objects (see lablgtk mess), 
%  - functors (see ocamlgraph or ocsigen mess).
% toadd: 
%  - type classes (no more + vs +., print_xxx, can factorize more code)
%  - compile time metaprogramming? (no more boilerplate, show, map, visit, etc)

\section{[[ocamlc]] services}

<<constant Main.usage>>=
let usage = "Usage: ocamlc <options> <files>\nOptions are:"
@

\section{[[calc.ml]]}

\section{Input OCaml Light language}

\section{Code organization}

% datarepr.ml:  
%  "Compute constructor and label descriptions from type declarations, determining their representation"
% ctype.ml: 
%  "Operations on core types"

% typedecl.ml: typing of the type declarations
%  "Typing of type definitions and primitive definitions"

% matching.ml: 
%  "Compilation of pattern matching"
% emitcode.ml:
%  "Generation of bytecode for .cmo files"

%https://github.com/ocamllabs/ocaml-internals/wiki/Source-layout

\section{Software architecture}

% https://github.com/ocamllabs/ocaml-internals/wiki/Compiler-pipelines


% .cmi! contain signature info (Obj.marshall of types really),
% kinda .h

\section{Bootstrapping}


<<constant Clflags.nopervasives>>=
let nopervasives = ref false            (* -nopervasives *)
@
<<[[Main.main()]] command line options>>=
"-nopervasives", Arg.Set nopervasives, " (undocumented)";
@

% make bootstrap

%###############################################################################

\chapter{Core Data Structures}

%parsing/parsetree.mli and asttypes.mli
%typing/types.mli
%typing/typedtree.mli (and asttypes.mli)
%bytecomp/lambda.mli
%bytecomp/instruct.mli
%byterun/instruct.h

\section{Abstract syntax tree}

\subsection{Names}

<<type Longident.t>>=
(* Long identifiers, used in parsetree. *)

type t =
    Lident of string
  | Ldot of t * string
@
%note: like a list, but enforce have at least one element

%<<signature Longident.flatten>>=
%val flatten: t -> string list
%@
%% dead, maybe dead because removed functors, module type, etc
%
%<<function Longident.flat>>=
%let rec flat accu = function
%    Lident s -> s :: accu
%  | Ldot(lid, s) -> flat (s :: accu) lid
%@
%<<function Longident.flatten>>=
%let flatten lid = flat [] lid
%@

\subsection{Positions}

<<type Location.t>>=
(* Source code locations, used in parsetree *)

type t =
  { loc_start: int; loc_end: int }
@
% charpos

<<signature Location.none>>=
val none: t
@
<<constant Location.none>>=
let none = { loc_start = -1; loc_end = -1 }
@


<<signature Location.symbol_loc>>=
val symbol_loc: unit -> t
@
<<function Location.symbol_loc>>=
let symbol_loc () = 
  { loc_start = Parsing.symbol_start(); loc_end = Parsing.symbol_end() }
@
% ?? global?

<<signature Location.input_name>>=
val input_name: string ref
@
<<constant Location.input_name>>=
let input_name = ref ""
@
%alt: my info scheme, where the filaneme, charpos, and also
% line is stored in the token.






\subsection{Types}

% ocaml is a statically typed language! types are important!

\subsubsection{Type expressions}
% this is the type "system", not the declaration of the types themselves.

<<type Parsetree.core_type>>=
type core_type =
  { ptyp_desc: core_type_desc;
    ptyp_loc: Location.t }
@
%alt: my info scheme and embedded token instead of wrapper extra type.
%less: at least could factorize? 'a wrap = 'a * Location.t  no?

<<type Parsetree.core_type_desc>>=
and core_type_desc = 
  | Ptyp_var of string
  | Ptyp_arrow of core_type * core_type
  | Ptyp_tuple of core_type list
  | Ptyp_constr of Longident.t * core_type list
@
%  <<[[Parsetree.core_type_desc]] cases>>
%less: how represent base type? like int? 
% it will be Ptyp_constr "int" [] ??
%see later: any? it's _, I think I can remove it
%note: rename constr? it's not constructor, it's apply,
% but well it's kinda a constructor, but for type level.
%note: alias here, but should disappear at some point.

% note that there is no '_a here, because it's not representable
% by the user. It can't appear in the source code itself.

\subsubsection{Type declarations}


<<type Parsetree.type_declaration>>=
type type_declaration =
  { ptype_params: string list;
    ptype_kind: type_kind;
    ptype_loc: Location.t;
    <<[[Parsetree.type_declaration]] other fields>>
  }
@

<<type Parsetree.type_kind>>=
and type_kind =
  | Ptype_variant of (string * core_type list) list
  | Ptype_record of (string * mutable_flag * core_type) list
  <<[[Parsetree.type_kind]] cases>>
@
% type sum, type product.

% int/float/array are actually neither a variant or a record,
% they are kinda builtin, so could have a Ptype_builtin of string,
% but those types are not defined in Pervasive.mli, they
% are really builtins and do not need a concrete representation.
% They need to be in the Env though, and so they have a
% Type_abstract for that (that they use also for abstract types,
% but primitive types are indeed kinda abstract types).

% The user can not define builtin types, so really Ptype_abstract is
% just for user defined abstract data type! so I didn't put
% it here.




<<type Asttypes.mutable_flag>>=
type mutable_flag = Immutable | Mutable
@
% remove? just use ref? I get confused anyway

%  | Psig_type of (string * type_declaration) list
% list when mutually recursive!

\subsubsection{Exception declarations}

<<type Parsetree.exception_declaration>>=
type exception_declaration = core_type list
@
% ??

%  | Psig_exception of string * exception_declaration


\subsection{Expressions}

% ocaml is an expression language! fully compositional

<<type Parsetree.expression>>=
type expression =
  { pexp_desc: expression_desc;
    pexp_loc: Location.t }
@

% rich, this includes also statements, locals, and so
% functions/constants/globals since ocaml is very regular

<<type Parsetree.expression_desc>>=
and expression_desc =
  | Pexp_constant of Asttypes.constant
  | Pexp_construct of Longident.t * expression option
  (* todo: Pexp_record_with *)
  | Pexp_record of (Longident.t * expression) list
  | Pexp_tuple of expression list

  (* lambda calcul! abs and app *)
  | Pexp_function of (pattern * expression) list
  | Pexp_apply of expression * expression list

  | Pexp_field of expression * Longident.t
  | Pexp_setfield of expression * Longident.t * expression

  | Pexp_let of rec_flag * (pattern * expression) list * expression
  | Pexp_ident of Longident.t

  | Pexp_match of expression * (pattern * expression) list
  (* todo? not only in match? *)
  | Pexp_when of expression * expression

  | Pexp_constraint of expression * core_type

  <<[[Parsetree.expression_desc]] cases>>
@
% list for let, for mutually recursive functions or data

<<type Asttypes.rec_flag>>=
type rec_flag = Nonrecursive | Recursive
@
% actually can also have rec_flag for constants? build a cycle?

<<type Asttypes.direction_flag>>=
type direction_flag = Upto | Downto
@

%  | Pexp_construct of Longident.t * expression option
% so if multi args? then have an intermediate Pexp_tuple!

\subsection{Patterns}

<<type Parsetree.pattern>>=
type pattern =
  { ppat_desc: pattern_desc;
    ppat_loc: Location.t }
@

<<type Parsetree.pattern_desc>>=
and pattern_desc =
    Ppat_any
  | Ppat_var of string

  | Ppat_constant of constant
  | Ppat_construct of Longident.t * pattern option
  | Ppat_record of (Longident.t * pattern) list
  | Ppat_tuple of pattern list

  | Ppat_alias of pattern * string
  | Ppat_constraint of pattern * core_type
  | Ppat_or of pattern * pattern
@

\subsection{Statements}

% actually stmts are exprs in ocaml!

<<[[Parsetree.expression_desc]] cases>>=
| Pexp_sequence of expression * expression

| Pexp_ifthenelse of expression * expression * expression option
| Pexp_while of expression * expression
| Pexp_for of string * expression * expression * direction_flag * expression

| Pexp_try of expression * (pattern * expression) list
@

\subsection{Modules}

\subsubsection{Signatures}

% mli

<<type Parsetree.signature>>=
and signature = signature_item list
@

<<type Parsetree.signature_item>>=
and signature_item =
  { psig_desc: signature_item_desc;
    psig_loc: Location.t }
@
<<type Parsetree.signature_item_desc>>=
and signature_item_desc =
    Psig_value of string * value_description
  | Psig_type of (string * type_declaration) list
  | Psig_exception of string * exception_declaration

  | Psig_module of string * module_type
  | Psig_open of Longident.t
@
% recursive module type
% type_declaration list  for mutually recursive types


<<type Parsetree.value_description>>=
(* Value descriptions *)

type value_description =
  { pval_type: core_type;
    pval_prim: string list }
@
%    Psig_value of string * value_description

<<type Parsetree.module_type>>=
type module_type =
  { pmty_desc: module_type_desc;
    pmty_loc: Location.t }
@
<<type Parsetree.module_type_desc>>=
and module_type_desc =
    Pmty_ident of Longident.t
  | Pmty_signature of signature
@
%less: remove PPmty_ident? no aliases for sig? because no module type




\subsubsection{Structures}

% ml

<<type Parsetree.structure>>=
and structure = structure_item list
@

<<type Parsetree.structure_item>>=
and structure_item =
  { pstr_desc: structure_item_desc;
    pstr_loc: Location.t }
@

<<type Parsetree.structure_item_desc>>=
and structure_item_desc =
    Pstr_eval of expression
  | Pstr_value of rec_flag * (pattern * expression) list
  | Pstr_primitive of string * value_description

  | Pstr_type of (string * type_declaration) list
  | Pstr_exception of string * exception_declaration

  | Pstr_module of string * module_expr
  | Pstr_open of Longident.t
@
% Pstr_value is a special case of Pstr_eval where the expr
% is a let! it's treated specially
% expression list  for mutually recursive functions

<<type Parsetree.module_expr>>=
type module_expr =
  { pmod_desc: module_expr_desc;
    pmod_loc: Location.t }
@

<<type Parsetree.module_expr_desc>>=
and module_expr_desc =
    Pmod_ident of Longident.t
  | Pmod_structure of structure
  | Pmod_constraint of module_expr * module_type
@


\section{Types and the typed tree}

<<type Types.type_expr>>=
type type_expr =
    Tvar of type_variable

  | Tarrow of type_expr * type_expr
  | Ttuple of type_expr list
  | Tconstr of Path.t * type_expr list
@
% Tconstr, type "constructor"
% diff with core_type_desc: no more Any, no more type aliases,
%  no manifest

<<type Types.type_variable>>=
and type_variable = 
  { mutable tvar_link: type_expr option;
    <<[[Types.type_variable]] other fields>>
  }
@
% kinda use a "global", that's what prolog Does in some way.
% the variable carries its substitution, so no need to
% return substitutions in unify, etc, simpler code (especially
% in language with no monadic do syntax)

% alternatives: 
% - return equations?
% - works with type substitutions (like in THIH)


% many Types.xxx are really close to Parsetree.xxx
% they actually have the same name, but core_type
% has been replaced by type_expr.

% In the same way many Pxxx become Txxx


\section{[[Lambda]] and [[Instruction]] intermediate languages}

\section{Bytecode}

% https://github.com/ocamllabs/ocaml-internals/wiki/Bytecode-compiler-pipeline

\section{Runtime values}

%https://rwmj.wordpress.com/2009/08/04/ocaml-internals/

% see also oreilly book, very good chapter on values

% blocks, will help understand elts from Lambda and Instruct


%\section{Native CMM, lambda, etc?}


\chapter{[[main()]]}

<<toplevel Main._1>>=
let _ = 
  Printexc.catch main ()
@

<<function Main.main>>=
let main () =
  try
    Arg.parse [
       <<[[Main.main()]] command line options>>
      ] 
      process_file 
      usage;

    (match () with
    <<[[Main.main()]] if make archive case>>
    <<[[Main.main()]] if linking case>>
    | _ -> ()
    );
    exit 0
  with x ->
    Format.set_formatter_out_channel stderr;
    Errors.report_error x;
    exit 2
@
% see report_error in appendix

<<constant Clflags.exec_name>>=
let exec_name = ref "a.out"             (* -o *)
@
<<[[Main.main()]] command line options>>=
"-o", Arg.String(fun s -> exec_name := s;
                          archive_name := s;
                          object_name := s),
      "<file>  Set output file name to <file> (default a.out)";
@






<<[[Main.main()]] command line options>>=
"-v", Arg.Unit print_version_number, " Print compiler version number";
"-verbose", Arg.Set verbose, " Print calls to external commands";
@

<<function Main.print_version_number>>=
let print_version_number () =
  print_string "The Objective Caml compiler, version ";
  print_string Config.version; print_newline();
  print_string "Standard library directory: ";
  print_string Config.standard_library; print_newline()
@

\section{[[Main.process_file()]]}

<<constant Clflags.objfiles>>=
let objfiles = ref ([] : string list)   (* .cmo and .cma files *)
@


<<function Main.process_file>>=
let process_file name =
  match () with
  | _ when Filename.check_suffix name ".ml" ->
      Compile.implementation name;
      objfiles := (Filename.chop_extension name ^ ".cmo") :: !objfiles

  | _ when Filename.check_suffix name ".mli" ->
      Compile.interface name

  <<[[Main.process_file()]] cases>>
  | _ -> 
      raise(Arg.Bad("don't know what to do with " ^ name))
@
%old: or Filename.check_suffix name ".mlt" ??
%old: I rewrote with match () with when


\ifallcode
<<[[Main.main()]] command line options>>=
"-", Arg.String process_file,
     "<file>  Treat <file> as a file name (even if it starts with `-')";
@
\fi


\section{[[Compile.implementation()]]}

<<signature Compile.implementation>>=
val implementation: string -> unit
@
% filename



<<signature Compile.init_path>>=
val init_path: unit -> unit
@
% ?

<<signature Compile.initial_env>>=
val initial_env: unit -> Env.t
@


<<function Compile.implementation>>=
let implementation sourcefile =
  init_path();
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppo") in

  let ast = parse_file inputfile Parse.implementation ast_impl_magic_number in

  let objfile = prefixname ^ ".cmo" in
  let oc = open_out_bin objfile in
  try
    let (struc, sg, finalenv) =
      Typemod.type_structure (initial_env()) ast in

    if !Clflags.print_types 
    then (Printtyp.signature sg; print_newline());

    let (coercion, _crc) =
      if Sys.file_exists (prefixname ^ ".mli") then begin
        let intf_file =
          try find_in_path !load_path (prefixname ^ ".cmi")
          with Not_found -> prefixname ^ ".cmi" 
        in
        let (dclsig, crc) = Env.read_signature modulename intf_file in
        (Includemod.compunit sourcefile sg intf_file dclsig, crc)
      end else begin
        let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
        Typemod.check_nongen_schemes struc;
        (Tcoerce_none, crc)
      end 
    in

    Translmod.transl_implementation modulename struc coercion
    |> print_if Clflags.dump_rawlambda Printlambda.lambda
    |> Simplif.simplify_lambda
    |> print_if Clflags.dump_lambda Printlambda.lambda
    |> Bytegen.compile_implementation modulename
    |> print_if Clflags.dump_instr Printinstr.instrlist
    |> Emitcode.to_file oc modulename
    ;

    remove_preprocessed inputfile;
    close_out oc
  with x ->
    close_out oc;
    remove_file objfile;
    raise x
@
%less: Common.finalize
%with later typing/
%(*
%    let coercion =
%      if Sys.file_exists (prefixname ^ ".mli") then begin
%        let intf_file =
%          try find_in_path !load_path (prefixname ^ ".cmi")
%          with Not_found -> prefixname ^ ".cmi" in
%        let dclsig = Env.read_signature modulename intf_file in
%        Includemod.compunit sourcefile sg intf_file dclsig
%      end else begin
%        Typemod.check_nongen_schemes finalenv str;
%        Env.save_signature sg modulename (prefixname ^ ".cmi");
%        Tcoerce_none
%      end in
%*)
%todo: crc seems unused later, why? and actually we don't use it here

% ast_impl_magic_number ???

<<signature Config.load_path>>=
val load_path: string list ref
        (* Directories in the search path for .cmi and .cmo files *)
@


\ifallcode
% -impl
<<function Main.process_implementation_file>>=
let process_implementation_file name =
  Compile.implementation name;
  objfiles := (Filename.chop_extension name ^ ".cmo") :: !objfiles
@
<<[[Main.main()]] command line options>>=
"-impl", Arg.String process_implementation_file,
      "<file>  Compile <file> as a .ml file";
@
\fi

\section{[[Compile.interface()]]}


<<signature Compile.interface>>=
val interface: string -> unit
@

<<function Compile.interface>>=
(* Compile a .mli file *)

let interface sourcefile =
  init_path();
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppi") in

  let ast = parse_file inputfile Parse.interface ast_intf_magic_number in

  let sg = Typemod.transl_signature (initial_env()) ast in

  if !Clflags.print_types 
  then (Printtyp.signature sg; print_newline());

  Env.save_signature sg modulename (prefixname ^ ".cmi");
  remove_preprocessed inputfile
@


\ifallcode
% -intf
<<[[Main.main()]] command line options>>=
"-intf", Arg.String process_interface_file,
      "<file>  Compile <file> as a .mli file";
@
<<function Main.process_interface_file>>=
let process_interface_file name =
  Compile.interface name
@
% delete?
\fi

\section{[[Bytelink.link()]]}

<<[[Main.main()]] command line options>>=
"-c", Arg.Set compile_only, " Compile only (do not link)";
@

<<[[Main.main()]] if linking case>>=
| _ when not !compile_only & !objfiles <> [] ->
    Compile.init_path();
    Bytelink.link (List.rev !objfiles)
@





\chapter{Lexing}

% See lex&yacc tutorial, even ocamllex/ocamlyacc tutorial.
% bootstrapping issue? yes for ocamllex.

% see also preprocessing section in advanced topics

<<signature Lexer.token>>=
(* The lexical analyzer *)

val token: Lexing.lexbuf -> Parser.token
@


<<./parsing/lexer.mll>>=
<<copyright header>>

(* The lexer definition *)

{
open Misc
open Parser

<<type Lexer.error>>
<<exception Lexer.Error>>

<<Lexer helpers>>

(* Error report *)
open Format
<<function Lexer.report_error>>
}

<<rule Lexer.token>>

<<rule Lexer.comment>>

<<rule Lexer.string>>

@
%$




<<rule Lexer.token>>=
rule token = parse
  <<[[Lexer.token()]] space case>>
  <<[[Lexer.token()]] comment case>>

  <<[[Lexer.token()]] underscore case>>
  <<[[Lexer.token()]] identifier or keyword cases>>

  <<[[Lexer.token()]] integer case>>
  <<[[Lexer.token()]] float case>>

  <<[[Lexer.token()]] string case>>
  <<[[Lexer.token()]] character case>>

  <<[[Lexer.token()]] directive case>>
  <<[[Lexer.token()]] sharp case>>

  <<[[Lexer.token()]] operator cases>>
  | eof { EOF }
  | _
      { raise (Error(Illegal_character,
                     Lexing.lexeme_start lexbuf, Lexing.lexeme_end lexbuf)) }

@
% the order of the patterns matter in ocamllex, so I prefer
% to be more explicit instead of having just a <<[[Lexer.token()]] cases ...


\ifallcode
<<Lexer helpers>>=
(* For nested comments *)

<<global Lexer.comment_depth>>

(* The table of keywords *)

<<constant Lexer.keyword_table>>

(* To buffer string literals *)

<<Lexer string related functions>>

(* To translate escape sequences *)

<<Lexer escape sequences related functions>>

(* To store the position of the beginning of a string or comment *)

<<global Lexer.start_pos>>
@
\fi



<<Parser tokens>>=
%token TRUE
%token FALSE
%token <int> INT
%token <char> CHAR
%token <string> FLOAT
%token <string> STRING

%token <string> LIDENT
%token <string> UIDENT

%token LET REC IN   FUN FUNCTION
%token IF THEN ELSE  BEGIN END  WHILE FOR DO DONE TO DOWNTO
%token MATCH WITH WHEN AS
%token TRY EXCEPTION
%token TYPE OF VAL EXTERNAL MUTABLE
%token MODULE SIG STRUCT OPEN
%token LAZY
%token ASSERT
%token AND
%token OR

%token LPAREN RPAREN
%token LBRACE RBRACE
%token LBRACKET RBRACKET
%token LBRACKETBAR BARRBRACKET

%token AMPERSAND
%token BAR
%token AMPERAMPER BARBAR
%token COLON
%token COLONCOLON
%token COMMA
%token DOT
%token DOTDOT
%token MINUSGREATER
%token LESSMINUS
%token COLONEQUAL
%token QUOTE
%token SEMI
%token SEMISEMI
%token STAR
%token UNDERSCORE
%token SHARP

%token EQUAL
%token LESS
%token GREATER
%token <string> PREFIXOP
%token <string> INFIXOP0
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token <string> INFIXOP4
%token <string> SUBTRACTIVE

%token EOF

@
%less: regroup? can put multiple on one line

\section{Comments}
% space and comments?

<<[[Lexer.token()]] space case>>=
  [' ' '\010' '\013' '\009' '\012'] +
    { token lexbuf }
@


<<[[Lexer.token()]] comment case>>=
| "(*"
    { comment_depth := 1;
      start_pos := Lexing.lexeme_start lexbuf;
      comment lexbuf;
      token lexbuf }
@

<<global Lexer.comment_depth>>=
let comment_depth = ref 0
@

<<global Lexer.start_pos>>=
let start_pos = ref 0
@

<<rule Lexer.comment>>=
and comment = parse
    "(*"
      { comment_depth := succ !comment_depth; comment lexbuf }
  | "*)"
      { comment_depth := pred !comment_depth;
        if !comment_depth > 0 then comment lexbuf }
  <<[[Lexer.comment()]] string or char in comment cases>>
  | eof
      { raise (Error(Unterminated_comment, !start_pos, !start_pos+2)) }
  | _
      { comment lexbuf }
@
%+2??




\section{Keywords and identifiers}

<<[[Lexer.token()]] identifier or keyword cases>>=
| ['a'-'z'  '_'] (['A'-'Z' 'a'-'z' '_' '\'' '0'-'9' ]) *
    { let s = Lexing.lexeme lexbuf in
        try
          Hashtbl.find keyword_table s
        with Not_found ->
          LIDENT s 
     }
| ['A'-'Z'  ] (['A'-'Z' 'a'-'z' '_' '\'' '0'-'9' ]) *
    { UIDENT(Lexing.lexeme lexbuf) }       (* No capitalized keywords *)
@
%old: was 
%| ['a'-'z' '\223'-'\246' '\248'-'\255' '_']
%  (['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255'
%| ['A'-'Z' '\192'-'\214' '\216'-'\222' ]
%  (['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255'
% not sure why allowed that

<<constant Lexer.keyword_table>>=
let keyword_table =
  create_hashtable 149 [
    "true", TRUE;
    "false", FALSE;

    "let", LET;
    "rec", REC;
    "in", IN;
    "fun", FUN;
    "function", FUNCTION;

    "if", IF;
    "then", THEN;
    "else", ELSE;
    "begin", BEGIN;
    "end", END;
    "while", WHILE;
    "for", FOR;
    "do", DO;
    "done", DONE;
    "to", TO;
    "downto", DOWNTO;

    "match", MATCH;
    "with", WITH;
    "when", WHEN;
    "as", AS;

    "try", TRY;
    "exception", EXCEPTION;

    "lazy", LAZY;
    "assert", ASSERT;

    "type", TYPE;
    "of", OF;
    "val", VAL;
    "external", EXTERNAL;
    "mutable", MUTABLE;

    "module", MODULE;
    "sig", SIG;
    "struct", STRUCT;
    "open", OPEN;

    "and", AND;
    "or", OR;

    "mod", INFIXOP3("mod");
    "land", INFIXOP3("land");
    "lor", INFIXOP3("lor");
    "lxor", INFIXOP3("lxor");
    "lsl", INFIXOP4("lsl");
    "lsr", INFIXOP4("lsr");
    "asr", INFIXOP4("asr")
]
@
%old: was sorted originally
%todo: and and or are obsolete no?

<<[[Lexer.token()]] underscore case>>=
| "_"  { UNDERSCORE }
@
% special rule, not an identifier!

\section{Operators}

<<[[Lexer.token()]] operator cases>>=
| "("  { LPAREN } | ")"  { RPAREN }
| "{"  { LBRACE } | "}"  { RBRACE }
| "["  { LBRACKET } | "]"  { RBRACKET }
| "[|" { LBRACKETBAR } | "|]" { BARRBRACKET }
@
% paren for expressions, brace for records, bracket for lists

<<[[Lexer.token()]] operator cases>>=
| "|"  { BAR }
| "*"  { STAR }
| "'"  { QUOTE }
@
% | for patterns, * for type tuples, ' for polymorphic types


<<[[Lexer.token()]] operator cases>>=
| ","  { COMMA }
| "->" { MINUSGREATER }
| "."  { DOT }
| ".." { DOTDOT }
| ":"  { COLON }
| "::" { COLONCOLON }
| ":=" { COLONEQUAL }
| "<-" { LESSMINUS }
| ";"  { SEMI }
@

<<[[Lexer.token()]] operator cases>>=
| "="  { EQUAL }
| "!=" { INFIXOP0 "!=" }
| "<"  { LESS } | ">"  { GREATER }
@

<<[[Lexer.token()]] operator cases>>=
| "&&" { AMPERAMPER }
| "||" { BARBAR }
@

<<[[Lexer.token()]] operator cases>>=
| "&"  { AMPERSAND }
@
%less: remove & ?


<<[[Lexer.token()]] operator cases>>=
| "-"  { SUBTRACTIVE "-" }
| "-." { SUBTRACTIVE "-." }
@

<<[[Lexer.token()]] operator cases>>=
| ['!' '?' '~']
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] *
          { PREFIXOP(Lexing.lexeme lexbuf) }

| ['=' '<' '>' '|' '&' '$']
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] *
          { INFIXOP0(Lexing.lexeme lexbuf) }
| ['@' '^']
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] *
          { INFIXOP1(Lexing.lexeme lexbuf) }
| ['+' '-']
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] *
          { INFIXOP2(Lexing.lexeme lexbuf) }
| "**"
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] *
          { INFIXOP4(Lexing.lexeme lexbuf) }
| ['*' '/' '%']
  ['!' '$' '%' '&' '*' '+' '-' '.' '/' ':' '<' '=' '>' '?' '@' '^' '|' '~'] *
          { INFIXOP3(Lexing.lexeme lexbuf) }
@
%$
%different priorities, mimicing the smaller version
%less: factorize ?
%less: why special case for ** ?

% in ocaml 4.00
%  | "!" symbolchar +
%            { PREFIXOP(Lexing.lexeme lexbuf) }
%  | ['~' '?'] symbolchar +
%            { PREFIXOP(Lexing.lexeme lexbuf) }
%  | ['=' '<' '>' '|' '&' '$'] symbolchar *
%            { INFIXOP0(Lexing.lexeme lexbuf) }
%  | ['@' '^'] symbolchar *
%            { INFIXOP1(Lexing.lexeme lexbuf) }
%  | ['+' '-'] symbolchar *
%            { INFIXOP2(Lexing.lexeme lexbuf) }
%  | "**" symbolchar *
%            { INFIXOP4(Lexing.lexeme lexbuf) }
%  | ['*' '/' '%'] symbolchar *
%            { INFIXOP3(Lexing.lexeme lexbuf) }
%$

<<[[Lexer.token()]] sharp case>>=
| "#"  { SHARP }
@
% special case because have also #line

\section{Numbers}

\subsection{Integers}

<<[[Lexer.token()]] integer case>>=
| ['0'-'9']+
  | '0' ['x' 'X'] ['0'-'9' 'A'-'F' 'a'-'f']+
  | '0' ['o' 'O'] ['0'-'7']+
  | '0' ['b' 'B'] ['0'-'1']+
    { INT (int_of_string(Lexing.lexeme lexbuf)) }
@
%int_of_string from pervasives handles many format

\subsection{Floats}

<<[[Lexer.token()]] float case>>=
| ['0'-'9']+ ('.' ['0'-'9']*)? (['e' 'E'] ['+' '-']? ['0'-'9']+)?
    { FLOAT (Lexing.lexeme lexbuf) }
@

\section{Characters}


<<[[Lexer.token()]] character case>>=
| "'" [^ '\\' '\''] "'"
    { CHAR(Lexing.lexeme_char lexbuf 1) }
@


<<[[Lexer.token()]] character case>>=
| "'" '\\' ['\\' '\'' 'n' 't' 'b' 'r'] "'"
    { CHAR(char_for_backslash (Lexing.lexeme_char lexbuf 2)) }
@

<<Lexer escape sequences related functions>>=
let char_for_backslash =
  match Sys.os_type with
  | "Unix" ->
      begin function
      | 'n' -> '\010'
      | 'r' -> '\013'
      | 'b' -> '\008'
      | 't' -> '\009'
      | c   -> c
      end
  | x -> fatal_error "Lexer: unknown system type"
@

<<[[Lexer.token()]] character case>>=
| "'" '\\' ['0'-'9'] ['0'-'9'] ['0'-'9'] "'"
    { CHAR(char_for_decimal_code lexbuf 2) }
@


<<Lexer escape sequences related functions>>=
let char_for_decimal_code lexbuf i =
  let c = 100 * (Char.code(Lexing.lexeme_char lexbuf i) - 48) +
           10 * (Char.code(Lexing.lexeme_char lexbuf (i+1)) - 48) +
                (Char.code(Lexing.lexeme_char lexbuf (i+2)) - 48) in  
  Char.chr(c land 0xFF)
@

\section{Strings}

<<[[Lexer.token()]] string case>>=
| "\""
    { reset_string_buffer();
      let string_start = Lexing.lexeme_start lexbuf in
      start_pos := string_start;

      string lexbuf;

      lexbuf.Lexing.lex_start_pos <-
        string_start - lexbuf.Lexing.lex_abs_pos;
      STRING (get_stored_string()) }
@

<<rule Lexer.string>>=
and string = parse
    '"'
      { () }
  | '\\' ("\010" | "\013" | "\013\010") [' ' '\009'] *
      { string lexbuf }
  | '\\' ['\\' '"' 'n' 't' 'b' 'r']
      { store_string_char(char_for_backslash(Lexing.lexeme_char lexbuf 1));
        string lexbuf }
  | '\\' ['0'-'9'] ['0'-'9'] ['0'-'9']
      { store_string_char(char_for_decimal_code lexbuf 1);
         string lexbuf }
  | eof
      { raise (Error(Unterminated_string, !start_pos, !start_pos+1)) }
  | _
      { store_string_char(Lexing.lexeme_char lexbuf 0);
        string lexbuf }
@

<<Lexer string related functions>>=
let initial_string_buffer = String.create 256
let string_buff = ref initial_string_buffer
let string_index = ref 0

let reset_string_buffer () =
  string_buff := initial_string_buffer;
  string_index := 0

let store_string_char c =
  if !string_index >= String.length (!string_buff) then begin
    let new_buff = String.create (String.length (!string_buff) * 2) in
      String.blit (!string_buff) 0 new_buff 0 (String.length (!string_buff));
      string_buff := new_buff
  end;
  String.unsafe_set (!string_buff) (!string_index) c;
  incr string_index

let get_stored_string () =
  let s = String.sub (!string_buff) 0 (!string_index) in
  string_buff := initial_string_buffer;
  s
@


\ifallcode
<<[[Lexer.comment()]] string or char in comment cases>>=
| "\""
    { reset_string_buffer();
      start_pos := Lexing.lexeme_start lexbuf;
      string lexbuf;
      string_buff := initial_string_buffer;
      comment lexbuf }
| "''"
    { comment lexbuf }
| "'" [^ '\\' '\''] "'"
    { comment lexbuf }
| "'\\" ['\\' '\'' 'n' 't' 'b' 'r'] "'"
    { comment lexbuf }
| "'\\" ['0'-'9'] ['0'-'9'] ['0'-'9'] "'"
    { comment lexbuf }
@
%less: meh for the string in comment honestly
\fi






\chapter{Parsing}

% Again, see lex&yacc tutorial, even ocamllex/ocamlyacc tutorial.
% bootstrapping issue? no for ocamlyacc as it's written in C.

<<signature Parse.implementation>>=
val implementation : Lexing.lexbuf -> Parsetree.structure
@

<<signature Parse.interface>>=
val interface : Lexing.lexbuf -> Parsetree.signature
@



<<./parsing/parser.mly>>=
<<copyright header C>>

/* The parser definition */

%{
<<Parser header>>
%}

/* Tokens */

<<Parser tokens>>

/* Precedences and associativities. Lower precedences come first. */

<<Parser precedences and associativities>>

/* Entry points */

<<Parser entry points types>>

%%

<<grammar>>
%%

@


<<Parser precedences and associativities>>=
%right prec_let                         /* let ... in ... */
%right prec_type_def                    /* = in type definitions */
%right SEMI                             /* e1; e2 (sequence) */
%right prec_fun prec_match prec_try     /* match ... with ... */
%right prec_list                        /* e1; e2 (list, array, record) */
%right prec_if                          /* if ... then ... else ... */
%right COLONEQUAL LESSMINUS             /* assignments */
%left  AS                               /* as in patterns */
%left  BAR                              /* | in patterns */
%left  COMMA                            /* , in expressions, patterns, types */
%right prec_type_arrow                  /* -> in type expressions */
%right OR BARBAR                        /* || */
%right AMPERSAND AMPERAMPER             /* && */
%left  INFIXOP0 EQUAL LESS GREATER      /* = < > etc */
%right INFIXOP1                         /* @ ^ etc */
%right COLONCOLON                       /* :: */
%left  INFIXOP2 SUBTRACTIVE             /* + - */
%left  INFIXOP3 STAR                    /* * / */
%right INFIXOP4                         /* ** */
%right prec_unary_minus                 /* - unary */
%left  prec_appl                        /* function application */
%right prec_constr_appl                 /* constructor application */
%left  DOT                              /* record access, array access */
%right PREFIXOP                         /* ! */
@
%todo: fix many conflicts by forwardporting from 4.00
% argh, ugly list above

<<function Parse.wrap>>=
let wrap parsing_fun lexbuf =
  try
    let ast = parsing_fun Lexer.token lexbuf in
    Parsing.clear_parser();
    ast
  with
    | Parsing.Parse_error | Syntaxerr.Escape_error ->
        let loc = { loc_start = Lexing.lexeme_start lexbuf;
                    loc_end = Lexing.lexeme_end lexbuf } in
        if !Location.input_name = "" 
        then maybe_skip_phrase lexbuf;
        raise (Syntaxerr.Error(Syntaxerr.Other loc))

    | Lexer.Error(Lexer.Unterminated_comment, _, _) as err -> raise err
    | Lexer.Error(Lexer.Unterminated_string, _, _) as err -> raise err
    | Lexer.Error(_, _, _) as err ->
        if !Location.input_name = "" 
        then skip_phrase lexbuf;
        raise err
    | Syntaxerr.Error _ as err ->
        if !Location.input_name = "" 
        then maybe_skip_phrase lexbuf;
        raise err
@
%todo: factorize and aspectize maybe_skip_phrase

<<function Parse.implementation>>=
let implementation = wrap Parser.implementation
@

<<function Parse.interface>>=
let interface = wrap Parser.interface
@

<<Parser entry points types>>=
%start implementation                   /* for implementation files */
%type <Parsetree.structure> implementation
%start interface                        /* for interface files */
%type <Parsetree.signature> interface
@


<<entry points rules>>=
implementation:
    structure EOF                        { $1 }
;
interface:
    signature EOF                        { List.rev $1 }
;
@



<<grammar>>=

/* Entry points */

<<entry points rules>>


/* Module expressions */

<<structure rules>>

/* Module types */

<<signature rules>>


/* Core expressions */

<<expression rules>>

/* Patterns */

<<pattern rules>>

/* Type declarations */

<<type declaration rules>>

/* Core types */

<<type expression rules>>


/* Identifiers and long identifiers */

<<name rules>>

/* Toplevel directives */

<<toplevel rules>>

<<extra rules>>

/* Miscellaneous */

<<misc rules>>
<<ebnf rules>>
@


% the opt
<<ebnf rules>>=
opt_bar:
    /* empty */                                 { () }
  | BAR                                         { () }
;
opt_semi:
  | /* empty */                                 { () }
  | SEMI                                        { () }
;
@


\section{Structures}
% the .ml
% Implementation


<<structure rules>>=
structure:
    structure_tail                              { $1 }
  | seq_expr structure_tail                     { mkstrexp $1 :: $2 }
;
structure_tail:
    /* empty */                                 { [] }
  | structure_item structure_tail               { $1 :: $2 }
  <<rule structure_tail optional semisemi cases>>
;
@
%$

<<structure rules>>=
structure_item:
    LET rec_flag let_bindings
      { match $3 with
          [{ppat_desc = Ppat_any}, exp] -> mkstr(Pstr_eval exp)
        | _ -> mkstr(Pstr_value($2, List.rev $3)) }
  | EXTERNAL val_ident COLON core_type EQUAL primitive_declaration
      { mkstr(Pstr_primitive($2, {pval_type = $4; pval_prim = $6})) }

  | TYPE type_declarations
      { mkstr(Pstr_type(List.rev $2)) }
  | EXCEPTION UIDENT constructor_arguments
      { mkstr(Pstr_exception($2, $3)) }

  | MODULE UIDENT module_binding
      { mkstr(Pstr_module($2, $3)) }
  | OPEN mod_longident
      { mkstr(Pstr_open $2) }
;
@

<<misc rules>>=
rec_flag:
    /* empty */                                 { Nonrecursive }
  | REC                                         { Recursive }
;
@

<<structure rules>>=
module_binding:
    EQUAL module_expr
      { $2 }
  | COLON module_type EQUAL module_expr
      { mkmod(Pmod_constraint($4, $2)) }
;
module_expr:
    mod_longident
      { mkmod(Pmod_ident $1) }
  | STRUCT structure END
      { mkmod(Pmod_structure($2)) }
  | LPAREN module_expr COLON module_type RPAREN
      { mkmod(Pmod_constraint($2, $4)) }
  | LPAREN module_expr RPAREN
      { $2 }
  <<rule module_expr error cases>>
;
@
%$

\ifallcode
<<rule structure_tail optional semisemi cases>>=
| SEMISEMI                                    { [] }
| SEMISEMI seq_expr structure_tail            { mkstrexp $2 :: $3 }
| SEMISEMI structure_item structure_tail      { $2 :: $3 }
@
%less: legacy, could remove
\fi

\section{Signatures}
% the .mli
% Ininterface

<<signature rules>>=
signature:
    /* empty */                                 { [] }
  | signature signature_item                    { $2 :: $1 }
  <<rule signature optional semisemi cases>>
;
@

<<signature rules>>=
signature_item:
    VAL val_ident COLON core_type
      { mksig(Psig_value($2, {pval_type = $4; pval_prim = []})) }
  | EXTERNAL val_ident COLON core_type EQUAL primitive_declaration
      { mksig(Psig_value($2, {pval_type = $4; pval_prim = $6})) }

  | TYPE type_declarations
      { mksig(Psig_type(List.rev $2)) }
  | EXCEPTION UIDENT constructor_arguments
      { mksig(Psig_exception($2, $3)) }

  | MODULE UIDENT module_declaration
      { mksig(Psig_module($2, $3)) }
  | OPEN mod_longident
      { mksig(Psig_open $2) }
;
@
%$

<<signature rules>>=
module_declaration:
    COLON module_type
      { $2 }
;

module_type:
    mty_longident
      { mkmty(Pmty_ident $1) }
  | SIG signature END
      { mkmty(Pmty_signature(List.rev $2)) }
  | LPAREN module_type RPAREN
      { $2 }
  <<rule module_type error cases>>
;

@
%$

<<extra rules>>=
primitive_declaration:
    STRING                                      { [$1] }
  | STRING primitive_declaration                { $1 :: $2 }
;
@
%$

\ifallcode
<<rule signature optional semisemi cases>>=
| signature signature_item SEMISEMI           { $2 :: $1 }
@
\fi


<<name rules>>=
mty_longident:
    ident                                       { Lident $1 }
  | mod_longident DOT ident                 { Ldot($1, $3) }
;
@
%$
%old: was mod_ex_longident
%less: maybe can remove now that don't allow module type

\section{Names}

% upper ident, lower ident

% when accept both?
<<name rules>>=
ident:
    UIDENT                                      { $1 }
  | LIDENT                                      { $1 }
;
@

<<name rules>>=
mod_longident:
    UIDENT                                      { Lident $1 }
  | mod_longident DOT UIDENT                    { Ldot($1, $3) }
;
@
%$
%old:
%mod_ext_longident:
%    UIDENT                                      { Lident $1 }
%  | mod_ext_longident DOT UIDENT                { Ldot($1, $3) }
%;
% diff? factorize no?



<<name rules>>=
val_ident:
    LIDENT                                      { $1 }
  | LPAREN operator RPAREN                      { $2 }
;
operator:
    PREFIXOP                                    { $1 }
  | INFIXOP0                                    { $1 }
  | INFIXOP1                                    { $1 }
  | INFIXOP2                                    { $1 }
  | INFIXOP3                                    { $1 }
  | INFIXOP4                                    { $1 }
  | SUBTRACTIVE                                 { $1 }
  | STAR                                        { "*" }
  | EQUAL                                       { "=" }
  | LESS                                        { "<" }
  | GREATER                                     { ">" }
  | OR                                          { "or" }
  | BARBAR                                      { "||" }
  | AMPERSAND                                   { "&" }
  | AMPERAMPER                                  { "&&" }
  | COLONEQUAL                                  { ":=" }
;
@
%$



\section{Type expressions}
% type expressions?

% ?complex?, core, simple, 

<<type expression rules>>=

core_type:
    simple_core_type
      { $1 }
  | core_type MINUSGREATER core_type %prec prec_type_arrow
      { mktyp(Ptyp_arrow($1, $3)) }
  | core_type_tuple
      { mktyp(Ptyp_tuple(List.rev $1)) }
;

simple_core_type:
    QUOTE ident
      { mktyp(Ptyp_var $2) }

  | type_longident
      { mktyp(Ptyp_constr($1, [])) }
  | simple_core_type type_longident %prec prec_constr_appl
      { mktyp(Ptyp_constr($2, [$1])) }
  | LPAREN core_type_comma_list RPAREN type_longident
      %prec prec_constr_appl
      { mktyp(Ptyp_constr($4, List.rev $2)) }

  | LPAREN core_type RPAREN
      { $2 }
;
core_type_tuple:
    simple_core_type STAR simple_core_type      { [$3; $1] }
  | core_type_tuple STAR simple_core_type       { $3 :: $1 }
;
core_type_list:
    simple_core_type                            { [$1] }
  | core_type_list STAR simple_core_type        { $3 :: $1 }
;
@
%less: diff core_type_tuple and core_type_list?
%old:  <<rule core_type cases>>
%old:  <<rule simple_core_type cases>>

<<ebnf rules>>=
core_type_comma_list:
    core_type COMMA core_type                   { [$3; $1] }
  | core_type_comma_list COMMA core_type        { $3 :: $1 }
;
@


<<name rules>>=
type_longident:
    LIDENT                                      { Lident $1 }
  | mod_longident DOT LIDENT                { Ldot($1, $3) }
;
@
%old: was mod_ex_longident
%$

\section{Type declarations}

<<type declaration rules>>=
type_declarations:
    type_declaration                            { [$1] }
  | type_declarations AND type_declaration      { $3 :: $1 }
;
@
%$
% mutually recursive types

<<type declaration rules>>=
type_declaration:
    type_parameters LIDENT type_kind
      { let (kind, manifest) = $3 in
        ($2, {ptype_params = $1;
              ptype_kind = kind;
              ptype_manifest = manifest;
              ptype_loc = Location.symbol_loc()}) }
;
@
%$
% will see manifest later, it's for abbrev type (and abstract types
%  which are treated as a form of abbrev type I think)

<<type declaration rules>>=
type_kind:
  <<rule type_kind cases>>
;
@
%$ 
% can't use opt_bar?



\subsection{Polymorphic types}
% part2 (def), part1(use) is  in core type expr

<<type declaration rules>>=
type_parameters:
    /*empty*/                                   { [] }
  | type_parameter                              { [$1] }
  | LPAREN type_parameter_list RPAREN           { List.rev $2 }
;
type_parameter:
    QUOTE ident                                 { $2 }
;
@
%$

<<ebnf rules>>=
type_parameter_list:
    type_parameter                              { [$1] }
  | type_parameter_list COMMA type_parameter    { $3 :: $1 }
;
@
%$

\subsection{Variants, sum types}

<<rule type_kind cases>>=
| EQUAL constructor_declarations
    { (Ptype_variant(List.rev $2), None) }
| EQUAL BAR constructor_declarations
    { (Ptype_variant(List.rev $3), None) }
@

<<ebnf rules>>=
constructor_declarations:
    constructor_declaration                     { [$1] }
  | constructor_declarations BAR constructor_declaration { $3 :: $1 }
;
@
%$

<<type declaration rules>>=
constructor_declaration:
    constr_ident constructor_arguments          { ($1, $2) }
;
constructor_arguments:
    /*empty*/                                   { [] }
  | OF core_type_list                           { List.rev $2 }
;
@
%$

<<name rules>>=
constr_ident:
    UIDENT                                      { $1 }
  | LBRACKET RBRACKET                           { "[]" }
  | LPAREN RPAREN                               { "()" }
  | COLONCOLON                                  { "::" }
  | FALSE                                       { "false" }
  | TRUE                                        { "true" }
;
@
%$
    

\subsection{Records, product types}

<<rule type_kind cases>>=
| EQUAL LBRACE label_declarations opt_semi RBRACE
    { (Ptype_record(List.rev $3), None) }
@
%$

<<ebnf rules>>=
label_declarations:
    label_declaration                           { [$1] }
  | label_declarations SEMI label_declaration   { $3 :: $1 }
;
@
%$

<<type declaration rules>>=
label_declaration:
    mutable_flag LIDENT COLON core_type         { ($2, $1, $4) }
;
@
%$

<<misc rules>>=
mutable_flag:
    /* empty */                                 { Immutable }
  | MUTABLE                                     { Mutable }
;
@


\section{Expressions}

<<expression rules>>=
expr:
    simple_expr
      { $1 }
  <<rule expr cases>>
;
@
%$

% no "application" in simple_expr, atomic elts, e.g. constructor with no arg
<<expression rules>>=
simple_expr:
  | constant
      { mkexp(Pexp_constant $1) }
  | LPAREN seq_expr RPAREN
      { $2 }
  | BEGIN seq_expr END
      { $2 }
  <<rule simple_expr cases>>
  <<rule simple_expr error cases>>
;
@
%$


\subsection{Constants}

<<type Asttypes.constant>>=
type constant =
    Const_int of int
  | Const_char of char
  | Const_string of string
  | Const_float of string
@

<<extra rules>>=
constant:
    INT                                         { Const_int $1 }
  | CHAR                                        { Const_char $1 }
  | STRING                                      { Const_string $1 }
  | FLOAT                                       { Const_float $1 }
;
signed_constant:
    constant                                    { $1 }
  | SUBTRACTIVE INT                             { Const_int(- $2) }
  | SUBTRACTIVE FLOAT                           { Const_float("-" ^ $2) }
;
@
%$

\subsection{Constructors}

<<rule simple_expr cases>>=
| constr_longident
    { mkexp(Pexp_construct($1, None)) }
@
%$
<<rule expr cases>>=
| constr_longident simple_expr %prec prec_constr_appl
    { mkexp(Pexp_construct($1, Some $2)) }
@
%$

<<name rules>>=
constr_longident:
    mod_longident                               { $1 }
  | LBRACKET RBRACKET                           { Lident "[]" }
  | LPAREN RPAREN                               { Lident "()" }
  | FALSE                                       { Lident "false" }
  | TRUE                                        { Lident "true" }
;
@
%$


\subsection{Lists}

% special sugar
<<rule expr cases>>=
| expr COLONCOLON expr
    { mkexp(Pexp_construct(Lident "::", Some(mkexp(Pexp_tuple[$1;$3])))) }
@
%$
<<rule simple_expr cases>>=
| LBRACKET expr_semi_list opt_semi RBRACKET
    { mklistexp(List.rev $2) }
@
%$
% of Pexp_tuple! extra boxing?

<<[[Parser.mklistexp()]]>>=
let rec mklistexp = function
    [] ->
      mkexp(Pexp_construct(Lident "[]", None))
  | e1 :: el ->
      mkexp(Pexp_construct(Lident "::",
                           Some(mkexp(Pexp_tuple[e1; mklistexp el]))
                           ))
@

<<ebnf rules>>=
expr_semi_list:
    expr %prec prec_list                        { [$1] }
  | expr_semi_list SEMI expr %prec prec_list    { $3 :: $1 }
;
@

\subsection{Records}


<<rule simple_expr cases>>=
| LBRACE lbl_expr_list opt_semi RBRACE
    { mkexp(Pexp_record(List.rev $2)) }
@
%$

<<expression rules>>=
lbl_expr_list:
                       label_longident EQUAL expr %prec prec_list
      { [$1,$3] }
  | lbl_expr_list SEMI label_longident EQUAL expr %prec prec_list
      { ($3, $5) :: $1 }
;
@
%$
%less: could have lbl_expr intermdiate that factorize things no?

<<name rules>>=
label_longident:
    LIDENT                                      { Lident $1 }
  | mod_longident DOT LIDENT                    { Ldot($1, $3) }
;
@
%$


<<rule simple_expr cases>>=
| simple_expr DOT label_longident
    { mkexp(Pexp_field($1, $3)) }
@
% get

<<rule expr cases>>=
| simple_expr DOT label_longident LESSMINUS expr
    { mkexp(Pexp_setfield($1, $3, $5)) }
@
%$
% set


\subsection{Tuples}

%kinda of sugar for records? anon records?

<<rule expr cases>>=
| expr_comma_list
    { mkexp(Pexp_tuple(List.rev $1)) }
@
%$

<<ebnf rules>>=
expr_comma_list:
    expr_comma_list COMMA expr                  { $3 :: $1 }
  | expr COMMA expr                             { [$3; $1] }
;
@


\subsection{Functions, closures}

% lambda calcul! abs and app

<<rule expr cases>>=
| FUNCTION opt_bar match_cases %prec prec_fun
    { mkexp(Pexp_function(List.rev $3)) }
| FUN simple_pattern fun_def %prec prec_fun
    { mkexp(Pexp_function([$2, $3])) }
@
%$
% 2 different syntaxes in ocaml; confusing a bit

<<expression rules>>=
fun_def:
    match_action                                { $1 }
  | simple_pattern fun_def                      { mkexp(Pexp_function[$1,$2]) }
;
@
%$



<<rule expr cases>>=
| simple_expr simple_expr_list %prec prec_appl
    { mkexp(Pexp_apply($1, List.rev $2)) }
@
%$
% lambda calcul! app, core! and can be an expr! not just an ident

% curry
<<ebnf rules>>=
simple_expr_list:
    simple_expr                                 { [$1] }
  | simple_expr_list simple_expr                { $2 :: $1 }
;
@
%$

\subsection{Let, entity definitions}

<<rule expr cases>>=
| LET rec_flag let_bindings IN seq_expr %prec prec_let
    { mkexp(Pexp_let($2, List.rev $3, $5)) }
@

<<ebnf rules>>=
let_bindings:
    let_binding                                 { [$1] }
  | let_bindings AND let_binding                { $3 :: $1 }
;
@
%$
% mutually recursive, AND

<<expression rules>>=
let_binding:
    val_ident fun_binding
      { ({ppat_desc = Ppat_var $1; ppat_loc = rhs_loc 1}, $2) }
  | pattern EQUAL seq_expr %prec prec_let
      { ($1, $3) }
;
@
% pattern can't be an ident?

<<expression rules>>=
fun_binding:
    EQUAL seq_expr %prec prec_let
      { $2 }
  | simple_pattern fun_binding
      { mkexp(Pexp_function[$1,$2]) }
  <<rule fun_binding cases>>
;
@
%$
% not necessarally a function actually



\subsection{Entity uses}

<<rule simple_expr cases>>=
|  val_longident
    { mkexp(Pexp_ident $1) }
@
%$

<<name rules>>=
val_longident:
    val_ident                                   { Lident $1 }
  | mod_longident DOT val_ident                 { Ldot($1, $3) }
;
@
%$


\subsection{Operators}

\subsubsection{Infix operators}

<<rule expr cases>>=
| expr INFIXOP0 expr
    { mkinfix $1 $2 $3 }
| expr INFIXOP1 expr
    { mkinfix $1 $2 $3 }
| expr INFIXOP2 expr
    { mkinfix $1 $2 $3 }
| expr INFIXOP3 expr
    { mkinfix $1 $2 $3 }
| expr INFIXOP4 expr
    { mkinfix $1 $2 $3 }

| expr SUBTRACTIVE expr
    { mkinfix $1 $2 $3 } 
| expr STAR expr
    { mkinfix $1 "*" $3 } 

| expr EQUAL expr
    { mkinfix $1 "=" $3 } 
| expr LESS expr
    { mkinfix $1 "<" $3 } 
| expr GREATER expr
    { mkinfix $1 ">" $3 } 

| expr BARBAR expr
    { mkinfix $1 "||" $3 }
| expr AMPERAMPER expr
    { mkinfix $1 "&&" $3 }

| expr COLONEQUAL expr
    { mkinfix $1 ":=" $3 }
@

%less: remove
<<rule expr cases>>=
| expr OR expr
    { mkinfix $1 "or" $3 }
| expr AMPERSAND expr
    { mkinfix $1 "&" $3 }

@

\subsubsection{Prefix operators}

<<rule expr cases>>=
| SUBTRACTIVE expr %prec prec_unary_minus
    { mkuminus $1 $2 }
@
% not sure why can't be merged with next case

<<rule simple_expr cases>>=
| PREFIXOP simple_expr
    { mkexp(Pexp_apply(mkoperator $1 1, [$2])) }
@


\subsection{Casts}

<<rule simple_expr cases>>=
| LPAREN seq_expr type_constraint RPAREN
    { mkexp(Pexp_constraint($2, $3)) }
@
%$

<<expression rules>>=
type_constraint:
    COLON core_type                             { ($2) }
  | COLON error                                 { syntax_error() }
;
@
%$



<<rule fun_binding cases>>=
| type_constraint EQUAL seq_expr %prec prec_let
    { mkexp(Pexp_constraint($3, $1)) }
@


\section{Patterns}

<<rule expr cases>>=
| MATCH seq_expr WITH opt_bar match_cases %prec prec_match
    { mkexp(Pexp_match($2, List.rev $5)) }
@

% also in FUNCTION and FUN have a match_cases

<<expression rules>>=
match_cases:
    pattern match_action                        { [$1, $2] }
  | match_cases BAR pattern match_action        { ($3, $4) :: $1 }
;
match_action:
    MINUSGREATER seq_expr                       { $2 }
  | WHEN seq_expr MINUSGREATER seq_expr         { mkexp(Pexp_when($2, $4)) }
;
@

<<pattern rules>>=
pattern:
    simple_pattern
      { $1 }

  | constr_longident pattern %prec prec_constr_appl
      { mkpat(Ppat_construct($1, Some $2)) }
  | pattern COLONCOLON pattern
      { mkpat(Ppat_construct(Lident "::", Some(mkpat(Ppat_tuple[$1;$3]))
                             )) }
  | pattern_comma_list
      { mkpat(Ppat_tuple(List.rev $1)) }

  | pattern AS val_ident
      { mkpat(Ppat_alias($1, $3)) }
  | pattern BAR pattern
      { mkpat(Ppat_or($1, $3)) }
;
@
% special case for :: here
%todo? could do other constructor like operator? e.g. :=>

% again, just atomic elt here, no application, e.g. constructor with no args
<<pattern rules>>=
simple_pattern:
  | signed_constant
      { mkpat(Ppat_constant $1) }
  | constr_longident
      { mkpat(Ppat_construct($1, None)) }
  | LBRACE lbl_pattern_list opt_semi RBRACE
      { mkpat(Ppat_record(List.rev $2)) }

  | val_ident
      { mkpat(Ppat_var $1) }
  | UNDERSCORE
      { mkpat(Ppat_any) }

  | LBRACKET pattern_semi_list opt_semi RBRACKET
      { mklistpat(List.rev $2) }

  | LPAREN pattern RPAREN
      { $2 }

  | CHAR DOTDOT CHAR
      { mkrangepat $1 $3 }
  | LPAREN pattern COLON core_type RPAREN
      { mkpat(Ppat_constraint($2, $4)) }
  <<rule simple_pattern error cases>>
;
@
% another special case of lists

<<pattern rules>>=
lbl_pattern_list:
    label_longident EQUAL pattern               { [($1, $3)] }
  | lbl_pattern_list SEMI label_longident EQUAL pattern { ($3, $5) :: $1 }
;
@
%$



<<ebnf rules>>=
pattern_comma_list:
    pattern_comma_list COMMA pattern            { $3 :: $1 }
  | pattern COMMA pattern                       { [$3; $1] }
;
@

<<ebnf rules>>=
pattern_semi_list:
    pattern                                     { [$1] }
  | pattern_semi_list SEMI pattern              { $3 :: $1 }
;
@
%$



\section{Statements}

\subsection{Sequence}

<<expression rules>>=
seq_expr:
  | expr                          { $1 }
  | expr SEMI                     { $1 }
  | expr SEMI seq_expr            { mkexp(Pexp_sequence($1, $3)) }
;
@

\subsection{Conditionals}

<<rule expr cases>>=
| IF seq_expr THEN expr ELSE expr %prec prec_if
    { mkexp(Pexp_ifthenelse($2, $4, Some $6)) }
| IF seq_expr THEN expr %prec prec_if
    { mkexp(Pexp_ifthenelse($2, $4, None)) }
@
%$

% why seq_expr for the condition? bof

\subsection{Loops}

<<rule expr cases>>=
| WHILE seq_expr DO seq_expr DONE
    { mkexp(Pexp_while($2, $4)) }
| FOR val_ident EQUAL seq_expr direction_flag seq_expr DO seq_expr DONE
    { mkexp(Pexp_for($2, $4, $6, $5, $8)) }
@
%$

<<misc rules>>=
direction_flag:
    TO                                          { Upto }
  | DOWNTO                                      { Downto }
;
@

\subsection{Exceptions}

<<rule expr cases>>=
| TRY seq_expr WITH opt_bar match_cases %prec prec_try
    { mkexp(Pexp_try($2, List.rev $5)) }
| TRY seq_expr WITH error %prec prec_try
    { syntax_error() }
@

% see also exception declaration

\section{Helpers}


<<functions Parser.mkxxx>>=
let mktyp d =
  { ptyp_desc = d; ptyp_loc = Location.symbol_loc() }
let mkpat d =
  { ppat_desc = d; ppat_loc = Location.symbol_loc() }
let mkexp d =
  { pexp_desc = d; pexp_loc = Location.symbol_loc() }
let mkmty d =
  { pmty_desc = d; pmty_loc = Location.symbol_loc() }
let mksig d =
  { psig_desc = d; psig_loc = Location.symbol_loc() }
let mkmod d =
  { pmod_desc = d; pmod_loc = Location.symbol_loc() }
let mkstr d =
  { pstr_desc = d; pstr_loc = Location.symbol_loc() }
@


<<Parser header>>=
open Location
open Asttypes
open Longident
open Parsetree

<<functions Parser.mkxxx>>

let mkoperator name pos =
  { pexp_desc = Pexp_ident(Lident name); pexp_loc = rhs_loc pos }

<<[[Parser.mkassert()]]>>
;;

<<[[Parser.mklazy()]]>>
;;

let mkinfix arg1 name arg2 =
  mkexp(Pexp_apply(mkoperator name 2, [arg1; arg2]))

let mkuminus name arg =
  match arg.pexp_desc with
    Pexp_constant(Const_int n) ->
      mkexp(Pexp_constant(Const_int(-n)))
  | Pexp_constant(Const_float f) ->
      mkexp(Pexp_constant(Const_float("-" ^ f)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [arg]))

<<[[Parser.mklistexp()]]>>

let rec mklistpat = function
    [] ->
      mkpat(Ppat_construct(Lident "[]", None))
  | p1 :: pl ->
      mkpat(Ppat_construct(Lident "::",
                           Some(mkpat(Ppat_tuple[p1; mklistpat pl]))
                           ))

let mkstrexp e =
  { pstr_desc = Pstr_eval e; pstr_loc = e.pexp_loc }

let array_function str name =
  Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name))

let rec mkrangepat c1 c2 =
  if c1 > c2 then mkrangepat c2 c1 else
  if c1 = c2 then mkpat(Ppat_constant(Const_char c1)) else
  mkpat(Ppat_or(mkpat(Ppat_constant(Const_char c1)),
                mkrangepat (Char.chr(Char.code c1 + 1)) c2))

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_num closing_name closing_num =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(rhs_loc opening_num, opening_name,
                                           rhs_loc closing_num, closing_name)))

@



<<signature Location.rhs_loc>>=
val rhs_loc: int -> t
@
<<function Location.rhs_loc>>=
let rhs_loc n =
  { loc_start = Parsing.rhs_start n; loc_end = Parsing.rhs_end n }
@





\chapter{Typing}
% Naming and typing

% note that this phase build a global environment,
% and will load .cmi of other files!

% reput 'type_expr' def from core DS chapter

% will do naming and typing, interwinded thing.
% can't do typing if don't know precisely to which
% entity an identifier refers to.

\section{Resolving names}
%Naming? A special section? nast

% there is open in ocaml, and even if was forbidding it,
% there will be the implicit open pervasives, so
% need to resolve identifiers.

% resolving? fully qualifying every idents?

\subsection{[[Ident]]}

% Can have let x = ... in let x = ... in the same module,
% need to create different identifier each time.
% In the same way can reuse the same identifier in patterns
% in different rules, or have different functions sharing
% parameters. Anyway, convenient to "resolve" names.

<<type Ident.t>>=
type t = { 
  mutable name: string; 
  mutable stamp: int; 
  <<[[Ident.t]] other fields>>
}
@
% what global is for?

% ?? for builtins and more? -> <>
<<signature Ident.create>>=
val create: string -> t
@
<<constant Ident.currentstamp>>=
(* A stamp of 0 denotes a persistent identifier *)
let currentstamp = ref 0
@
<<function Ident.create>>=
let create s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; global = false }
@
% this is never decremented.
% see also make_global() and create_persistent()
%todo: why need global and stamp?

%ex: unit test?
%let ident_int = Ident.create "int"
% unique!

<<signature Ident.name>>=
val name: t -> string
@
<<function Ident.name>>=
let name i = 
  i.name
@

% persistent??


\subsection{[[Path]]}
% qualifier

% path is fully qualified entity.
% once we can fully name identifiers, we can look
% for their type in the symbol table.

<<type Path.t>>=
(* Access paths *)

type t =
    Pident of Ident.t
  | Pdot of t * string * int
@
% int? when multiple occurents of same name? like let x = ... in let x = ...?

%ex: unit test?
%let path_int = Pident ident_int,  not even Pervasives! higher than that

\section{Resolving types}
%The typed AST

% mainly string -> Ident.t, Longident.t -> Path.t,
% and core_type -> type_expr.

% seen type_expr in core DS chapter.

\subsection{Signatures, the [[.cmi]]}

<<type Types.signature>>=
and signature = signature_item list
@
% .cmi, that is important! we will load that to know the
% type of entities referenced but defined in other module!
% no .h in ocaml :)

<<type Types.signature_item>>=
and signature_item =
    Tsig_value of Ident.t * value_description
  | Tsig_type of Ident.t * type_declaration
  | Tsig_exception of Ident.t * exception_declaration
  | Tsig_module of Ident.t * module_type
@
%diff? no open anymore, not needed, have Path now.


%\subsection Types.xxx
<<type Types.value_description>>=
(* Value descriptions *)

type value_description =
  { val_type: type_expr;                       (* Type of the val *)
    val_prim: Primitive.description option }   (* Is this a primitive? *)
@
% diff? core_type -> type_expr! same in most of what is below.
% also val_prim string list become more precise type




<<type Types.type_declaration>>=
type type_declaration =
  { type_params: type_expr list;
    type_arity: int; (* List.length td.type_params *)
    type_kind: type_kind;
    <<[[Types.type_declaration]] other fields>>
  }
@
% diff type_params string list -> type_expr list, 
% but can only be Tvar no? can do type (int, int) myhash = ... ?? 
% does not mean anything no?
%ex: put decl_bool here?


<<type Types.type_kind>>=
and type_kind =
  | Type_variant of (string * type_expr list) list
  | Type_record of (string * mutable_flag * type_expr) list
  <<[[Types.type_kind]] cases>>
@
% diff? Ptxx->Txx

<<[[Types.type_kind]] cases>>=
| Type_abstract
@
% it's actually useful for some builtin types too! type int;; type float;;
% (type bool is a Type_variant though!)
% because int is neither a variant or a record (or it's very special
% kind of variant ...)

<<type Types.exception_declaration>>=
type exception_declaration = type_expr list
@
% diff? again, core_type -> type_expr

<<type Types.module_type>>=
type module_type =
    Tmty_ident of Path.t
  | Tmty_signature of signature
@
%less: remove Tmty_ident


\subsection{Typed expressions}


<<type Typedtree.expression>>=
type expression =
  { exp_desc: expression_desc;
    exp_loc: Location.t;
    exp_type: type_expr; }
@
%diff = type_expr!

<<type Typedtree.expression_desc>>=
and expression_desc =
  | Texp_constant of constant
  | Texp_construct of constructor_description * expression list
  | Texp_record of (label_description * expression) list
  | Texp_tuple of expression list

  | Texp_function of (pattern * expression) list
  | Texp_apply of expression * expression list

  | Texp_field of expression * label_description
  | Texp_setfield of expression * label_description * expression

  | Texp_let of rec_flag * (pattern * expression) list * expression
  | Texp_ident of Path.t * value_description

  | Texp_match of expression * (pattern * expression) list
  | Texp_when of expression * expression

  | Texp_try of expression * (pattern * expression) list
  | Texp_ifthenelse of expression * expression * expression option
  | Texp_sequence of expression * expression
  | Texp_while of expression * expression
  | Texp_for of
      Ident.t * expression * expression * direction_flag * expression

  <<[[Typedtree.expression_desc]] cases>>
@
% diff? resolved Path for ident and value_description!
% and no more Pexp_constraint


<<type Types.constructor_description>>=
type constructor_description =
  { cstr_res: type_expr;                (* Type of the result *)
    cstr_args: type_expr list;          (* Type of the arguments *)
    cstr_arity: int;                    (* Number of arguments *)

    <<[[Types.constructor_description]] other fields>>
   }
@
% diff with before? from a Longident.t to full information about
% the constructor!

<<type Types.label_description>>=
type label_description =
  { lbl_res: type_expr;                 (* Type of the result *)
    lbl_arg: type_expr;                 (* Type of the argument *)
    lbl_mut: mutable_flag;              (* Is this a mutable field? *)

    <<[[Types.label_description]] other fields>>
  }
@
% diff with before? from a Longident.t to full information about
% the label!



\subsection{Typed patterns}
% but not the .cmo, the .cmo contain bytecode, very
% different nature.
% it's more the .cmt


%\subsection Typedtree.xxx

% could factorize?

<<type Typedtree.pattern>>=
type pattern =
  { pat_desc: pattern_desc;
    pat_loc: Location.t;
    pat_type: type_expr }
@
% note that pat_type now!

<<type Typedtree.pattern_desc>>=
and pattern_desc =
  | Tpat_any
  | Tpat_var of Ident.t

  | Tpat_constant of constant
  | Tpat_construct of constructor_description * pattern list
  | Tpat_record of (label_description * pattern) list

  | Tpat_tuple of pattern list

  | Tpat_alias of pattern * Ident.t
  | Tpat_or of pattern * pattern
@
% diff? for Ppat_constructor from a longident to a full
% resolved and type constructor_description now! see later.
% same for Tpat_record
% no more Ppat_constraint also


\subsection{Typed modules}

<<type Typedtree.module_expr>>=
type module_expr =
  { mod_desc: module_expr_desc;
    mod_loc: Location.t;
    mod_type: module_type; }
@

<<type Typedtree.module_expr_desc>>=
and module_expr_desc =
    Tmod_ident of Path.t
  | Tmod_structure of structure
  | Tmod_constraint of module_expr * module_type * module_coercion
@
%todo: module_coercion? need?

<<type Typedtree.structure>>=
and structure = structure_item list
@

<<type Typedtree.structure_item>>=
and structure_item =
    Tstr_eval of expression
  | Tstr_value of rec_flag * (pattern * expression) list
  | Tstr_primitive of Ident.t * value_description

  | Tstr_type of (Ident.t * type_declaration) list
  | Tstr_exception of Ident.t * exception_declaration

  | Tstr_module of Ident.t * module_expr
  | Tstr_open of Path.t
@
% why keep str_open info?

<<type Typedtree.module_coercion>>=
and module_coercion =
    Tcoerce_none
  | Tcoerce_structure of (int * module_coercion) list
  | Tcoerce_primitive of Primitive.description
@
%delete?

\section{Builtins}

% examples!!

\subsection{Builtin types}
% (and exceptions but exceptions are LP splitted and presented later)

%(* Predefined type constructors (with special typing rules in typecore) *)

<<signatures Predef.type_xxx>>=
val type_int    : type_expr
val type_char   : type_expr
val type_string : type_expr
val type_float  : type_expr
val type_bool   : type_expr
val type_unit   : type_expr

val type_list  : type_expr -> type_expr
val type_array : type_expr -> type_expr
@


<<constants Predef.type_xxx>>=
let type_int     = Tconstr(path_int, [])
and type_char    = Tconstr(path_char, [])
and type_string  = Tconstr(path_string, [])
and type_float   = Tconstr(path_float, [])
and type_bool    = Tconstr(path_bool, [])
and type_unit    = Tconstr(path_unit, [])

and type_list t = Tconstr(path_list, [t])
and type_array t = Tconstr(path_array, [t])
@




<<signatures Predef.path_xxx>>=
val path_int: Path.t
val path_char: Path.t
val path_string: Path.t
val path_float: Path.t
val path_bool: Path.t
val path_unit: Path.t

val path_list: Path.t
val path_array: Path.t
@

<<constants Predef.path_xxx>>=
let path_int = Pident ident_int
and path_char = Pident ident_char
and path_string = Pident ident_string
and path_float = Pident ident_float
and path_bool = Pident ident_bool
and path_unit = Pident ident_unit

and path_list = Pident ident_list
and path_array = Pident ident_array
@



<<constants Predef.ident_xxx>>=
let ident_int = Ident.create "int"
and ident_char = Ident.create "char"
and ident_string = Ident.create "string"
and ident_float = Ident.create "float"
and ident_bool = Ident.create "bool"
and ident_unit = Ident.create "unit"

and ident_exn = Ident.create "exn"

and ident_array = Ident.create "array"
and ident_list = Ident.create "list"
@
% no module
% subtle: don't change the order here, otherwise you may
%  have problem in otherlibs/unix, and get error like
%  "type exn is used where expect exn"





<<function Typecore.type_constant>>=
(* Typing of constants *)

let type_constant = function
    Const_int _ -> Predef.type_int
  | Const_char _ -> Predef.type_char
  | Const_string _ -> Predef.type_string
  | Const_float _ -> Predef.type_float
@


\subsection{Builtin values}
% different from primitives
% different from pervasives

<<signature Predef.build_initial_env>>=
(* To build the initial environment. Since there is a nasty mutual
   recursion between predef and env, we break it by parameterizing
   over Env.t, Env.add_type and Env.add_exception. *)

val build_initial_env:
  (Ident.t -> type_declaration -> 'a -> 'a) ->      (* add_type *)
  (Ident.t -> exception_declaration -> 'a -> 'a) -> (* add_exception *)
  'a -> 'a
@
% will see add_type and the environment later! 'a is really Env.t here.


<<function Predef.build_initial_env>>=
let build_initial_env add_type add_exception empty_env =
  let newvar() =
    (* Cannot call the real newvar from ctype here
       because ctype imports predef via env *)
    Tvar{
      tvar_link = None; 
      <<[[Predef.build_initial_env()]] set other fields in local newvar>>
    } 
  in

  <<[[Predef.build_initial_env()]] decls>>
  <<[[Predef.build_initial_env()]] adding exceptions>>

  add_type ident_format decl_format (

  add_type ident_list decl_list (
  add_type ident_array decl_array (

  add_type ident_exn decl_exn (

  add_type ident_unit decl_unit (
  add_type ident_bool decl_bool (

  add_type ident_float decl_abstr (
  add_type ident_string decl_abstr (
  add_type ident_char decl_abstr (
  add_type ident_int decl_abstr (
  empty_env
  )))))))))))))))))))
@


<<[[Predef.build_initial_env()]] decls>>=
let decl_bool =
  {type_params = [];
   type_arity = 0;
   type_kind = Type_variant["false",[]; "true",[]];
   type_manifest = None}
in
let decl_unit =
  {type_params = []; 
   type_arity = 0;
   type_kind = Type_variant["()",[]];
   type_manifest = None}
in
@


<<[[Predef.build_initial_env()]] decls>>=
let decl_list =
  let tvar = newvar() in
  {type_params = [tvar];
   type_arity = 1;
   type_kind = Type_variant["[]", []; "::", [tvar; type_list tvar]];
   type_manifest = None}
in
@
% newvar? should be a generic type no?


% why decl_abstr for float, string, char, int?
% because not a simple value from a variant or record!
% all the other are
% Abuse Type_abstract for that!

<<[[Predef.build_initial_env()]] decls>>=
let decl_abstr =
  {type_params = [];
   type_arity = 0;
   type_kind = Type_abstract;
   type_manifest = None}
in
@


\subsection{Primitives}

<<type Primitive.description>>=
(* Description of primitive functions *)

type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)

    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)
@

<<signature Primitive.parse_declaration>>=
val parse_declaration: int -> string list -> description option
@

<<function Primitive.parse_declaration>>=
let parse_declaration arity decl =
  match decl with
    name :: "noalloc" :: name2 :: "float" :: _ ->
      Some{prim_name = name; prim_arity = arity; prim_alloc = false;
           prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: name2 :: _ ->
      Some{prim_name = name; prim_arity = arity; prim_alloc = false;
           prim_native_name = name2; prim_native_float = false}
  | name :: name2 :: "float" :: _ ->
      Some{prim_name = name; prim_arity = arity; prim_alloc = true;
           prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: _ ->
      Some{prim_name = name; prim_arity = arity; prim_alloc = false;
           prim_native_name = ""; prim_native_float = false}
  | name :: name2 :: _ ->
      Some{prim_name = name; prim_arity = arity; prim_alloc = true;
           prim_native_name = name2; prim_native_float = false}
  | name :: _ ->
      Some{prim_name = name; prim_arity = arity; prim_alloc = true;
           prim_native_name = ""; prim_native_float = false}
  | [] ->
      None
@


\section{The (typed, named) symbol table, [[Env.t]]}
% The typed, resolved symbol table

\subsection{[[Env.t]]}

<<signature type Env.t>>=
type t
@

% Associate to Ident in env in scope the full information about it, that is
% its full path, and it's type.
% This env will evolve as we typecheck a program and recurse on its
% AST.

<<type Env.t>>=
type t = {
  values     : (Path.t * Types.value_description) Ident.tbl;
  types      : (Path.t * Types.type_declaration)  Ident.tbl;

  modules    : (Path.t * Types.module_type)       Ident.tbl;
  components : (Path.t * module_components)       Ident.tbl;

  constrs    : Types.constructor_description      Ident.tbl;
  labels     : Types.label_description            Ident.tbl;
}
@
%less: no Path for constructor and record?
% not needed?
%less: components?? should rename modules to modtypes, and components to modules
%less: exn? same as types?
%less: diff with components? values/types/constrs/labels are
% for the currently accessible toplevel elts? so after a open
% we populate those tables?
%old:  summary: summary, used by debugger.

<<type Env.module_components>>=
and module_components =
    Structure_comps of structure_components
@

<<type Env.structure_components>>=
and structure_components = {
  mutable comp_values     : (string, (Types.value_description * int)) Tbl.t;
  mutable comp_types      : (string, (Types.type_declaration * int))  Tbl.t;

  mutable comp_modules    : (string, (Types.module_type * int))       Tbl.t;
  mutable comp_components : (string, (module_components * int))       Tbl.t;

  mutable comp_constrs    : (string, (constructor_description * int)) Tbl.t;
  mutable comp_labels     : (string, (label_description * int))       Tbl.t;
}
@
%todo: replace by just Env.t itself no?
% no because the purpose is different. The key are string here!
% before they are Ident and they return a pair of Path and the value.
%todo: what is the int above? like in Ident, to handle dupe names in one modul?
%todo: this is also in the .cmi
%todo: why need that in typing context? Env.modules not enough?

<<signature Env.empty>>=
val empty: t
@

<<constant Env.empty>>=
let empty = {
  values = Ident.empty; 
  constrs = Ident.empty;
  labels = Ident.empty; 
  types = Ident.empty;
  modules = Ident.empty;
  components = Ident.empty; }
@
%old:  summary = Env_empty }

% this will evolve as we go down and introduce more local entities.

<<signature Env.initial>>=
val initial: t
@

<<constant Env.initial>>=
(* Make the initial environment *)

let initial = Predef.build_initial_env add_type add_exception empty
@
% bool, int, etc. Even before Pervasives!



\subsection{Example of use, [[open]]}
% naming issue

% good to see an example of the kinda of API
% we need. otherwise just see hundreds of small
% functions without understand why they are needed.

<<signature Env.open_signature>>=
(* Insertion of all fields of a signature, relative to the given path.
   Used to implement open. *)

val open_signature: Path.t -> signature -> t -> t
@
% when do open X.Y, then all use of entities from module X.Y
% should be fully qualified and resolved when we encouter them.

% sg = signature
<<function Env.open_signature>>=
(* Open a signature path *)

let open_signature root sg env =
  (* First build the paths and substitution *)
  let (pl, sub) = prefix_idents root 0 Subst.identity sg in

  (* Then enter the components in the environment after substitution *)
  List.fold_left2
    (fun env item p ->
      match item with
      (* boilerplate and overloading *)
      | Tsig_value(id, decl) ->
          store_value (Ident.hide id) p
                      (Subst.value_description sub decl) env
      | Tsig_type(id, decl) ->
          store_type (Ident.hide id) p
                     (Subst.type_declaration sub decl) env
      | Tsig_exception(id, decl) ->
          store_exception (Ident.hide id) p
                          (Subst.exception_declaration sub decl) env
      | Tsig_module(id, mty) ->
          store_module (Ident.hide id) p 
                       (Subst.modtype sub mty) env
    )
    env sg pl
@
% no need subst the id returned by Ident.hide since it appears
% only on the left. In a .mli there are no recursive things,
% only in the .ml and structures.

<<signature Ident.hide>>=
val hide: t -> t
        (* Return an identifier with same name as the given identifier,
           but stamp different from any stamp returns by new.
           When put in a 'a tbl, this identifier can only be looked
           up by name. *)
@
<<function Ident.hide>>=
let hide i =
  { stamp = -1; name = i.name; global = i.global }
@
% ???

<<function Env.prefix_idents>>=
(* Given a signature and a root path, prefix all idents in the signature
   by the root path and build the corresponding substitution. *)

let rec prefix_idents root pos sub = function
    [] -> ([], sub)
  | Tsig_value(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let nextpos = match decl.val_prim with None -> pos+1 | Some _ -> pos in
      let (pl, final_sub) = prefix_idents root nextpos sub rem in
      (p::pl, final_sub)

  | Tsig_type(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos (Subst.add_type id p sub) rem in
      (p::pl, final_sub)
  | Tsig_exception(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) = prefix_idents root (pos+1) sub rem in
      (p::pl, final_sub)

  | Tsig_module(id, mty) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) =
        prefix_idents root (pos+1) (Subst.add_module id p sub) rem in
      (p::pl, final_sub)
@
% pos? what for? for primitives??





\subsection{Populating the environment}

\subsubsection{By [[Ident]] and [[Path]]}

% (* Insertion of bindings by identifier + path *)

<<function Env.store_value>>=
and store_value id path decl env =
  { values = Ident.add id (path, decl) env.values;
    (* boilerplate, with record *)
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
    components = env.components }
@
%todo: env with syntax! will factorize lots of code already

<<function Env.store_type>>=
and store_type id path info env =
  { types = Ident.add id (path, info) env.types;
    constrs =
      List.fold_right
        (fun (name, descr) constrs ->
          Ident.add (Ident.create name) descr constrs
        )
        (constructors_of_type path info)
        env.constrs;
    labels =
      List.fold_right
        (fun (name, descr) labels ->
          Ident.add (Ident.create name) descr labels
        )
        (labels_of_type path info)
        env.labels;
    (* boilerplate, with record *)
    values = env.values;
    modules = env.modules;
    components = env.components }
@


<<function Env.store_module>>=
and store_module id path mty env =
  { modules = Ident.add id (path, mty) env.modules;
    components =
      Ident.add id (path, components_of_module env Subst.identity path mty)
                   env.components;
    (* boilerplate, with record *)
    values = env.values;
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
}
@

<<function Env.store_components>>=
and store_components id path comps env =
  { components = Ident.add id (path, comps) env.components;
    (* boilerplate, with record *)
    values = env.values;
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
  }
@

\subsubsection{By [[Ident]]}
% (* Insertion by identifier *)

<<signature Env.add_value>>=
val add_value: Ident.t -> value_description -> t -> t
@
<<signature Env.add_type>>=
val add_type: Ident.t -> type_declaration -> t -> t
@
<<signature Env.add_module>>=
val add_module: Ident.t -> module_type -> t -> t
@
% rename add_module_type?


<<function Env.add_value>>=
let add_value id desc env =
  store_value id (Pident id) desc env
@
<<function Env.add_type>>=
and add_type id info env =
  store_type id (Pident id) info env
@
<<function Env.add_module>>=
and add_module id mty env =
  store_module id (Pident id) mty env
@


\subsubsection{By name}

% (* Insertion by name *)

% Typecore.type_exp (case For, which introduces a local) -> <>
<<signature Env.enter_value>>=
val enter_value: string -> value_description -> t -> Ident.t * t
@
<<signature Env.enter_type>>=
val enter_type: string -> type_declaration -> t -> Ident.t * t
@
<<signature Env.enter_module>>=
val enter_module: string -> module_type -> t -> Ident.t * t
@


<<function Env.enter>>=
(* Insertion of bindings by name *)

let enter store_fun name data env =
  let id = Ident.create name in 
  (id, store_fun id (Pident id) data env)
@

<<functions Env.enter_xxx>>=
let enter_value     = enter store_value
and enter_type      = enter store_type
and enter_module    = enter store_module
@


\subsection{Accessing the environment}

\subsubsection{By [[Path]]}

% by Path
<<signature Env.find_value>>=
val find_value: Path.t -> t -> Types.value_description
@
<<signature Env.find_type>>=
val find_type: Path.t -> t -> Types.type_declaration
@

<<function Env.find>>=
let find proj1 proj2 path env =
  match path with
    Pident id ->
      let (_p, data) = Ident.find_same id (proj1 env) in
      data
  | Pdot(p, s, pos) ->
      (match find_module_descr p env with
        Structure_comps c ->
          let (data, _pos) = Tbl.find s (proj2 c) in 
          data
      )
@

<<function Env.find_value>>=
let find_value = 
  find (fun env -> env.values) (fun sc -> sc.comp_values)
@

<<function Env.find_type>>=
and find_type = 
  find (fun env -> env.types) (fun sc -> sc.comp_types)
@


\subsubsection{By [[Longident]]}

% by Longident

<<signature Env.lookup_value>>=
val lookup_value: Longident.t -> t -> Path.t * Types.value_description
@
<<signature Env.lookup_type>>=
val lookup_type: Longident.t -> t -> Path.t * Types.type_declaration
@
<<signature Env.lookup_module>>=
val lookup_module: Longident.t -> t -> Path.t * Types.module_type
@
% rename lookup_module_type?


<<function Env.lookup>>=
let lookup proj1 proj2 lid env =
  match lid with
    Lident s ->
      Ident.find_name s (proj1 env)
  | Ldot(l, s) ->
      (match lookup_module_descr l env with
       (p, Structure_comps c) ->
        let (data, pos) = Tbl.find s (proj2 c) in
           (Pdot(p, s, pos), data)
      )
@


<<function Env.lookup_value>>=
let lookup_value =
  lookup (fun env -> env.values) (fun sc -> sc.comp_values)
@
<<function Env.lookup_type>>=
and lookup_type =
  lookup (fun env -> env.types) (fun sc -> sc.comp_types)
@


<<signature Env.lookup_constructor>>=
val lookup_constructor: Longident.t -> t -> Types.constructor_description
@
<<signature Env.lookup_label>>=
val lookup_label: Longident.t -> t -> Types.label_description
@



<<function Env.lookup_simple>>=
let lookup_simple proj1 proj2 lid env =
  match lid with
    Lident s ->
      Ident.find_name s (proj1 env)
  | Ldot(l, s) ->
      begin match lookup_module_descr l env with
       (p, Structure_comps c) ->
      let (data, pos) = Tbl.find s (proj2 c) in
          data
      end
@

<<function Env.lookup_constructor>>=
and lookup_constructor =
  lookup_simple (fun env -> env.constrs) (fun sc -> sc.comp_constrs)
@
<<function Env.lookup_label>>=
and lookup_label =
  lookup_simple (fun env -> env.labels) (fun sc -> sc.comp_labels)
@







\subsection{Substitutions}
% It's for naming.

% when we open_signature, we need to add the toplevel elts
% ident in the env, and associate their type, but their type
% may reference elt from their module too, so we must
% qualify all those things. Enter subst, which is just
% to apply the Ident.t -> Path.t for everything added in the Env.

<<type Subst.t>>=
type t = 
  { types: Path.t Ident.tbl;
    modules: Path.t Ident.tbl;
    modtypes: module_type Ident.tbl }
@
% for naming. to transform ident to path. 
%todo: But why need modules? because different namespace for types and values?
% which is why there is type_path() and module_path() below
%todo: why for modtypes it's not a Path.t?

<<signature Subst.identity>>=
val identity: t
@
<<constant Subst.identity>>=
let identity =
  { types = Ident.empty; modules = Ident.empty; modtypes = Ident.empty }
@

\subsubsection{Populating substitutions}

<<signature Subst.add_type>>=
val add_type: Ident.t -> Path.t -> t -> t
@
<<signature Subst.add_module>>=
val add_module: Ident.t -> Path.t -> t -> t
@
<<signature Subst.add_modtype>>=
val add_modtype: Ident.t -> module_type -> t -> t
@

% boilerplate mostly

<<function Subst.add_type>>=
let add_type id p s =
  { types = Ident.add id p s.types;
    (* boilerplate, with record *)
    modules = s.modules;
    modtypes = s.modtypes }
@

<<function Subst.add_module>>=
let add_module id p s =
  { modules = Ident.add id p s.modules;
    (* boilerplate, with record *)
    types = s.types;
    modtypes = s.modtypes }
@

<<function Subst.add_modtype>>=
let add_modtype id ty s =
  { modtypes = Ident.add id ty s.modtypes;
    (* boilerplate, with record *)
    modules = s.modules;
    types = s.types;
  }
@

\subsubsection{Applying substitutions}

<<signature Subst.type_expr>>=
val type_expr: t -> type_expr -> type_expr
@
<<signature Subst.value_description>>=
val value_description: t -> value_description -> value_description
@
<<signature Subst.type_declaration>>=
val type_declaration: t -> type_declaration -> type_declaration
@
<<signature Subst.modtype>>=
val modtype: t -> module_type -> module_type
@
<<signature Subst.signature>>=
val signature: t -> signature -> signature
@



<<function Subst.type_expr>>=
let rec type_expr s = function
    Tvar{tvar_link = None} as ty -> ty
  | Tvar{tvar_link = Some ty} -> type_expr s ty
  (* boilerplate mapper *)
  | Tarrow(t1, t2) -> Tarrow(type_expr s t1, type_expr s t2)
  | Ttuple tl -> Ttuple(List.map (type_expr s) tl)
  | Tconstr(p, []) -> Tconstr(type_path s p, [])
  | Tconstr(p, tl) -> Tconstr(type_path s p, List.map (type_expr s) tl)
@
% follow link!

<<function Subst.type_path>>=
let type_path s = function
    Pident id as p ->
      begin try Ident.find_same id s.types with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
@
<<function Subst.module_path>>=
let rec module_path s = function
    Pident id as p ->
      begin try Ident.find_same id s.modules with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
@

%less: could do modtype_path here, and use it below

% boilerplate
<<function Subst.value_description>>=
let value_description s descr =
  { val_type = type_expr s descr.val_type;
    val_prim = descr.val_prim }
@

<<function Subst.type_declaration>>=
let type_declaration s decl =
  { type_params = decl.type_params;
    type_arity = decl.type_arity;
    type_kind =
      begin match decl.type_kind with 
       (* boilerplate mapper *)
        Type_abstract -> Type_abstract
      | Type_variant cstrs ->
          Type_variant(List.map (fun (n, args) -> (n, List.map (type_expr s) args))
                           cstrs)
      | Type_record lbls ->
          Type_record(List.map (fun (n, mut, arg) -> (n, mut, type_expr s arg))
                          lbls)
      end;
    type_manifest =
      begin match decl.type_manifest with
        None -> None
      | Some ty -> Some(type_expr s ty)
      end
  }
@


<<function Subst.modtype>>=
let rec modtype s = function
    Tmty_ident p as mty ->
      begin match p with
        Pident id ->
          begin try Ident.find_same id s.modtypes with Not_found -> mty end
      | Pdot(p, n, pos) ->
          Tmty_ident(Pdot(module_path s p, n, pos))
      end
  | Tmty_signature sg ->
      Tmty_signature(signature s sg)

and signature s sg = List.map (signature_item s) sg

and signature_item s = function
    Tsig_value(id, d) -> Tsig_value(id, value_description s d)
  | Tsig_type(id, d) -> Tsig_type(id, type_declaration s d)
  | Tsig_exception(id, d) -> Tsig_exception(id, exception_declaration s d)
  | Tsig_module(id, mty) -> Tsig_module(id, modtype s mty)
@


\section{Reading [[.cmi]]}

<<signature Env.read_signature>>=
(* Read, save a signature to/from a file *)

val read_signature: string -> string -> Types.signature * Digest.t
        (* Arguments: module name, file name.
           Results: signature, CRC. *)
@

<<function Env.read_signature>>=
(* Read a signature from a file *)

let read_signature modname filename =
  let (ps, crc) = read_pers_struct modname filename in 
  (ps.ps_sig, crc)
@

<<type Env.pers_struct>>=
(* Persistent structure descriptions *)

type pers_struct =
  { ps_name: string;
    ps_sig: signature;
    ps_comps: module_components }
@
% have module_components in a .cmi?? redundant with signature no?
% just a hashed version of ps_sig?

<<function Env.read_pers_struct>>=
let read_pers_struct modname filename =
  let ic = open_in_bin filename in
  try
    let buffer = String.create (String.length cmi_magic_number) in
    really_input ic buffer 0 (String.length cmi_magic_number);
    if buffer <> cmi_magic_number then begin
      close_in ic;
      raise(Error(Not_an_interface filename))
    end;

    let ps = (input_value ic : pers_struct) in
    let crc = Digest.input ic in
    close_in ic;

    if ps.ps_name <> modname then
      raise(Error(Illegal_renaming(ps.ps_name, filename)));
    (ps, crc)
  with End_of_file | Failure _ ->
    close_in ic;
    raise(Error(Corrupted_interface(filename)))
@

<<signature Config.cmi_magic_number>>=
val cmi_magic_number: string
        (* Magic number for compiled interface files *)
@



% memoization
<<constant Env.persistent_structures>>=
let persistent_structures =
  (Hashtbl.create 17 : (string, pers_struct) Hashtbl.t)
@
% string is toplevel modname (which should lead to a unique file.cmi)

% opti, memoize
% less: could rewrite with Common.memoize or something?
<<function Env.find_pers_struct>>=
let find_pers_struct name =
  try
    Hashtbl.find persistent_structures name
  with Not_found ->
    let (ps, crc) =
      read_pers_struct name
        (find_in_path !load_path (String.lowercase name ^ ".cmi")) in
    Hashtbl.add persistent_structures name ps;
    <<[[Env.find_pers_struct()]] hook when read Name.cmi and its crc>>
    ps
@



\section{Type operations}


\subsection{Unification}

% core to type inference mechanism and type checking,
% unification! if have 'a -> 'a can we pass an int? yes!
%  (and we should also know now that 'a should be substituted to
%   an int everywhere it occurs)
% if have bool -> int, can we pass an int? no!
% unify() will answer those questions.

<<signature Ctype.unify>>=
val unify: Env.t -> type_expr -> type_expr -> unit
        (* Unify the two types given. Raise [Unify] if not possible. *)
@


<<exception Ctype.Unify>>=
exception Unify
@
%new: exception Unify of (type_expr * type_expr) list



<<function Ctype.unify>>=
let rec unify env t1 t2 =
  if t1 == t2 
  then () 
  else begin
    let t1 = repr t1 in
    let t2 = repr t2 in
    if t1 == t2 
    then () 
    else begin
      match (t1, t2) with
        (Tvar v, _) ->
          occur v t2; 
          v.tvar_link <- Some t2
      | (_, Tvar v) ->
          occur v t1; 
          v.tvar_link <- Some t1
      | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
          unify env t1 t2; unify env u1 u2
      | (Ttuple tl1, Ttuple tl2) ->
          unify_list env tl1 tl2
      | (Tconstr(p1, tl1), Tconstr(p2, tl2)) ->
          if Path.same p1 p2 
          then unify_list env tl1 tl2
          else begin
            <<[[Ctype.unify()]] if p1 or p2 are abbreviation type paths>>
                raise Unify
          end
      <<[[Ctype.unify()]] match t1 t2 other cases>>
      | (_, _) ->
          raise Unify
    end
  end

and unify_list env tl1 tl2 =
  match (tl1, tl2) with
    ([], []) -> ()
  | (t1::r1, t2::r2) -> 
      unify env t1 t2; 
      unify_list env r1 r2
  | (_, _) -> raise Unify
@


<<function Ctype.occur>>=
let rec occur tvar ty =
  match repr ty with
    Tvar v ->
      if v == tvar 
      then raise Unify; (* occur check fail *)
      <<[[Ctype.occur()]] in Tvar case, adjust levels if needed>>
  (* boilerplate visitor *)
  | Tarrow(t1, t2) ->
      occur tvar t1; occur tvar t2
  | Ttuple tl ->
      List.iter (occur tvar) tl
  | Tconstr(_p, tl) ->
      List.iter (occur tvar) tl
@
% ==, physical equality
%old: but useless I think
%  | Tconstr(p, []) ->
%      ()



<<signature Path.same>>=
val same: t -> t -> bool
@
<<function Path.same>>=
let rec same p1 p2 =
  match (p1, p2) with
    (Pident id1, Pident id2) -> Ident.same id1 id2
  | (Pdot(p1, s1, pos1), Pdot(p2, s2, pos2)) -> s1 = s2 & same p1 p2
  | (_, _) -> false
@

<<signature Ident.same>>=
val same: t -> t -> bool
        (* Compare identifiers by binding location.
           Two identifiers are the same either if they are both
           non-persistent and have been created by the same call to
           [new], or if they are both persistent and have the same
           name. *)
@
<<function Ident.same>>=
let same i1 i2 = 
  i1 = i2
@
%  (* Possibly more efficient version (with a real compiler, at least):
%       if i1.stamp <> 0
%       then i1.stamp = i2.stamp
%       else i2.stamp = 0 & i1.name = i2.name *)


\subsection{Canonical types, links}

%todo? put earlier? in header of the chapter?
%todo? the code of the dumper helps to understand things?

<<signature Ctype.repr>>=
val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)
@
% actually it just does one level no?

<<function Ctype.repr>>=
let rec repr = function
    Tvar({tvar_link = Some ty} as v) ->
      let r = repr ty in
      if r != ty 
      then v.tvar_link <- Some r;
      r
  | t -> t
@
% stores the end of the chain each time when can.
% so further calls to repr with the same var will go faster.

\subsection{Instantiation}
% type scheme? see later too?

\subsection{Generalization}
% will see later


\section{Typing expressions}

% string -> Ident.t -> Path.t
% Longident.t -> Path.t
% Parsetree.xxx -> Types.xxx or Typedtree.xxx, P -> T

<<signature Typecore.type_expression>>=
val type_expression:
        Env.t -> Parsetree.expression -> Typedtree.expression
@
%less: rename type_toplevel_expression

% for toplevel one! those are specials!
<<function Typecore.type_expression>>=
(* Typing of toplevel expressions *)

let type_expression env sexp =
  <<[[Typecode.type_expression()]] before type_exp>>
  let exp = type_exp env sexp in
  <<[[Typecode.type_expression()]] after type_exp>>
  exp
@

<<function Typecore.type_exp>>=
let rec type_exp env sexp =
  match sexp.pexp_desc with
  <<[[Typecore.type_exp()]] match cases>>
@
% not just toplevel


<<signature Ctype.newvar>>=
val newvar: unit -> type_expr
        (* Return a fresh variable *)
@
<<function Ctype.newvar>>=
let newvar () =
  Tvar { tvar_link = None; 
         <<[[Ctype.newvar()]] set other fields>>
       }
@
% this allocates a new cell with a new mutable field tvar_link!



\subsection{Constants}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_constant cst ->
    { exp_desc = Texp_constant cst;
      exp_loc = sexp.pexp_loc;
      exp_type = type_constant cst }
@

% P -> T
% saw type_constant() before

\subsection{Constructors}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_construct(lid, sarg) ->
    let constr =
      try
        Env.lookup_constructor lid env
      with Not_found ->
        raise(Error(sexp.pexp_loc, Unbound_constructor lid)) 
    in
    let sargs =
      match sarg with
        None -> []
      | Some {pexp_desc = Pexp_tuple sel} when constr.cstr_arity > 1 -> sel
      | Some se -> [se] 
    in
    <<[[Typecore.type_exp()]] constructor case, sanity check>>

    let (ty_args, ty_res) = instance_constructor constr in
    let args = List.map2 (type_expect env) sargs ty_args in
    { exp_desc = Texp_construct(constr, args);
      exp_loc = sexp.pexp_loc;
      exp_type = ty_res }
@

% list has been desugard in constructor already

<<[[Typecore.type_exp()]] constructor case, sanity check>>=
if List.length sargs <> constr.cstr_arity 
then
  raise(Error(sexp.pexp_loc, Constructor_arity_mismatch(lid,
                                 constr.cstr_arity, List.length sargs)));
@



<<function Typecode.type_expect>>=
(* Typing of an expression with an expected type.
   Some constructs are treated specially to provide better error messages. *)

and type_expect env sexp ty_expected =
  match sexp.pexp_desc with
  <<[[Typecode.type_expect()]] match cases>>
  | _ ->
      let exp = type_exp env sexp in
      unify_exp env exp ty_expected;
      exp
@


<<function Typecore.unify_exp>>=
(* Typing of expressions *)

let unify_exp env exp expected_ty =
  try
    unify env exp.exp_type expected_ty
  with Unify ->
    raise(Error(exp.exp_loc, Expr_type_clash(exp.exp_type, expected_ty)))
@
% better error message than just Unify failure




\subsection{Records}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_record lid_sexp_list ->
    let ty = newvar() in
    let num_fields = ref 0 in
    let type_label_exp (lid, sarg) =
      let label =
        try
          Env.lookup_label lid env
        with Not_found ->
          raise(Error(sexp.pexp_loc, Unbound_label lid)) 
      in
      let (ty_arg, ty_res) = instance_label label in
      (try
        unify env ty_res ty
      with Unify ->
        raise(Error(sexp.pexp_loc, Label_mismatch(lid, ty_res, ty)))
      );
      let arg = type_expect env sarg ty_arg in
      num_fields := Array.length label.lbl_all;
      (label, arg) 
    in
    let lbl_exp_list = List.map type_label_exp lid_sexp_list in
    <<[[Typecore.type_exp()]] record case, sanity check duplicates and missing>>
    { exp_desc = Texp_record lbl_exp_list;
      exp_loc = sexp.pexp_loc;
      exp_type = ty }
@


<<[[Typecore.type_exp()]] record case, sanity check duplicates and missing>>=
let rec check_duplicates = function
  [] -> ()
| (lid, sarg) :: remainder ->
    if List.mem_assoc lid remainder
    then raise(Error(sexp.pexp_loc, Label_multiply_defined lid))
    else check_duplicates remainder 
in
check_duplicates lid_sexp_list;

if List.length lid_sexp_list <> !num_fields 
then raise(Error(sexp.pexp_loc, Label_missing));
@
%todo: hmm would be nice to explain which one are missing ...

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_field(sarg, lid) ->
    let arg = type_exp env sarg in
    let label =
      try
        Env.lookup_label lid env
      with Not_found ->
        raise(Error(sexp.pexp_loc, Unbound_label lid)) 
    in
    let (ty_arg, ty_res) = instance_label label in
    unify_exp env arg ty_res;
    { exp_desc = Texp_field(arg, label);
      exp_loc = sexp.pexp_loc;
      exp_type = ty_arg }
@

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_setfield(srecord, lid, snewval) ->
    let record = type_exp env srecord in
    let label =
      try
        Env.lookup_label lid env
      with Not_found ->
        raise(Error(sexp.pexp_loc, Unbound_label lid)) 
    in
    if label.lbl_mut = Immutable 
    then raise(Error(sexp.pexp_loc, Label_not_mutable lid));
    let (ty_arg, ty_res) = instance_label label in
    unify_exp env record ty_res;
    let newval = type_expect env snewval ty_arg in
    { exp_desc = Texp_setfield(record, label, newval);
      exp_loc = sexp.pexp_loc;
      exp_type = Predef.type_unit }
@


\subsection{Tuples}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_tuple sexpl ->
    let expl = List.map (type_exp env) sexpl in
    { exp_desc = Texp_tuple expl;
      exp_loc = sexp.pexp_loc;
      exp_type = Ttuple(List.map (fun exp -> exp.exp_type) expl) }
@

\subsection{Statements}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_sequence(sexp1, sexp2) ->
    let exp1 = type_statement env sexp1 in
    let exp2 = type_exp env sexp2 in
    { exp_desc = Texp_sequence(exp1, exp2);
      exp_loc = sexp.pexp_loc;
      exp_type = exp2.exp_type }
@


<<[[Typecode.type_expect()]] match cases>>=
| Pexp_sequence(sexp1, sexp2) ->
    let exp1 = type_statement env sexp1 in
    let exp2 = type_expect env sexp2 ty_expected in
    { exp_desc = Texp_sequence(exp1, exp2);
      exp_loc = sexp.pexp_loc;
      exp_type = exp2.exp_type }
@
% how this is better than the default case of type_Expect?


<<function Typecore.type_statement>>=
(* Typing of statements (expressions whose values are discarded) *)

and type_statement env sexp =
    let exp = type_exp env sexp in
    match Ctype.repr exp.exp_type with
      Tarrow(_, _) ->
        Location.print_warning sexp.pexp_loc
          "this function application is partial,\n\
           maybe some arguments are missing.";
        exp
    | _ -> exp
@
% nice check!
%less: could also check that the type is unit!


<<[[Typecore.type_exp()]] match cases>>=
| Pexp_ifthenelse(scond, sifso, sifnot) ->
    let cond = type_expect env scond Predef.type_bool in
    (match sifnot with
    | None ->
        let ifso = type_expect env sifso Predef.type_unit in
        { exp_desc = Texp_ifthenelse(cond, ifso, None);
          exp_loc = sexp.pexp_loc;
          exp_type = Predef.type_unit }
    | Some sexp ->
        let ifso = type_exp env sifso in
        let ifnot = type_expect env sexp ifso.exp_type in
        { exp_desc = Texp_ifthenelse(cond, ifso, Some ifnot);
          exp_loc = sexp.pexp_loc;
          exp_type = ifso.exp_type }
    )
@


<<[[Typecore.type_exp()]] match cases>>=
| Pexp_while(scond, sbody) ->
    let cond = type_expect env scond Predef.type_bool in
    let body = type_statement env sbody in
    { exp_desc = Texp_while(cond, body);
      exp_loc = sexp.pexp_loc;
      exp_type = Predef.type_unit }
@

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_for(param, slow, shigh, dir, sbody) ->
    let low = type_expect env slow Predef.type_int in
    let high = type_expect env shigh Predef.type_int in
    let (id, new_env) =
      Env.enter_value param {val_type = Predef.type_int;
                              val_prim = None} env 
    in
    let body = type_statement new_env sbody in
    { exp_desc = Texp_for(id, low, high, dir, body);
      exp_loc = sexp.pexp_loc;
      exp_type = Predef.type_unit }
@




\subsection{Patterns}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_match(sarg, caselist) ->
    let arg = type_exp env sarg in
    let ty_res = newvar() in
    let cases = type_cases env arg.exp_type ty_res caselist in
    <<[[Typecore.type_exp()]] match case, sanity check unused or partial>>
    { exp_desc = Texp_match(arg, cases);
      exp_loc = sexp.pexp_loc;
      exp_type = ty_res }
@

<<function Typecore.type_cases>>=
(* Typing of match cases *)

and type_cases env ty_arg ty_res caselist =
  List.map (fun (spat, sexp) ->
      let (pat, ext_env) = type_pattern env spat in
      unify_pat env pat ty_arg;
      let exp = type_expect ext_env sexp ty_res in
      (pat, exp)
  ) caselist
@

<<[[Typecore.type_exp()]] match case, sanity check unused or partial>>=
Parmatch.check_unused cases;
Parmatch.check_partial sexp.pexp_loc cases;
@
% see in next chapter


<<[[Typecore.type_exp()]] match cases>>=
| Pexp_when(scond, sbody) ->
    let cond = type_expect env scond Predef.type_bool in
    let body = type_exp env sbody in
    { exp_desc = Texp_when(cond, body);
      exp_loc = sexp.pexp_loc;
      exp_type = body.exp_type }
@


\subsection{Functions}
% better to be put after pattern case as function is taking
% some patterns

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_function caselist ->
    let ty_arg = newvar() in
    let ty_res = newvar() in
    let cases = type_cases env ty_arg ty_res caselist in
    <<[[Typecore.type_exp()]] match case, sanity check unused or partial>>
    { exp_desc = Texp_function cases;
      exp_loc = sexp.pexp_loc;
      exp_type = Tarrow(ty_arg, ty_res) }
@

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_apply(sfunct, sargs) ->
    let funct = type_exp env sfunct in

    let rec type_args ty_fun = function
    | [] ->
        ([], ty_fun)
    | sarg1 :: sargl ->
        let (ty1, ty2) =
          try
            filter_arrow env ty_fun
          with Unify ->
            raise(Error(sfunct.pexp_loc,
                        Apply_non_function funct.exp_type)) 
        in
        let arg1 = type_expect env sarg1 ty1 in
        let (argl, ty_res) = type_args ty2 sargl in
        (arg1 :: argl, ty_res) 
    in

    let (args, ty_res) = type_args funct.exp_type sargs in
    { exp_desc = Texp_apply(funct, args);
      exp_loc = sexp.pexp_loc;
      exp_type = ty_res }
@

<<signature Ctype.filter_arrow>>=
val filter_arrow: Env.t -> type_expr -> type_expr * type_expr
        (* A special case of unification (with 'a -> 'b). *)
@

% why not using newvar?
<<function Ctype.filter_arrow>>=
let rec filter_arrow env t =
  match repr t with
    Tvar v ->
      let t1 = Tvar { tvar_level = v.tvar_level; tvar_link = None } in
      let t2 = Tvar { tvar_level = v.tvar_level; tvar_link = None } in
      v.tvar_link <- Some(Tarrow(t1, t2));
      (t1, t2)
  | Tarrow(t1, t2) ->
      (t1, t2)
  <<[[Ctype.filter_arrow()]] other cases>>
  | _ ->
      raise Unify
@

\subsection{Casts}

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_constraint(sarg, sty) ->
    let ty = Typetexp.transl_simple_type env false sty in
    let arg = type_expect env sarg ty in
    { exp_desc = arg.exp_desc;
      exp_loc = arg.exp_loc;
      exp_type = ty }
@

% link with next section where type types ...

\section{Typing let}
% complex, new_env again! like for For, because introduce new
% entities

<<[[Typecore.type_exp()]] match cases>>=
| Pexp_let(rec_flag, spat_sexp_list, sbody) ->
    let (pat_exp_list, new_env) = type_let env rec_flag spat_sexp_list in
    let body = type_exp new_env sbody in
    { exp_desc = Texp_let(rec_flag, pat_exp_list, body);
      exp_loc = sexp.pexp_loc;
      exp_type = body.exp_type }
@

% if allcode?
<<[[Typecode.type_expect()]] match cases>>=
| Pexp_let(rec_flag, spat_sexp_list, sbody) ->
    let (pat_exp_list, new_env) = type_let env rec_flag spat_sexp_list in
    let body = type_expect new_env sbody ty_expected in
    { exp_desc = Texp_let(rec_flag, pat_exp_list, body);
      exp_loc = sexp.pexp_loc;
      exp_type = body.exp_type }
@
% how this is better than the default case of type_Expect?
% because distribute the expected type error message?


<<function Typecode.type_let>>=
(* Typing of let bindings *)

and type_let env rec_flag spat_sexp_list =

  <<[[Typecode.type_let()]] before typing>>
  let (pat_list, new_env) =
    spat_sexp_list 
    |> List.map (fun (spat, sexp) -> spat)
    |> type_pattern_list env 
  in
  let exp_env =
    match rec_flag with 
    | Nonrecursive -> env 
    | Recursive -> new_env 
  in
  let exp_list =
    List.map2
      (fun (_spat, sexp) pat -> type_expect exp_env sexp pat.pat_type)
      spat_sexp_list pat_list in
  <<[[Typecode.type_let()]] sanity check partial patterns>>
  <<[[Typecode.type_let()]] after typing>>

  (List.combine pat_list exp_list, new_env)
@

<<[[Typecode.type_let()]] sanity check partial patterns>>=
List.iter2
  (fun pat exp -> Parmatch.check_partial pat.pat_loc [pat, exp])
  pat_list exp_list;
@



<<[[Typecore.type_exp()]] match cases>>=
|  Pexp_ident lid ->
    begin try
      let (path, desc) = Env.lookup_value lid env in
      { exp_desc = Texp_ident(path, desc);
        exp_loc = sexp.pexp_loc;
        exp_type = instance desc.val_type }
    with Not_found ->
      raise(Error(sexp.pexp_loc, Unbound_value lid))
    end
@
% instance!

\subsection{Type levels}

<<[[Typecode.type_let()]] before typing>>=
begin_def();
@

<<[[Typecode.type_let()]] after typing>>=
end_def();
<<[[Typecode.type_let()]] after end_def, generalize or not>>
@


<<[[Typecode.type_expression()]] before type_exp>>=
reset_def();
Typetexp.reset_type_variables();

begin_def();
@

<<[[Typecode.type_expression()]] after type_exp>>=
end_def();
<<[[Typecode.type_expression()]] after end_def, generalize or not>>
@



<<constant Ctype.current_level>>=
let current_level = ref 0
@

<<function Ctype.reset_def>>=
let reset_def () = 
  current_level := 0
@

<<function Ctype.begin_def>>=
let begin_def () = 
  incr current_level
@

<<function Ctype.end_def>>=
let end_def () = 
  decr current_level
@
% why need that? just increment always, why need to decrement?


<<[[Types.type_variable]] other fields>>=
mutable tvar_level: int;
@
<<[[Ctype.newvar()]] set other fields>>=
tvar_level = !current_level;  
@





<<constant Ctype.generic_level>>=
let generic_level = (-1)
@
% ???
% it's for type scheme?

<<[[Predef.build_initial_env()]] set other fields in local newvar>>=
tvar_level = -1 (*generic_level*); 
@


<<[[Ctype.occur()]] in Tvar case, adjust levels if needed>>=
if v.tvar_level > tvar.tvar_level 
then v.tvar_level <- tvar.tvar_level
@




\subsection{Non expansive}

\subsection{Instanciation}

\subsection{Generalization}

<<[[Typecode.type_expression()]] after end_def, generalize or not>>=
if is_nonexpansive exp 
then generalize exp.exp_type;
@

<<[[Typecode.type_let()]] after end_def, generalize or not>>=
List.iter (fun exp -> 
  if not (is_nonexpansive exp) 
  then make_nongen exp.exp_type
) exp_list;
List.iter (fun exp -> 
  generalize exp.exp_type
) exp_list;
@





\section{Typing other elements}


% the most complex I guess
<<signature Typecore.type_binding>>=
val type_binding:
        Env.t -> rec_flag ->
          (Parsetree.pattern * Parsetree.expression) list -> 
            (Typedtree.pattern * Typedtree.expression) list * Env.t
@


\subsection{Type expressions}
% this is mostly to build the environment that will then
% be used when typing expressions!

<<signature Typetexp.transl_simple_type>>=
(* Typechecking of type expressions for the core language *)

val transl_simple_type:
        Env.t -> bool -> Parsetree.core_type -> Types.type_expr
@
% bool? "fixed"?



<<constant Typetexp.type_variables>>=
(* Translation of type expressions *)

let type_variables = ref (Tbl.empty : (string, Types.type_expr) Tbl.t)
@


% fixed?
<<function Typetexp.transl_simple_type>>=
let rec transl_simple_type env fixed styp =
  match styp.ptyp_desc with
    Ptyp_var name ->
      begin try
        Tbl.find name !type_variables
      with Not_found ->
        if fixed then
          raise(Error(styp.ptyp_loc, Unbound_type_variable name))
        else begin
          let v = new_global_var() in
          type_variables := Tbl.add name v !type_variables;
          v
        end
      end
  | Ptyp_constr(lid, stl) ->
      let (path, decl) =
        try
          Env.lookup_type lid env
        with Not_found ->
          raise(Error(styp.ptyp_loc, Unbound_type_constructor lid)) in
      if List.length stl <> decl.type_arity 
      then
        raise(Error(styp.ptyp_loc, Type_arity_mismatch(lid, decl.type_arity,
                                                           List.length stl)));
      Tconstr(path, List.map (transl_simple_type env fixed) stl)
  (* boilerplate mapper *)
  | Ptyp_arrow(st1, st2) ->
      Tarrow(transl_simple_type env fixed st1,
             transl_simple_type env fixed st2)
  | Ptyp_tuple stl ->
      Ttuple(List.map (transl_simple_type env fixed) stl)
@




\subsection{Type declarations}


<<signature Typedecl.transl_type_decl>>=
val transl_type_decl:
        Env.t -> (string * Parsetree.type_declaration) list ->
                         (Ident.t * Types.type_declaration) list * Env.t
@




% why reset_def?

<<function Typedecl.transl_type_decl>>=
(* Translate a set of mutually recursive type declarations *)

let transl_type_decl env name_sdecl_list =
  Ctype.reset_def();
  let decls =
    match name_sdecl_list with
      [(name, {ptype_kind = Ptype_abstract}) as name_sdecl] ->
        (* No recursion involved, use original env for translation *)
        let id = Ident.create name in
        [transl_declaration env name_sdecl id]
    | _ ->
        (* Enter the types as abstract *)
        let (id_list, temp_env) = enter_types env name_sdecl_list in
        (* Translate each declaration *)
        List.map2 (transl_declaration temp_env) name_sdecl_list id_list 
  in
  (* Build the final env *)
  let newenv =
    List.fold_right
      (fun (id, decl) env -> Env.add_type id decl env)
      decls env in
  <<[[Typedecl.transl_type_decl()]] check recursive abbrevs>>
  (decls, newenv)
@




% exported because used in typedecl too
<<signature Typetexp.reset_type_variables>>=
val reset_type_variables: unit -> unit
@
<<function Typetexp.reset_type_variables>>=
let reset_type_variables () =
  type_variables := Tbl.empty
@
% a bit ugly to use those globals, could
% be instead passed in a second environment





<<exception Typetexp.Already_bound>>=
exception Already_bound
@

<<signature Typetexp.enter_type_variable>>=
val enter_type_variable: string -> Types.type_expr
@
<<function Typetexp.enter_type_variable>>=
let enter_type_variable name =
  try
    Tbl.find name !type_variables; 
    raise Already_bound
  with Not_found ->
    let v = new_global_var() in
    type_variables := Tbl.add name v !type_variables;
    v
@
%todo: boilerplate again? could factorize code?




% called for one of the decl possiblty of a type x = ... and type y = ...
<<function Typedecl.transl_declaration>>=
let transl_declaration env (name, sdecl) id =
  Ctype.begin_def();
  reset_type_variables();

  let params =
    try
      List.map enter_type_variable sdecl.ptype_params
    with Already_bound ->
      raise(Error(sdecl.ptype_loc, Repeated_parameter)) in

  let decl =
    { type_params = params;
      type_arity = List.length params;
      type_kind =
        (match sdecl.ptype_kind with
        (* boilerplate mapper Pxxx -> Xxx *)
          Ptype_abstract ->
            Type_abstract
        | Ptype_variant cstrs ->
            <<[[Typedecl.transl_declaration()]] sanity check when variant case>>
            Type_variant(List.map
              (fun (name, args) ->
                      (name, List.map (transl_simple_type env true) args))
              cstrs)
        | Ptype_record lbls ->
            <<[[Typedecl.transl_declaration()]] sanity check when record case>>
            Type_record(List.map
              (fun (name, mut, arg) ->
                      (name, mut, transl_simple_type env true arg))
              lbls)
        );
      type_manifest =
        (match sdecl.ptype_manifest with
        | None -> None
        | Some sty -> Some(transl_simple_type env true sty)
        ); 
  } in
  Ctype.end_def();

  List.iter Ctype.generalize params;

  <<[[Typedecl.transl_declaration()]] sanity check decl>>
  (id, decl)
@

<<function Typedecl.enter_types>>=
(* Enter all declared types in the environment as abstract types *)

let rec enter_types env = function
    [] ->
      ([], env)
  | (name, sdecl) :: srem ->
      let decl =
        { type_params = []; (*this field is unused when kind = Type_abstract*)
          type_arity = List.length sdecl.ptype_params;
          type_kind = Type_abstract;
          type_manifest = None } in
      let (id, extenv) = Env.enter_type name decl env in
      let (rem_id, final_env) = enter_types extenv srem in
      (id :: rem_id, final_env)
@

% generalize???


<<[[Typedecl.transl_declaration()]] sanity check when variant case>>=
let all_constrs = ref StringSet.empty in
List.iter
  (fun (name, args) ->
    if StringSet.mem name !all_constrs then
      raise(Error(sdecl.ptype_loc, Duplicate_constructor name));
    all_constrs := StringSet.add name !all_constrs)
  cstrs;
if List.length cstrs > Config.max_tag then
  raise(Error(sdecl.ptype_loc, Too_many_constructors));
@

<<[[Typedecl.transl_declaration()]] sanity check when record case>>=
let all_labels = ref StringSet.empty in
List.iter
  (fun (name, mut, arg) ->
    if StringSet.mem name !all_labels then
      raise(Error(sdecl.ptype_loc, Duplicate_label name));
    all_labels := StringSet.add name !all_labels)
  lbls;
@

<<[[Typedecl.transl_declaration()]] sanity check decl>>=
(* If both a variant/record definition and a type equation are given,
   need to check that the equation refers to a type of the same kind
   with the same constructors and labels *)
(match decl with
  {type_kind = (Type_variant _ | Type_record _); type_manifest = Some ty} ->
    (match ty with
     | Tconstr(path, args) ->
        begin try
          let decl' = Env.find_type path env in
          if args = params & Includecore.type_declarations env id decl decl'
          then ()
          else raise(Error(sdecl.ptype_loc, Definition_mismatch ty))
        with Not_found ->
          raise(Error(sdecl.ptype_loc, Definition_mismatch ty))
        end
    | _ -> raise(Error(sdecl.ptype_loc, Definition_mismatch ty))
    )
| _ -> ()
);
@






\subsection{Modules}

<<signature Typemod.transl_signature>>=
val transl_signature:
        Env.t -> Parsetree.signature -> Types.signature
@

<<signature Typemod.type_structure>>=
val type_structure:
        Env.t -> Parsetree.structure -> 
          Typedtree.structure * Types.signature * Env.t
@




<<signature Typedecl.transl_value_decl>>=
val transl_value_decl:
        Env.t -> Parsetree.value_description -> Types.value_description
@

<<function Typedecl.transl_value_decl>>=
(* Translate a value declaration *)

let transl_value_decl env valdecl =
  Ctype.reset_def();
  let ty = Typetexp.transl_type_scheme env valdecl.pval_type in
  { val_type = ty;
    val_prim = Primitive.parse_declaration (Ctype.arity ty) valdecl.pval_prim }
@

\section{Advanced typing issues}

% those are the reasons the typechecker got so complicated?

\subsection{References, [['_a]]}
% _a

\subsection{Exceptions}

% exn are really like an open variant, a variant that
% can be extended in different files.

% builtin exceptions

<<signatures Predef.type_xxx>>=
val type_exn: type_expr
@
<<constants Predef.type_xxx>>=
and type_exn = Tconstr(path_exn, [])
@

<<signatures Predef.path_xxx>>=
val path_exn: Path.t
@
<<constants Predef.path_xxx>>=
and path_exn = Pident ident_exn
@


<<[[Predef.build_initial_env()]] decls>>=
let decl_exn =
  {type_params = [];
   type_arity = 0;
   type_kind = Type_variant [];
   type_manifest = None}
in
@
% variant with no cases, but really it's more a variant
% with many cases, added in a cross-cutting way in different
% files. 


<<[[Typecore.type_exp()]] match cases>>=
| Pexp_try(sbody, caselist) ->
    let body = type_exp env sbody in
    let cases = type_cases env Predef.type_exn body.exp_type caselist in
    Parmatch.check_unused cases;
    { exp_desc = Texp_try(body, cases);
      exp_loc = sexp.pexp_loc;
      exp_type = body.exp_type }
@
% no check_partial here!








<<signature Predef.path_match_failure>>=
val path_match_failure: Path.t
@
% why a path for this one?
<<constant Predef.path_match_failure>>=
let path_match_failure = Pident ident_match_failure
@

<<constants Predef.ident_exn_xxx>>=
let ident_match_failure    = Ident.create "Match_failure"
and ident_out_of_memory    = Ident.create "Out_of_memory"
and ident_invalid_argument = Ident.create "Invalid_argument"
and ident_failure          = Ident.create "Failure"
and ident_not_found        = Ident.create "Not_found"
and ident_sys_error        = Ident.create "Sys_error"
and ident_end_of_file      = Ident.create "End_of_file"
and ident_division_by_zero = Ident.create "Division_by_zero"
and ident_stack_overflow   = Ident.create "Stack_overflow"
@
% why not in pervasives? because used in the compiler itself?


<<[[Predef.build_initial_env()]] adding exceptions>>=
add_exception ident_match_failure [Ttuple[type_string; type_int; type_int]] (
add_exception ident_out_of_memory [] (
add_exception ident_stack_overflow [] (
add_exception ident_invalid_argument [type_string] (
add_exception ident_failure [type_string] (
add_exception ident_not_found [] (
add_exception ident_sys_error [type_string] (
add_exception ident_end_of_file [] (
add_exception ident_division_by_zero [] (
@




<<signature Env.add_exception>>=
val add_exception: Ident.t -> exception_declaration -> t -> t
@
<<function Env.add_exception>>=
and add_exception id decl env =
  store_exception id (Pident id) decl env
@

<<function Env.store_exceptions>>=
and store_exception id path decl env =
  { constrs = Ident.add id (Datarepr.exception_descr path decl) env.constrs;
    (* boilerplate, with record *)
    values = env.values;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
    components = env.components }
@




<<signature Predef.builtin_values>>=
(* To initialize linker tables *)

val builtin_values: (string * Ident.t) list
@

<<constant Predef.builtin_values>>=
let builtin_values =
  List.map (fun id -> Ident.make_global id; (Ident.name id, id))
      [ident_match_failure; ident_out_of_memory; ident_stack_overflow;
       ident_invalid_argument;
       ident_failure; ident_not_found; ident_sys_error; ident_end_of_file;
       ident_division_by_zero]
@

<<signature Ident.make_global>>=
val make_global: t -> unit
@
<<function Ident.make_global>>=
let make_global i =
  i.global <- true
@

<<[[Ident.t]] other fields>>=
mutable global: bool 
@
% what is it for? for Ident.name! to create something really unique.
% make sure they don't interface with names defined by user?
% but need that? the stamp in ident is not enough?
% create_persistent() not enough?




<<signature Typedecl.transl_exception>>=
val transl_exception:
        Env.t -> Parsetree.exception_declaration -> Types.exception_declaration
@

<<function Typedecl.transl_exception>>=
(* Translate an exception declaration *)

let transl_exception env excdecl =
  Ctype.reset_def();
  reset_type_variables();

  List.map (transl_simple_type env true) excdecl
@



<<signature Env.enter_exception>>=
val enter_exception: string -> exception_declaration -> t -> Ident.t * t
@

<<functions Env.enter_xxx>>=
and enter_exception = enter store_exception
@

<<signature Subst.exception_declaration>>=
val exception_declaration: t -> exception_declaration -> exception_declaration
@
<<function Subst.exception_declaration>>=
let exception_declaration s tyl =
  List.map (type_expr s) tyl
@



\subsection{Abstract types}

<<[[Parsetree.type_kind]] cases>>=
| Ptype_abstract
@
% int/float/array are actually neither a variant or a record,
% they are kinda builtin, so could have a Ptype_builtin of string,
% but instead they use Ptype_abstract for that too!
% less: could move that later because even Type_abstract
%  need to be presented early for builtin types, but the user
%  can not define builtin types, so really Ptype_abstract is
%  just for user defined abstract data type!


% type t (in .mli, and no = after)
% but also for builtins, because int, float, ...
% are not really variants or records, they are more
% type int;; type float;;

<<rule type_kind cases>>=
|  /*empty*/
    { (Ptype_abstract, None) }
@


\subsection{Type abbreviations}
% Manifest types
% Type aliases (but actually it's used for something else in ocaml)

% it's also for type x = y = z
% not sure it's very useful

<<rule type_kind cases>>=
| EQUAL core_type %prec prec_type_def
    { (Ptype_abstract, Some $2) }
@
%$
% use abstract, why? 

<<[[Parsetree.type_declaration]] other fields>>=
ptype_manifest: core_type option;
@

<<[[Types.type_declaration]] other fields>>=
type_manifest: type_expr option 
@


% in ctype.ml before unify

%   1. When unifying two non-abbreviated types, one type is made a link
%      to the other. When unifying an abbreviated type with a
%      non-abbreviated type, the non-abbreviated type is made a link to
%      the other one. When unifying to abbreviated types, these two
%      types are kept distincts, but they are made to (temporally)
%      expand to the same type.
%   2. Abbreviations with at least one parameter are systematically
%      expanded. The overhead does not seem to high, and that way
%      abbreviations where some parameters does not appear in the
%      expansion, such as ['a t = int], are correctly handled. In
%      particular, for this example, unifying ['a t] with ['b t] keeps
%      ['a] and ['b] distincts. (Is it really important ?)
%   3. Unifying an abbreviation ['a t = 'a] with ['a] should not yield
%      ['a t as 'a]. Indeed, the type variable would otherwise be lost.
%      This problem occurs for abbreviations expanding to a type
%      variable, but also to many other constrained abbreviations (for
%      instance, [(< x : 'a > -> unit) t = <x : 'a>]). The solution is
%      that, if an abbreviation is unified with some subpart of its
%      parameters, then the parameter actually does not get
%      abbreviated.  It would be possible to check whether some
%      information is indeed lost, but it probably does not worth it.


<<exception Ctype.Cannot_expand>>=
(* Unification *)

exception Cannot_expand
@

<<[[Ctype.unify()]] if p1 or p2 are abbreviation type paths>>=
try
  unify env (expand_abbrev env p1 tl1) t2
with Cannot_expand ->
  try
    unify env t1 (expand_abbrev env p2 tl2)
  with Cannot_expand ->
@

% p1 or p2 are possible paths to abbriviation types
<<[[Ctype.unify()]] match t1 t2 other cases>>=
| (Tconstr(p1, tl1), _) ->
    begin try
      unify env (expand_abbrev env p1 tl1) t2
    with Cannot_expand ->
      raise Unify
    end
| (_, Tconstr(p2, tl2)) ->
    begin try
      unify env t1 (expand_abbrev env p2 tl2)
    with Cannot_expand ->
      raise Unify
    end
@


<<[[Ctype.filter_arrow()]] other cases>>=
| Tconstr(p, tl) ->
    begin try
      filter_arrow env (expand_abbrev env p tl)
    with Cannot_expand ->
      raise Unify
    end
@

<<function Ctype.expand_abbrev>>=
let expand_abbrev env path args =
  try
    let decl = Env.find_type path env in
    match decl.type_manifest with
      Some body -> substitute decl.type_params args body
    | None -> raise Cannot_expand
  with Not_found ->
    raise Cannot_expand
@



<<[[Typedecl.transl_type_decl()]] check recursive abbrevs>>=
(* Check for recursive abbrevs *)
List.iter2 (check_recursive_abbrev newenv) name_sdecl_list decls;
(* Done *)
@

<<function Typedecl.check_recursive_abbrev>>=
(* Check for recursive abbrevs *)

let check_recursive_abbrev env (name, sdecl) (id, decl) =
  match decl.type_manifest with
    Some ty ->
      if Ctype.free_type_ident env [id] ty
      then raise(Error(sdecl.ptype_loc, Recursive_abbrev name))
  | _ -> ()
@

<<signature Ctype.free_type_ident>>=
val free_type_ident: Env.t -> Ident.t list -> type_expr -> bool
        (* Test whether one of the given type identifiers occur free
           in the given type expression. *)
@


<<function Ctype.free_type_ident>>=
let rec free_type_ident env ids ty =
  match repr ty with
    Tvar _ -> false
  | Tconstr((Pident id as p), tl) ->
      List.exists (Ident.same id) ids or begin
        try
          free_type_ident env (id::ids) (expand_abbrev env p tl)
        with Cannot_expand ->
          List.exists (free_type_ident env ids) tl
      end
  | Tconstr(p, tl) ->
      begin try
        free_type_ident env ids (expand_abbrev env p tl)
      with Cannot_expand ->
        List.exists (free_type_ident env ids) tl
      end
  (* boilerplate folder *)
  | Tarrow(t1, t2) ->
      free_type_ident env ids t1 || free_type_ident env ids t2
  | Ttuple tl ->
      List.exists (free_type_ident env ids) tl
@




%there is also this, but is it useful?
<<rule type_kind cases>>=
| EQUAL core_type EQUAL opt_bar constructor_declarations %prec prec_type_def
    { (Ptype_variant(List.rev $5), Some $2) }
| EQUAL core_type EQUAL LBRACE label_declarations opt_semi RBRACE
  %prec prec_type_def
    { (Ptype_record(List.rev $5), Some $2) }
@



\subsection{Printf}

<<constants Predef.ident_xxx>>=
and ident_format = Ident.create "format"
@

<<signatures Predef.path_xxx>>=
val path_format: Path.t
@

<<constants Predef.path_xxx>>=
and path_format = Pident ident_format
@



<<[[Predef.build_initial_env()]] decls>>=
let decl_format =
  {type_params = [newvar(); newvar(); newvar()];
   type_arity = 3;
   type_kind = Type_abstract;
   type_manifest = None} 
in
@

% special format typechecking


<<function Typecore.type_format>>=
(* Typing of printf formats *)

let type_format loc fmt =
  let len = String.length fmt in
  let ty_input = newvar()
  and ty_result = newvar() in
  let rec skip_args j =
    if j >= len then j else
      match fmt.[j] with
        '0' .. '9' | ' ' | '.' | '-' -> skip_args (j+1)
      | _ -> j in
  let rec scan_format i =
    if i >= len then ty_result else
    match fmt.[i] with
      '%' ->
        let j = skip_args(i+1) in
        begin match String.unsafe_get fmt j with
        (* We're using unsafe_get here so that if j = String.length fmt,
           we'll fall in the catch-all case of the match *)
          '%' ->
            scan_format (j+1)
        | 's' ->
            Tarrow(Predef.type_string, scan_format (j+1))
        | 'c' ->
            Tarrow(Predef.type_char, scan_format (j+1))
        | 'd' | 'o' | 'x' | 'X' | 'u' ->
            Tarrow(Predef.type_int, scan_format (j+1))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            Tarrow(Predef.type_float, scan_format (j+1))
        | 'b' ->
            Tarrow(Predef.type_bool, scan_format (j+1))
        | 'a' ->
            let ty_arg = newvar() in
            Tarrow (Tarrow(ty_input, Tarrow (ty_arg, ty_result)),
                    Tarrow (ty_arg, scan_format (j+1)))
        | 't' ->
            Tarrow(Tarrow(ty_input, ty_result), scan_format (j+1))
        | c ->
            raise(Error(loc, Bad_format(String.sub fmt i (j-i))))
        end
    | _ -> scan_format (i+1) in
  Tconstr(Predef.path_format, [scan_format 0; ty_input; ty_result])
@


<<[[Typecode.type_expect()]] match cases>>=
|  Pexp_constant(Const_string s as cst) ->
    let exp =
      { exp_desc = Texp_constant cst;
        exp_loc = sexp.pexp_loc;
        exp_type =
          (* Terrible hack for format strings *)
          match Ctype.repr ty_expected with
            Tconstr(path, _) when Path.same path Predef.path_format ->
              type_format sexp.pexp_loc s
          | _ -> Predef.type_string } in
    unify_exp env exp ty_expected;
    exp
@

\subsection{Objects}

% things got so much more complicated with objects ...
% huge change in the typechecker, ctype.ml from 400LOC to 1200LOC
% and actually should also count the new btype.ml

% there was
%  'constraints' in type declarations

\subsection{Module type and functors}

% things got more complicated also with functors ...


%\subsection{Type any}
%% '_' in types, but not that useful.
%%It was actually never matched ... probably because backported raw
% typing/ and didn't forward ported this feature
%
%<<[[Parsetree.core_type_desc]] cases>>=
%| Ptyp_any
%@
%
%<<rule simple_core_type cases>>=
%| UNDERSCORE
%    { mktyp(Ptyp_any) }
%@

%\subsection{Type aliases}
%% type t = x as 'a ????
%
%<<[[Parsetree.core_type_desc]] cases>>=
%| Ptyp_alias of core_type * string
%@
%% not what you think ...
%
%<<rule core_type cases>>=
%| core_type AS type_parameter
%    { mktyp(Ptyp_alias($1, $3)) }
%@


\chapter{Checking}

% have seen lots of checking done already, 
%  - naming (e.g. label not defined, Unbound_xxx),
%  - typing (e.g. was expecting an int, also arity checks)
% but there are other sanity checks done on the program
% (see sanity check chunknames before):
%  - partial app in sequence
%  - ???

\section{Interface/Implementation consistency}

%includemod.ml

%includecore.ml

\section{Partial pattern matches}
% parmatch.ml

<<signature Parmatch.check_partial>>=
val check_partial: 
  Location.t -> (Typedtree.pattern * Typedtree.expression) list -> unit
@

\section{Unused pattern matches}

<<signature Parmatch.check_unused>>=
val check_unused: 
  (Typedtree.pattern * Typedtree.expression) list -> unit
@





\chapter{Compiling}
% Generating

<<constant Clflags.compile_only>>=
let compile_only = ref false            (* -c *)
@



\section{Descriptions and representations}
% this is very compiler oriented no? not really typing.

<<[[Types.constructor_description]] other fields>>=
cstr_tag: constructor_tag;          (* Tag for heap blocks *)
cstr_consts: int;                   (* Number of constant constructors *)
cstr_nonconsts: int;               (* Number of non-const constructors *)
@

<<type Types.constructor_tag>>=
and constructor_tag =
    Cstr_constant of int                (* Constant constructor (an int) *)
  | Cstr_block of int                   (* Regular constructor (a block) *)
  | Cstr_exception of Path.t            (* Exception constructor *)
@



<<[[Types.label_description]] other fields>>=
lbl_pos: int;                       (* Position in block *)
lbl_all: label_description array;   (* All the labels in this type *)
lbl_repres: record_representation;  (* Representation for this record *)
@
% this is a form of compilation already no?

<<type Types.record_representation>>=
and record_representation =
    Record_regular                      (* All fields are boxed / tagged *)
  | Record_float                        (* All fields are floats *)
@






<<signature Datarepr.constructor_descrs>>=
val constructor_descrs:
  type_expr -> (string * type_expr list) list ->
    (string * constructor_description) list
@
<<signature Datarepr.exception_descr>>=
val exception_descr:
  Path.t -> type_expr list -> constructor_description
@

<<signature Datarepr.label_descrs>>=
val label_descrs:
  type_expr -> (string * mutable_flag * type_expr) list ->
    (string * label_description) list
@





<<function Datarepr.constructor_descrs>>=
let constructor_descrs ty_res cstrs =
  let num_consts = ref 0 and num_nonconsts = ref 0 in
  List.iter
    (function (name, []) -> incr num_consts
            | (name, _)  -> incr num_nonconsts)
    cstrs;
  let rec describe_constructors idx_const idx_nonconst = function
      [] -> []
    | (name, ty_args) :: rem ->
        let (tag, descr_rem) =
          match ty_args with
            [] -> (Cstr_constant idx_const,
                   describe_constructors (idx_const+1) idx_nonconst rem)
          | _  -> (Cstr_block idx_nonconst,
                   describe_constructors idx_const (idx_nonconst+1) rem) in
        let cstr =
          { cstr_res = ty_res;
            cstr_args = ty_args;
            cstr_arity = List.length ty_args;
            cstr_tag = tag;
            cstr_consts = !num_consts;
            cstr_nonconsts = !num_nonconsts } in
        (name, cstr) :: descr_rem in
  describe_constructors 0 0 cstrs
@

<<function Datarepr.exception_descr>>=
let exception_descr path_exc decl =
  { cstr_res = Predef.type_exn;
    cstr_args = decl;
    cstr_arity = List.length decl;
    cstr_tag = Cstr_exception path_exc;
    cstr_consts = -1;
    cstr_nonconsts = -1 }
@

<<constant Datarepr.dummy_label>>=
let dummy_label =
  { lbl_res = Ttuple []; lbl_arg = Ttuple []; lbl_mut = Immutable;
    lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular }
@

<<function Datarepr.is_float>>=
(* Cannot call ctype.repres here *)

let rec is_float = function
    Tvar{tvar_link = Some ty} -> is_float ty
  | Tconstr(p, _) -> Path.same p Predef.path_float
  | _ -> false
@

<<function Datarepr.label_descrs>>=
let label_descrs ty_res lbls =
  let all_labels = Array.create (List.length lbls) dummy_label in
  let repres =
    if List.for_all (fun (name, flag, ty) -> is_float ty) lbls
    then Record_float
    else Record_regular in
  let rec describe_labels num = function
      [] -> []
    | (name, mut_flag, ty_arg) :: rest ->
        let lbl =
          { lbl_res = ty_res;
            lbl_arg = ty_arg;
            lbl_mut = mut_flag;
            lbl_pos = num;
            lbl_all = all_labels;
            lbl_repres = repres } in
        all_labels.(num) <- lbl;
        (name, lbl) :: describe_labels (num+1) rest in
  describe_labels 0 lbls
@


\section{Typed AST to untyped [[Lambda]] calcul}


%(* Translation from typed abstract syntax to lambda terms,
%   for the core language *)

%<<signature Translcore.transl_exp>>=
%val transl_exp: expression -> lambda
%@


\subsection{[[Lambda]]}

<<type Lambda.lambda>>=
type lambda =
    Lvar of Ident.t
  | Lconst of structured_constant
  | Lapply of lambda * lambda list

  | Lfunction of function_kind * Ident.t list * lambda
  | Llet of let_kind * Ident.t * lambda * lambda
  | Lletrec of (Ident.t * lambda) list * lambda

  | Lprim of primitive * lambda list

  | Lswitch of lambda * lambda_switch
  | Lstaticfail
  | Lcatch of lambda * lambda
  | Ltrywith of lambda * Ident.t * lambda
  | Lifthenelse of lambda * lambda * lambda
  | Lsequence of lambda * lambda
  | Lwhile of lambda * lambda
  | Lfor of Ident.t * lambda * lambda * direction_flag * lambda
  | Lassign of Ident.t * lambda

  | Levent of lambda * lambda_event
@

<<type Lambda.lambda_switch>>=
and lambda_switch =
  { sw_numconsts: int;                  (* Number of integer cases *)
    sw_consts: (int * lambda) list;     (* Integer cases *)
    sw_numblocks: int;                  (* Number of tag block cases *)
    sw_blocks: (int * lambda) list;     (* Tag block cases *)
    sw_checked: bool }                  (* True if bound checks needed *)
@


<<type Lambda.function_kind>>=
type function_kind = Curried | Tupled
@

<<type Lambda.let_kind>>=
type let_kind = Strict | Alias | StrictOpt
@

<<type Lambda.shared_code>>=
type shared_code = (int * int) list     (* stack size -> code label *)
@
% ???

\subsubsection{Primitives}

<<type Lambda.primitive>>=
type primitive =
    Pidentity

  (* Globals *)
  | Pgetglobal of Ident.t
  | Psetglobal of Ident.t

  (* Operations on heap blocks *)
  | Pmakeblock of int * mutable_flag
  | Pfield of int
  | Psetfield of int * bool
  | Pfloatfield of int
  | Psetfloatfield of int

  (* External call *)
  | Pccall of Primitive.description

  (* Exceptions *)
  | Praise

  (* Boolean operations *)
  | Psequand | Psequor | Pnot

  (* Integer operations *)
  | Pnegint | Paddint | Psubint | Pmulint | Pdivint | Pmodint
  | Pandint | Porint | Pxorint
  | Plslint | Plsrint | Pasrint
  | Pintcomp of comparison
  | Poffsetint of int
  | Poffsetref of int

  (* Float operations *)
  | Pintoffloat | Pfloatofint
  | Pnegfloat | Pabsfloat
  | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
  | Pfloatcomp of comparison

  (* String operations *)
  | Pstringlength | Pstringrefu | Pstringsetu | Pstringrefs | Pstringsets

  (* Array operations *)
  | Pmakearray of array_kind
  | Parraylength of array_kind
  | Parrayrefu of array_kind
  | Parraysetu of array_kind
  | Parrayrefs of array_kind
  | Parraysets of array_kind

  (* Bitvect operations *)
  | Pbittest
@

<<type Lambda.comparison>>=
and comparison =
    Ceq | Cneq | Clt | Cgt | Cle | Cge
@


\subsubsection{Structured constants}

<<type Lambda.structured_constant>>=
type structured_constant =
    Const_base of constant
  | Const_pointer of int
  | Const_block of int * structured_constant list
  | Const_float_array of string list
@



\subsection{Primitives, [[Translcore.transl_primitive()]]}

<<signature Translcore.transl_primitive>>=
val transl_primitive: Primitive.description -> lambda
@

<<signature Translcore.transl_exception>>=
val transl_exception: Ident.t -> exception_declaration -> lambda
@





<<signature Translmod.primitive_declarations>>=
val primitive_declarations: string list ref
@


<<constant Translcore.comparisons_table>>=
(* Translation of primitives *)

let comparisons_table = create_hashtable 11 [
  "%equal",
      (Pccall{prim_name = "equal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Ceq,
       Pfloatcomp Ceq,
       Pccall{prim_name = "string_equal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%notequal",
      (Pccall{prim_name = "notequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cneq,
       Pfloatcomp Cneq,
       Pccall{prim_name = "string_notequal"; prim_arity = 2;
              prim_alloc = false; prim_native_name = ""; 
              prim_native_float = false});
  "%lessthan",
      (Pccall{prim_name = "lessthan"; prim_arity = 2; prim_alloc = false; 
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Clt,
       Pfloatcomp Clt,
       Pccall{prim_name = "lessthan"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%greaterthan",
      (Pccall{prim_name = "greaterthan"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cgt,
       Pfloatcomp Cgt,
       Pccall{prim_name = "greaterthan"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%lessequal",
      (Pccall{prim_name = "lessequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cle,
       Pfloatcomp Cle,
       Pccall{prim_name = "lessequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false});
  "%greaterequal",
      (Pccall{prim_name = "greaterequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false},
       Pintcomp Cge,
       Pfloatcomp Cge,
       Pccall{prim_name = "greaterequal"; prim_arity = 2; prim_alloc = false;
              prim_native_name = ""; prim_native_float = false})
]
@

<<constant Translcore.primitives_table>>=
let primitives_table = create_hashtable 31 [
  "%identity", Pidentity;
  "%field0", Pfield 0;
  "%field1", Pfield 1;
  "%setfield0", Psetfield(0, true);
  "%makeblock", Pmakeblock(0, Immutable);
  "%makemutable", Pmakeblock(0, Mutable);
  "%raise", Praise;
  "%sequand", Psequand;
  "%sequor", Psequor;
  "%boolnot", Pnot;
  "%negint", Pnegint;
  "%succint", Poffsetint 1;
  "%predint", Poffsetint(-1);
  "%addint", Paddint;
  "%subint", Psubint;
  "%mulint", Pmulint;
  "%divint", Pdivint;
  "%modint", Pmodint;
  "%andint", Pandint;
  "%orint", Porint;
  "%xorint", Pxorint;
  "%lslint", Plslint;
  "%lsrint", Plsrint;
  "%asrint", Pasrint;
  "%eq", Pintcomp Ceq;
  "%noteq", Pintcomp Cneq;
  "%ltint", Pintcomp Clt;
  "%leint", Pintcomp Cle;
  "%gtint", Pintcomp Cgt;
  "%geint", Pintcomp Cge;
  "%incr", Poffsetref(1);
  "%decr", Poffsetref(-1);
  "%intoffloat", Pintoffloat;
  "%floatofint", Pfloatofint;
  "%negfloat", Pnegfloat;
  "%absfloat", Pabsfloat;
  "%addfloat", Paddfloat;
  "%subfloat", Psubfloat;
  "%mulfloat", Pmulfloat;
  "%divfloat", Pdivfloat;
  "%eqfloat", Pfloatcomp Ceq;
  "%noteqfloat", Pfloatcomp Cneq;
  "%ltfloat", Pfloatcomp Clt;
  "%lefloat", Pfloatcomp Cle;
  "%gtfloat", Pfloatcomp Cgt;
  "%gefloat", Pfloatcomp Cge;
  "%string_length", Pstringlength;
  "%string_safe_get", Pstringrefs;
  "%string_safe_set", Pstringsets;
  "%string_unsafe_get", Pstringrefu;
  "%string_unsafe_set", Pstringsetu;
  "%array_length", Parraylength Pgenarray;
  "%array_safe_get", Parrayrefs Pgenarray;
  "%array_safe_set", Parraysets Pgenarray;
  "%array_unsafe_get", Parrayrefu Pgenarray;
  "%array_unsafe_set", Parraysetu Pgenarray;
  "%obj_size", Parraylength Paddrarray;
  "%obj_field", Parrayrefu Paddrarray;
  "%obj_set_field", Parraysetu Paddrarray
]
@

\subsection{Expressions, [[Translcore.transl_exp()]]}


<<signature Translcore.transl_exp>>=
val transl_exp: Typedtree.expression -> lambda
@



<<signature Translcore.transl_let>>=
val transl_let:
      rec_flag -> (Typedtree.pattern * Typedtree.expression) list -> 
        lambda -> lambda
@

\subsection{Modules, [[transl_implementation()]]}
%Translmod

<<signature Translmod.transl_implementation>>=
val transl_implementation: 
  string -> Typedtree.structure -> module_coercion -> lambda
@

<<signature Translmod.transl_store_implementation>>=
val transl_store_implementation:
      string -> Typedtree.structure -> module_coercion -> int * lambda
@
%? variant?

\section{Lambda simplifications}

<<signature Simplif.simplify_lambda>>=
val simplify_lambda: lambda -> lambda
@

%(* Elimination of useless Llet(Alias) bindings.
%   Also transform let-bound references into variables. *)

\section{Pattern matching compilation}

<<signature Matching.for_function>>=
val for_function:
        Location.t -> int ref option -> lambda -> (pattern * lambda) list ->
        lambda
@

<<signature Matching.for_trywith>>=
val for_trywith:
        lambda -> (pattern * lambda) list -> lambda
@

<<signature Matching.for_let>>=
val for_let:
        Location.t -> lambda -> pattern -> lambda -> lambda
@

<<signature Matching.for_multiple_match>>=
val for_multiple_match:
        Location.t -> lambda list -> (pattern * lambda) list -> lambda
@

<<signature Matching.for_tupled_function>>=
val for_tupled_function:
        Location.t -> Ident.t list -> (pattern list * lambda) list -> lambda
@


%(*  See Peyton-Jones, "The Implementation of functional programming
%    languages", chapter 5. *)


\section{[[Lambda]] calcul to bytecode}


\subsection{[[Instruction]]}

<<type Instruct.label>>=
(* Abstract machine instructions *)

type label = int                        (* Symbolic code labels *)
@

<<type Instruct.instruction>>=
type instruction =
    Klabel of label
  | Kacc of int
  | Kenvacc of int
  | Kpush
  | Kpop of int
  | Kassign of int
  | Kpush_retaddr of label
  | Kapply of int                       (* number of arguments *)
  | Kappterm of int * int               (* number of arguments, slot size *)
  | Kreturn of int                      (* slot size *)
  | Krestart
  | Kgrab of int                        (* number of arguments *)
  | Kclosure of label * int
  | Kclosurerec of label * int
  | Kgetglobal of Ident.t
  | Ksetglobal of Ident.t
  | Kconst of structured_constant
  | Kmakeblock of int * int             (* size, tag *)
  | Kgetfield of int
  | Ksetfield of int
  | Kdummy of int                       (* block size *)
  | Kupdate of int                      (* block size *)
  | Kvectlength
  | Kgetvectitem
  | Ksetvectitem
  | Kgetstringchar
  | Ksetstringchar
  | Kbranch of label
  | Kbranchif of label
  | Kbranchifnot of label
  | Kstrictbranchif of label
  | Kstrictbranchifnot of label
  | Kswitch of label array * label array
  | Kboolnot
  | Kpushtrap of label
  | Kpoptrap
  | Kraise
  | Kcheck_signals
  | Kccall of string * int
  | Knegint | Kaddint | Ksubint | Kmulint | Kdivint | Kmodint
  | Kandint | Korint | Kxorint | Klslint | Klsrint | Kasrint
  | Kintcomp of comparison
  | Koffsetint of int
  | Koffsetref of int
  | Kevent of debug_event
  | Kstop
@

<<signature Instruct.immed_min>>=
val immed_min: int
@

<<signature Instruct.immed_max>>=
val immed_max: int
@

\subsection{[[Bytegen.compile_implementation()]]}

<<signature Bytegen.compile_implementation>>=
val compile_implementation: string -> lambda -> instruction list
@

\subsection{Binary bytecode format, [[.cmo]]}

%(* Format of a .cmo file:
%     magic number (Config.cmo_magic_number)
%     absolute offset of compilation unit descriptor
%     block of relocatable bytecode
%     compilation unit descriptor *)

<<type Emitcode.reloc_info>>=
(* Relocation information *)

type reloc_info =
    Reloc_literal of structured_constant    (* structured constant *)
  | Reloc_getglobal of Ident.t              (* reference to a global *)
  | Reloc_setglobal of Ident.t              (* definition of a global *)
  | Reloc_primitive of string               (* C primitive number *)
@

<<type Emitcode.compilation_unit>>=
(* Descriptor for compilation units *)

type compilation_unit =
  { cu_name: string;                    (* Name of compilation unit *)
    mutable cu_pos: int;                (* Absolute position in file *)
    cu_codesize: int;                   (* Size of code block *)
    cu_reloc: (reloc_info * int) list;  (* Relocation information *)
    cu_imports: (string * Digest.t) list; (* Names and CRC of intfs imported *)
    cu_primitives: string list;         (* Primitives declared inside *)
    mutable cu_force_link: bool;        (* Must be linked even if unref'ed *)
    mutable cu_debug: int;              (* Position of debugging info, or 0 *)
    cu_debugsize: int }                 (* Length of debugging info *)
@


\subsection{[[Emitcode.to_file()]]}

<<signature Emitcode.to_file>>=
(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     compilation unit descriptor *)

val to_file: out_channel -> string -> instruction list -> unit
        (* Arguments:
             channel on output file
             name of compilation unit implemented
             list of instructions to emit *)
@


<<function Emitcode.to_file>>=
(* Emission to a file *)

let to_file outchan unit_name code =
  init();
  output_string outchan cmo_magic_number;
  let pos_depl = pos_out outchan in
  output_binary_int outchan 0;
  let pos_code = pos_out outchan in
  emit code;
  output outchan !out_buffer 0 !out_position;
  let (pos_debug, size_debug) =
    if !Clflags.debug then begin
      let p = pos_out outchan in
      output_value outchan !events;
      (p, pos_out outchan - p)
    end else
      (0, 0) in
  let compunit =
    { cu_name = unit_name;
      cu_pos = pos_code;
      cu_codesize = !out_position;
      cu_reloc = List.rev !reloc_info;
      cu_imports = Env.imported_units();
      cu_primitives = !Translmod.primitive_declarations;
      cu_force_link = false;
      cu_debug = pos_debug;
      cu_debugsize = size_debug } in
  init();                               (* Free out_buffer and reloc_info *)
(*  Btype.cleanup_abbrev ();*)              (* Remove any cached abbreviation
                                           expansion before saving *)
  let pos_compunit = pos_out outchan in
  output_value outchan compunit;
  seek_out outchan pos_depl;
  output_binary_int outchan pos_compunit
@



<<signature Env.imported_units>>=
(* Return the set of compilation units imported, with their CRC *)

val imported_units: unit -> (string * Digest.t) list
@
% it's for the linker, this will be saved in the .cmo, so one
% can know all the .cmi that were required to typecheck and produce
% this .cmo
<<constant Env.imported_units>>=
let imported_units = ref ([] : (string * Digest.t) list)
@
<<function Env.imported_units>>=
(* Return the list of imported interfaces with their CRCs *)
let imported_units() = !imported_units
@

<<[[Env.find_pers_struct()]] hook when read Name.cmi and its crc>>=
imported_units := (name, crc) :: !imported_units;
@

\chapter{Linking}

<<[[Main.process_file()]] cases>>=
| _ when Filename.check_suffix name ".cmo" 
      or Filename.check_suffix name ".cma" ->
    objfiles := name :: !objfiles
@

<<constant Clflags.include_dirs>>=
let include_dirs = ref ([] : string list)(* -I *)
@
<<[[Main.main()]] command line options>>=
"-I", Arg.String(fun dir -> include_dirs := dir :: !include_dirs),
      "<dir>  Add <dir> to the list of include directories";
@









<<type Bytelink.link_action>>=
type link_action =
    Link_object of string * compilation_unit
      (* Name of .cmo file and descriptor of the unit *)
  | Link_archive of string * compilation_unit list
      (* Name of .cma file and descriptors of the units to be linked. *)
@

\section{Basic linking}

<<signature Bytelink.link>>=
(* Link .cmo files and produce a bytecode executable. *)

val link: string list -> unit
@




\section{Safe linking}

<<signature Bytelink.check_consistency>>=
val check_consistency: string -> Emitcode.compilation_unit -> unit
@

<<constant Bytelink.crc_interfaces>>=
(* Consistency check between interfaces *)

let crc_interfaces =
  (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)
@

<<function Bytelink.check_consistency>>=
let check_consistency file_name cu =
  List.iter
    (fun (name, crc) ->
      if name = cu.cu_name then begin
        Hashtbl.add crc_interfaces name (file_name, crc)
      end else begin
        try
          let (auth_name, auth_crc) = Hashtbl.find crc_interfaces name in
          if crc <> auth_crc then
            raise(Error(Inconsistent_import(name, file_name, auth_name)))
        with Not_found ->
          (* Can only happen for unit for which only a .cmi file was used,
             but no .cmo is provided *)
          Hashtbl.add crc_interfaces name (file_name, crc)
      end)
    cu.cu_imports
@

\section{Archives}

<<constant Clflags.make_archive>>=
let make_archive = ref false            (* -a *)
@
<<[[Main.main()]] command line options>>=
"-a", Arg.Set make_archive, " Build a library";
@

<<[[Main.main()]] if make archive case>>=
| _ when !make_archive ->
    Compile.init_path();
    Bytelibrarian.create_archive (List.rev !objfiles) !archive_name
@


<<constant Clflags.archive_name>>=
let archive_name = ref "library.cma"    (* -o *)
@

<<signature Bytelibrarian.create_archive>>=
(* Format of a library file:
      magic number (Config.cma_magic_number)
      absolute offset of content table
      blocks of relocatable bytecode
      content table = list of compilation units
*)
val create_archive: string list -> string -> unit
@



\subsection{Archive format, [[.cma]]}

%(* Format of a library file:
%      magic number (Config.cma_magic_number)
%      absolute offset of content table
%      blocks of relocatable bytecode
%      content table = list of compilation units
%*)

\section{Linking with C}

<<constant Clflags.ccobjs>>=
let ccobjs = ref ([] : string list)     (* .o, .a and -lxxx files *)
@

<<[[Main.process_file()]] cases>>=
| _ when Filename.check_suffix name ext_obj
      or Filename.check_suffix name ext_lib ->
    ccobjs := name :: !ccobjs
| _ when Filename.check_suffix name ".c" ->
    Compile.c_file name;
    ccobjs := (Filename.chop_suffix (Filename.basename name) ".c" ^ ext_obj)
     :: !ccobjs
@

<<signature Compile.c_file>>=
val c_file: string -> unit
@

<<function Compile.c_file>>=
let c_file name =
  if Ccomp.compile_file_bytecode name <> 0 then exit 2
@

<<constant Clflags.ccopts>>=
let ccopts = ref ([] : string list)     (* -ccopt *)
@

<<[[Main.main()]] command line options>>=
"-cclib", Arg.String(fun s -> ccobjs := s :: !ccobjs),
      "<opt>  Pass option <opt> to the C linker";
"-ccopt", Arg.String(fun s -> ccopts := s :: !ccopts),
      "<opt>  Pass option <opt> to the C compiler and linker";
@

\subsection{Foreign function interface}
% ffi

\subsection{C compilation}

<<signature Ccomp.command>>=
val command: string -> int
@

<<signature Ccomp.compile_file_bytecode>>=
val compile_file_bytecode: string -> int
@

<<signature Ccomp.compile_file_native>>=
val compile_file_native: string -> int
@

<<signature Ccomp.create_archive>>=
val create_archive: string -> string list -> int
@



<<function Ccomp.compile_file_bytecode>>=
let compile_file_bytecode name =
  command
   (Printf.sprintf
     "%s -c %s %s -I%s %s"
     Config.bytecomp_c_compiler
     (String.concat " " (List.rev !Clflags.ccopts))
     (String.concat " "
       (List.map (fun dir -> "-I" ^ dir) 
                 (List.rev !Clflags.include_dirs)))
     Config.standard_library
     name)
@

<<signature Config.bytecomp_c_compiler>>=
val bytecomp_c_compiler: string
        (* The C compiler to use for the custom runtime mode of the
           bytecode compiler *)
@


<<function Ccomp.compile_file_native>>=
let compile_file_native name =
  command
   (Printf.sprintf
     "%s -c %s %s -I%s %s"
     Config.native_c_compiler
     (String.concat " " (List.rev !Clflags.ccopts))
     (String.concat " "
       (List.map (fun dir -> "-I" ^ dir) 
                 (List.rev !Clflags.include_dirs)))
     Config.standard_library
     name)
@

<<signature Config.native_c_compiler>>=
val native_c_compiler: string
        (* The C compiler to use for the native code compiler *)
@


<<function Ccomp.create_archive>>=
let create_archive archive file_list =
  Misc.remove_file archive;
  match Config.system with
    "win32" ->
      command(Printf.sprintf "lib /nologo /debugtype:cv /out:%s %s"
                                 archive (String.concat " " file_list))
  | _ ->
      let r1 =
        command(Printf.sprintf "ar rc %s %s"
                                   archive (String.concat " " file_list)) in
      if r1 <> 0 or String.length Config.ranlib = 0
      then r1
      else command(Config.ranlib ^ " " ^ archive)
@

<<signature Config.ranlib>>=
val ranlib: string
        (* Command to randomize a library, or "" if not needed *)
@

\section{Advanced linking issues}

\subsection{[[-custom]]}

<<constant Clflags.custom_runtime>>=
let custom_runtime = ref false          (* -custom *)
@
<<[[Main.main()]] command line options>>=
"-custom", Arg.Set custom_runtime, " Link in custom mode";
@

<<function Bytelink.build_custom_runtime>>=
let build_custom_runtime prim_name exec_name =
  let libname = "libcamlrun" ^ ext_lib in
  let runtime_lib =
    try
      find_in_path !load_path libname
    with Not_found ->
      raise(Error(File_not_found libname)) in
  match Sys.os_type with
    "Unix" ->
      Ccomp.command
       (Printf.sprintf
          "%s -o %s -I%s %s %s -L%s %s %s %s"
          Config.bytecomp_c_compiler
          exec_name
          Config.standard_library
          (String.concat " " (List.rev !Clflags.ccopts))
          prim_name
          Config.standard_library
          (String.concat " " (List.rev !Clflags.ccobjs))
          runtime_lib
          Config.c_libraries)
  | _ ->
    fatal_error "Bytelink.build_custom_runtime"
@

<<signature Config.c_libraries>>=
val c_libraries: string
        (* The C libraries to link with custom runtimes *)
@


\subsection{[[-linkall]]}

<<constant Clflags.link_everything>>=
let link_everything = ref false         (* -linkall *)
@
<<[[Main.main()]] command line options>>=
"-linkall", Arg.Set link_everything,
      " Link all modules, even unused ones";
@


\subsection{[[-output-obj]]}

<<constant Clflags.object_name>>=
let object_name = ref ("camlprog" ^ Config.ext_obj) (* -o *)
@
%camlprog??

<<constant Clflags.output_c_object>>=
let output_c_object = ref false         (* -output-obj *)
@
%??

<<[[Main.main()]] command line options>>=
"-output-obj", Arg.Unit(fun () -> output_c_object := true;
                                  custom_runtime := true),
      "Output a C object file instead of an executable";
@

\chapter{Interpreting}
% Running

\section{Startup}

<<constant Clflags.keep_startup_file>>=
let keep_startup_file = ref false       (* -dstartup *)
@

\section{Primitives}


\chapter{Garbage Collection}




\chapter{Native Code Generation}

<<constant Clflags.native_code>>=
let native_code = ref false             (* set to true under ocamlopt *)
@



<<constant Clflags.inline_threshold>>=
let inline_threshold = ref 10
@

<<constant Clflags.keep_asm_file>>=
let keep_asm_file = ref false           (* -S *)
@



\chapter{Debugging Support}

<<constant Clflags.debug>>=
let debug = ref false                   (* -g *)
@
<<[[Main.main()]] command line options>>=
"-g", Arg.Set debug, " Save debugging information";
@


\section{Events}

<<constant Bytelink.debug_info>>=
(* Second pass: link in the required units *)

let debug_info = ref ([] : debug_event list list)
@



<<constant Bytelink.debug_info (./bytecomp/bytelink.ml)>>=
(* Relocate and record compilation events *)

let debug_info = ref ([] : debug_event list list)
@

<<function Bytelink.record_events>>=
let record_events orig evl =
  if evl <> [] then begin
    List.iter
      (fun ev ->
         ev.ev_pos <- orig + ev.ev_pos;
         begin match ev.ev_repr with
           Event_parent repr -> repr := ev.ev_pos
         | _                 -> ()
         end)
      evl;
    debug_info := evl :: !debug_info
  end
@

\subsection{Lambda events}

<<type Lambda.lambda_event>>=
and lambda_event =
  { lev_loc: int;
    lev_kind: lambda_event_kind;
    lev_repr: int ref option;
    lev_env: unit; (*Env.summary*) }
@

<<type Lambda.lambda_event_kind>>=
and lambda_event_kind =
    Lev_before
  | Lev_after of Types.type_expr
  | Lev_function
@

\subsection{Instruction events}

%(* The ce_stack component gives locations of variables residing 
%   in the stack. The locations are offsets w.r.t. the origin of the
%   stack frame.
%   The ce_heap component gives the positions of variables residing in the
%   heap-allocated environment. *)

<<type Instruct.compilation_env>>=
(* Structure of compilation environments *)

type compilation_env =
  { ce_stack: int Ident.tbl; (* Positions of variables in the stack *)
    ce_heap: int Ident.tbl } (* Structure of the heap-allocated env *)
@

<<type Instruct.debug_event>>=
type debug_event =
  { mutable ev_pos: int;                (* Position in bytecode *)
    ev_module: string;                  (* Name of defining module *)
    ev_char: int;                       (* Location in source file *)
    ev_kind: debug_event_kind;          (* Before/after event *)
    ev_info: debug_event_info;          (* Extra information *)
    ev_typenv: unit(*Env.summary*);             (* Typing environment *)
    ev_compenv: compilation_env;        (* Compilation environment *)
    ev_stacksize: int;                  (* Size of stack frame *)
    ev_repr: debug_event_repr }         (* Position of the representative *)
@

<<type Instruct.debug_event_kind>>=
and debug_event_kind =
    Event_before
  | Event_after of Types.type_expr
  | Event_pseudo
@

<<type Instruct.debug_event_info>>=
and debug_event_info =
    Event_function
  | Event_return of int
  | Event_other
@

<<type Instruct.debug_event_repr>>=
and debug_event_repr =
    Event_none
  | Event_parent of int ref
  | Event_child of int ref
@

\subsection{Bytecode events}

<<constant Emitcode.events>>=
(* Debugging events *)

let events = ref ([] : debug_event list)
@

<<function Emitcode.record_event>>=
let record_event ev =
  ev.ev_pos <- !out_position;
  events := ev :: !events
@


\chapter{Profiling Support}

% actually there is no flag for profiling in ocamlc?


\chapter{Advanced Features}

% objects?
% functors? can be interesting to understand how it's compiled

\section{Floats}

\section{Arrays}

<<[[Parsetree.expression_desc]] cases>>=
| Pexp_array of expression list
@
<<[[Typedtree.expression_desc]] cases>>=
| Texp_array of expression list
@


<<rule simple_expr cases>>=
| LBRACKETBAR expr_semi_list opt_semi BARRBRACKET
    { mkexp(Pexp_array(List.rev $2)) }
| LBRACKETBAR BARRBRACKET
    { mkexp(Pexp_array []) }
@
%$

% sugar
<<rule simple_expr cases>>=
| simple_expr DOT LPAREN seq_expr RPAREN
    { mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "Array" "get")),
                       [$1; $4])) }
@
%$

<<rule expr cases>>=
| simple_expr DOT LPAREN seq_expr RPAREN LESSMINUS expr
    { mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "Array" "set")),
                       [$1; $4; $7])) }
@
%$



<<[[Predef.build_initial_env()]] decls>>=
let decl_array =
  let tvar = newvar() in
  {type_params = [tvar];
   type_arity = 1;
   type_kind = Type_abstract;
   type_manifest = None}
in
@


<<[[Typecore.type_exp()]] match cases>>=
| Pexp_array(sargl) ->
    let ty = newvar() in
    let argl = List.map (fun sarg -> type_expect env sarg ty) sargl in
    { exp_desc = Texp_array argl;
      exp_loc = sexp.pexp_loc;
      exp_type = Predef.type_array ty }
@


<<type Lambda.array_kind>>=
and array_kind =
    Pgenarray | Paddrarray | Pintarray | Pfloatarray
@


\section{String indexing}

% sugar
<<rule simple_expr cases>>=
| simple_expr DOT LBRACKET seq_expr RBRACKET
    { mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "String" "get")),
                       [$1; $4])) }
@

<<rule expr cases>>=
| simple_expr DOT LBRACKET seq_expr RBRACKET LESSMINUS expr
    { mkexp(Pexp_apply(mkexp(Pexp_ident(array_function "String" "set")),
                       [$1; $4; $7])) }
@
%$

\section{Assert, and [[-noassert]]}

<<rule expr cases>>=
| ASSERT simple_expr %prec prec_appl
    { mkassert $2 }
@
%$

% assert x --> ()  |   raise Assert_failure ... if noassert flag is set
<<[[Parser.mkassert()]]>>=
let mkassert e =
  let {loc_start = st; loc_end = en} = Location.symbol_loc () in
  let triple = mkexp (Pexp_tuple
                       [mkexp (Pexp_constant (Const_string !input_name));
                        mkexp (Pexp_constant (Const_int st));
                        mkexp (Pexp_constant (Const_int en))]) in
  let ex = Ldot (Lident "Pervasives", "Assert_failure") in
  let bucket = mkexp (Pexp_construct (ex, Some triple)) in
  let ra = Ldot (Lident "Pervasives", "raise") in
  let raiser = mkexp (Pexp_apply (mkexp (Pexp_ident ra), [bucket])) in
  let un = mkexp (Pexp_construct (Lident "()", None)) in
  match e with
  | {pexp_desc = Pexp_construct (Lident "false", None) } -> raiser
  | _ -> if !Clflags.noassert
         then un
         else mkexp (Pexp_ifthenelse (e, un, Some raiser))
@

%\section{[[-noassert]]}

<<constant Clflags.noassert>>=
let noassert = ref false                (* -noassert *)
@
<<[[Main.main()]] command line options>>=
"-noassert", Arg.Set noassert, " Don't compile assertion checks";
@

\section{Lazy}

<<rule expr cases>>=
| LAZY simple_expr %prec prec_appl
    { mklazy $2 }
@
%$

% lazy x --> ?
<<[[Parser.mklazy()]]>>=
let mklazy e =
  let void_pat = mkpat (Ppat_construct (Lident "()", None)) in
  let f = mkexp (Pexp_function ([void_pat, e])) in
  let delayed = Ldot (Lident "Lazy", "Delayed") in
  let df = mkexp (Pexp_construct (delayed, Some f)) in
  let r = mkexp (Pexp_ident (Ldot (Lident "Pervasives", "ref"))) in
  mkexp (Pexp_apply (r, [df]))
@

\chapter{Advanced Topics}


<<constant Clflags.optimize_for_speed>>=
let optimize_for_speed = ref true       (* -compact *)
@


\section{Printing types, [[-i]]}

<<constant Clflags.print_types>>=
let print_types = ref false             (* -i *)
@

<<[[Main.main()]] command line options>>=
"-i", Arg.Set print_types, " Print the types";
@


\section{[[-unsafe]]}

<<constant Clflags.fast>>=
let fast = ref false                    (* -unsafe *)
@

<<[[Main.main()]] command line options>>=
"-unsafe", Arg.Set fast,
      " No bounds checking on array and string access";
@

\section{Threads}

<<constant Clflags.thread_safe>>=
let thread_safe = ref false             (* -thread *)
@
<<[[Main.main()]] command line options>>=
"-thread", Arg.Set thread_safe, " Use thread-safe standard library";
@

\section{Preprocessing}

<<constant Clflags.preprocessor>>=
let preprocessor = ref(None : string option) (* -pp *)
@

<<[[Main.main()]] command line options>>=
"-pp", Arg.String(fun s -> preprocessor := Some s),
      "<command>  Pipe sources through preprocessor <command>";
@

<<function Compile.preprocess>>=
(* Optionally preprocess a source file *)

let preprocess sourcefile tmpfile =
  match !Clflags.preprocessor with
    None -> sourcefile
  | Some pp ->
      let comm = pp ^ " " ^ sourcefile ^ " > " ^ tmpfile in
      if Ccomp.command comm <> 0 then begin
        Printf.eprintf "Preprocessing error\n";
        flush stderr;
        exit 2
      end;
      tmpfile
@

<<function Compile.remove_preprocessed>>=
let remove_preprocessed inputfile =
  match !Clflags.preprocessor with
    None -> ()
  | Some _ -> remove_file inputfile
@


\subsection{[[#line]]}

<<[[Lexer.token()]] directive case>>=
| "#" [' ' '\t']* ['0'-'9']+ [' ' '\t']* "\"" [^ '\n' '\r'] *
  ('\n' | '\r' | "\r\n")
    (* # linenum "filename" flags \n *)
    { token lexbuf }
@

<<signature Linenum.for_position>>=
(* An auxiliary lexer for determining the line number corresponding to
   a file position, honoring the directives # linenum "filename" *)

val for_position: string -> int -> string * int * int
        (* [Linenum.for_position file loc] returns a triple describing
           the location [loc] in the file named [file].
           First result is name of actual source file.
           Second result is line number in that source file.
           Third result is position of beginning of that line in [file]. *)
@
% in linenum.mll

\section{Toplevel}

<<Parser entry points types>>=
%start toplevel_phrase                  /* for interactive use */
%type <Parsetree.toplevel_phrase> toplevel_phrase
%start use_file                         /* for the #use directive */
%type <Parsetree.toplevel_phrase list> use_file
@

<<entry points rules>>=

toplevel_phrase:
    top_structure SEMISEMI               { Ptop_def $1 }
  | seq_expr SEMISEMI                    { Ptop_def[mkstrexp $1] }
  | toplevel_directive SEMISEMI          { $1 }
  | EOF                                  { raise End_of_file }
;
top_structure:
    structure_item                       { [$1] }
  | structure_item top_structure         { $1 :: $2 }
;
use_file:
    use_file_tail                        { $1 }
  | seq_expr use_file_tail               { Ptop_def[mkstrexp $1] :: $2 }
;
use_file_tail:
    EOF                                         { [] }
  | SEMISEMI EOF                                { [] }
  | SEMISEMI seq_expr use_file_tail             { Ptop_def[mkstrexp $2] :: $3 }
  | SEMISEMI structure_item use_file_tail       { Ptop_def[$2] :: $3 }
  | SEMISEMI toplevel_directive use_file_tail   { $2 :: $3 }
  | structure_item use_file_tail                { Ptop_def[$1] :: $2 }
  | toplevel_directive use_file_tail            { $1 :: $2 }
;

@
%$

<<toplevel rules>>=
toplevel_directive:
    SHARP ident                 { Ptop_dir($2, Pdir_none) }
  | SHARP ident STRING          { Ptop_dir($2, Pdir_string $3) }
  | SHARP ident INT             { Ptop_dir($2, Pdir_int $3) }
  | SHARP ident val_longident   { Ptop_dir($2, Pdir_ident $3) }
;
@
%$


<<[[Lexer.token()]] operator cases>>=
| ";;" { SEMISEMI }
@

<<signature Parse.toplevel_phrase>>=
val toplevel_phrase : Lexing.lexbuf -> Parsetree.toplevel_phrase
@

<<signature Parse.use_file>>=
val use_file : Lexing.lexbuf -> Parsetree.toplevel_phrase list
@

<<function Parse.skip_phrase>>=
(* Skip tokens to the end of the phrase *)
let rec skip_phrase lexbuf =
  try
    match Lexer.token lexbuf with
      Parser.SEMISEMI | Parser.EOF -> ()
    | _ -> skip_phrase lexbuf
  with
    | Lexer.Error (Lexer.Unterminated_comment, _, _) -> ()
    | Lexer.Error (Lexer.Unterminated_string, _, _) -> ()
    | Lexer.Error(_,_,_) -> skip_phrase lexbuf
@

<<function Parse.maybe_skip_phrase>>=
let maybe_skip_phrase lexbuf =
  if Parsing.is_current_lookahead Parser.SEMISEMI
  or Parsing.is_current_lookahead Parser.EOF
  then ()
  else skip_phrase lexbuf
@


<<function Parse.xxx>>=
let toplevel_phrase = wrap Parser.toplevel_phrase
let use_file = wrap Parser.use_file
@

<<signature Translmod.transl_toplevel_definition>>=
val transl_toplevel_definition: 
  Typedtree.structure -> lambda
@

\subsection{Phrases}

<<type Parsetree.toplevel_phrase>>=
type toplevel_phrase =
    Ptop_def of structure
  | Ptop_dir of string * directive_argument
@

<<type Parsetree.directive_argument>>=
and directive_argument =
    Pdir_none
  | Pdir_string of string
  | Pdir_int of int
  | Pdir_ident of Longident.t
@

\chapter{Conclusion}







\appendix

\chapter{Debugging}


\section{Verbose mode, [[-v]]}

<<constant Clflags.verbose>>=
let verbose = ref false                 (* -verbose *)
@

% when compiling c stuff? calling assembler? -> <>
<<function Ccomp.command>>=
let command cmdline =
  if !Clflags.verbose then begin
    prerr_string "+ ";
    prerr_string cmdline;
    prerr_newline()
  end;
  Sys.command cmdline
@

\section{Dumpers, [[-dxxx]]}

%later: could be autogenerated! and save lots of boilerplate code?



\subsection{Typed data structures}

\subsubsection{Primitives}

% primitives
<<signature Primitive.print_description>>=
val print_description: description -> unit
@


<<function Primitive.print_description>>=
let print_description p =
  print_quoted p.prim_name;
  if not p.prim_alloc then
    (print_space(); print_quoted "noalloc");
  if p.prim_native_name <> "" then
    (print_space(); print_quoted p.prim_native_name);
  if p.prim_native_float then
    (print_space(); print_quoted "float")
@

<<function Primitive.print_quoted>>=
let print_quoted s = print_char '"'; print_string s; print_char '"'
@


\subsubsection{Names}

<<signature Printtyp.longident>>=
val longident: Longident.t -> unit
@

<<signature Printtyp.ident>>=
val ident: Ident.t -> unit
@

<<signature Printtyp.path>>=
val path: Path.t -> unit
@






<<function Printtyp.longident>>=
(* Print a long identifier *)

let rec longident = function
    Lident s -> print_string s
  | Ldot(p, s) -> longident p; print_string "."; print_string s
@

<<function Printtyp.ident>>=
(* Print an identifier *)

let ident id =
  print_string(Ident.name id)
@

<<constant Printtyp.ident_pervasive>>=
(* Print a path *)

let ident_pervasive = Ident.create_persistent "Pervasives"
@

<<function Printtyp.path>>=
let rec path = function
    Pident id ->
      ident id
  | Pdot(Pident id, s, pos) when Ident.same id ident_pervasive ->
      print_string s
  | Pdot(p, s, pos) ->
      path p; print_string "."; print_string s
@


\subsubsection{Types}

<<signature Printtyp.type_expr>>=
val type_expr: type_expr -> unit
@

<<function Printtyp.type_expr>>=
let type_expr ty = 
  typexp false 0 ty
@


<<function Printtyp.typeexp>>=
let rec typexp sch prio = function
    Tvar {tvar_link = Some ty} ->
      typexp sch prio ty
  | Tvar {tvar_link = None; tvar_level = lvl} as v ->
      if (not sch) || lvl = -1 (* generic *)
      then print_string "'"
      else print_string "'_";
      print_string(name_of_var v)
  | Tarrow(ty1, ty2) ->
      if prio >= 1 then begin open_hovbox 1; print_string "(" end
                   else open_hovbox 0;
      typexp sch 1 ty1;
      print_string " ->"; print_space();
      typexp sch 0 ty2;
      if prio >= 1 then print_string ")";
      close_box()
  | Ttuple tyl ->
      if prio >= 2 then begin open_hovbox 1; print_string "(" end
                   else open_hovbox 0;
      typlist sch 2 " *" tyl;
      if prio >= 2 then print_string ")";
      close_box()
  | Tconstr(p, tyl) ->
      open_hovbox 0;
      begin match tyl with
        [] -> ()
      | [ty1] ->
          typexp sch 2 ty1; print_space()
      | tyl ->
          open_hovbox 1; print_string "("; typlist sch 0 "," tyl;
          print_string ")"; close_box(); print_space()
      end;
      path p;
      close_box()

and typlist sch prio sep = function
    [] -> ()
  | [ty] -> typexp sch prio ty
  | ty::tyl ->
      typexp sch prio ty; print_string sep; print_space();
      typlist sch prio sep tyl

@


<<constant Printtyp.var_names>>=
(* Print a type expression *)

let var_names = ref ([] : (type_expr * string) list)
@
<<constant Printtyp.var_counter>>=
let var_counter = ref 0
@

<<function Printtyp.reset_var_names>>=
let reset_var_names () = 
  var_names := []; 
  var_counter := 0
@

<<function Printtyp.name_of_var>>=
let name_of_var v =
  try
    List.assq v !var_names
  with Not_found ->
    let name = 
      if !var_counter < 26
      then String.make 1 (Char.chr(97 + !var_counter)) 
      else String.make 1 (Char.chr(97 + !var_counter mod 26)) ^
           string_of_int(!var_counter / 26) in
    var_names := (v, name) :: !var_names;
    incr var_counter;
    name
@



\subsubsection{Expressions}

<<signature Printtyp.value_description>>=
val value_description: Ident.t -> value_description -> unit
@

<<function Printtyp.value_description>>=
(* Print a value declaration *)

let value_description id decl =
  open_hovbox 2;
  print_string "val "; ident id; print_string " :"; print_space();
  type_scheme decl.val_type;
  begin match decl.val_prim with
    None -> ()
  | Some p -> print_space(); print_string "= "; Primitive.print_description p
  end;
  close_box()
@

<<function Printtyp.type_scheme>>=
and type_scheme ty = 
  reset_var_names(); 
  typexp true 0 ty
@

\subsubsection{Type declarations}

<<signature Printtyp.type_declaration>>=
val type_declaration: Ident.t -> type_declaration -> unit
@

<<signature Printtyp.exception_declaration>>=
val exception_declaration: Ident.t -> exception_declaration -> unit
@


<<function Printtyp.type_declaration>>=
let rec type_declaration id decl =
  reset_var_names();
  open_hvbox 2;
  print_string "type ";
  type_expr (Tconstr(Pident id, decl.type_params));
  begin match decl.type_manifest with
    None -> ()
  | Some ty -> print_string " ="; print_space(); type_expr ty
  end;
  begin match decl.type_kind with
    Type_abstract -> ()
  | Type_variant [] -> ()
      (* A fatal error actually, except when printing type exn... *)
  | Type_variant (cstr1 :: cstrs) ->
      print_string " ="; print_break 1 2;
      constructor cstr1;
      List.iter
        (fun cstr -> print_space(); print_string "| "; constructor cstr)
        cstrs
  | Type_record (lbl1 :: lbls) ->
      print_string " ="; print_space();
      print_string "{ "; label lbl1;
      List.iter
        (fun lbl -> print_string ";"; print_break 1 2; label lbl)
        lbls;
      print_string " }"
  end;
  close_box()

and constructor (name, args) =
  print_string name;
  match args with
    [] -> ()
  | _  -> print_string " of ";
          open_hovbox 2; typlist false 2 " *" args; close_box()

and label (name, mut, arg) =
  begin match mut with
      Immutable -> ()
    | Mutable -> print_string "mutable "
  end;
  print_string name;
  print_string ": ";
  type_expr arg
@

<<function Printtyp.exception_declaration>>=
(* Print an exception declaration *)

let exception_declaration id decl =
  print_string "exception "; constructor (Ident.name id, decl)
@

\subsubsection{Modules}

<<signature Printtyp.modtype>>=
val modtype: module_type -> unit
@

<<signature Printtyp.signature>>=
val signature: signature -> unit
@



<<function Printtyp.modtype>>=

let rec modtype = function
    Tmty_ident p ->
      path p
  | Tmty_signature [] ->
      print_string "sig end"
  | Tmty_signature(item :: rem) ->
      open_hvbox 2;
      print_string "sig"; print_space(); 
      signature_item item;
      List.iter
        (fun item -> print_space(); signature_item item)
      rem;
      print_break 1 (-2); print_string "end";
      close_box()

and signature_item = function
    Tsig_value(id, decl) ->
      value_description id decl
  | Tsig_type(id, decl) ->
      type_declaration id decl
  | Tsig_exception(id, decl) ->
      exception_declaration id decl
  | Tsig_module(id, mty) ->
      open_hovbox 2; print_string "module "; ident id; print_string " :";
      print_space(); modtype mty; close_box()

@


<<function Printtyp.signature>>=
(* Print a signature body (used when compiling a .mli and printing results
   in interactive use). *)

let signature sg =
  open_vbox 0;
  List.iter (fun item -> signature_item item; print_space()) sg;
  close_box()
@





\subsection{Bytecode data structures}

\subsubsection{[[-dlambda]]}

<<constant Clflags.dump_lambda>>=
let dump_lambda = ref false             (* -dlambda *)
@

<<constant Clflags.dump_rawlambda>>=
let dump_rawlambda = ref false          (* -drawlambda *)
@
% before simplify

<<[[Main.main()]] command line options>>=
"-dlambda", Arg.Set dump_lambda, " (undocumented)";
"-drawlambda", Arg.Set dump_rawlambda, " (undocumented)";
@



<<signature Printlambda.lambda>>=
val lambda: lambda -> unit
@


<<function Printlambda.lambda>>=
let rec lambda = function
    Lvar id ->
      Ident.print id
  | Lconst cst ->
      structured_constant cst
  | Lapply(lfun, largs) ->
      open_box 2;
      print_string "(apply"; print_space();
      lambda lfun;
      List.iter (fun l -> print_space(); lambda l) largs;
      print_string ")";
      close_box()
  | Lfunction(kind, params, body) ->
      open_box 2;
      print_string "(function";
      begin match kind with
        Curried ->
          List.iter (fun param -> print_space(); Ident.print param) params
      | Tupled ->
          print_string " (";
          let first = ref true in
          List.iter
            (fun param ->
              if !first
              then first := false
              else begin print_string ",";print_space() end;
              Ident.print param)
            params
      end;
      print_space(); lambda body; print_string ")"; close_box()
  | Llet(str, id, arg, body) ->
      open_box 2;
      print_string "(let"; print_space();
      open_hvbox 1;
      print_string "(";
      open_box 2; Ident.print id; print_space(); lambda arg; close_box();
      letbody body;
      print_string ")";
      close_box()
  | Lletrec(id_arg_list, body) ->
      open_box 2;
      print_string "(letrec"; print_space();
      print_string "(";
      open_hvbox 1;
      let spc = ref false in
      List.iter
        (fun (id, l) ->
          if !spc then print_space() else spc := true;
          open_box 2;
          Ident.print id; print_space(); lambda l;
          close_box())
        id_arg_list;
      close_box();
      print_string ")";
      print_space(); lambda body;
      print_string ")"; close_box()
  | Lprim(prim, largs) ->
      open_box 2;
      print_string "("; primitive prim;
      List.iter (fun l -> print_space(); lambda l) largs;
      print_string ")";
      close_box()
  | Lswitch(larg, sw) ->
      open_box 1;
      print_string (if sw.sw_checked then "(switch-checked " else "(switch ");
      lambda larg; print_space();
      open_vbox 0;
      let spc = ref false in
      List.iter
        (fun (n, l) ->
          if !spc then print_space() else spc := true;
          open_hvbox 1;
          print_string "case int "; print_int n;
          print_string ":"; print_space();
          lambda l;
          close_box())
        sw.sw_consts;
      List.iter
        (fun (n, l) ->
          if !spc then print_space() else spc := true;
          open_hvbox 1;
          print_string "case tag "; print_int n;
          print_string ":"; print_space();
          lambda l;
          close_box())
        sw.sw_blocks;
      print_string ")"; close_box(); close_box()
  | Lstaticfail ->
      print_string "exit"
  | Lcatch(lbody, lhandler) ->
      open_box 2;
      print_string "(catch"; print_space();
      lambda lbody; print_break 1 (-1);
      print_string "with"; print_space(); lambda lhandler;
      print_string ")";
      close_box()
  | Ltrywith(lbody, param, lhandler) ->
      open_box 2;
      print_string "(try"; print_space();
      lambda lbody; print_break 1 (-1);
      print_string "with "; Ident.print param; print_space();
      lambda lhandler;
      print_string ")";
      close_box()
  | Lifthenelse(lcond, lif, lelse) ->
      open_box 2;
      print_string "(if"; print_space();
      lambda lcond; print_space();
      lambda lif; print_space();
      lambda lelse; print_string ")";
      close_box()
  | Lsequence(l1, l2) ->
      open_box 2;
      print_string "(seq"; print_space();
      lambda l1; print_space(); sequence l2; print_string ")";
      close_box()
  | Lwhile(lcond, lbody) ->
      open_box 2;
      print_string "(while"; print_space();
      lambda lcond; print_space();
      lambda lbody; print_string ")";
      close_box()
  | Lfor(param, lo, hi, dir, body) ->
      open_box 2;
      print_string "(for "; Ident.print param; print_space();
      lambda lo; print_space();
      print_string(match dir with Upto -> "to" | Downto -> "downto");
      print_space();
      lambda hi; print_space();
      lambda body; print_string ")";
      close_box()
  | Lassign(id, expr) ->
      open_box 2;
      print_string "(assign"; print_space();
      Ident.print id; print_space();
      lambda expr; print_string ")";
      close_box()
  | Levent(lam, ev) ->
      open_box 2;
      begin match ev.lev_kind with
        Lev_before   -> print_string "(before "
      | Lev_after _  -> print_string "(after "
      | Lev_function -> print_string "(funct-body "
      end;
      print_int ev.lev_loc;
      print_space();
      lambda lam;
      print_string ")";
      close_box()

and sequence = function
    Lsequence(l1, l2) ->
      sequence l1; print_space(); sequence l2
  | Llet(str, id, arg, body) ->
      open_box 2;
      print_string "let"; print_space();
      Ident.print id; print_space(); lambda arg;
      close_box();
      print_space();
      sequence body
  | l ->
      lambda l

and letbody = function
    Llet(str, id, arg, body) ->
      print_space();
      open_box 2; Ident.print id; print_space(); lambda arg;
      close_box();
      letbody body
  | l ->
      print_string ")";
      close_box();
      print_space();
      lambda l
@


<<signature Printlambda.structured_constant>>=
val structured_constant: structured_constant -> unit
@


<<function Printlambda.structured_constant>>=
let rec structured_constant = function
    Const_base(Const_int n) -> print_int n
  | Const_base(Const_char c) ->
      print_string "'"; print_string(Char.escaped c); print_string "'"
  | Const_base(Const_string s) ->
      print_string "\""; print_string(String.escaped s); print_string "\""
  | Const_base(Const_float s) ->
      print_string s
  | Const_pointer n -> print_int n; print_string "a"
  | Const_block(tag, []) ->
      print_string "["; print_int tag; print_string "]"
  | Const_block(tag, sc1::scl) ->
      open_box 1;
      print_string "["; print_int tag; print_string ":";
      print_space();
      open_box 0;
      structured_constant sc1;
      List.iter (fun sc -> print_space(); structured_constant sc) scl;
      close_box();
      print_string "]";
      close_box()
  | Const_float_array [] ->
      print_string "[| |]"
  | Const_float_array (f1 :: fl) ->
      open_box 1;
      print_string "[|";
      open_box 0;
      print_string f1;
      List.iter (fun f -> print_space(); print_string f) fl;
      close_box();
      print_string "|]";
      close_box()
@

<<function Printlambda.primitive>>=
let primitive = function
    Pidentity -> print_string "id"
  | Pgetglobal id -> print_string "global "; Ident.print id
  | Psetglobal id -> print_string "setglobal "; Ident.print id
  | Pmakeblock(tag, Immutable) -> print_string "makeblock "; print_int tag
  | Pmakeblock(tag, Mutable) -> print_string "makemutable "; print_int tag
  | Pfield n -> print_string "field "; print_int n
  | Psetfield(n, _) -> print_string "setfield "; print_int n
  | Pfloatfield n -> print_string "floatfield "; print_int n
  | Psetfloatfield n -> print_string "setfloatfield "; print_int n
  | Pccall p -> print_string p.prim_name
  | Praise -> print_string "raise"
  | Psequand -> print_string "&&"
  | Psequor -> print_string "||"
  | Pnot -> print_string "not"
  | Pnegint -> print_string "~"
  | Paddint -> print_string "+"
  | Psubint -> print_string "-"
  | Pmulint -> print_string "*"
  | Pdivint -> print_string "/"
  | Pmodint -> print_string "mod"
  | Pandint -> print_string "and"
  | Porint -> print_string "or"
  | Pxorint -> print_string "xor"
  | Plslint -> print_string "lsl"
  | Plsrint -> print_string "lsr"
  | Pasrint -> print_string "asr"
  | Pintcomp(Ceq) -> print_string "=="
  | Pintcomp(Cneq) -> print_string "!="
  | Pintcomp(Clt) -> print_string "<"
  | Pintcomp(Cle) -> print_string "<="
  | Pintcomp(Cgt) -> print_string ">"
  | Pintcomp(Cge) -> print_string ">="
  | Poffsetint n -> print_int n; print_string "+"
  | Poffsetref n -> print_int n; print_string "+:="
  | Pintoffloat -> print_string "int_of_float"
  | Pfloatofint -> print_string "float_of_int"
  | Pnegfloat -> print_string "~."
  | Pabsfloat -> print_string "abs."
  | Paddfloat -> print_string "+."
  | Psubfloat -> print_string "-."
  | Pmulfloat -> print_string "*."
  | Pdivfloat -> print_string "/."
  | Pfloatcomp(Ceq) -> print_string "==."
  | Pfloatcomp(Cneq) -> print_string "!=."
  | Pfloatcomp(Clt) -> print_string "<."
  | Pfloatcomp(Cle) -> print_string "<=."
  | Pfloatcomp(Cgt) -> print_string ">."
  | Pfloatcomp(Cge) -> print_string ">=."
  | Pstringlength -> print_string "string.length"
  | Pstringrefu -> print_string "string.unsafe_get"
  | Pstringsetu -> print_string "string.unsafe_set"
  | Pstringrefs -> print_string "string.get"
  | Pstringsets -> print_string "string.set"
  | Parraylength _ -> print_string "array.length"
  | Pmakearray _ -> print_string "makearray "
  | Parrayrefu _ -> print_string "array.unsafe_get"
  | Parraysetu _ -> print_string "array.unsafe_set"
  | Parrayrefs _ -> print_string "array.get"
  | Parraysets _ -> print_string "array.set"
  | Pbittest -> print_string "testbit"
@



\subsubsection{[[-dInstr]]}


<<constant Clflags.dump_instr>>=
let dump_instr = ref false              (* -dinstr *)
@
<<[[Main.main()]] command line options>>=
"-dinstr", Arg.Set dump_instr, " (undocumented)";
@


<<signature Printinstr.instruction>>=
val instruction: instruction -> unit
@

<<signature Printinstr.instrlist>>=
val instrlist: instruction list -> unit
@


<<constant Printinstr.instruction>>=
let instruction = function
    Klabel lbl -> print_string "L"; print_int lbl; print_string ":"
  | Kacc n -> print_string "\tacc "; print_int n
  | Kenvacc n -> print_string "\tenvacc "; print_int n
  | Kpush -> print_string "\tpush"
  | Kpop n -> print_string "\tpop "; print_int n
  | Kassign n -> print_string "\tassign "; print_int n
  | Kpush_retaddr lbl -> print_string "\tpush_retaddr L"; print_int lbl
  | Kapply n -> print_string "\tapply "; print_int n
  | Kappterm(n, m) ->
      print_string "\tappterm "; print_int n; print_string ", "; print_int m
  | Kreturn n -> print_string "\treturn "; print_int n
  | Krestart -> print_string "\trestart"
  | Kgrab n -> print_string "\tgrab "; print_int n
  | Kclosure(lbl, n) ->
      print_string "\tclosure L"; print_int lbl; print_string ", "; print_int n
  | Kclosurerec(lbl, n) ->
      print_string "\tclosurerec L"; print_int lbl;
      print_string ", "; print_int n
  | Kgetglobal id -> print_string "\tgetglobal "; Ident.print id
  | Ksetglobal id -> print_string "\tsetglobal "; Ident.print id
  | Kconst cst ->
      open_box 10; print_string "\tconst"; print_space();
      Printlambda.structured_constant cst; close_box()
  | Kmakeblock(n, m) ->
      print_string "\tmakeblock "; print_int n; print_string ", "; print_int m
  | Kgetfield n -> print_string "\tgetfield "; print_int n
  | Ksetfield n -> print_string "\tsetfield "; print_int n
  | Kdummy n -> print_string "\tdummy "; print_int n
  | Kupdate n -> print_string "\tupdate"; print_int n
  | Kvectlength -> print_string "\tvectlength"
  | Kgetvectitem -> print_string "\tgetvectitem"
  | Ksetvectitem -> print_string "\tsetvectitem"
  | Kgetstringchar -> print_string "\tgetstringchar"
  | Ksetstringchar -> print_string "\tsetstringchar"
  | Kbranch lbl -> print_string "\tbranch L"; print_int lbl
  | Kbranchif lbl -> print_string "\tbranchif L"; print_int lbl
  | Kbranchifnot lbl -> print_string "\tbranchifnot L"; print_int lbl
  | Kstrictbranchif lbl -> print_string "\tstrictbranchif L"; print_int lbl
  | Kstrictbranchifnot lbl ->
      print_string "\tstrictbranchifnot L"; print_int lbl
  | Kswitch(consts, blocks) ->
      open_box 10;
      print_string "\tswitch";
      Array.iter (fun lbl -> print_space(); print_int lbl) consts;
      print_string "/";
      Array.iter (fun lbl -> print_space(); print_int lbl) blocks;
      close_box()
  | Kboolnot -> print_string "\tboolnot"
  | Kpushtrap lbl -> print_string "\tpushtrap L"; print_int lbl
  | Kpoptrap -> print_string "\tpoptrap"
  | Kraise -> print_string "\traise"
  | Kcheck_signals -> print_string "\tcheck_signals"
  | Kccall(s, n) ->
      print_string "\tccall "; print_string s; print_string ", "; print_int n
  | Knegint -> print_string "\tnegint"
  | Kaddint -> print_string "\taddint"
  | Ksubint -> print_string "\tsubint"
  | Kmulint -> print_string "\tmulint"
  | Kdivint -> print_string "\tdivint"
  | Kmodint -> print_string "\tmodint"
  | Kandint -> print_string "\tandint"
  | Korint -> print_string "\torint"
  | Kxorint -> print_string "\txorint"
  | Klslint -> print_string "\tlslint"
  | Klsrint -> print_string "\tlsrint"
  | Kasrint -> print_string "\tasrint"
  | Kintcomp Ceq -> print_string "\teqint"
  | Kintcomp Cneq -> print_string "\tneqint"
  | Kintcomp Clt -> print_string "\tltint"
  | Kintcomp Cgt -> print_string "\tgtint"
  | Kintcomp Cle -> print_string "\tleint"
  | Kintcomp Cge -> print_string "\tgeint"
  | Koffsetint n -> print_string "\toffsetint "; print_int n
  | Koffsetref n -> print_string "\toffsetref "; print_int n
  | Kstop -> print_string "\tstop"
  | Kevent ev -> print_string "\tevent "; print_int ev.ev_char
@

<<constant Printinstr.instruction_list>>=
let rec instruction_list = function
    [] -> ()
  | Klabel lbl :: il ->
      print_string "L"; print_int lbl; print_string ":"; instruction_list il
  | instr :: il ->
      instruction instr; print_space(); instruction_list il
@

<<function Printinstr.instrlist>>=
let instrlist il =
  open_vbox 0;
  instruction_list il;
  close_box()
@


\subsection{Native code data structures}

<<constant Clflags.dump_cmm>>=
let dump_cmm = ref false                (* -dcmm *)
@




<<constant Clflags.dump_selection>>=
let dump_selection = ref false          (* -dsel *)
@

<<constant Clflags.dump_live>>=
let dump_live = ref false               (* -dlive *)
@

<<constant Clflags.dump_spill>>=
let dump_spill = ref false              (* -dspill *)
@

<<constant Clflags.dump_split>>=
let dump_split = ref false              (* -dsplit *)
@

<<constant Clflags.dump_scheduling>>=
let dump_scheduling = ref false         (* -dscheduling *)
@

<<constant Clflags.dump_interf>>=
let dump_interf = ref false             (* -dinterf *)
@

<<constant Clflags.dump_prefer>>=
let dump_prefer = ref false             (* -dprefer *)
@

<<constant Clflags.dump_regalloc>>=
let dump_regalloc = ref false           (* -dalloc *)
@

<<constant Clflags.dump_reload>>=
let dump_reload = ref false             (* -dreload *)
@

<<constant Clflags.dump_linear>>=
let dump_linear = ref false             (* -dlinear *)
@

\subsubsection{[[-dcmm]]}



\chapter{Profiling}

\chapter{Error Managment}

<<signature Errors.report_error>>=
(* Error report *)

val report_error: exn -> unit
@


% main -> <>
<<function Errors.report_error>>=
(* Report an error *)

let report_error exn =
  open_box 0;
  begin match exn with
    Lexer.Error(err, start, stop) ->
      Location.print {loc_start = start; loc_end = stop};
      Lexer.report_error err
  | Syntaxerr.Error err ->
      Syntaxerr.report_error err

  | Env.Error err ->
      Env.report_error err
  | Typecore.Error(loc, err) ->
      Location.print loc; Typecore.report_error err
  | Typetexp.Error(loc, err) ->
      Location.print loc; Typetexp.report_error err
  | Typedecl.Error(loc, err) ->
      Location.print loc; Typedecl.report_error err
  | Includemod.Error err ->
      Includemod.report_error err
  | Typemod.Error(loc, err) ->
      Location.print loc; Typemod.report_error err

  | Translcore.Error(loc, err) ->
      Location.print loc; Translcore.report_error err
  | Symtable.Error code ->
      Symtable.report_error code
  | Bytelink.Error code ->
      Bytelink.report_error code
  | Bytelibrarian.Error code ->
      Bytelibrarian.report_error code

  | Sys_error msg ->
      print_string "I/O error: "; print_string msg

  | x ->
      close_box(); raise x
  end;
  close_box(); print_newline()
@



%\section{Location errors}

<<signature Location.print>>=
val print: t -> unit
@

<<signature Location.print_warning>>=
val print_warning: t -> string -> unit
@



<<constants Location.msg_xxx>>=
let (msg_file, msg_line, msg_chars, msg_to, msg_colon, warn_head) =
  match Sys.os_type with
  | _ -> ("File \"", "\", line ", ", characters ", "-", ":", "")
@

<<function Location.print>>=
let print loc =
  if String.length !input_name = 0 then
    if highlight_locations loc none then () else begin
      print_string "Characters ";
      print_int loc.loc_start; print_string "-";
      print_int loc.loc_end; print_string ":";
      force_newline()
    end
  else begin
    let (filename, linenum, linebeg) =
            Linenum.for_position !input_name loc.loc_start in
    print_string msg_file; print_string filename;
    print_string msg_line; print_int linenum;
    print_string msg_chars; print_int (loc.loc_start - linebeg);
    print_string msg_to; print_int (loc.loc_end - linebeg);
    print_string msg_colon;
    force_newline()
  end
@




<<function Location.print_warning>>=
let print_warning loc msg =
  let (f1, f2) = Format.get_formatter_output_functions() in
  if not !Sys.interactive then Format.set_formatter_out_channel stderr;
  print loc;
  print_string warn_head;
  print_string "Warning: "; print_string msg; print_newline();
  incr num_loc_lines;
  Format.set_formatter_output_functions f1 f2
@





\section{Fatal errors}

% ?? -> <>
<<signature Misc.fatal_error>>=
val fatal_error: string -> 'a
@

<<exception Misc.Fatal_error>>=
exception Fatal_error
@

<<function Misc.fatal_error>>=
let fatal_error msg =
  prerr_string ">> Fatal error: "; prerr_endline msg; raise Fatal_error
@

\section{Lexing errors}

<<type Lexer.error>>=
type error =
    Illegal_character
  | Unterminated_comment
  | Unterminated_string
@

<<exception Lexer.Error>>=
exception Error of error * int * int
@

<<signature Lexer.report_error>>=
val report_error: error -> unit
@

% in .mll

<<function Lexer.report_error>>=
let report_error = function
    Illegal_character ->
      print_string "Illegal character"
  | Unterminated_comment ->
      print_string "Comment not terminated"
  | Unterminated_string ->
      print_string "String literal not terminated"
@

\section{Syntax errors}

%\subsection{Grammar managment}

% error yacc terminal!

<<rule module_expr error cases>>=
| STRUCT structure error
    { unclosed "struct" 1 "end" 3 }
| LPAREN module_expr COLON module_type error
    { unclosed "(" 1 ")" 5 }
| LPAREN module_expr error
    { unclosed "(" 1 ")" 3 }
@

<<rule module_type error cases>>=
| SIG signature error
    { unclosed "sig" 1 "end" 3 }
| LPAREN module_type error
    { unclosed "(" 1 ")" 3 }
@

<<rule simple_expr error cases>>=
| LPAREN seq_expr error
    { unclosed "(" 1 ")" 3 }
| BEGIN seq_expr error
    { unclosed "begin" 1 "end" 3 }
| simple_expr DOT LPAREN seq_expr error
    { unclosed "(" 3 ")" 5 }
| simple_expr DOT LBRACKET seq_expr error
    { unclosed "[" 3 "]" 5 }
| LBRACE lbl_expr_list opt_semi error
    { unclosed "{" 1 "}" 4 }
| LBRACKETBAR expr_semi_list opt_semi error
    { unclosed "[|" 1 "|]" 4 }
| LBRACKET expr_semi_list opt_semi error
    { unclosed "[" 1 "]" 4 }
@


<<rule simple_pattern error cases>>=
| LBRACE lbl_pattern_list opt_semi error
    { unclosed "{" 1 "}" 4 }
| LBRACKET pattern_semi_list opt_semi error
    { unclosed "{" 1 "}" 4 }
| LPAREN pattern error
    { unclosed "(" 1 ")" 3 }
| LPAREN pattern COLON core_type error
    { unclosed "(" 1 ")" 5 }
@


<<type Syntaxerr.error>>=
(* Auxiliary type for reporting syntax errors *)

type error =
    Unclosed of Location.t * string * Location.t * string
  | Other of Location.t
@
%Other for ?

<<exception Syntaxerr.Error>>=
exception Error of error
@

<<exception Syntaxerr.Escape_error>>=
exception Escape_error
@
% why not an error case? 

<<signature Syntaxerr.report_error>>=
val report_error: error -> unit
@


<<function Syntaxerr.report_error>>=
let report_error = function
    Unclosed(opening_loc, opening, closing_loc, closing) ->
      if String.length !Location.input_name = 0
      && Location.highlight_locations opening_loc closing_loc
      then begin
        print_string "Syntax error: '";
        print_string closing;
        print_string "' expected, the highlighted '";
        print_string opening;
        print_string "' might be unmatched"
      end else begin
        Location.print closing_loc;
        print_string "Syntax error: '";
        print_string closing;
        print_string "' expected"; force_newline();
        Location.print opening_loc;
        print_string "This '";
        print_string opening;
        print_string "' might be unmatched"
      end
  | Other loc ->
      Location.print loc;
      print_string "Syntax error"
@





\section{Naming errors}

<<type Env.error>>=
(* Error report *)

type error =
    Not_an_interface of string
  | Corrupted_interface of string
  | Illegal_renaming of string * string
@

<<exception Env.Error>>=
exception Error of error
@

<<signature Env.report_error>>=
val report_error: error -> unit
@

<<function Env.report_error>>=
(* Error report *)

let report_error = function
    Not_an_interface filename ->
      print_string filename; print_space();
      print_string "is not a compiled interface."
  | Corrupted_interface filename ->
      print_string "Corrupted compiled interface"; print_space();
      print_string filename
  | Illegal_renaming(modname, filename) ->
      print_string "Wrong file naming:"; print_space();
      print_string filename; print_space();
      print_string "contains the compiled interface for"; print_space();
      print_string modname
@
%TODO: forward port Inconsistent_import check
%  | Inconsistent_import(name, source1, source2) ->
%      open_hvbox 0;
%      print_string "The compiled interfaces for "; print_string source1;
%      print_string " and "; print_string source2; print_space();
%      print_string "make inconsistent assumptions over interface ";
%      print_string name;
%      close_box()


\section{Typing errors}

\subsection{Types}

<<type Typetexp.error>>=
type error =
    Unbound_type_variable of string
  | Unbound_type_constructor of Longident.t
  | Type_arity_mismatch of Longident.t * int * int
@
% no unify error?
%TODO: error a la julien? far easier to understand

<<exception Typetexp.Error>>=
exception Error of Location.t * error
@

<<signature Typetexp.report_error>>=
val report_error: error -> unit
@


<<function Typetexp.report_error>>=
let report_error = function
    Unbound_type_variable name ->
      print_string "Unbound type parameter "; print_string name
  | Unbound_type_constructor lid ->
      print_string "Unbound type constructor "; longident lid
  | Type_arity_mismatch(lid, expected, provided) ->
      open_hovbox 0;
      print_string "The type constructor "; longident lid;
      print_space(); print_string "expects "; print_int expected;
      print_string " argument(s),"; print_space();
      print_string "but is here applied to "; print_int provided;
      print_string " argument(s)";
      close_box()
@

\subsection{Modules}

<<type Typemod.error>>=
type error =
    Unbound_module of Longident.t
  | Not_included of Includemod.error list
  | Signature_expected
  | Structure_expected of module_type
  | With_no_component of Longident.t
  | Repeated_name of string * string
  | Non_generalizable of type_expr
@

<<exception Typemod.Error>>=
exception Error of Location.t * error
@

<<signature Typemod.report_error>>=
val report_error: error -> unit
@


<<function Typemod.report_error>>=
let report_error = function
    Unbound_module lid ->
      print_string "Unbound module "; longident lid
  | Not_included errs ->
      open_vbox 0;
      print_string "Signature mismatch:"; print_space();
      Includemod.report_error errs;
      close_box()
  | Signature_expected ->
      print_string "This module type is not a signature"
  | Structure_expected mty ->
      open_hovbox 0;
      print_string "This module is not a structure; it has type";
      print_space(); modtype mty;
      close_box()
  | With_no_component lid ->
      print_string "The signature constrained by `with' has no component named";
      print_space(); longident lid
  | Repeated_name(kind, name) ->
      open_hovbox 0;
      print_string "Multiple definition of the "; print_string kind;
      print_string " name "; print_string name; print_string ".";
      print_space();
      print_string "Names must be unique in a given structure.";
      close_box()
  | Non_generalizable typ ->
      open_hovbox 0;
      print_string "The type of this expression,"; print_space();
      type_scheme typ; print_string ","; print_space();
      print_string "contains type variables that cannot be generalized"
@




<<type Includemod.error>>=
type error =
    Missing_field of Ident.t
  | Value_descriptions of Ident.t * value_description * value_description
  | Type_declarations of Ident.t * type_declaration * type_declaration
  | Exception_declarations of
      Ident.t * exception_declaration * exception_declaration
  | Module_types of module_type * module_type
  | Interface_mismatch of string * string
@
% last one is probably the most classic?

<<exception Includemod.Error>>=
exception Error of error list
@

<<signature Includemod.report_error>>=
val report_error: error list -> unit
@


<<function Includemod.include_err>>=
let include_err = function
    Missing_field id ->
      print_string "The field `"; ident id; 
      print_string "' is required but not provided"
  | Value_descriptions(id, d1, d2) ->
      open_hvbox 2;
      print_string "Values do not match:"; print_space();
      value_description id d1; 
      print_break 1 (-2);
      print_string "is not included in"; print_space();
      value_description id d2;
      close_box()
  | Type_declarations(id, d1, d2) ->
      open_hvbox 2;
      print_string "Type declarations do not match:"; print_space();
      type_declaration id d1; 
      print_break 1 (-2);
      print_string "is not included in"; print_space();
      type_declaration id d2;
      close_box()
  | Exception_declarations(id, d1, d2) ->
      open_hvbox 2;
      print_string "Exception declarations do not match:"; print_space();
      exception_declaration id d1; 
      print_break 1 (-2);
      print_string "is not included in"; print_space();
      exception_declaration id d2;
      close_box()
  | Module_types(mty1, mty2)->
      open_hvbox 2;
      print_string "Modules do not match:"; print_space();
      modtype mty1;
      print_break 1 (-2);
      print_string "is not included in"; print_space();
      modtype mty2;
      close_box()
  | Interface_mismatch(impl_name, intf_name) ->
      open_hovbox 0;
      print_string "The implementation "; print_string impl_name;
      print_space(); print_string "does not match the interface ";
      print_string intf_name;
      print_string ":";
      close_box()
@

<<function Includemod.report_error>>=
let report_error errlist =
  match errlist with
    [] -> ()
  | err :: rem ->
      open_vbox 0;
      include_err err;
      List.iter (fun err -> print_space(); include_err err) rem;
      close_box()
@

\subsection{Declarations}

<<type Typedecl.error>>=
type error =
    Repeated_parameter
  | Duplicate_constructor of string
  | Too_many_constructors
  | Duplicate_label of string
  | Recursive_abbrev of string
  | Definition_mismatch of type_expr
@


<<exception Typedecl.Error>>=
exception Error of Location.t * error
@

<<signature Typedecl.report_error>>=
val report_error: error -> unit
@


<<function Typedecl.report_error>>=
let report_error = function
    Repeated_parameter ->
      print_string "A type parameter occurs several times"
  | Duplicate_constructor s ->
      print_string "Two constructors are named "; print_string s
  | Too_many_constructors ->
      print_string "Too many constructors -- maximum is ";
      print_int Config.max_tag; print_string " constructors"
  | Duplicate_label s ->
      print_string "Two labels are named "; print_string s
  | Recursive_abbrev s ->
      print_string "The type abbreviation "; print_string s;
      print_string " is cyclic"
  | Definition_mismatch ty ->
      print_string
        "The variant or record definition does not match that of type";
      print_space(); Printtyp.type_expr ty
@


\subsection{Expressions}

<<type Typecore.error>>=
type error =
    Unbound_value of Longident.t
  | Unbound_constructor of Longident.t
  | Unbound_label of Longident.t

  | Constructor_arity_mismatch of Longident.t * int * int
  | Label_mismatch of Longident.t * type_expr * type_expr
  | Pattern_type_clash of type_expr * type_expr
  | Multiply_bound_variable
  | Orpat_not_closed
  | Expr_type_clash of type_expr * type_expr
  | Apply_non_function of type_expr
  | Label_multiply_defined of Longident.t
  | Label_missing
  | Label_not_mutable of Longident.t
  | Bad_format of string
@

<<exception Typecore.Error>>=
exception Error of Location.t * error
@

<<signature Typecore.report_error>>=
val report_error: error -> unit
@


<<function Typecore.report_error>>=
let report_error = function
    Unbound_value lid ->
      print_string "Unbound value "; longident lid
  | Unbound_constructor lid ->
      print_string "Unbound constructor "; longident lid
  | Unbound_label lid ->
      print_string "Unbound label "; longident lid
  | Constructor_arity_mismatch(lid, expected, provided) ->
      open_hovbox 0;
      print_string "The constructor "; longident lid;
      print_space(); print_string "expects "; print_int expected;
      print_string " argument(s),"; print_space();
      print_string "but is here applied to "; print_int provided;
      print_string " argument(s)";
      close_box()
  | Label_mismatch(lid, actual, expected) ->
      open_hovbox 0;
      print_string "The label "; longident lid;
      print_space(); print_string "belongs to the type"; print_space();
      type_expr actual; print_space();
      print_string "but is here mixed with labels of type"; print_space();
      type_expr expected;
      close_box()
  | Pattern_type_clash(inferred, expected) ->
      open_hovbox 0;
      print_string "This pattern matches values of type"; print_space();
      type_expr inferred; print_space();
      print_string "but is here used to match values of type"; print_space();
      type_expr expected;
      close_box()
  | Multiply_bound_variable ->
      print_string "This variable is bound several times in this matching"
  | Orpat_not_closed ->
      print_string "A pattern with | must not bind variables"
  | Expr_type_clash(inferred, expected) ->
      open_hovbox 0;
      print_string "This expression has type"; print_space();
      type_expr inferred; print_space();
      print_string "but is here used with type"; print_space();
      type_expr expected;
      close_box()
  | Apply_non_function typ ->
      begin match Ctype.repr typ with
        Tarrow(_, _) ->
          print_string "This function is applied to too many arguments"
      | _ ->
          print_string "This expression is not a function, it cannot be applied"
      end
  | Label_multiply_defined lid ->
      print_string "The label "; longident lid;
      print_string " is defined several times"
  | Label_missing ->
      print_string "Some labels are undefined"
  | Label_not_mutable lid ->
      print_string "The label "; longident lid;
      print_string " is not mutable"
  | Bad_format s ->
      print_string "Bad format `"; print_string s; print_string "'"
@


\section{Compilation errors}

<<type Translcore.error>>=
type error =
    Illegal_letrec_pat
  | Illegal_letrec_expr
@

<<exception Translcore.Error>>=
exception Error of Location.t * error
@

<<signature Translcore.report_error>>=
val report_error: error -> unit
@

<<constant Translcore.report_error>>=
let report_error = function
    Illegal_letrec_pat ->
      print_string
      "Only variables are allowed as left-hand side of `let rec'"
  | Illegal_letrec_expr ->
      print_string
      "This kind of expression is not allowed as right-hand side of `let rec'"
@

\section{Linking errors}

<<type Bytelink.error>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
  | Symbol_error of string * Symtable.error
  | Inconsistent_import of string * string * string
  | Custom_runtime
  | File_exists of string
@

<<exception Bytelink.Error>>=
exception Error of error
@

<<signature Bytelink.report_error>>=
val report_error: error -> unit
@



<<constant Bytelink.report_error>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Not_an_object_file name ->
      print_string "The file "; print_string name;
      print_string " is not a bytecode object file"
  | Symbol_error(name, err) ->
      print_string "Error while linking "; print_string name; print_string ":";
      print_space();
      Symtable.report_error err
  | Inconsistent_import(intf, file1, file2) ->
      open_hvbox 0;
      print_string "Files "; print_string file1; print_string " and ";
      print_string file2; print_space();
      print_string "make inconsistent assumptions over interface ";
      print_string intf;
      close_box()
  | Custom_runtime ->
      print_string "Error while building custom runtime system"
  | File_exists file ->
      print_string "Cannot overwrite existing file "; print_string file
@





<<type Bytelibrarian.error>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
@

<<exception Bytelibrarian.Error>>=
exception Error of error
@

<<signature Bytelibrarian.report_error>>=
val report_error: error -> unit
@


<<constant Bytelibrarian.report_error>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Not_an_object_file name ->
      print_string "The file "; print_string name;
      print_string " is not a bytecode object file"
@

\chapter{Standard Library}

\section{Lists}

<<signature Misc.map_end>>=
val map_end: ('a -> 'b) -> 'a list -> 'b list -> 'b list
        (* [map_end f l t] is [map f l @ t], just more efficient. *)
@

<<signature Misc.for_all2>>=
val for_all2: ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
        (* Same as [List.for_all] but for a binary predicate. *)
@

<<signature Misc.filter>>=
val filter: ('a -> bool) -> 'a list -> 'a list
@


<<signature Misc.replicate_list>>=
val replicate_list: 'a -> int -> 'a list
        (* [replicate_list elem n] is the list with [n] elements
           all identical to [elem]. *)
@




<<function Misc.map_end>>=
let rec map_end f l1 l2 =
  match l1 with
    [] -> l2
  | hd::tl -> f hd :: map_end f tl l2
@

<<function Misc.for_all2>>=
let rec for_all2 pred l1 l2 =
  match (l1, l2) with
    ([], []) -> true
  | (hd1::tl1, hd2::tl2) -> pred hd1 hd2 & for_all2 pred tl1 tl2
  | (_, _) -> false
@

<<function Misc.filter>>=
let rec filter pred =
  function
    [] ->
      []
  | a::l ->
      if pred a then
        a::(filter pred l)
      else
        filter pred l
@

<<function Misc.replicate_list>>=
let rec replicate_list elem n =
  if n <= 0 then [] else elem :: replicate_list elem (n-1)
@

\section{Assocs}

<<signature Misc.mem_assq>>=
val mem_assq: 'a -> ('a * 'b) list -> bool
@

<<function Misc.mem_assq>>=
let rec mem_assq x = function
    [] -> false
  | (a,b)::l -> a == x or mem_assq x l
@

\section{Hashes}

<<signature Misc.create_hashtable>>=
val create_hashtable: int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
        (* Create a hashtable of the given size and fills it with the
           given bindings. *)
@

<<function Misc.create_hashtable>>=
let create_hashtable size init =
  let tbl = Hashtbl.create size in
  List.iter (fun (key, data) -> Hashtbl.add tbl key data) init;
  tbl
@

\section{Files}

<<signature Misc.find_in_path>>=
val find_in_path: string list -> string -> string
        (* Search a file in a list of directories. *)
@

<<signature Misc.remove_file>>=
val remove_file: string -> unit
        (* Delete the given file if it exists. Never raise an error. *)
@

<<signature Misc.copy_file>>=
val copy_file: in_channel -> out_channel -> unit
        (* [copy_file ic oc] reads the contents of file [ic] and copies
           them to [oc]. It stops when encountering EOF on [ic]. *)
@

<<signature Misc.copy_file_chunk>>=
val copy_file_chunk: in_channel -> out_channel -> int -> unit
        (* [copy_file_chunk ic oc n] reads [n] bytes from [ic] and copies
           them to [oc]. It raises [End_of_file] when encountering
           EOF on [ic]. *)
@



<<function Misc.find_in_path>>=
let find_in_path path name =
  if not (Filename.is_implicit name) then
    if Sys.file_exists name then name else raise Not_found
  else begin
    let rec try_dir = function
      [] -> raise Not_found
    | dir::rem ->
        let fullname = Filename.concat dir name in
        if Sys.file_exists fullname then fullname else try_dir rem
    in try_dir path
  end
@

<<function Misc.remove_file>>=
let remove_file filename =
  try
    Sys.remove filename
  with Sys_error msg ->
    ()
@


<<function Misc.copy_file>>=
let copy_file ic oc =
  let buff = String.create 0x1000 in
  let rec copy () =
    let n = input ic buff 0 0x1000 in
    if n = 0 then () else (output oc buff 0 n; copy())
  in copy()
@

<<function Misc.copy_file_chunk>>=
let copy_file_chunk ic oc len =
  let buff = String.create 0x1000 in
  let rec copy n =
    if n <= 0 then () else begin
      let r = input ic buff 0 (min n 0x1000) in
      if r = 0 then raise End_of_file else (output oc buff 0 r; copy(n-r))
    end
  in copy len
@


\section{Math}

<<signature Misc.log2>>=
val log2: int -> int
        (* [log2 n] returns [s] such that [n = 1 lsl s] 
           if [n] is a power of 2*)
@

<<signature Misc.align>>=
val align: int -> int -> int
        (* [align n a] rounds [n] upwards to a multiple of [a]
           (a power of 2). *)
@

<<signature Misc.no_overflow_add>>=
val no_overflow_add: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 + n2] does not overflow. *)
@

<<signature Misc.no_overflow_sub>>=
val no_overflow_sub: int -> int -> bool
        (* [no_overflow_add n1 n2] returns [true] if the computation of
           [n1 - n2] does not overflow. *)
@



<<function Misc.log2>>=
let rec log2 n =
  if n <= 1 then 0 else 1 + log2(n asr 1)
@

<<function Misc.align>>=
(* @Scheck: dead by nice to have *)
let align n a =
  if n >= 0 then (n + a - 1) land (-a) else n land (-a)
@

<<function Misc.no_overflow_add>>=
let no_overflow_add a b = (a lxor b) lor (a lxor (lnot (a+b))) < 0
@

<<function Misc.no_overflow_sub>>=
let no_overflow_sub a b = (a lxor (lnot b)) lor (b lxor (a-b)) < 0
@

\section{Pretty printing}

% lots of use of Format, maybe could be good to explain,
% as it's not as common as other stuff from stdlib/


\chapter{Extra Code}

\ifallcode
#include "OCaml_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

