\section{[[./utils/]]}

\subsection*{[[./utils/config.mli]]}

<<signature Config.max_tag>>=
val max_tag: int
        (* Biggest tag that can be stored in the header of a block. *)
@

<<signature Config.max_young_wosize>>=
val max_young_wosize: int
        (* Maximal size of arrays that are directly allocated in the
           minor heap *)
@

<<signature Config.architecture>>=
val architecture: string
        (* Name of processor type for the native-code compiler *)
@

<<signature Config.model>>=
val model: string
        (* Name of processor submodel for the native-code compiler *)
@

<<signature Config.system>>=
val system: string
        (* Name of operating system for the native-code compiler *)
@

<<signature Config.ext_obj>>=
val ext_obj: string
        (* Extension for object files, e.g. [.o] under Unix. *)
@

<<signature Config.ext_asm>>=
val ext_asm: string
        (* Extension for assembler files, e.g. [.s] under Unix. *)
@

<<signature Config.ext_lib>>=
val ext_lib: string
        (* Extension for library files, e.g. [.a] under Unix. *)
@


%-------------------------------------------------------------

<<./utils/config.mli>>=

<<copyright header>>

(* System configuration *)

<<signature Config.version>>

<<signature Config.standard_library>>
<<signature Config.bytecomp_c_compiler>>
<<signature Config.native_c_compiler>>
<<signature Config.native_partial_linker>>
<<signature Config.c_libraries>>
<<signature Config.ranlib>>

<<signature Config.load_path>>

<<signature Config.exec_magic_number>>
<<signature Config.cmi_magic_number>>
<<signature Config.cmo_magic_number>>
<<signature Config.cma_magic_number>>
<<signature Config.cmx_magic_number>>
<<signature Config.cmxa_magic_number>>
<<signature Config.ast_intf_magic_number>>
<<signature Config.ast_impl_magic_number>>

<<signature Config.max_tag>>
<<signature Config.max_young_wosize>>
<<signature Config.architecture>>
<<signature Config.model>>
<<signature Config.system>>

<<signature Config.ext_obj>>
<<signature Config.ext_asm>>
<<signature Config.ext_lib>>
@


\subsection*{[[./utils/misc.mli]]}


%-------------------------------------------------------------

<<./utils/misc.mli>>=
<<copyright header>>

(* Miscellaneous useful types and functions *)

<<signature Misc.fatal_error>>
<<exception Misc.Fatal_error>>

<<signature Misc.map_end>>
<<signature Misc.for_all2>>
<<signature Misc.filter>>
<<signature Misc.mem_assq>>
<<signature Misc.replicate_list>>

<<signature Misc.find_in_path>>
<<signature Misc.remove_file>>

<<signature Misc.create_hashtable>>

<<signature Misc.copy_file>>
<<signature Misc.copy_file_chunk>>

<<signature Misc.log2>>
<<signature Misc.align>>
<<signature Misc.no_overflow_add>>
<<signature Misc.no_overflow_sub>>
@


\subsection*{[[./utils/misc.ml]]}



%-------------------------------------------------------------

<<./utils/misc.ml>>=
<<copyright header>>

(* Errors *)

<<exception Misc.Fatal_error>>

<<function Misc.fatal_error>>

(* List functions *)

<<function Misc.map_end>>

<<function Misc.for_all2>>

<<function Misc.filter>>

<<function Misc.mem_assq>>

<<function Misc.replicate_list>>

(* File functions *)

<<function Misc.find_in_path>>

<<function Misc.remove_file>>

(* Hashtable functions *)

<<function Misc.create_hashtable>>

<<function Misc.copy_file>>

<<function Misc.copy_file_chunk>>

(* Integer operations *)

<<function Misc.log2>>

<<function Misc.align>>

<<function Misc.no_overflow_add>>

<<function Misc.no_overflow_sub>>

@


\subsection*{[[./utils/tbl.mli]]}

<<signature Tbl.empty>>=
val empty: ('a, 'b) t
@

<<signature Tbl.add>>=
val add: 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t
@

<<signature Tbl.find>>=
val find: 'a -> ('a, 'b) t -> 'b
@

<<signature Tbl.remove>>=
val remove: 'a -> ('a,  'b) t -> ('a, 'b) t
@

<<signature Tbl.iter>>=
val iter: ('a -> 'b -> 'c) -> ('a, 'b) t -> unit
@

<<signature Tbl.print>>=
val print: ('a -> unit) -> ('b -> unit) -> ('a, 'b) t -> unit
@


%-------------------------------------------------------------

<<./utils/tbl.mli>>=
<<copyright header>>

(* Association tables from any ordered type to any type.
   We use the generic ordering to compare keys. *)

type ('a, 'b) t

<<signature Tbl.empty>>
<<signature Tbl.add>>
<<signature Tbl.find>>
<<signature Tbl.remove>>
<<signature Tbl.iter>>

<<signature Tbl.print>>
@


\subsection*{[[./utils/tbl.ml]]}

% lol, can now use Map :)

<<type Tbl.t>>=

type ('a, 'b) t =
    Empty
  | Node of ('a, 'b) t * 'a * 'b * ('a, 'b) t * int
@

<<constant Tbl.empty>>=
let empty = Empty
@

<<constant Tbl.height>>=
let height = function
    Empty -> 0
  | Node(_,_,_,_,h) -> h
@

<<function Tbl.create>>=
let create l x d r =
  let hl = height l and hr = height r in
  Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))
@

<<function Tbl.bal>>=
let bal l x d r =
  let hl = height l and hr = height r in
  if hl > hr + 1 then
    match l with
    | Node (ll, lv, ld, lr, _) when height ll >= height lr ->
        create ll lv ld (create lr x d r)
    | Node (ll, lv, ld, Node (lrl, lrv, lrd, lrr, _), _) ->
        create (create ll lv ld lrl) lrv lrd (create lrr x d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rv, rd, rr, _) when height rr >= height rl ->
        create (create l x d rl) rv rd rr
    | Node (Node (rll, rlv, rld, rlr, _), rv, rd, rr, _) ->
        create (create l x d rll) rlv rld (create rlr rv rd rr)
    | _ -> assert false
  else
    create l x d r
@

<<function Tbl.add>>=
let rec add x data = function
    Empty ->
      Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) as t ->
      let c = compare x v in
      if c = 0 then
        Node(l, x, data, r, h)
      else if c < 0 then
        bal (add x data l) v d r
      else
        bal l v d (add x data r)
@

<<function Tbl.find>>=
let rec find x = function
    Empty ->
      raise Not_found
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      if c = 0 then d
      else find x (if c < 0 then l else r)
@

<<function Tbl.merge>>=
let rec merge t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (Node(l1, v1, d1, r1, h1), Node(l2, v2, d2, r2, h2)) ->
      bal l1 v1 d1 (bal (merge r1 l2) v2 d2 r2)
@

<<function Tbl.remove>>=
let rec remove x = function
    Empty ->
      Empty
  | Node(l, v, d, r, h) as t ->
      let c = compare x v in
      if c = 0 then
        merge l r
      else if c < 0 then
        bal (remove x l) v d r
      else
        bal l v d (remove x r)
@

<<function Tbl.iter>>=
let rec iter f = function
    Empty -> ()
  | Node(l, v, d, r, _) ->
      iter f l; f v d; iter f r
@

<<function Tbl.print>>=
(* @Scheck: dumper *)
let print print_key print_data tbl =
  open_hvbox 2;
  print_string "[[";
  iter (fun k d ->
          open_box 2;
          print_key k; print_string " ->"; print_space();
          print_data d; print_string ";";
          close_box(); print_space())
        tbl;
  print_string "]]";
  close_box()
@


%-------------------------------------------------------------

<<./utils/tbl.ml>>=
<<copyright header>>
<<type Tbl.t>>

<<constant Tbl.empty>>

<<constant Tbl.height>>

<<function Tbl.create>>

<<function Tbl.bal>>

<<function Tbl.add>>

<<function Tbl.find>>

<<function Tbl.merge>>

<<function Tbl.remove>>

<<function Tbl.iter>>

open Format

<<function Tbl.print>>
@


\subsection*{[[./utils/terminfo.mli]]}


%-------------------------------------------------------------

<<./utils/terminfo.mli>>=
<<copyright header>>

(* Basic interface to the terminfo database *)

external setupterm: unit -> unit = "terminfo_setup"
external getstr: string -> string = "terminfo_getstr"
external getnum: string -> int = "terminfo_getnum"
external puts: out_channel -> string -> int -> unit = "terminfo_puts"

@


\subsection*{[[./utils/terminfo.ml]]}


%-------------------------------------------------------------

<<./utils/terminfo.ml>>=
<<copyright header>>

(* Basic interface to the terminfo database *)

external setupterm: unit -> unit = "terminfo_setup"
external getstr: string -> string = "terminfo_getstr"
external getnum: string -> int = "terminfo_getnum"
external puts: out_channel -> string -> int -> unit = "terminfo_puts"

@


\subsection*{[[./utils/clflags.ml]]}



%-------------------------------------------------------------

<<./utils/clflags.ml>>=
<<copyright header>>

(* Command-line parameters *)

<<constant Clflags.objfiles>>
<<constant Clflags.ccobjs>>
<<constant Clflags.compile_only>>
<<constant Clflags.exec_name>>
<<constant Clflags.archive_name>>
<<constant Clflags.object_name>>
<<constant Clflags.include_dirs>>
<<constant Clflags.print_types>>
<<constant Clflags.make_archive>>
<<constant Clflags.debug>>
<<constant Clflags.fast>>
<<constant Clflags.link_everything>>
<<constant Clflags.custom_runtime>>
<<constant Clflags.output_c_object>>
<<constant Clflags.ccopts>>
<<constant Clflags.nopervasives>>
<<constant Clflags.preprocessor>>
<<constant Clflags.thread_safe>>
<<constant Clflags.noassert>>
<<constant Clflags.verbose>>

<<constant Clflags.dump_rawlambda>>
<<constant Clflags.dump_lambda>>
<<constant Clflags.dump_instr>>

<<constant Clflags.keep_asm_file>>
<<constant Clflags.optimize_for_speed>>

<<constant Clflags.dump_cmm>>
<<constant Clflags.dump_selection>>
<<constant Clflags.dump_live>>
<<constant Clflags.dump_spill>>
<<constant Clflags.dump_split>>
<<constant Clflags.dump_scheduling>>
<<constant Clflags.dump_interf>>
<<constant Clflags.dump_prefer>>
<<constant Clflags.dump_regalloc>>
<<constant Clflags.dump_reload>>
<<constant Clflags.dump_linear>>
<<constant Clflags.keep_startup_file>>

<<constant Clflags.native_code>>

<<constant Clflags.inline_threshold>>
@


\subsection*{[[./utils/ccomp.mli]]}



%-------------------------------------------------------------

<<./utils/ccomp.mli>>=
<<copyright header>>

(* Compiling C files and building C libraries *)

<<signature Ccomp.command>>
<<signature Ccomp.compile_file_bytecode>>
<<signature Ccomp.compile_file_native>>
<<signature Ccomp.create_archive>>
@


\subsection*{[[./utils/ccomp.ml]]}

%-------------------------------------------------------------

<<./utils/ccomp.ml>>=
<<copyright header>>

(* Compiling C files and building C libraries *)

<<function Ccomp.command>>

<<function Ccomp.compile_file_bytecode>>

<<function Ccomp.compile_file_native>>

<<function Ccomp.create_archive>>
@


\section{[[./parsing/]]}

\subsection*{[[./parsing/asttypes.mli]]}



%-------------------------------------------------------------

<<./parsing/asttypes.mli>>=
<<copyright header>>

(* Auxiliary a.s.t. types used by parsetree and typedtree. *)

<<type Asttypes.constant>>

<<type Asttypes.rec_flag>>

<<type Asttypes.direction_flag>>

<<type Asttypes.mutable_flag>>
@


\subsection*{[[./parsing/linenum.mli]]}



%-------------------------------------------------------------

<<./parsing/linenum.mli>>=
<<copyright header 1997>>

<<signature Linenum.for_position>>
@

\subsection*{[[./parsing/longident.mli]]}


%-------------------------------------------------------------

<<./parsing/longident.mli>>=
<<copyright header>>

<<type Longident.t>>
@


\subsection*{[[./parsing/longident.ml]]}


%-------------------------------------------------------------

<<./parsing/longident.ml>>=
<<copyright header>>

<<type Longident.t>>
@


\subsection*{[[./parsing/location.mli]]}



%-------------------------------------------------------------

<<./parsing/location.mli>>=
<<copyright header>>

<<type Location.t>>

<<signature Location.none>>
<<signature Location.symbol_loc>>
<<signature Location.rhs_loc>>

<<signature Location.input_name>>
<<signature Location.input_lexbuf>>

<<signature Location.print>>
<<signature Location.print_warning>>
<<signature Location.echo_eof>>
<<signature Location.reset>>

<<signature Location.highlight_locations>>
@


\subsection*{[[./parsing/location.ml]]}



<<type Location.terminal_info_status>>=
(* Terminal info *)

type terminal_info_status = Unknown | Bad_term | Good_term
@

<<function Location.setup_terminal_info>>=
let setup_terminal_info() =
  try
    Terminfo.setupterm();
    num_lines := Terminfo.getnum "li";
    cursor_up := Terminfo.getstr "up";
    cursor_down := Terminfo.getstr "do";
    begin try
      start_standout := Terminfo.getstr "us";
      end_standout := Terminfo.getstr "ue"
    with Not_found ->
      start_standout := Terminfo.getstr "so";
      end_standout := Terminfo.getstr "se"
    end;
    status := Good_term
  with _ ->
    status := Bad_term
@

<<constant Location.num_loc_lines>>=
(* Print the location using standout mode. *)

let num_loc_lines = ref 0 (* number of lines already printed after input *)
@

<<signature Location.highlight_locations>>=
val highlight_locations: t -> t -> bool
@

<<signature Location.input_lexbuf>>=
val input_lexbuf: Lexing.lexbuf option ref
@

<<constant Location.input_lexbuf>>=
let input_lexbuf = ref (None : lexbuf option)
@


<<function Location.highlight_locations>>=
let rec highlight_locations loc1 loc2 =
  match !status with
    Unknown ->
      setup_terminal_info(); highlight_locations loc1 loc2
  | Bad_term ->
      false
  | Good_term ->
      match !input_lexbuf with
        None -> false
      | Some lb ->
          (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
          let pos0 = -lb.lex_abs_pos in
          (* Do nothing if the buffer does not contain the whole phrase. *)
          if pos0 < 0 then false else begin
            (* Count number of lines in phrase *)
            let lines = ref !num_loc_lines in
            for i = pos0 to String.length lb.lex_buffer - 1 do
              if lb.lex_buffer.[i] = '\n' then incr lines
            done;
            (* If too many lines, give up *)
            if !lines >= !num_lines - 2 then false else begin
              (* Move cursor up that number of lines *)
              for i = 1 to !lines do
                Terminfo.puts stdout !cursor_up 1
              done;
              (* Print the input, switching to standout for the location *)
              let bol = ref false in
          print_string "# ";
              for pos = 0 to String.length lb.lex_buffer - pos0 - 1 do
                if !bol then (print_string "  "; bol := false);
                if pos = loc1.loc_start || pos = loc2.loc_start then
                  Terminfo.puts stdout !start_standout 1;
                if pos = loc1.loc_end || pos = loc2.loc_end then
                  Terminfo.puts stdout !end_standout 1;
                let c = lb.lex_buffer.[pos + pos0] in
                print_char c;
                bol := (c = '\n')
              done;
              (* Make sure standout mode is over *)
              Terminfo.puts stdout !end_standout 1;
              (* Position cursor back to original location *)
              for i = 1 to !num_loc_lines do
                Terminfo.puts stdout !cursor_down 1
              done;
              true
            end
          end
@

<<signature Location.reset>>=
val reset: unit -> unit
@

<<function Location.reset>>=
let reset () =
  num_loc_lines := 0
@


<<signature Location.echo_eof>>=
val echo_eof: unit -> unit
@

<<function Location.echo_eof>>=
let echo_eof () =
  print_newline ();
  incr num_loc_lines
@


%-------------------------------------------------------------

<<./parsing/location.ml>>=
<<copyright header>>

open Lexing

<<type Location.t>>

<<constant Location.none>>

<<function Location.symbol_loc>>

<<function Location.rhs_loc>>

<<constant Location.input_name>>

<<constant Location.input_lexbuf>>

<<type Location.terminal_info_status>>

let status = ref Unknown
and num_lines = ref 0
and cursor_up = ref ""
and cursor_down = ref ""
and start_standout = ref ""
and end_standout = ref ""

<<function Location.setup_terminal_info>>

<<constant Location.num_loc_lines>>

<<function Location.highlight_locations>>

(* Print the location in some way or another *)

open Format

<<function Location.reset>>

<<constants Location.msg_xxx>>

<<function Location.print>>

<<function Location.print_warning>>

<<function Location.echo_eof>>

@


\subsection*{[[./parsing/syntaxerr.mli]]}


%-------------------------------------------------------------

<<./parsing/syntaxerr.mli>>=
<<copyright header 1997>>

<<type Syntaxerr.error>>

<<exception Syntaxerr.Error>>
<<exception Syntaxerr.Escape_error>>

<<signature Syntaxerr.report_error>>
@

\subsection*{[[./parsing/syntaxerr.ml]]}



%-------------------------------------------------------------

<<./parsing/syntaxerr.ml>>=
<<copyright header 1997>>

(* Auxiliary type for reporting syntax errors *)

open Format

<<type Syntaxerr.error>>

<<exception Syntaxerr.Error>>
<<exception Syntaxerr.Escape_error>>

<<function Syntaxerr.report_error>>

@


\subsection*{[[./parsing/parsetree.mli]]}


%-------------------------------------------------------------

<<./parsing/parsetree.mli>>=
<<copyright header>>

(* Abstract syntax tree produced by parsing *)

open Asttypes

(* Type expressions for the core language *)

<<type Parsetree.core_type>>

<<type Parsetree.core_type_desc>>

(* Value expressions for the core language *)

<<type Parsetree.pattern>>

<<type Parsetree.pattern_desc>>

<<type Parsetree.expression>>

<<type Parsetree.expression_desc>>

<<type Parsetree.value_description>>

(* Type declarations *)

<<type Parsetree.type_declaration>>

<<type Parsetree.type_kind>>

<<type Parsetree.exception_declaration>>

(* Type expressions for the module language *)

<<type Parsetree.module_type>>

<<type Parsetree.module_type_desc>>


<<type Parsetree.signature>>

<<type Parsetree.signature_item>>

<<type Parsetree.signature_item_desc>>

(* Value expressions for the module language *)

<<type Parsetree.module_expr>>

<<type Parsetree.module_expr_desc>>

<<type Parsetree.structure>>

<<type Parsetree.structure_item>>

<<type Parsetree.structure_item_desc>>

(* Toplevel phrases *)

<<type Parsetree.toplevel_phrase>>

<<type Parsetree.directive_argument>>
@




\subsection*{[[./parsing/lexer.mll]]}



\subsection*{[[./parsing/parser.mly]]}




\subsection*{[[./parsing/lexer.mli]]}


%-------------------------------------------------------------

<<./parsing/lexer.mli>>=
<<copyright header>>

<<signature Lexer.token>>

<<type Lexer.error>>

<<exception Lexer.Error>>

<<signature Lexer.report_error>>

@


\subsection*{[[./parsing/parse.mli]]}


%-------------------------------------------------------------

<<./parsing/parse.mli>>=
<<copyright header>>

(* Entry points in the parser *)

<<signature Parse.implementation>>
<<signature Parse.interface>>
<<signature Parse.toplevel_phrase>>
<<signature Parse.use_file>>

@


\subsection*{[[./parsing/parse.ml]]}

%-------------------------------------------------------------

<<./parsing/parse.ml>>=
<<copyright header>>

(* Entry points in the parser *)

open Location

<<function Parse.skip_phrase>>

<<function Parse.maybe_skip_phrase>>

<<function Parse.wrap>>

<<function Parse.implementation>>
<<function Parse.interface>>

<<function Parse.xxx>>
@


\section{[[./typing/]]}

\subsection*{[[./typing/ident.mli]]}














% todo, again replace with Map?
<<signature Ident.empty>>=
val empty: 'a tbl
@

<<signature Ident.add>>=
val add: t -> 'a -> 'a tbl -> 'a tbl
@

<<signature Ident.find_same>>=
val find_same: t -> 'a tbl -> 'a
@

<<signature Ident.find_name>>=
val find_name: string -> 'a tbl -> 'a
@

<<signature Ident.print_tbl>>=
val print_tbl: ('a -> unit) -> 'a tbl -> unit
@


%-------------------------------------------------------------

<<./typing/ident.mli>>=
<<copyright header0>>

(* Identifiers (unique names) *)

type t

<<signature Ident.create>>
<<signature Ident.create_persistent>>
<<signature Ident.name>>
<<signature Ident.unique_name>>
<<signature Ident.persistent>>
<<signature Ident.same>>
<<signature Ident.identify>>
<<signature Ident.hide>>

<<signature Ident.make_global>>
<<signature Ident.global>>

<<signature Ident.print>>

type 'a tbl
        (* Association tables from identifiers to type 'a. *)

<<signature Ident.empty>>
<<signature Ident.add>>
<<signature Ident.find_same>>
<<signature Ident.find_name>>

<<signature Ident.print_tbl>>

@


\subsection*{[[./typing/ident.ml]]}


%<<signature Ident.equal>>=
%val equal: t -> t -> bool
%        (* Compare identifiers by name. *)      
%@
%<<function Ident.equal>>=
%let equal i1 i2 = 
%  i1.name = i2.name
%@



<<type Ident.tbl>>=
type 'a tbl =
    Empty
  | Node of 'a tbl * 'a data * 'a tbl * int
@

<<type Ident.data>>=
and 'a data =
  { ident: t;
    data: 'a;
    previous: 'a data option }
@

<<constant Ident.empty>>=
let empty = Empty
@

<<function Ident.mknode>>=
(* Inline expansion of height for better speed
 * let height = function
 *     Empty -> 0
 *   | Node(_,_,_,h) -> h
 *)

let mknode l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))
@

<<function Ident.balance>>=
let balance l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 1 then
    let (Node(ll, ld, lr, _)) = l in
    if (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
       (match lr with Empty -> 0 | Node(_,_,_,h) -> h) then
      mknode ll ld (mknode lr d r)
    else
      let (Node(lrl, lrd, lrr, _)) = lr in
      mknode (mknode ll ld lrl) lrd (mknode lrr d r)
  else if hr > hl + 1 then
    let (Node(rl, rd, rr, _)) = r in
    if (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
       (match rl with Empty -> 0 | Node(_,_,_,h) -> h) then
      mknode (mknode l d rl) rd rr
    else
      let (Node(rll, rld, rlr, _)) = rl in
      mknode (mknode l d rll) rld (mknode rlr rd rr)
  else
    mknode l d r
@

<<function Ident.add>>=
let rec add id data = function
    Empty ->
      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
  | Node(l, k, r, h) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        Node(l, {ident = id; data = data; previous = Some k}, r, h)
      else if c < 0 then
        balance (add id data l) k r
      else
        balance l k (add id data r)
@

<<function Ident.find_stamp>>=
let rec find_stamp s = function
    None ->
      raise Not_found
  | Some k ->
      if k.ident.stamp = s then k.data else find_stamp s k.previous
@

<<function Ident.find_same>>=
let rec find_same id = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        if id.stamp = k.ident.stamp
        then k.data
        else find_stamp id.stamp k.previous
      else
        find_same id (if c < 0 then l else r)
@

<<function Ident.find_name>>=
let rec find_name name = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data
      else
        find_name name (if c < 0 then l else r)
@

<<function Ident.print_tbl>>=
let print_tbl print_elt tbl =
  open_hovbox 2;
  print_string "[[";
  let rec print_tbl = function
      Empty -> ()
    | Node(l, k, r, _) ->
        print_tbl l;
        print_entry k;
        print_tbl r
  and print_entry k =
    open_hovbox 2;
    print k.ident; print_string " ->"; print_space(); print_elt k.data;
    print_string ";"; close_box(); print_space();
    match k.previous with None -> () | Some k -> print_entry k in
  print_tbl tbl;
  print_string "]]";
  close_box()
@

<<signature Ident.print>>=
val print: t -> unit
@
<<function Ident.print>>=
let print i =
  print_string i.name;
  match i.stamp with
    0 -> print_string "!"
  | -1 -> print_string "#"
  | n -> print_string "/"; print_int n; if i.global then print_string "g"
@


%<<signature Ident.current_time>>=
%val current_time: unit -> int
%@
%% ???
%
%<<function Ident.current_time>>=
%let current_time _ = 1
%@
% ???

%-------------------------------------------------------------

<<./typing/ident.ml>>=
<<copyright header0>>

open Format

<<type Ident.t>>

<<constant Ident.currentstamp>>

<<function Ident.create>>

<<function Ident.create_persistent>>

<<function Ident.name>>

<<function Ident.unique_name>>

<<function Ident.persistent>>

<<function Ident.same>>

<<function Ident.identify>>

<<function Ident.hide>>

<<function Ident.make_global>>

<<function Ident.global>>

<<function Ident.print>>

<<type Ident.tbl>>

<<type Ident.data>>

<<constant Ident.empty>>

<<function Ident.mknode>>

<<function Ident.balance>>

<<function Ident.add>>

<<function Ident.find_stamp>>

<<function Ident.find_same>>

<<function Ident.find_name>>

<<function Ident.print_tbl>>

@


\subsection*{[[./typing/primitive.mli]]}


%-------------------------------------------------------------

<<./typing/primitive.mli>>=
<<copyright header0>>


<<type Primitive.description>>

<<signature Primitive.parse_declaration>>
<<signature Primitive.print_description>>
@


\subsection*{[[./typing/primitive.ml]]}



%-------------------------------------------------------------

<<./typing/primitive.ml>>=
<<copyright header0>>

(* Description of primitive functions *)

open Format

<<type Primitive.description>>

<<function Primitive.parse_declaration>>

<<function Primitive.print_quoted>>

<<function Primitive.print_description>>
@


\subsection*{[[./typing/path.mli]]}


%-------------------------------------------------------------

<<./typing/path.mli>>=
<<copyright header0>>

<<type Path.t>>

<<signature Path.same>>
<<signature Path.isfree>>

<<signature Path.nopos>>
@


\subsection*{[[./typing/path.ml]]}


%-------------------------------------------------------------

<<./typing/path.ml>>=
<<copyright header0>>

<<type Path.t>>

<<constant Path.nopos>>

<<function Path.same>>

<<function Path.isfree>>
@


\subsection*{[[./typing/types.ml]]}



%-------------------------------------------------------------

<<./typing/types.ml>>=
<<copyright header0>>

open Asttypes

(* Type expressions for the core language *)

<<type Types.type_expr>>

<<type Types.type_variable>>

<<type Types.value_description>>

(* Constructor descriptions *)

<<type Types.constructor_description>>

<<type Types.constructor_tag>>

(* Record label descriptions *)

<<type Types.label_description>>

<<type Types.record_representation>>

(* Type definitions *)

<<type Types.type_declaration>>

<<type Types.type_kind>>

<<type Types.exception_declaration>>

(* Type expressions for the module language *)

<<type Types.module_type>>

<<type Types.signature>>

<<type Types.signature_item>>
@


\subsection*{[[./typing/subst.mli]]}



%-------------------------------------------------------------

<<./typing/subst.mli>>=
<<copyright header0>>

(* Substitutions *)

open Types

type t

<<signature Subst.identity>>

<<signature Subst.add_type>>
<<signature Subst.add_module>>
<<signature Subst.add_modtype>>

<<signature Subst.type_expr>>
<<signature Subst.value_description>>
<<signature Subst.type_declaration>>
<<signature Subst.exception_declaration>>
<<signature Subst.modtype>>
<<signature Subst.signature>>

@


\subsection*{[[./typing/subst.ml]]}


%-------------------------------------------------------------

<<./typing/subst.ml>>=
<<copyright header0>>

(* Substitutions *)

open Misc
open Path
open Types


<<type Subst.t>>

<<constant Subst.identity>>

<<function Subst.add_type>>

<<function Subst.add_module>>

<<function Subst.add_modtype>>

<<function Subst.module_path>>

<<function Subst.type_path>>

<<function Subst.type_expr>>

<<function Subst.value_description>>

<<function Subst.type_declaration>>

<<function Subst.exception_declaration>>

<<function Subst.modtype>>

@


\subsection*{[[./typing/predef.mli]]}

%-------------------------------------------------------------

<<./typing/predef.mli>>=
<<copyright header0>>

(* Predefined type constructors (with special typing rules in typecore) *)

open Types

<<signatures Predef.type_xxx>>

<<signatures Predef.path_xxx>>

<<signature Predef.path_match_failure>>

<<signature Predef.build_initial_env>>

<<signature Predef.builtin_values>>
@


\subsection*{[[./typing/predef.ml]]}


%-------------------------------------------------------------

<<./typing/predef.ml>>=
<<copyright header0>>

(* Predefined type constructors (with special typing rules in typecore) *)

open Path
open Types


<<constants Predef.ident_xxx>>
<<constants Predef.path_xxx>>

<<constants Predef.type_xxx>>


<<constants Predef.ident_exn_xxx>>

<<constant Predef.path_match_failure>>

<<function Predef.build_initial_env>>

<<constant Predef.builtin_values>>
@


\subsection*{[[./typing/datarepr.mli]]}

%-------------------------------------------------------------

<<./typing/datarepr.mli>>=
<<copyright header0>>

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types

<<signature Datarepr.constructor_descrs>>
<<signature Datarepr.exception_descr>>
<<signature Datarepr.label_descrs>>
@


\subsection*{[[./typing/datarepr.ml]]}



%-------------------------------------------------------------

<<./typing/datarepr.ml>>=
<<copyright header0>>

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Misc
open Asttypes
open Types

<<function Datarepr.constructor_descrs>>

<<function Datarepr.exception_descr>>

<<constant Datarepr.dummy_label>>

<<function Datarepr.is_float>>

<<function Datarepr.label_descrs>>
@


\subsection*{[[./typing/env.mli]]}


%<<type Env.summary>>=
%@
% was for debugger, but deleted for now
%
%<<signature Env.summary>>=
%@


%-------------------------------------------------------------

<<./typing/env.mli>>=
<<copyright header0>>

(* Environment handling *)

open Types

<<signature type Env.t>>

<<signature Env.empty>>
<<signature Env.initial>>

<<signature Env.find_value>>
<<signature Env.find_type>>

<<signature Env.lookup_value>>
<<signature Env.lookup_constructor>>
<<signature Env.lookup_label>>
<<signature Env.lookup_type>>
<<signature Env.lookup_module>>

(* Insertion by identifier *)

<<signature Env.add_value>>
<<signature Env.add_type>>
<<signature Env.add_exception>>
<<signature Env.add_module>>

<<signature Env.add_signature>>

<<signature Env.open_signature>>
<<signature Env.open_pers_signature>>

(* Insertion by name *)

<<signature Env.enter_value>>
<<signature Env.enter_type>>
<<signature Env.enter_exception>>
<<signature Env.enter_module>>

<<signature Env.reset_cache>>

<<signature Env.read_signature>>
<<signature Env.save_signature>>

<<signature Env.imported_units>>

<<type Env.error>>

<<exception Env.Error>>

<<signature Env.report_error>>

<<signature Env.check_modtype_inclusion>>

@


\subsection*{[[./typing/env.ml]]}



%-------------------------------------------------------------

<<./typing/env.ml>>=
<<copyright header0>>

(* Environment handling *)

open Format
open Config
open Misc
open Asttypes
open Longident
open Path
open Types


<<type Env.error>>

<<exception Env.Error>>


<<type Env.t>>

<<type Env.module_components>>

<<type Env.structure_components>>



<<constant Env.empty>>

<<type Env.pers_struct>>

<<constant Env.persistent_structures>>

<<constant Env.imported_units>>

<<function Env.read_pers_struct>>

<<function Env.find_pers_struct>>

<<function Env.reset_cache>>

<<constant Env.check_modtype_inclusion>>

<<function Env.find_module_descr>>

<<function Env.find>>

<<function Env.find_value>>
<<function Env.find_type>>


(* Lookup by name *)

<<function Env.lookup_module_descr>>

<<function Env.lookup_module>>


<<function Env.lookup>>

<<function Env.lookup_simple>>

<<function Env.lookup_value>>
<<function Env.lookup_type>>

<<function Env.lookup_constructor>>
<<function Env.lookup_label>>

<<function Env.scrape_modtype>>

<<function Env.constructors_of_type>>

<<function Env.labels_of_type>>

<<function Env.prefix_idents>>

(* Compute structure descriptions *)

<<function Env.components_of_module>>

(* Insertion of bindings by identifier + path *)

<<function Env.store_value>>

<<function Env.store_type>>

<<function Env.store_exceptions>>

<<function Env.store_module>>

<<function Env.store_components>>


(* Insertion of bindings by identifier *)

<<function Env.add_value>>
<<function Env.add_type>>
<<function Env.add_exception>>
<<function Env.add_module>>


<<function Env.enter>>

<<functions Env.enter_xxx>>

<<function Env.add_signature_component>>

<<function Env.add_signature>>

<<function Env.open_signature>>

<<function Env.open_pers_signature>>

<<function Env.read_signature>>

<<function Env.save_signature>>

<<constant Env.initial>>

<<function Env.imported_units>>

<<function Env.report_error>>
@


\subsection*{[[./typing/typedtree.mli]]}


%-------------------------------------------------------------

<<./typing/typedtree.mli>>=
<<copyright header0>>

(* Abstract syntax tree after typing *)

open Asttypes
open Types

(* Value expressions for the core language *)

<<type Typedtree.pattern>>

<<type Typedtree.pattern_desc>>

<<type Typedtree.expression>>

<<type Typedtree.expression_desc>>

(* Value expressions for the module language *)

<<type Typedtree.module_expr>>

<<type Typedtree.module_expr_desc>>

<<type Typedtree.structure>>

<<type Typedtree.structure_item>>

<<type Typedtree.module_coercion>>

<<signature Typedtree.pat_bound_idents>>
<<signature Typedtree.let_bound_idents>>
<<signature Typedtree.rev_let_bound_idents>>
@


\subsection*{[[./typing/typedtree.ml]]}


<<signature Typedtree.pat_bound_idents>>=
(* Auxiliary functions over the a.s.t. *)

val pat_bound_idents: pattern -> Ident.t list
@

<<signature Typedtree.let_bound_idents>>=
val let_bound_idents: (pattern * expression) list -> Ident.t list
@

<<signature Typedtree.rev_let_bound_idents>>=
val rev_let_bound_idents: (pattern * expression) list -> Ident.t list
@

<<constant Typedtree.idents>>=
(* List the identifiers bound by a pattern or a let *)

let idents = ref([]: Ident.t list)
@

<<function Typedtree.bound_idents>>=
let rec bound_idents pat =
  match pat.pat_desc with
    Tpat_any -> ()
  | Tpat_var id -> idents := id :: !idents
  | Tpat_alias(p, id) -> bound_idents p; idents := id :: !idents
  | Tpat_constant cst -> ()
  | Tpat_tuple patl -> List.iter bound_idents patl
  | Tpat_construct(cstr, patl) -> List.iter bound_idents patl
  | Tpat_record lbl_pat_list ->
      List.iter (fun (lbl, pat) -> bound_idents pat) lbl_pat_list
  | Tpat_or(p1, p2) -> bound_idents p1; bound_idents p2
@

<<function Typedtree.pat_bound_idents>>=
let pat_bound_idents pat =
  idents := []; bound_idents pat; let res = !idents in idents := []; res
@

<<function Typedtree.rev_let_bound_idents>>=
let rev_let_bound_idents pat_expr_list =
  idents := [];
  List.iter (fun (pat, expr) -> bound_idents pat) pat_expr_list;
  let res = !idents in idents := []; res
@

<<function Typedtree.let_bound_idents>>=
let let_bound_idents pat_expr_list =
  List.rev(rev_let_bound_idents pat_expr_list)
@


%-------------------------------------------------------------

<<./typing/typedtree.ml>>=
<<copyright header0>>

(* Abstract syntax tree after typing *)

open Misc
open Asttypes
open Types

(* Value expressions for the core language *)

<<type Typedtree.pattern>>

<<type Typedtree.pattern_desc>>

<<type Typedtree.expression>>

<<type Typedtree.expression_desc>>


(* Value expressions for the module language *)

<<type Typedtree.module_expr>>

<<type Typedtree.module_expr_desc>>

<<type Typedtree.structure>>

<<type Typedtree.structure_item>>

<<type Typedtree.module_coercion>>

(* Auxiliary functions over the a.s.t. *)

<<constant Typedtree.idents>>

<<function Typedtree.bound_idents>>

<<function Typedtree.pat_bound_idents>>

<<function Typedtree.rev_let_bound_idents>>

<<function Typedtree.let_bound_idents>>
      
@


\subsection*{[[./typing/ctype.mli]]}




<<signature Ctype.moregeneral>>=
val moregeneral: Env.t -> type_expr -> type_expr -> bool
        (* Check if the first type scheme is more general than the second. *)
@

<<signature Ctype.equal>>=
val equal: Env.t -> type_expr list -> type_expr ->
                       type_expr list -> type_expr -> bool
        (* [equal env [x1...xn] tau [y1...yn] sigma]
           checks whether the parameterized types
           [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
@

<<signature Ctype.closed_schema>>=
val closed_schema: type_expr -> bool
        (* Check whether the given type scheme contains no non-generic
           type variables *)
@

<<signature Ctype.nondep_type>>=
val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
        (* Return a type equivalent to the given type but without
           references to the given module identifier. Raise [Not_found]
           if no such type exists. *)
@


<<signature Ctype.is_generic>>=
val is_generic: type_expr -> bool
        (* Test whether the given type variable is generic *)
@

<<signature Ctype.arity>>=
val arity: type_expr -> int
        (* Return the arity (as for curried functions) of the given type. *)
@







%-------------------------------------------------------------

<<./typing/ctype.mli>>=
<<copyright header0>>

(* Operations on core types *)

open Types

<<signature Ctype.begin_def>>
<<signature Ctype.end_def>>
<<signature Ctype.reset_def>>
<<signature Ctype.newvar>>
<<signature Ctype.new_global_var>>
<<signature Ctype.repr>>
<<signature Ctype.generalize>>
<<signature Ctype.make_nongen>>
<<signature Ctype.instance>>
<<signature Ctype.instance_constructor>>
<<signature Ctype.instance_label>>
<<signature Ctype.unify>>
<<signature Ctype.filter_arrow>>
<<signature Ctype.moregeneral>>
<<signature Ctype.equal>>
<<signature Ctype.closed_schema>>
<<signature Ctype.nondep_type>>
<<signature Ctype.free_type_ident>>
<<signature Ctype.is_generic>>
<<signature Ctype.arity>>
<<signature Ctype.none>>
<<signature Ctype.substitute>>

<<exception Ctype.Unify>>

@


\subsection*{[[./typing/ctype.ml]]}




<<signature Path.isfree>>=
val isfree: Ident.t -> t -> bool
@

<<function Path.isfree>>=
let rec isfree id = function
    Pident id' -> Ident.same id id'
  | Pdot(p, s, pos) -> isfree id p
@

<<function Ctype.nondep_type>>=
(* Remove dependencies *)

let rec nondep_type env id ty =
  match repr ty with
    Tvar v as tvar -> tvar
  | Tarrow(t1, t2) ->
      Tarrow(nondep_type env id t1, nondep_type env id t2)
  | Ttuple tl ->
      Ttuple(List.map (nondep_type env id) tl)
  | Tconstr(p, tl) ->
      if Path.isfree id p then begin
        let ty' =
          try
            expand_abbrev env p tl
          with Cannot_expand ->
            raise Not_found in
        nondep_type env id ty'
      end else
        Tconstr(p, List.map (nondep_type env id) tl)
@


<<function Ctype.closed_schema>>=
(* Miscellaneous *)

let rec closed_schema ty =
  match repr ty with
    Tvar v -> v.tvar_level = generic_level
  | Tarrow(t1, t2) -> closed_schema t1 & closed_schema t2
  | Ttuple tl -> List.for_all closed_schema tl
  | Tconstr(p, tl) -> List.for_all closed_schema tl
@

<<function Ctype.is_generic>>=
let is_generic ty =
  match repr ty with
    Tvar v -> v.tvar_level = generic_level
  | _ -> fatal_error "Ctype.is_generic"
@

<<function Ctype.arity>>=
let rec arity ty =
  match repr ty with
    Tarrow(t1, t2) -> 1 + arity t2
  | _ -> 0
@



%-------------------------------------------------------------

<<./typing/ctype.ml>>=
<<copyright header0>>

(* Operations on core types *)

open Misc
open Path
open Types

<<exception Ctype.Unify>>

<<constant Ctype.current_level>>

<<constant Ctype.generic_level>>

<<function Ctype.reset_def>>
<<function Ctype.begin_def>>
<<function Ctype.end_def>>

<<function Ctype.newvar>>

<<function Ctype.new_global_var>>

<<function Ctype.repr>>

<<constant Ctype.none>>

<<function Ctype.generalize>>

<<function Ctype.make_nongen>>

<<constant Ctype.inst_subst>>

<<function Ctype.copy>>

<<function Ctype.instance>>

<<function Ctype.instance_constructor>>

<<function Ctype.instance_label>>

<<function Ctype.substitute>>

<<exception Ctype.Cannot_expand>>

<<function Ctype.expand_abbrev>>

<<function Ctype.occur>>

<<function Ctype.unify>>

<<function Ctype.filter_arrow>>

<<function Ctype.moregen_occur>>

<<function Ctype.moregen>>
  
<<function Ctype.moregeneral>>

<<function Ctype.equal>>

<<function Ctype.nondep_type>>

<<function Ctype.free_type_ident>>

<<function Ctype.closed_schema>>

<<function Ctype.is_generic>>

<<function Ctype.arity>>

@


\subsection*{[[./typing/includecore.mli]]}


%-------------------------------------------------------------

<<./typing/includecore.mli>>=
<<copyright header0>>

(* Inclusion checks for the core language *)

open Types
open Typedtree

<<exception Includecore.Dont_match>>

<<signature Includecore.value_descriptions>>
<<signature Includecore.type_declarations>>
<<signature Includecore.exception_declarations>>


@


\subsection*{[[./typing/includecore.ml]]}


%-------------------------------------------------------------

<<./typing/includecore.ml>>=
<<copyright header0>>

(* Inclusion checks for the core language *)

open Misc
open Path
open Types
open Typedtree

(* Inclusion between value descriptions *)

<<exception Includecore.Dont_match>>

<<function Includecore.value_descriptions>>

<<function Includecore.type_declarations>>

<<function Includecore.exception_declarations>>

@


\subsection*{[[./typing/mtype.mli]]}

%less: delete?

<<signature Mtype.scrape>>=
val scrape: Env.t -> module_type -> module_type
        (* Expand toplevel module type abbreviations
           till hitting a "hard" module type (signature, functor,
           or abstract module type ident. *)
@

<<signature Mtype.strengthen>>=
val strengthen: Env.t -> module_type -> Path.t -> module_type
        (* Strengthen abstract type components relative to the
           given path. *)
@

<<signature Mtype.nondep_supertype>>=
val nondep_supertype: Env.t -> Ident.t -> module_type -> module_type
        (* Return the smallest supertype of the given type
           in which the given ident does not appear.
           Raise [Not_found] if no such type List.exists. *)
@


%-------------------------------------------------------------

<<./typing/mtype.mli>>=
<<copyright header0>>

(* Operations on module types *)

open Types

<<signature Mtype.scrape>>
<<signature Mtype.strengthen>>
<<signature Mtype.nondep_supertype>>
@


\subsection*{[[./typing/mtype.ml]]}

<<function Mtype.scrape>>=
let rec scrape env mty =
  match mty with
    Tmty_ident p ->
      failwith "Mtype.scrape:TODO"
(*
      begin try
        match Env.find_modtype p env with
          Tmodtype_abstract -> mty
        | Tmodtype_manifest mty' -> scrape env mty'
      with Not_found ->
        mty
      end
*)
  | _ -> mty
@

<<type Mtype.variance>>=
(* In nondep_supertype, env is only used for the type it assigns to id.
   Hence there is no need to keep env up-to-date by adding the bindings
   traversed. *)

type variance = Co | Contra | Strict
@
% delete!

<<function Mtype.nondep_supertype>>=
let nondep_supertype env mid mty =

  let rec nondep_mty var mty =
    match mty with
      Tmty_ident p ->
        if Path.isfree mid p then begin
          failwith "nondep_mty:TODO"
            (*
          match Env.find_modtype p env with
            Tmodtype_abstract -> raise Not_found
          | Tmodtype_manifest mty -> nondep_mty var mty      
            *)
        end else mty
    | Tmty_signature sg ->
        Tmty_signature(nondep_sig var sg)

  and nondep_sig var = function
    [] -> []
  | item :: rem ->
      let rem' = nondep_sig var rem in
      match item with
        Tsig_value(id, d) ->
          Tsig_value(id, {val_type = Ctype.nondep_type env mid d.val_type;
                          val_prim = d.val_prim}) :: rem'
      | Tsig_type(id, d) ->
          Tsig_type(id, nondep_type_decl var d) :: rem'
      | Tsig_exception(id, d) ->
          Tsig_exception(id, List.map (Ctype.nondep_type env mid) d) :: rem'
      | Tsig_module(id, mty) ->
          Tsig_module(id, nondep_mty var mty) :: rem'

  and nondep_type_decl var d =
    {type_params = d.type_params;
     type_arity = d.type_arity;
     type_kind =
       begin try
         match d.type_kind with
           Type_abstract ->
             Type_abstract
         | Type_variant cstrs ->
             Type_variant(List.map
               (fun (c, tl) -> (c, List.map (Ctype.nondep_type env mid) tl))
               cstrs)
         | Type_record lbls ->
             Type_record(List.map
               (fun (c, mut, t) -> (c, mut, Ctype.nondep_type env mid t))
               lbls)
       with Not_found ->
         match var with Co -> Type_abstract | _ -> raise Not_found
       end;
     type_manifest =
       begin try
         match d.type_manifest with
           None -> None
         | Some ty -> Some(Ctype.nondep_type env mid ty)
       with Not_found ->
         match var with Co -> None | _ -> raise Not_found
       end}

  in
    nondep_mty Co mty
@


%-------------------------------------------------------------

<<./typing/mtype.ml>>=
<<copyright header0>>

(* Operations on module types *)

open Path
open Types


<<function Mtype.scrape>>

let rec strengthen env mty p =
  match scrape env mty with
    Tmty_signature sg ->
      Tmty_signature(strengthen_sig env sg p)
  | mty ->
      mty

and strengthen_sig env sg p =
  match sg with
    [] -> []
  | (Tsig_value(id, desc) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Tsig_type(id, decl) :: rem ->
      let newdecl =
        match decl.type_manifest with
          None ->
            { type_params = decl.type_params;
              type_arity = decl.type_arity;
              type_kind = decl.type_kind;
              type_manifest = Some(Tconstr(Pdot(p, Ident.name id, nopos),
                                                decl.type_params)) }
        | _ -> decl in
      Tsig_type(id, newdecl) :: strengthen_sig env rem p
  | (Tsig_exception(id, d) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Tsig_module(id, mty) :: rem ->
      Tsig_module(id, strengthen env mty (Pdot(p, Ident.name id, nopos))) ::
      strengthen_sig (Env.add_module id mty env) rem p
      (* Need to add the module in case it defines manifest module types *)

<<type Mtype.variance>>

<<function Mtype.nondep_supertype>>
@


\subsection*{[[./typing/printtyp.mli]]}


<<signature Printtyp.reset_var_names>>=
val reset_var_names: unit -> unit
@


<<signature Printtyp.type_scheme>>=
val type_scheme: type_expr -> unit
@


<<signature Printtyp.signature_item>>=
val signature_item: signature_item -> unit
@


%-------------------------------------------------------------

<<./typing/printtyp.mli>>=
<<copyright header0>>

(* Printing functions *)
open Types
open Typedtree

<<signature Printtyp.longident>>
<<signature Printtyp.ident>>
<<signature Printtyp.path>>
<<signature Printtyp.reset_var_names>>
<<signature Printtyp.type_expr>>
<<signature Printtyp.type_scheme>>
<<signature Printtyp.value_description>>
<<signature Printtyp.type_declaration>>
<<signature Printtyp.exception_declaration>>
<<signature Printtyp.modtype>>
<<signature Printtyp.signature>>
<<signature Printtyp.signature_item>>
@


\subsection*{[[./typing/printtyp.ml]]}


%-------------------------------------------------------------

<<./typing/printtyp.ml>>=
<<copyright header0>>

(* Printing functions *)

open Format
open Longident
open Path
open Asttypes
open Types
open Typedtree


<<function Printtyp.longident>>

<<function Printtyp.ident>>

<<constant Printtyp.ident_pervasive>>

<<function Printtyp.path>>

<<constant Printtyp.var_names>>
<<constant Printtyp.var_counter>>

<<function Printtyp.reset_var_names>>

<<function Printtyp.name_of_var>>

<<function Printtyp.typeexp>>
<<function Printtyp.type_expr>>

<<function Printtyp.type_scheme>>

(* Print one type declaration *)

<<function Printtyp.type_declaration>>

<<function Printtyp.exception_declaration>>

<<function Printtyp.value_description>>

(* Print a module type *)

<<function Printtyp.modtype>>

<<function Printtyp.signature>>
@


\subsection*{[[./typing/parmatch.mli]]}


%-------------------------------------------------------------

<<./typing/parmatch.mli>>=
<<copyright header0>>

(* Detection of partial matches and unused match cases. *)

open Typedtree

<<signature Parmatch.check_partial>>
<<signature Parmatch.check_unused>>
@


\subsection*{[[./typing/parmatch.ml]]}

<<function Parmatch.make_pat>>=
let make_pat desc ty =
  {pat_desc = desc; pat_loc = Location.none; pat_type = ty}
@

<<constant Parmatch.omega>>=
let omega = make_pat Tpat_any Ctype.none
@

<<signature Ctype.none>>=
val none: type_expr
        (* A dummy type expression *)
@
<<constant Ctype.none>>=
let none = Ttuple []                  (* Clearly ill-formed type *)
@


<<function Parmatch.omegas>>=
let rec omegas i =
  if i <= 0 then [] else omega :: omegas (i-1)
@

<<function Parmatch.omega_list>>=
let omega_list l = omegas(List.length l)
@

<<function Parmatch.has_guard>>=
let has_guard act =
  match act.exp_desc with
    Texp_when(_, _) -> true
  | _ -> false
@

<<function Parmatch.simple_match>>=
let simple_match p1 p2 = 
  match p1.pat_desc, p2.pat_desc with
    Tpat_construct(c1, _), Tpat_construct(c2, _) ->
      c1.cstr_tag = c2.cstr_tag
  | Tpat_constant(c1), Tpat_constant(c2) ->
      c1 = c2
  | Tpat_tuple(_), Tpat_tuple(_) -> true
  | Tpat_record(_), Tpat_record(_) -> true
  | _, (Tpat_any | Tpat_var(_)) -> true
  | _, _ -> false
@

<<function Parmatch.record_labels>>=
(* Return the set of labels and number of fields for a record pattern. *)

let record_labels p =
  match p.pat_desc with
    Tpat_record((lbl1, pat1) :: rem) -> Array.to_list lbl1.lbl_all
  | _ -> fatal_error "Parmatch.record_labels"
@

<<function Parmatch.record_num_fields>>=
let record_num_fields p =
  match p.pat_desc with
    Tpat_record((lbl1, pat1) :: rem) -> Array.length lbl1.lbl_all
  | _ -> fatal_error "Parmatch.record_num_fields"
@

<<function Parmatch.set_fields>>=
let set_fields size l =
  let v = Array.create size omega in
  let rec change_rec l = match l with
    (lbl,p)::l ->  v.(lbl.lbl_pos) <- p ;  change_rec l 
  | [] -> () in
  change_rec l;
  Array.to_list v
@

<<function Parmatch.simple_match_args>>=
let simple_match_args p1 p2 =
  match p2.pat_desc with
    Tpat_construct(cstr, args) -> args
  | Tpat_tuple(args)  -> args
  | Tpat_record(args) ->  set_fields (record_num_fields p1) args
  | (Tpat_any | Tpat_var(_)) ->
      begin match p1.pat_desc with
        Tpat_construct(_, args) -> omega_list args
      | Tpat_tuple(args) -> omega_list args
      | Tpat_record(args) ->  omega_list args
      | _ -> []
      end
  | _ -> []
@

<<function Parmatch.simple_pat>>=
(*
  Computes the discriminating pattern for matching by the first
  column of pss, that is:
     checks for a tuple or a record when q is a variable.
*)

let rec simple_pat q pss = match pss with
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        simple_pat q ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        simple_pat q ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
        simple_pat q pss
  | (({pat_desc = Tpat_tuple(args)} as p)::_)::_ ->
        make_pat (Tpat_tuple(omega_list args)) p.pat_type
  | (({pat_desc = Tpat_record(args)} as p)::_)::pss ->
        make_pat (Tpat_record (List.map (fun lbl -> (lbl,omega)) (record_labels p)))
                 p.pat_type
  | _ -> q
@

<<function Parmatch.filter_one>>=
let filter_one q pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | (p::ps)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss
@

<<function Parmatch.filter_extra>>=
let filter_extra pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | ({pat_desc = (Tpat_any | Tpat_var(_))} :: qs) :: pss ->
        qs :: filter_rec pss
    | _::pss  -> filter_rec pss
    | [] -> [] in
  filter_rec pss
@

<<function Parmatch.filter_all>>=
let filter_all pat0 pss =

  let rec insert q qs env =
    match env with
      [] -> [q, [simple_match_args q q @ qs]]
    | ((p,pss) as c)::env ->
        if simple_match q p
        then (p, ((simple_match_args p q @ qs) :: pss)) :: env
        else c :: insert q qs env in

  let rec filter_rec env = function
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss ->
      filter_rec env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
      filter_rec env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
      filter_rec env pss
  | (p::ps)::pss ->
      filter_rec (insert p ps env) pss
  | _ -> env

  and filter_omega env = function
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss ->
      filter_omega env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
      filter_omega env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::ps)::pss ->
      filter_omega
        (List.map (fun (q,qss) -> (q,(simple_match_args q omega @ ps) :: qss)) env)
        pss
  | _::pss -> filter_omega env pss
  | [] -> env in
        
  filter_omega
    (filter_rec
      (match pat0.pat_desc with
        (Tpat_record(_) | Tpat_tuple(_)) -> [pat0,[]]
      | _ -> [])
      pss)
    pss
@

<<function Parmatch.full_match>>=
let full_match env =
  match env with
    ({pat_desc = Tpat_construct(c,_)},_) :: _ ->
      List.length env = c.cstr_consts + c.cstr_nonconsts
  | ({pat_desc = Tpat_constant(Const_char _)},_) :: _ ->
      List.length env = 256
  | ({pat_desc = Tpat_constant(_)},_) :: _ -> false
  | ({pat_desc = Tpat_tuple(_)},_) :: _ -> true
  | ({pat_desc = Tpat_record(_)},_) :: _ -> true
  | _ -> fatal_error "Parmatch.full_match"
@

<<function Parmatch.satisfiable>>=
(*
  Is the last row of pattern matrix pss + qs satisfiable ?
        That is :
  Does there List.exists at least one value vector, es such that :
   1/ for all ps in pss ps # es (ps and es are not compatible)
   2/ qs <= es                  (es matches qs)
*)

let rec satisfiable pss qs =
  match pss with
    [] -> true
  | _ ->
    match qs with
      [] -> false
    | {pat_desc = Tpat_or(q1,q2)}::qs ->
        satisfiable pss (q1::qs) or satisfiable pss (q2::qs)
    | {pat_desc = Tpat_alias(q,_)}::qs ->
        satisfiable pss (q::qs)
    | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
        let q0 = simple_pat omega pss in     
        begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
          [] -> satisfiable (filter_extra pss) qs 
        | constrs ->          
            let try_non_omega (p,pss) =
              satisfiable pss (simple_match_args p omega @ qs)  in
            if full_match constrs
            then List.exists try_non_omega constrs
            else satisfiable (filter_extra pss) qs or
                 List.exists try_non_omega constrs
        end
    | q::qs ->
        let q0 = simple_pat q pss in
        satisfiable (filter_one q0 pss) (simple_match_args q0 q @ qs)
@

<<function Parmatch.initial_matrix>>=
let rec initial_matrix = function
    [] -> []
  | (pat, act) :: rem ->
       if has_guard act
       then initial_matrix rem
       else [pat] :: initial_matrix rem
@

<<function Parmatch.get_mins>>=
let get_mins ps =
  let rec select_rec r = function
    [] -> r
  | p::ps ->
      if List.exists (fun p0 -> le_pats p0 p) ps
      then select_rec r ps
      else select_rec (p::r) ps in
  select_rec [] (select_rec [] ps)
@

<<function Parmatch.check_partial>>=
let check_partial loc casel =
  let pss = get_mins (initial_matrix casel) in
  if match pss with
      []     -> true
    | ps::_  -> satisfiable pss (List.map (fun _ -> omega) ps)
  then Location.print_warning loc "this pattern-matching is not exhaustive"
@

<<function Parmatch.location_of_clause>>=
let location_of_clause = function
    pat :: _ -> pat.pat_loc
  | _ -> fatal_error "Parmatch.location_of_clause"
@

<<function Parmatch.check_unused>>=
let check_unused casel =
  let prefs =   
    List.fold_right
      (fun (pat,act as clause) r ->
         if has_guard act
         then ([], ([pat], act)) :: r
         else ([], ([pat], act)) :: 
              List.map (fun (pss,clause) -> [pat]::pss,clause) r)
      casel [] in
  List.iter
    (fun (pss, ((qs, _) as clause)) ->
      if not (satisfiable pss qs) then
        Location.print_warning (location_of_clause qs)
                                "this match case is unused.")
    prefs
@


%-------------------------------------------------------------

<<./typing/parmatch.ml>>=
<<copyright header0>>

(* Detection of partial matches and unused match cases. *)

open Misc
open Asttypes
open Types
open Typedtree


<<function Parmatch.make_pat>>

<<constant Parmatch.omega>>

<<function Parmatch.omegas>>

<<function Parmatch.omega_list>>

<<function Parmatch.has_guard>>

<<function Parmatch.simple_match>>

<<function Parmatch.record_labels>>

<<function Parmatch.record_num_fields>>

<<function Parmatch.set_fields>>

<<function Parmatch.simple_match_args>>

<<function Parmatch.simple_pat>>

<<function Parmatch.filter_one>>

<<function Parmatch.filter_extra>>

<<function Parmatch.filter_all>>

      
<<function Parmatch.full_match>>

<<function Parmatch.satisfiable>>

<<function Parmatch.initial_matrix>>

<<function Parmatch.le_pat>>

<<function Parmatch.get_mins>>

<<function Parmatch.check_partial>>

<<function Parmatch.location_of_clause>>

<<function Parmatch.check_unused>>
@

<<function Parmatch.le_pat>>=
let rec le_pat p q =
  match (p.pat_desc, q.pat_desc) with
    (Tpat_var _ | Tpat_any), _ -> true
  | Tpat_alias(p,_), _ -> le_pat p q
  | _, Tpat_alias(q,_) -> le_pat p q
  | Tpat_or(p1,p2), _ -> le_pat p1 q or le_pat p2 q
  | _, Tpat_or(q1,q2) -> le_pat p q1 & le_pat p q2
  | Tpat_constant(c1), Tpat_constant(c2) -> c1 = c2
  | Tpat_construct(c1,ps), Tpat_construct(c2,qs) ->
      c1.cstr_tag = c2.cstr_tag & le_pats ps qs
  | Tpat_tuple(ps), Tpat_tuple(qs) -> le_pats ps qs
  | Tpat_record(l1), Tpat_record(l2) ->
     let size = record_num_fields p in
     le_pats (set_fields size l1) (set_fields size l2)
  | _, _ -> false  

and le_pats ps qs =
  match ps,qs with
    p::ps, q::qs -> le_pat p q & le_pats ps qs
  | _, _         -> true
@


\subsection*{[[./typing/typetexp.mli]]}



%-------------------------------------------------------------

<<./typing/typetexp.mli>>=
<<copyright header0>>

<<signature Typetexp.transl_simple_type>>
<<signature Typetexp.transl_type_scheme>>
<<signature Typetexp.reset_type_variables>>
<<signature Typetexp.enter_type_variable>>

<<exception Typetexp.Already_bound>>

<<type Typetexp.error>>

<<exception Typetexp.Error>>

<<signature Typetexp.report_error>>
@


\subsection*{[[./typing/typetexp.ml]]}

%-------------------------------------------------------------

<<./typing/typetexp.ml>>=
<<copyright header0>>

(* Typechecking of type expressions for the core language *)

open Parsetree
open Types
open Ctype

<<exception Typetexp.Already_bound>>

<<type Typetexp.error>>

<<exception Typetexp.Error>>

<<constant Typetexp.type_variables>>

<<function Typetexp.reset_type_variables>>

<<function Typetexp.enter_type_variable>>

<<function Typetexp.transl_simple_type>>

<<function Typetexp.transl_type_scheme>>

(* Error report *)

open Format
open Printtyp

<<function Typetexp.report_error>>
@


\subsection*{[[./typing/includemod.mli]]}





%-------------------------------------------------------------

<<./typing/includemod.mli>>=
<<copyright header0>>

(* Inclusion checks for the module language *)

open Types
open Typedtree

<<signature Includemod.modtypes>>
<<signature Includemod.signatures>>
<<signature Includemod.compunit>>

<<type Includemod.error>>

<<exception Includemod.Error>>

<<signature Includemod.report_error>>
@


\subsection*{[[./typing/includemod.ml]]}



<<exception Includemod.Dont_match>>=
(* Expand a module type identifier when possible *)

exception Dont_match
@

<<function Includemod.expand_module_path>>=
let expand_module_path env path =
  failwith "expand_module_path:TODO"
(*
  try
    match Env.find_modtype path env with
      Tmodtype_abstract -> raise Dont_match
    | Tmodtype_manifest mty -> mty
  with Not_found ->
    raise Dont_match
*)
@

<<type Includemod.field_desc>>=
(* Extract name, kind and ident from a signature item *)

type field_desc =
    Field_value of string
  | Field_type of string
  | Field_exception of string
  | Field_module of string
  | Field_modtype of string
@

<<function Includemod.item_ident_name>>=
let item_ident_name = function
    Tsig_value(id, _) -> (id, Field_value(Ident.name id))
  | Tsig_type(id, _) -> (id, Field_type(Ident.name id))
  | Tsig_exception(id, _) -> (id, Field_exception(Ident.name id))
  | Tsig_module(id, _) -> (id, Field_module(Ident.name id))
@

<<function Includemod.simplify_structure_coercion>>=
(* Simplify a structure coercion *)

let simplify_structure_coercion cc =
  let pos = ref 0 in
  try
    List.iter
      (fun (n, c) ->
        if n <> !pos or c <> Tcoerce_none then raise Exit;
        incr pos)
      cc;
    Tcoerce_none
  with Exit ->
    Tcoerce_structure cc
@





%-------------------------------------------------------------

<<./typing/includemod.ml>>=
<<copyright header0>>

(* Inclusion checks for the module language *)

open Misc
open Path
open Types
open Typedtree


<<type Includemod.error>>

<<exception Includemod.Error>>

(* All functions "blah env x1 x2" check that x1 is included in x2,
   i.e. that x1 is the type of an implementation that fulfills the
   specification x2. If not, Error is raised with a backtrace of the error. *)

<<function Includemod.value_descriptions>>

<<function Includemod.type_declarations>>

<<function Includemod.exception_declarations>>

<<exception Includemod.Dont_match>>

<<function Includemod.expand_module_path>>

<<type Includemod.field_desc>>

<<function Includemod.item_ident_name>>

<<function Includemod.simplify_structure_coercion>>

<<function Includemod.modtypes>>

<<function Includemod.signatures>>

<<function Includemod.signature_components>>

<<function Includemod.check_modtype_inclusion>>

<<toplevel Includemod._1>>

<<function Includemod.compunit>>

(* Error report *)

open Format
open Printtyp

<<function Includemod.include_err>>

<<function Includemod.report_error>>

@




<<function Includemod.modtypes>>=
(* Inclusion between module types. 
   Return the restriction that transforms a value of the smaller type
   into a value of the bigger type. *)

let rec modtypes env mty1 mty2 =
  try
    try_modtypes env mty1 mty2
  with 
    Dont_match ->
      raise(Error[Module_types(mty1, mty2)])
  | Error reasons ->
      raise(Error(Module_types(mty1, mty2) :: reasons))

and try_modtypes env mty1 mty2 =
  match (mty1, mty2) with
    (Tmty_ident p1, Tmty_ident p2) when Path.same p1 p2 ->
      Tcoerce_none
  | (Tmty_ident p1, _) ->
      try_modtypes env (expand_module_path env p1) mty2
  | (_, Tmty_ident p2) ->
      try_modtypes env mty1 (expand_module_path env p2)
  | (Tmty_signature sig1, Tmty_signature sig2) ->
      signatures env sig1 sig2
  | (_, _) ->
      raise Dont_match
@







\subsection*{[[./typing/typedecl.mli]]}


%-------------------------------------------------------------

<<./typing/typedecl.mli>>=
<<copyright header0>>

(* Typing of type definitions and primitive definitions *)

open Types
open Typedtree

<<signature Typedecl.transl_type_decl>>
<<signature Typedecl.transl_exception>>

<<signature Typedecl.transl_value_decl>>
   
<<type Typedecl.error>>

<<exception Typedecl.Error>>

<<signature Typedecl.report_error>>
@


\subsection*{[[./typing/typedecl.ml]]}


%-------------------------------------------------------------

<<./typing/typedecl.ml>>=
<<copyright header0>>

(* Typing of type definitions *)

open Parsetree
open Types
open Typedtree
open Typetexp


<<type Typedecl.error>>

<<exception Typedecl.Error>>

<<function Typedecl.enter_types>>

(* Translate one type declaration *)

module StringSet = Set

<<function Typedecl.transl_declaration>>

<<function Typedecl.check_recursive_abbrev>>

<<function Typedecl.transl_type_decl>>

<<function Typedecl.transl_exception>>

<<function Typedecl.transl_value_decl>>

(* Error report *)

open Format

<<function Typedecl.report_error>>

@


\subsection*{[[./typing/typecore.mli]]}



%-------------------------------------------------------------

<<./typing/typecore.mli>>=
<<copyright header0>>

(* Type inference for the core language *)

open Asttypes
open Types

<<signature Typecore.type_binding>>

<<signature Typecore.type_expression>>
        
<<type Typecore.error>>

<<exception Typecore.Error>>

<<signature Typecore.report_error>>
@


\subsection*{[[./typing/typecore.ml]]}



<<function Typecore.unify_pat>>=
(* Typing of patterns *)

let unify_pat env pat expected_ty =
  try
    unify env pat.pat_type expected_ty
  with Unify ->
    raise(Error(pat.pat_loc, Pattern_type_clash(pat.pat_type, expected_ty)))
@

<<constant Typecore.pattern_variables>>=
let pattern_variables = ref ([]: (Ident.t * type_expr) list)
@

<<function Typecore.enter_variable>>=
let enter_variable loc name ty =
  if List.exists (fun (id, ty) -> Ident.name id = name) !pattern_variables
  then raise(Error(loc, Multiply_bound_variable));
  let id = Ident.create name in
  pattern_variables := (id, ty) :: !pattern_variables;
  id
@

<<function Typecore.type_pat>>=
let rec type_pat env sp =
  match sp.ppat_desc with
    Ppat_any ->
      { pat_desc = Tpat_any;
        pat_loc = sp.ppat_loc;
        pat_type = newvar() }
  | Ppat_var name ->
      let ty = newvar() in
      let id = enter_variable sp.ppat_loc name ty in
      { pat_desc = Tpat_var id;
        pat_loc = sp.ppat_loc;
        pat_type = ty }
  | Ppat_alias(sp, name) ->
      let p = type_pat env sp in
      let id = enter_variable sp.ppat_loc name p.pat_type in
      { pat_desc = Tpat_alias(p, id);
        pat_loc = sp.ppat_loc;
        pat_type = p.pat_type }
  | Ppat_constant cst ->
      { pat_desc = Tpat_constant cst;
        pat_loc = sp.ppat_loc;
        pat_type = type_constant cst }
  | Ppat_tuple spl ->
      let pl = List.map (type_pat env) spl in
      { pat_desc = Tpat_tuple pl;
        pat_loc = sp.ppat_loc;
        pat_type = Ttuple(List.map (fun p -> p.pat_type) pl) }
  | Ppat_construct(lid, sarg) ->
      let constr =
        try
          Env.lookup_constructor lid env
        with Not_found ->
          raise(Error(sp.ppat_loc, Unbound_constructor lid)) in
      let sargs =
        match sarg with
          None -> []
        | Some {ppat_desc = Ppat_tuple spl} when constr.cstr_arity > 1 -> spl
        | Some({ppat_desc = Ppat_any} as sp) when constr.cstr_arity > 1 ->
            replicate_list sp constr.cstr_arity
        | Some sp -> [sp] in
      if List.length sargs <> constr.cstr_arity then
        raise(Error(sp.ppat_loc, Constructor_arity_mismatch(lid,
                                     constr.cstr_arity, List.length sargs)));
      let args = List.map (type_pat env) sargs in
      let (ty_args, ty_res) = instance_constructor constr in
      List.iter2 (unify_pat env) args ty_args;
      { pat_desc = Tpat_construct(constr, args);
        pat_loc = sp.ppat_loc;
        pat_type = ty_res }
  | Ppat_record lid_sp_list ->
      let ty = newvar() in
      let type_label_pat (lid, sarg) =
        let label =
          try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sp.ppat_loc, Unbound_label lid)) in
        let (ty_arg, ty_res) = instance_label label in
        begin try
          unify env ty_res ty
        with Unify ->
          raise(Error(sp.ppat_loc, Label_mismatch(lid, ty_res, ty)))
        end;
        let arg = type_pat env sarg in
        unify_pat env arg ty_arg;
        (label, arg)
      in
      { pat_desc = Tpat_record(List.map type_label_pat lid_sp_list);
        pat_loc = sp.ppat_loc;
        pat_type = ty }
  | Ppat_or(sp1, sp2) ->
      let initial_pattern_variables = !pattern_variables in
      let p1 = type_pat env sp1 in
      let p2 = type_pat env sp2 in
      if !pattern_variables != initial_pattern_variables then
        raise(Error(sp.ppat_loc, Orpat_not_closed));
      unify_pat env p2 p1.pat_type;
      { pat_desc = Tpat_or(p1, p2);
        pat_loc = sp.ppat_loc;
        pat_type = p1.pat_type }
  | Ppat_constraint(sp, sty) ->
      let p = type_pat env sp in
      let ty = Typetexp.transl_simple_type env false sty in
      unify_pat env p ty;
      p
@

<<function Typecore.add_pattern_variables>>=
let add_pattern_variables env =
  let pv = !pattern_variables in
  pattern_variables := [];
  List.fold_right
    (fun (id, ty) env ->
      Env.add_value id {val_type = ty; val_prim = None} env)
    pv env
@

<<function Typecore.type_pattern>>=
let type_pattern env spat =
  pattern_variables := [];
  let pat = type_pat env spat in
  let new_env = add_pattern_variables env in
  (pat, new_env)
@

<<function Typecore.type_pattern_list>>=
let type_pattern_list env spatl =
  pattern_variables := [];
  let patl = List.map (type_pat env) spatl in
  let new_env = add_pattern_variables env in
  (patl, new_env)
@





%-------------------------------------------------------------

<<./typing/typecore.ml>>=
<<copyright header0>>

(* Typechecking for the core language *)

open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Ctype


<<type Typecore.error>>

<<exception Typecore.Error>>

<<function Typecore.type_constant>>

<<function Typecore.unify_pat>>

<<constant Typecore.pattern_variables>>

<<function Typecore.enter_variable>>

<<function Typecore.type_pat>>

<<function Typecore.add_pattern_variables>>

<<function Typecore.type_pattern>>

<<function Typecore.type_pattern_list>>

<<function Typecore.is_nonexpansive>>

<<function Typecore.type_format>>

<<function Typecore.unify_exp>>

<<function Typecore.type_exp>>

<<function Typecode.type_expect>>

<<function Typecore.type_statement>>

<<function Typecore.type_cases>>

<<function Typecode.type_let>>

<<function Typecore.type_binding>>

<<function Typecore.type_expression>>

(* Error report *)

open Format
open Printtyp

<<function Typecore.report_error>>
@


\subsection*{[[./typing/typemod.mli]]}

<<signature Typemod.check_nongen_schemes>>=
val check_nongen_schemes:
        structure -> unit
@


%-------------------------------------------------------------

<<./typing/typemod.mli>>=
<<copyright header0>>

(* Type-checking of the module language *)

open Types
open Typedtree

<<signature Typemod.type_structure>>
<<signature Typemod.transl_signature>>
<<signature Typemod.check_nongen_schemes>>

<<type Typemod.error>>

<<exception Typemod.Error>>

<<signature Typemod.report_error>>
@


\subsection*{[[./typing/typemod.ml]]}


<<function Typemod.extract_sig>>=
(* Extract a signature from a module type *)

let extract_sig env loc mty =
  match Mtype.scrape env mty with
    Tmty_signature sg -> sg
  | _ -> raise(Error(loc, Signature_expected))
@

<<function Typemod.extract_sig_open>>=
let extract_sig_open env loc mty =
  match Mtype.scrape env mty with
    Tmty_signature sg -> sg
  | _ -> raise(Error(loc, Structure_expected mty))
@

<<function Typemod.type_module_path>>=
(* Lookup the type of a module path *)

let type_module_path env loc lid =
  try
    Env.lookup_module lid env
  with Not_found ->
    raise(Error(loc, Unbound_module lid))
@

<<exception Typemod.Not_a_path>>=
(* Try to convert a module expression to a module path. *)

exception Not_a_path
@

<<function Typemod.path_of_module>>=
let rec path_of_module mexp =
  match mexp.mod_desc with
    Tmod_ident p -> p
  | _ -> raise Not_a_path
@

<<function Typemod.check_unique_names>>=
let check_unique_names sg =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in
  let check cl loc set_ref name =
    if StringSet.mem name !set_ref
    then raise(Error(loc, Repeated_name(cl, name)))
    else set_ref := StringSet.add name !set_ref in
  let check_item item =
    match item.pstr_desc with
      Pstr_eval exp -> ()
    | Pstr_value(rec_flag, exps) -> ()
    | Pstr_primitive(name, desc) -> ()
    | Pstr_type name_decl_list ->
        List.iter
          (fun (name, decl) -> check "type" item.pstr_loc type_names name)
          name_decl_list
    | Pstr_exception(name, decl) -> ()
    | Pstr_module(name, smod) ->
        check "module" item.pstr_loc module_names name
    | Pstr_open lid -> () in
  List.iter check_item sg
@

<<function Typemod.check_nongen_schemes>>=
(* Check that all core type schemes in a structure are closed *)

let check_nongen_schemes str =
  List.iter 
    (function
        Tstr_value(rec_flag, pat_exp_list) ->
          List.iter
            (fun (pat, exp) ->
              if not (Ctype.closed_schema exp.exp_type) then
                raise(Error(exp.exp_loc, Non_generalizable exp.exp_type)))
            pat_exp_list
      | _ -> ())  (* Sub-structures have been checked before *)
  str
@



%-------------------------------------------------------------

<<./typing/typemod.ml>>=
<<copyright header0>>

(* Type-checking of the module language *)

open Misc
open Longident
open Path
open Parsetree
open Types
open Typedtree


<<type Typemod.error>>

<<exception Typemod.Error>>

<<function Typemod.extract_sig>>

<<function Typemod.extract_sig_open>>

<<function Typemod.type_module_path>>

(* Check and translate a module type expression *)

let rec transl_modtype env smty =
  match smty.pmty_desc with
    Pmty_ident lid ->
      failwith "transl_modtype:TODO"
(*
      begin try
        let (path, info) = Env.lookup_modtype lid env in 
        Tmty_ident path
      with Not_found ->
        raise(Error(smty.pmty_loc, Unbound_modtype lid))
      end
*)
  | Pmty_signature ssg ->
      Tmty_signature(transl_signature env ssg)
      
and transl_signature env sg =
  match sg with
    [] -> []
  | {psig_desc = Psig_value(name, sdesc)} :: srem ->
      let desc = Typedecl.transl_value_decl env sdesc in
      let (id, newenv) = Env.enter_value name desc env in
      let rem = transl_signature newenv srem in
      Tsig_value(id, desc) :: rem
  | {psig_desc = Psig_type sdecls} :: srem ->
      let (decls, newenv) = Typedecl.transl_type_decl env sdecls in
      let rem = transl_signature newenv srem in
      map_end (fun (id, info) -> Tsig_type(id, info)) decls rem
  | {psig_desc = Psig_exception(name, sarg)} :: srem ->
      let arg = Typedecl.transl_exception env sarg in
      let (id, newenv) = Env.enter_exception name arg env in
      let rem = transl_signature newenv srem in
      Tsig_exception(id, arg) :: rem
  | {psig_desc = Psig_module(name, smty)} :: srem ->
      let mty = transl_modtype env smty in
      let (id, newenv) = Env.enter_module name mty env in
      let rem = transl_signature newenv srem in
      Tsig_module(id, mty) :: rem
  | {psig_desc = Psig_open lid; psig_loc = loc} :: srem ->
      let (path, mty) = type_module_path env loc lid in
      let sg = extract_sig_open env loc mty in
      let newenv = Env.open_signature path sg env in
      transl_signature newenv srem

<<exception Typemod.Not_a_path>>

<<function Typemod.path_of_module>>

(* Check that all type and module identifiers in a structure have
   distinct names (so that access by named paths is unambiguous). *)

module StringSet = Set

<<function Typemod.check_unique_names>>

<<function Typemod.check_nongen_schemes>>

(* Type a module value expression *)

let rec type_module env smod =
  match smod.pmod_desc with
    Pmod_ident lid ->
      let (path, mty) = type_module_path env smod.pmod_loc lid in
      { mod_desc = Tmod_ident path;
        mod_type = Mtype.strengthen env mty path;
        mod_loc = smod.pmod_loc }
  | Pmod_structure sstr ->
      let (str, sg, _) = type_structure env sstr in
      check_nongen_schemes str;
      { mod_desc = Tmod_structure str;
        mod_type = Tmty_signature sg;
        mod_loc = smod.pmod_loc }
  | Pmod_constraint(sarg, smty) ->
      let arg = type_module env sarg in
      let mty = transl_modtype env smty in
      let coercion =
        try
          Includemod.modtypes env arg.mod_type mty
        with Includemod.Error msg ->
          raise(Error(sarg.pmod_loc, Not_included msg)) in
      { mod_desc = Tmod_constraint(arg, mty, coercion);
        mod_type = mty;
        mod_loc = smod.pmod_loc }

and type_structure env sstr =
  check_unique_names sstr;
  type_struct env sstr

and type_struct env = function
    [] ->
      ([], [], env)
  | {pstr_desc = Pstr_eval sexpr} :: srem ->
      let expr = Typecore.type_expression env sexpr in
      let (str_rem, sig_rem, final_env) = type_struct env srem in
      (Tstr_eval expr :: str_rem, sig_rem, final_env)
  | {pstr_desc = Pstr_value(rec_flag, sdefs)} :: srem ->
      let (defs, newenv) =
        Typecore.type_binding env rec_flag sdefs in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      let bound_idents = let_bound_idents defs in
      let make_sig_value id =
        Tsig_value(id, Env.find_value (Pident id) newenv) in
      (Tstr_value(rec_flag, defs) :: str_rem,
       map_end make_sig_value bound_idents sig_rem,
       final_env)
  | {pstr_desc = Pstr_primitive(name, sdesc)} :: srem ->
      let desc = Typedecl.transl_value_decl env sdesc in
      let (id, newenv) = Env.enter_value name desc env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_primitive(id, desc) :: str_rem,
       Tsig_value(id, desc) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_type sdecls} :: srem ->
      let (decls, newenv) = Typedecl.transl_type_decl env sdecls in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_type decls :: str_rem,
       map_end (fun (id, info) -> Tsig_type(id, info)) decls sig_rem,
       final_env)
  | {pstr_desc = Pstr_exception(name, sarg)} :: srem ->
      let arg = Typedecl.transl_exception env sarg in
      let (id, newenv) = Env.enter_exception name arg env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_exception(id, arg) :: str_rem,
       Tsig_exception(id, arg) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_module(name, smodl)} :: srem ->
      let modl = type_module env smodl in
      let (id, newenv) = Env.enter_module name modl.mod_type env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_module(id, modl) :: str_rem,
       Tsig_module(id, modl.mod_type) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_open lid; pstr_loc = loc} :: srem ->
      let (path, mty) = type_module_path env loc lid in
      let sg = extract_sig_open env loc mty in
      type_struct (Env.open_signature path sg env) srem

(* Error report *)

open Format
open Printtyp

<<function Typemod.report_error>>
@










\section{[[./bytecomp/]]}


\subsection*{[[./bytecomp/lambda.mli]]}


<<signature Lambda.const_unit>>=
val const_unit: structured_constant
@

<<signature Lambda.lambda_unit>>=
val lambda_unit: lambda
@

<<signature Lambda.name_lambda>>=
val name_lambda: lambda -> (Ident.t -> lambda) -> lambda
@

<<signature Lambda.is_guarded>>=
val is_guarded: lambda -> bool
@

<<signature Lambda.free_variables>>=
val free_variables: lambda -> Ident.t Set.t
@

<<signature Lambda.transl_path>>=
val transl_path: Path.t -> lambda
@


%-------------------------------------------------------------

<<./bytecomp/lambda.mli>>=
<<copyright header>>

(* The "lambda" intermediate code *)

open Asttypes

<<type Lambda.primitive>>

<<type Lambda.comparison>>

<<type Lambda.array_kind>>

<<type Lambda.structured_constant>>

<<type Lambda.function_kind>>

<<type Lambda.let_kind>>

<<type Lambda.shared_code>>

<<type Lambda.lambda>>

<<type Lambda.lambda_switch>>

<<type Lambda.lambda_event>>

<<type Lambda.lambda_event_kind>>

<<signature Lambda.const_unit>>
<<signature Lambda.lambda_unit>>
<<signature Lambda.name_lambda>>
<<signature Lambda.is_guarded>>

<<signature Lambda.free_variables>>

<<signature Lambda.transl_path>>
@


\subsection*{[[./bytecomp/lambda.ml]]}



<<constant Lambda.const_unit>>=
let const_unit = Const_pointer 0
@

<<constant Lambda.lambda_unit>>=
let lambda_unit = Lconst const_unit
@

<<function Lambda.name_lambda>>=
let name_lambda arg fn =
  match arg with
    Lvar id -> fn id
  | _ -> let id = Ident.create "let" in Llet(Strict, id, arg, fn id)
@

<<function Lambda.free_variables>>=
let free_variables l =
  let fv = ref IdentSet.empty in
  let rec freevars = function
    Lvar id ->
      fv := IdentSet.add id !fv
  | Lconst sc -> ()
  | Lapply(fn, args) ->
      freevars fn; List.iter freevars args
  | Lfunction(kind, params, body) ->
      freevars body;
      List.iter (fun param -> fv := IdentSet.remove param !fv) params
  | Llet(str, id, arg, body) ->
      freevars arg; freevars body; fv := IdentSet.remove id !fv
  | Lletrec(decl, body) ->
      freevars body;
      List.iter (fun (id, exp) -> freevars exp) decl;
      List.iter (fun (id, exp) -> fv := IdentSet.remove id !fv) decl
  | Lprim(p, args) ->
      List.iter freevars args
  | Lswitch(arg, sw) ->
      freevars arg; 
      List.iter (fun (key, case) -> freevars case) sw.sw_consts;
      List.iter (fun (key, case) -> freevars case) sw.sw_blocks
  | Lstaticfail -> ()
  | Lcatch(e1, e2) ->
      freevars e1; freevars e2
  | Ltrywith(e1, exn, e2) ->
      freevars e1; freevars e2; fv := IdentSet.remove exn !fv
  | Lifthenelse(e1, e2, e3) ->
      freevars e1; freevars e2; freevars e3
  | Lsequence(e1, e2) ->
      freevars e1; freevars e2
  | Lwhile(e1, e2) ->
      freevars e1; freevars e2
  | Lfor(v, e1, e2, dir, e3) -> 
      freevars e1; freevars e2; freevars e3; fv := IdentSet.remove v !fv
  | Lassign(id, e) ->
      fv := IdentSet.add id !fv; freevars e
  | Levent (lam, evt) ->
      freevars lam
  in freevars l; !fv
@

<<constant Lambda.is_guarded>>=
(* Check if an action has a "when" guard *)

let rec is_guarded = function
    Lifthenelse(cond, body, Lstaticfail) -> true
  | Llet(str, id, lam, body) -> is_guarded body
  | Levent(lam, ev) -> is_guarded lam
  | _ -> false
@

<<constant Lambda.transl_path>>=
let rec transl_path = function
    Pident id ->
      if Ident.global id 
      then Lprim(Pgetglobal id, []) 
      else Lvar id
  | Pdot(p, s, pos) ->
      Lprim(Pfield pos, [transl_path p])
@

<<signature Ident.global>>=
val global: t -> bool
@
<<function Ident.global>>=
let global i =
  i.global
@


%-------------------------------------------------------------

<<./bytecomp/lambda.ml>>=
<<copyright header>>

open Misc
open Path
open Asttypes

<<type Lambda.primitive>>

<<type Lambda.comparison>>

<<type Lambda.array_kind>>

<<type Lambda.structured_constant>>

<<type Lambda.function_kind>>

<<type Lambda.let_kind>>

<<type Lambda.shared_code>>

<<type Lambda.lambda>>

<<type Lambda.lambda_switch>>

<<type Lambda.lambda_event>>

<<type Lambda.lambda_event_kind>>

<<constant Lambda.const_unit>>

<<constant Lambda.lambda_unit>>

<<function Lambda.name_lambda>>

module IdentSet = Set

<<function Lambda.free_variables>>

<<constant Lambda.is_guarded>>

<<constant Lambda.transl_path>>
@


\subsection*{[[./bytecomp/printlambda.mli]]}

%-------------------------------------------------------------

<<./bytecomp/printlambda.mli>>=
<<copyright header>>

open Lambda

<<signature Printlambda.structured_constant>>
<<signature Printlambda.lambda>>
@


\subsection*{[[./bytecomp/printlambda.ml]]}

%-------------------------------------------------------------

<<./bytecomp/printlambda.ml>>=
<<copyright header>>

open Format
open Asttypes
open Primitive
open Types
open Lambda


<<function Printlambda.structured_constant>>

<<function Printlambda.primitive>>

<<function Printlambda.lambda>>
@

\subsection*{[[./bytecomp/meta.mli]]}

<<type Meta.closure>>=
type closure = unit -> Obj.t
@


%-------------------------------------------------------------

<<./bytecomp/meta.mli>>=
<<copyright header>>

(* To control the runtime system and bytecode interpreter *)

external global_data : unit -> Obj.t array = "get_global_data"
external realloc_global_data : int -> unit = "realloc_global"
external static_alloc : int -> string = "static_alloc"
external static_free : string -> unit = "static_free"
<<type Meta.closure>>
external reify_bytecode : string -> int -> closure = "reify_bytecode"
external available_primitives : unit -> string array = "available_primitives"
@


\subsection*{[[./bytecomp/meta.ml]]}

<<type Meta.closure (./bytecomp/meta.ml)>>=
type closure = unit -> Obj.t
@


%-------------------------------------------------------------

<<./bytecomp/meta.ml>>=
<<copyright header>>

external global_data : unit -> Obj.t array = "get_global_data"
external realloc_global_data : int -> unit = "realloc_global"
external static_alloc : int -> string = "static_alloc"
external static_free : string -> unit = "static_free"
<<type Meta.closure (./bytecomp/meta.ml)>>
external reify_bytecode : string -> int -> closure = "reify_bytecode"
external available_primitives : unit -> string array = "available_primitives"
@


\subsection*{[[./bytecomp/runtimedef.mli]]}

<<signature Runtimedef.builtin_exceptions>>=
(* Values and functions known and/or provided by the runtime system *)

val builtin_exceptions: string array
@

<<signature Runtimedef.builtin_primitives>>=
val builtin_primitives: string array
@


%-------------------------------------------------------------

<<./bytecomp/runtimedef.mli>>=
<<copyright header>>

<<signature Runtimedef.builtin_exceptions>>
<<signature Runtimedef.builtin_primitives>>
@


\subsection*{[[./bytecomp/instruct.mli]]}


%-------------------------------------------------------------

<<./bytecomp/instruct.mli>>=
<<copyright header>>

(* The type of the instructions of the abstract machine *)

open Lambda

<<type Instruct.compilation_env>>

(* The ce_stack component gives locations of variables residing 
   in the stack. The locations are offsets w.r.t. the origin of the
   stack frame.
   The ce_heap component gives the positions of variables residing in the
   heap-allocated environment. *)

(* Debugging events *)

<<type Instruct.debug_event>>

<<type Instruct.debug_event_kind>>

<<type Instruct.debug_event_info>>

<<type Instruct.debug_event_repr>>

<<type Instruct.label>>

<<type Instruct.instruction>>

<<signature Instruct.immed_min>>
<<signature Instruct.immed_max>>
@


\subsection*{[[./bytecomp/instruct.ml]]}



%-------------------------------------------------------------

<<./bytecomp/instruct.ml>>=
<<copyright header>>

open Lambda

<<type Instruct.compilation_env>>


<<type Instruct.debug_event>>

<<type Instruct.debug_event_kind>>

<<type Instruct.debug_event_info>>

<<type Instruct.debug_event_repr>>

<<type Instruct.label>>

<<type Instruct.instruction>>

let immed_min = -0x40000000
and immed_max = 0x3FFFFFFF

(* Actually the abstract machine accomodates -0x80000000 to 0x7FFFFFFF,
   but these numbers overflow the Caml type int if the compiler runs on
   a 32-bit processor. *)
@


\subsection*{[[./bytecomp/printinstr.mli]]}

%-------------------------------------------------------------

<<./bytecomp/printinstr.mli>>=
<<copyright header>>

(* Pretty-print lists of instructions *)

open Instruct

<<signature Printinstr.instruction>>
<<signature Printinstr.instrlist>>
@


\subsection*{[[./bytecomp/printinstr.ml]]}


%-------------------------------------------------------------

<<./bytecomp/printinstr.ml>>=
<<copyright header>>

(* Pretty-print lists of instructions *)

open Format
open Lambda
open Instruct


<<constant Printinstr.instruction>>

<<constant Printinstr.instruction_list>>
 
<<function Printinstr.instrlist>>
@


\subsection*{[[./bytecomp/simplif.mli]]}



%-------------------------------------------------------------

<<./bytecomp/simplif.mli>>=
<<copyright header>>

(* Elimination of useless Llet(Alias) bindings *)

open Lambda

<<signature Simplif.simplify_lambda>>
@


\subsection*{[[./bytecomp/simplif.ml]]}

<<exception Simplif.Real_reference>>=
(* To transform let-bound references into variables *)

exception Real_reference
@

<<function Simplif.eliminate_ref>>=
let rec eliminate_ref id = function
    Lvar v as lam ->
      if Ident.same v id then raise Real_reference else lam
  | Lconst cst as lam -> lam
  | Lapply(e1, el) -> 
      Lapply(eliminate_ref id e1, List.map (eliminate_ref id) el)
  | Lfunction(kind, params, body) as lam ->
      if IdentSet.mem id (free_variables lam)
      then raise Real_reference
      else lam
  | Llet(str, v, e1, e2) ->
      Llet(str, v, eliminate_ref id e1, eliminate_ref id e2)
  | Lletrec(idel, e2) ->
      Lletrec(List.map (fun (v, e) -> (v, eliminate_ref id e)) idel,
              eliminate_ref id e2)
  | Lprim(Pfield 0, [Lvar v]) when Ident.same v id ->
      Lvar id
  | Lprim(Psetfield(0, _), [Lvar v; e]) when Ident.same v id ->
      Lassign(id, eliminate_ref id e)
  | Lprim(Poffsetref delta, [Lvar v]) when Ident.same v id ->
      Lassign(id, Lprim(Poffsetint delta, [Lvar id]))
  | Lprim(p, el) ->
      Lprim(p, List.map (eliminate_ref id) el)
  | Lswitch(e, sw) ->
      Lswitch(eliminate_ref id e,
        {sw_numconsts = sw.sw_numconsts;
         sw_consts =
            List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_consts;
         sw_numblocks = sw.sw_numblocks;
         sw_blocks =
            List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_blocks;
         sw_checked = sw.sw_checked})
  | Lstaticfail ->
      Lstaticfail
  | Lcatch(e1, e2) ->
      Lcatch(eliminate_ref id e1, eliminate_ref id e2)
  | Ltrywith(e1, v, e2) ->
      Ltrywith(eliminate_ref id e1, v, eliminate_ref id e2)
  | Lifthenelse(e1, e2, e3) ->
      Lifthenelse(eliminate_ref id e1,
                  eliminate_ref id e2,
                  eliminate_ref id e3)
  | Lsequence(e1, e2) ->
      Lsequence(eliminate_ref id e1, eliminate_ref id e2)
  | Lwhile(e1, e2) ->
      Lwhile(eliminate_ref id e1, eliminate_ref id e2)
  | Lfor(v, e1, e2, dir, e3) ->
      Lfor(v, eliminate_ref id e1, eliminate_ref id e2,
           dir, eliminate_ref id e3)
  | Lassign(v, e) ->
      Lassign(v, eliminate_ref id e)
  | Levent(l, ev) ->
      Levent(eliminate_ref id l, ev)
@

<<function Simplif.simplify_lambda>>=
(* Simplification of lets *)

let simplify_lambda lam =
  (* First pass: count the occurrences of all identifiers *)
  let occ = Hashtbl.create 83 in
  let count_var v =
    try
      !(Hashtbl.find occ v)
    with Not_found ->
      0 in
  let rec count = function
    Lvar v ->
      begin try
        incr(Hashtbl.find occ v)
      with Not_found ->
        Hashtbl.add occ v (ref 1)
      end
  | Lconst cst -> ()
  | Lapply(l1, ll) -> count l1; List.iter count ll
  | Lfunction(kind, params, l) -> count l
  | Llet(str, v, Lvar w, l2) ->
      (* v will be replaced by w in l2, so each occurrence of v in l2
         increases w's refcount *)
      count l2;
      let vc = count_var v in
      begin try
        let r = Hashtbl.find occ w in r := !r + vc
      with Not_found ->
        Hashtbl.add occ w (ref vc)
      end
  | Llet(str, v, l1, l2) ->
      count l2;
      (* If v is unused, l1 will be removed, so don't count its variables *)
      if str = Strict or count_var v > 0 then count l1
  | Lletrec(bindings, body) ->
      List.iter (fun (v, l) -> count l) bindings;
      count body
  | Lprim(p, ll) -> List.iter count ll
  | Lswitch(l, sw) ->
      count l;
      List.iter (fun (n, l) -> count l) sw.sw_consts;
      List.iter (fun (n, l) -> count l) sw.sw_blocks
  | Lstaticfail -> ()
  | Lcatch(l1, l2) -> count l1; count l2
  | Ltrywith(l1, v, l2) -> count l1; count l2
  | Lifthenelse(l1, l2, l3) -> count l1; count l2; count l3
  | Lsequence(l1, l2) -> count l1; count l2
  | Lwhile(l1, l2) -> count l1; count l2
  | Lfor(v, l1, l2, dir, l3) -> count l1; count l2; count l3
  | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refcount *)
      count l
  | Levent(l, ev) -> count l
  in
  count lam;
  (* Second pass: remove Lalias bindings of unused variables,
     and substitute the bindings of variables used exactly once. *)
  let subst = Hashtbl.create 83 in
  let rec simplif = function
    Lvar v as l ->
      begin try
        Hashtbl.find subst v
      with Not_found ->
        l
      end
  | Lconst cst as l -> l
  | Lapply(l1, ll) -> Lapply(simplif l1, List.map simplif ll)
  | Lfunction(kind, params, l) -> Lfunction(kind, params, simplif l)
  | Llet(str, v, Lvar w, l2) ->
      Hashtbl.add subst v (simplif (Lvar w));
      simplif l2
  | Llet(Strict, v, Lprim(Pmakeblock(0, Mutable), [linit]), lbody)
    when not !Clflags.debug ->
      let slinit = simplif linit in
      let slbody = simplif lbody in
      begin try
        Llet(Strict, v, slinit, eliminate_ref v slbody)
      with Real_reference ->
        Llet(Strict, v, Lprim(Pmakeblock(0, Mutable), [slinit]), slbody)
      end
  | Llet(Strict, v, l1, l2) -> Llet(Strict, v, simplif l1, simplif l2)
  | Llet(Alias, v, l1, l2) ->
      begin match count_var v with
        0 -> simplif l2
      | 1 -> Hashtbl.add subst v (simplif l1); simplif l2
      | n -> Llet(Alias, v, simplif l1, simplif l2)
      end
  | Llet(StrictOpt, v, l1, l2) ->
      begin match count_var v with
        0 -> simplif l2
      | n -> Llet(Alias, v, simplif l1, simplif l2)
      end
  | Lletrec(bindings, body) ->
      Lletrec(List.map (fun (v, l) -> (v, simplif l)) bindings, simplif body)
  | Lprim(p, ll) -> Lprim(p, List.map simplif ll)
  | Lswitch(l, sw) ->
      Lswitch(simplif l,
        {sw_numconsts = sw.sw_numconsts;
         sw_consts = List.map (fun (n, e) -> (n, simplif e)) sw.sw_consts;
         sw_numblocks = sw.sw_numblocks;
         sw_blocks = List.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks;
         sw_checked = sw.sw_checked})
  | Lstaticfail -> Lstaticfail
  | Lcatch(l1, l2) -> Lcatch(simplif l1, simplif l2)
  | Ltrywith(l1, v, l2) -> Ltrywith(simplif l1, v, simplif l2)
  | Lifthenelse(l1, l2, l3) -> Lifthenelse(simplif l1, simplif l2, simplif l3)
  | Lsequence(l1, l2) -> Lsequence(simplif l1, simplif l2)
  | Lwhile(l1, l2) -> Lwhile(simplif l1, simplif l2)
  | Lfor(v, l1, l2, dir, l3) ->
      Lfor(v, simplif l1, simplif l2, dir, simplif l3)
  | Lassign(v, l) -> Lassign(v, simplif l)
  | Levent(l, ev) -> Levent(simplif l, ev)
  in
  simplif lam
@


%-------------------------------------------------------------

<<./bytecomp/simplif.ml>>=
<<copyright header>>

(* Elimination of useless Llet(Alias) bindings.
   Also transform let-bound references into variables. *)

open Asttypes
open Lambda

<<exception Simplif.Real_reference>>

module IdentSet = Set

<<function Simplif.eliminate_ref>>

<<function Simplif.simplify_lambda>>
@


\subsection*{[[./bytecomp/matching.mli]]}


<<exception Matching.Cannot_flatten>>=
exception Cannot_flatten
@

<<signature Matching.flatten_pattern>>=
val flatten_pattern: int -> pattern -> pattern list
@


%-------------------------------------------------------------

<<./bytecomp/matching.mli>>=
<<copyright header>>

(* Compilation of pattern-matching *)

open Typedtree
open Lambda

<<signature Matching.for_function>>
<<signature Matching.for_trywith>>
<<signature Matching.for_let>>
<<signature Matching.for_multiple_match>>
<<signature Matching.for_tupled_function>>

<<exception Matching.Cannot_flatten>>

<<signature Matching.flatten_pattern>>
@


\subsection*{[[./bytecomp/matching.ml]]}

<<type Matching.pattern_matching>>=
(*  See Peyton-Jones, "The Implementation of functional programming
    languages", chapter 5. *)

type pattern_matching =
  { mutable cases : (pattern list * lambda) list;
    args : (lambda * let_kind) list }
@

<<function Matching.add_line>>=
(* To group lines of patterns with identical keys *)

let add_line patl_action pm =
  pm.cases <- patl_action :: pm.cases; pm
@

<<function Matching.add>>=
let add make_matching_fun division key patl_action args =
  try
    let pm = List.assoc key division in
    pm.cases <- patl_action :: pm.cases;
    division
  with Not_found ->
    let pm = make_matching_fun args in
    pm.cases <- patl_action :: pm.cases;
    (key, pm) :: division
@

<<function Matching.name_pattern>>=
(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    (pat :: patl, action) :: rem ->
      begin match pat.pat_desc with
        Tpat_var id -> id
      | Tpat_alias(p, id) -> id
      | _ -> name_pattern default rem
      end
  | _ -> Ident.create default
@

<<constant Matching.any_pat>>=
(* To remove aliases and bind named components *)

let any_pat =
  {pat_desc = Tpat_any; pat_loc = Location.none; pat_type = Ctype.none}
@

<<function Matching.simplify_matching>>=
let simplify_matching m =
  match m.args with
    [] -> m
  | (arg, mut) :: argl ->
      let rec simplify = function
        (pat :: patl, action as patl_action) :: rem ->
          begin match pat.pat_desc with
            Tpat_var id ->
              (any_pat :: patl, Llet(Alias, id, arg, action)) ::
              simplify rem
          | Tpat_alias(p, id) ->
              simplify ((p :: patl, Llet(Alias, id, arg, action)) :: rem)
          | _ ->
              patl_action :: simplify rem
          end
      | cases -> cases in
    { args = m.args; cases = simplify m.cases }
@

<<constant Matching.make_constant_matching>>=
(* Matching against a constant *)

let make_constant_matching = function
    [] -> fatal_error "Matching.make_constant_matching"
  | (arg :: argl) -> {cases = []; args = argl}
@

<<function Matching.divide_constant>>=
let divide_constant {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_constant cst} :: patl, action) :: rem ->
        let (constants, others) = divide rem in
        (add make_constant_matching constants cst (patl, action) al, others)
    | cl ->
      ([], {cases = cl; args = al})
  in divide cl
@

<<function Matching.make_constr_matching>>=
(* Matching against a constructor *)

let make_constr_matching cstr = function
    [] -> fatal_error "Matching.make_constr_matching"
  | ((arg, mut) :: argl) ->
      let (first_pos, last_pos) =
        match cstr.cstr_tag with
          Cstr_constant _ | Cstr_block _ -> (0, cstr.cstr_arity - 1)
        | Cstr_exception _ -> (1, cstr.cstr_arity) in
      let rec make_args pos =
        if pos > last_pos
        then argl
        else (Lprim(Pfield pos, [arg]), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args first_pos}
@

<<function Matching.divide_constructor>>=
let divide_constructor {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_construct(cstr, args)} :: patl, action) :: rem ->
        let (constructs, others) = divide rem in
        (add (make_constr_matching cstr) constructs
             cstr.cstr_tag (args @ patl, action) al,
         others)
    | cl ->
      ([], {cases = cl; args = al})
  in divide cl
@

<<function Matching.divide_var>>=
(* Matching against a variable *)

let divide_var {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (vars, others) = divide rem in
        (add_line (patl, action) vars, others)
    | cl ->
        (make_constant_matching al, {cases = cl; args = al})
  in divide cl
@

<<function Matching.make_tuple_matching>>=
(* Matching against a tuple pattern *)

let make_tuple_matching num_comps = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | (arg, mut) :: argl ->
      let rec make_args pos =
        if pos >= num_comps
        then argl
        else (Lprim(Pfield pos, [arg]), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args 0}
@

<<function Matching.divide_tuple>>=
let divide_tuple arity {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_tuple args} :: patl, action) :: rem ->
        let (tuples, others) = divide rem in
        (add_line (args @ patl, action) tuples, others)
    | ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (tuples, others) = divide rem in
        (add_line (replicate_list any_pat arity @ patl, action) tuples, others)
    | cl ->
        (make_tuple_matching arity al, {cases = cl; args = al})
  in divide cl
@

<<function Matching.make_record_matching>>=
(* Matching against a record pattern *)

let make_record_matching all_labels = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | ((arg, mut) :: argl) ->
      let rec make_args pos =
        if pos >= Array.length all_labels then argl else begin
          let lbl = all_labels.(pos) in
          let access =
            match lbl.lbl_repres with
              Record_regular -> Pfield lbl.lbl_pos
            | Record_float -> Pfloatfield lbl.lbl_pos in
          let str =
            match lbl.lbl_mut with
              Immutable -> Alias
            | Mutable -> StrictOpt in
          (Lprim(access, [arg]), str) :: make_args(pos + 1)
        end in
      {cases = []; args = make_args 0}
@

<<function Matching.divide_record>>=
let divide_record all_labels {cases = cl; args = al} =
  let num_fields = Array.length all_labels in
  let record_matching_line lbl_pat_list =
    let patv = Array.create num_fields any_pat in
    List.iter (fun (lbl, pat) -> patv.(lbl.lbl_pos) <- pat) lbl_pat_list;
    Array.to_list patv in
  let rec divide = function
      ({pat_desc = Tpat_record lbl_pat_list} :: patl, action) :: rem ->
        let (records, others) = divide rem in
        (add_line (record_matching_line lbl_pat_list @ patl, action) records,
         others)
    | ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (records, others) = divide rem in
        (add_line (record_matching_line [] @ patl, action) records, others)
    | cl ->
        (make_record_matching all_labels al, {cases = cl; args = al})
  in divide cl
@

<<function Matching.flatten_orpat_match>>=
(* Matching against an or pattern. *)

let rec flatten_orpat_match pat =
  match pat.pat_desc with
    Tpat_or(p1, p2) -> flatten_orpat_match p1 @ flatten_orpat_match p2
  | _ -> [[pat], lambda_unit]
@

<<constant Matching.divide_orpat>>=
let divide_orpat = function
    {cases = (orpat :: patl, act) :: casel; args = arg1 :: argl as args} ->
      ({cases = flatten_orpat_match orpat; args = [arg1]},
       {cases = [patl, act]; args = argl},
       {cases = casel; args = args})
  | _ ->
    fatal_error "Matching.divide_orpat"
@

<<function Matching.combine_var>>=
(* To combine sub-matchings together *)

let combine_var (lambda1, total1) (lambda2, total2) =
  if total1 then (lambda1, true)
  else if lambda2 = Lstaticfail then (lambda1, total1)
  else (Lcatch(lambda1, lambda2), total2)
@

<<function Matching.make_test_sequence>>=
let make_test_sequence tst arg const_lambda_list =
  List.fold_right
    (fun (c, act) rem ->
      Lifthenelse(Lprim(tst, [arg; Lconst(Const_base c)]), act, rem))
    const_lambda_list Lstaticfail
@

<<function Matching.make_switch_or_test_sequence>>=
let make_switch_or_test_sequence arg const_lambda_list int_lambda_list =
  let min_key =
    List.fold_right (fun (k, l) m -> min k m) int_lambda_list max_int in
  let max_key =
    List.fold_right (fun (k, l) m -> max k m) int_lambda_list min_int in
  (* min_key and max_key can be arbitrarily large, so watch out for
     overflow in the following comparison *)
  if List.length int_lambda_list <= 1 + max_key / 4 - min_key / 4 then
    (* Sparse matching -- use a sequence of tests
       (4 bytecode instructions per test)  *)
    make_test_sequence (Pintcomp Ceq) arg const_lambda_list
  else begin
    (* Dense matching -- use a jump table
       (2 bytecode instructions + 1 word per entry in the table) *)
    let numcases = max_key - min_key + 1 in
    let cases =
      List.map (fun (key, l) -> (key - min_key, l)) int_lambda_list in
    let offsetarg =
      if min_key = 0 then arg else Lprim(Poffsetint(-min_key), [arg]) in
    Lswitch(offsetarg,
            {sw_numconsts = numcases; sw_consts = cases;
             sw_numblocks = 0; sw_blocks = []; sw_checked = true})
  end
@

<<function Matching.make_bitvect_check>>=
let make_bitvect_check arg int_lambda_list =
  let bv = String.make 32 '\000' in
  List.iter
    (fun (n, l) ->
      bv.[n lsr 3] <- Char.chr(Char.code bv.[n lsr 3] lor (1 lsl (n land 7))))
    int_lambda_list;
  Lifthenelse(Lprim(Pbittest, [Lconst(Const_base(Const_string bv)); arg]),
              lambda_unit, Lstaticfail)
@

<<constant Matching.prim_string_equal>>=
let prim_string_equal =
  Pccall{prim_name = "string_equal";
         prim_arity = 2; prim_alloc = false;
         prim_native_name = ""; prim_native_float = false}
@

<<function Matching.combine_constant>>=
let combine_constant arg cst (const_lambda_list, total1) (lambda2, total2) =
  let lambda1 =
    match cst with
      Const_int _ ->
        let int_lambda_list =
          List.map (function Const_int n, l -> n,l | _ -> assert false)
                   const_lambda_list in
        make_switch_or_test_sequence arg const_lambda_list int_lambda_list
    | Const_char _ ->
        let int_lambda_list =
          List.map (function Const_char c, l -> (Char.code c, l)
                           | _ -> assert false)
                   const_lambda_list in
        if List.for_all (fun (c, l) -> l = lambda_unit) const_lambda_list then
          make_bitvect_check arg int_lambda_list 
        else
          make_switch_or_test_sequence arg const_lambda_list int_lambda_list
    | Const_string _ ->
        make_test_sequence prim_string_equal arg const_lambda_list
    | Const_float _ ->
        make_test_sequence (Pfloatcomp Ceq) arg const_lambda_list
  in (Lcatch(lambda1, lambda2), total2)
@

<<function Matching.combine_constructor>>=
let combine_constructor arg cstr (tag_lambda_list, total1) (lambda2, total2) =
  if cstr.cstr_consts < 0 then begin
    (* Special cases for exceptions *)
    let lambda1 =
      List.fold_right
        (fun (ex, act) rem ->
           match ex with
           | Cstr_exception path ->
               Lifthenelse(Lprim(Pintcomp Ceq, 
                                 [Lprim(Pfield 0, [arg]); transl_path path]),
                           act, rem)
           | _ -> assert false)
        tag_lambda_list Lstaticfail
    in (Lcatch(lambda1, lambda2), total2)
  end else begin
    (* Regular concrete type *)
    let rec split_cases = function
      [] -> ([], [])
    | (cstr, act) :: rem ->
        let (consts, nonconsts) = split_cases rem in
        match cstr with
          Cstr_constant n -> ((n, act) :: consts, nonconsts)
        | Cstr_block n    -> (consts, (n, act) :: nonconsts)
        | _ -> assert false in
    let (consts, nonconsts) = split_cases tag_lambda_list in
    let lambda1 =
      match (cstr.cstr_consts, cstr.cstr_nonconsts, consts, nonconsts) with
        (1, 0, [0, act], []) -> act
      | (0, 1, [], [0, act]) -> act
      | (1, 1, [0, act1], [0, act2]) ->
          Lifthenelse(arg, act2, act1)
      | (1, 1, [0, act1], []) ->
          Lifthenelse(arg, Lstaticfail, act1)
      | (1, 1, [], [0, act2]) ->
          Lifthenelse(arg, act2, Lstaticfail)
      | (_, _, _, _) ->
          Lswitch(arg, {sw_numconsts = cstr.cstr_consts;
                        sw_consts = consts;
                        sw_numblocks = cstr.cstr_nonconsts;
                        sw_blocks = nonconsts;
                        sw_checked = false}) in
    if total1
     & List.length tag_lambda_list = cstr.cstr_consts + cstr.cstr_nonconsts
    then (lambda1, true)
    else (Lcatch(lambda1, lambda2), total2)
  end
@

<<function Matching.combine_orpat>>=
let combine_orpat (lambda1, total1) (lambda2, total2) (lambda3, total3) =
  (Lcatch(Lsequence(lambda1, lambda2), lambda3), total3)
@

<<function Matching.event_branch>>=
(* Insertion of debugging events *)

let rec event_branch repr lam =
  begin match lam, repr with
    (_, None) ->
      lam
  | (Levent(lam', ev), Some r) ->
      incr r;
      Levent(lam', {lev_loc = ev.lev_loc;
                    lev_kind = ev.lev_kind;
                    lev_repr = repr;
                    lev_env = ev.lev_env})
  | (Llet(str, id, lam, body), _) ->
      Llet(str, id, lam, event_branch repr body)
  | (_, Some r) ->
(*      incr r;
      Levent(lam, {lev_loc = -1;
                   lev_kind = Lev_before;
                   lev_repr = repr;
                   lev_env = Env.Env_empty})
*)      fatal_error "Matching.event_branch"
  end
@

<<function Matching.compile_match>>=
(* The main compilation function.
   Input: a pattern matching.
   Output: a lambda term, a "total" flag (true if we're sure that the
     matching covers all cases; this is an approximation). *)

let rec compile_match repr m =

  let rec compile_list = function
    [] -> ([], true)
  | (key, pm) :: rem ->
      let (lambda1, total1) = compile_match repr pm in
      let (list2, total2) = compile_list rem in
      ((key, lambda1) :: list2, total1 & total2) in

  match m with
    { cases = [] } ->
      (Lstaticfail, false)
  | { cases = ([], action) :: rem; args = argl } ->
      if is_guarded action then begin
        let (lambda, total) =
          compile_match None { cases = rem; args = argl }
        in
        (Lcatch(event_branch repr action, lambda), total)
      end else
        (event_branch repr action, true)
  | { args = (arg, str) :: argl } ->
      let v = name_pattern "match" m.cases in
      let newarg = Lvar v in
      let pm =
        simplify_matching
          { cases = m.cases; args = (newarg, Alias) :: argl } in
      let (lam, total) =
        match pm.cases with
          (pat :: patl, action) :: _ ->
            begin match pat.pat_desc with
              Tpat_any ->
                let (vars, others) = divide_var pm in
                combine_var (compile_match repr vars)
                            (compile_match repr others)
            | Tpat_constant cst ->
                let (constants, others) = divide_constant pm in
                combine_constant newarg cst
                  (compile_list constants) (compile_match repr others)
            | Tpat_tuple patl ->
                let (tuples, others) = divide_tuple (List.length patl) pm in
                combine_var (compile_match repr tuples)
                            (compile_match repr others)
            | Tpat_construct(cstr, patl) ->
                let (constrs, others) = divide_constructor pm in
                combine_constructor newarg cstr
                  (compile_list constrs) (compile_match repr others)
            | Tpat_record((lbl, _) :: _) ->
                let (records, others) = divide_record lbl.lbl_all pm in
                combine_var (compile_match repr records)
                            (compile_match repr others)
            | Tpat_or(pat1, pat2) ->
                (* Avoid duplicating the code of the action *)
                let (or_match, remainder_line, others) = divide_orpat pm in
                combine_orpat (compile_match None or_match)
                              (compile_match repr remainder_line)
                              (compile_match repr others)
            | _ ->
                fatal_error "Matching.compile_match1"
            end
        | _ -> fatal_error "Matching.compile_match2" in
      (Llet(str, v, arg, lam), total)
  | _ -> assert false
@

<<function Matching.compile_matching>>=
(* The entry points *)

let compile_matching repr handler_fun arg pat_act_list =
  let pm =
    { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
      args = [arg, Strict] } in
  let (lambda, total) = compile_match repr pm in
  if total then lambda else Lcatch(lambda, handler_fun())
@

<<function Matching.partial_function>>=
let partial_function loc () =
  Lprim(Praise, [Lprim(Pmakeblock(0, Immutable),
          [transl_path Predef.path_match_failure;
           Lconst(Const_block(0,
              [Const_base(Const_string !Location.input_name);
               Const_base(Const_int loc.loc_start);
               Const_base(Const_int loc.loc_end)]))])])
@

<<function Matching.for_function>>=
let for_function loc repr param pat_act_list =
  compile_matching repr (partial_function loc) param pat_act_list
@

<<function Matching.for_trywith>>=
let for_trywith param pat_act_list =
  compile_matching None (fun () -> Lprim(Praise, [param])) param pat_act_list
@

<<function Matching.for_let>>=
let for_let loc param pat body =
  compile_matching None (partial_function loc) param [pat, body]
@

<<exception Matching.Cannot_flatten (./bytecomp/matching.ml)>>=
(* Handling of tupled functions and matches *)

exception Cannot_flatten
@

<<function Matching.flatten_pattern>>=
let flatten_pattern size p =
  match p.pat_desc with
    Tpat_tuple args -> args
  | Tpat_any -> replicate_list any_pat size
  | _ -> raise Cannot_flatten
@

<<function Matching.flatten_cases>>=
let flatten_cases size cases =
  List.map (function (pat :: _, act) -> (flatten_pattern size pat, act)
                   | _ -> assert false)
           cases
@

<<function Matching.for_tupled_function>>=
let for_tupled_function loc paraml pats_act_list =
  let pm =
    { cases = pats_act_list;
      args = List.map (fun id -> (Lvar id, Strict)) paraml } in
  let (lambda, total) = compile_match None pm in
  if total then lambda else Lcatch(lambda, partial_function loc ())
@

<<function Matching.for_multiple_match>>=
let for_multiple_match loc paraml pat_act_list =
  let pm1 =
    { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
      args = [Lprim(Pmakeblock(0, Immutable), paraml), Strict] } in
  let pm2 =
    simplify_matching pm1 in
  let pm3 =
    try
      { cases = flatten_cases (List.length paraml) pm2.cases;
        args = List.map (fun lam -> (lam, Strict)) paraml }
    with Cannot_flatten ->
      pm2 in
  let (lambda, total) = compile_match None pm3 in
  if total then lambda else Lcatch(lambda, partial_function loc ())
@


%-------------------------------------------------------------

<<./bytecomp/matching.ml>>=
<<copyright header>>

(* Compilation of pattern matching *)

open Misc
open Location
open Asttypes
open Primitive
open Types
open Typedtree
open Lambda

<<type Matching.pattern_matching>>

<<function Matching.add_line>>

<<function Matching.add>>

<<function Matching.name_pattern>>

<<constant Matching.any_pat>>

<<function Matching.simplify_matching>>

<<constant Matching.make_constant_matching>>

<<function Matching.divide_constant>>

<<function Matching.make_constr_matching>>

<<function Matching.divide_constructor>>

<<function Matching.divide_var>>

<<function Matching.make_tuple_matching>>

<<function Matching.divide_tuple>>

<<function Matching.make_record_matching>>

<<function Matching.divide_record>>

<<function Matching.flatten_orpat_match>>

<<constant Matching.divide_orpat>>

<<function Matching.combine_var>>

<<function Matching.make_test_sequence>>

<<function Matching.make_switch_or_test_sequence>>

<<function Matching.make_bitvect_check>>

<<constant Matching.prim_string_equal>>

<<function Matching.combine_constant>>

<<function Matching.combine_constructor>>

<<function Matching.combine_orpat>>

<<function Matching.event_branch>>

<<function Matching.compile_match>>

<<function Matching.compile_matching>>

<<function Matching.partial_function>>

<<function Matching.for_function>>

<<function Matching.for_trywith>>

<<function Matching.for_let>>

<<exception Matching.Cannot_flatten (./bytecomp/matching.ml)>>

<<function Matching.flatten_pattern>>

<<function Matching.flatten_cases>>

<<function Matching.for_tupled_function>>

<<function Matching.for_multiple_match>>
@


\subsection*{[[./bytecomp/translcore.mli]]}

<<signature Translcore.name_pattern>>=
val name_pattern: string -> (pattern * 'a) list -> Ident.t
@

<<signature Translcore.maybe_pointer>>=
val maybe_pointer: expression -> bool
@




%-------------------------------------------------------------

<<./bytecomp/translcore.mli>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Asttypes
open Types
open Typedtree
open Lambda

<<signature Translcore.name_pattern>>
<<signature Translcore.maybe_pointer>>

<<signature Translcore.transl_exp>>
<<signature Translcore.transl_let>>
<<signature Translcore.transl_primitive>>
<<signature Translcore.transl_exception>>

<<type Translcore.error>>

<<exception Translcore.Error>>

<<signature Translcore.report_error>>
@


\subsection*{[[./bytecomp/translcore.ml]]}


<<function Translcore.has_base_type>>=
(*
let has_base_type exp base_ty =
  let exp_ty =
    Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
  match (Ctype.repr exp_ty, Ctype.repr base_ty) with
    {desc = Tconstr(p1, _, _)}, {desc = Tconstr(p2, _, _)} -> Path.same p1 p2
  | (_, _) -> false
*)
@

<<function Translcore.maybe_pointer>>=
(*
let maybe_pointer arg =
  not(has_base_type arg Predef.type_int or has_base_type arg Predef.type_char)
*)
@

<<function Translcore.array_element_kind>>=
(*
let array_element_kind env ty =
  let ty = Ctype.repr (Ctype.expand_head env ty) in
  match ty.desc with
    Tvar ->
      Pgenarray
  | Tconstr(p, args, abbrev) ->
      if Path.same p Predef.path_int || Path.same p Predef.path_char then
        Pintarray
      else if Path.same p Predef.path_float then
        Pfloatarray
      else if Path.same p Predef.path_string
           || Path.same p Predef.path_array then
        Paddrarray
      else begin
        try
          match Env.find_type p env with
            {type_kind = Type_abstract} ->
              Pgenarray
          | {type_kind = Type_variant cstrs}
            when List.for_all (fun (name, args) -> args = []) cstrs ->
              Pintarray
          | {type_kind = _} ->
              Paddrarray
        with Not_found ->
          (* This can happen due to e.g. missing -I options,
             causing some .cmi files to be unavailable.
             Maybe we should emit a warning. *)
          Pgenarray
      end
  | _ ->
      Paddrarray
*)
@

<<function Translcore.array_kind>>=
(*
let array_kind arg =
  let ty = Ctype.correct_levels arg.exp_type in
  let array_ty = Ctype.expand_head arg.exp_env ty in
  match (Ctype.repr array_ty).desc with
    Tconstr(p, [elt_ty], _) when Path.same p Predef.path_array ->
      array_element_kind arg.exp_env elt_ty
  | _ ->
    fatal_error "Translcore.array_kind"
*)
@

<<constant Translcore.prim_makearray>>=
let prim_makearray =
  { prim_name = "make_vect"; prim_arity = 2; prim_alloc = true;
    prim_native_name = ""; prim_native_float = false }
@

<<function Translcore.transl_prim>>=
let transl_prim prim args =
  try
    let (gencomp, intcomp, floatcomp, stringcomp) =
      Hashtbl.find comparisons_table prim.prim_name in
    begin match args with
      [arg1; {exp_desc = Texp_construct({cstr_tag = Cstr_constant _}, _)}] ->
        intcomp
    | [{exp_desc = Texp_construct({cstr_tag = Cstr_constant _}, _)}; arg2] ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_int
                     or has_base_type arg1 Predef.type_char ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_float ->
        floatcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_string ->
        stringcomp
    | _ ->
        gencomp
    end
  with Not_found ->
  try
    let p = Hashtbl.find primitives_table prim.prim_name in
    (* Try strength reduction based on the type of the argument *)
    begin match (p, args) with
        (Psetfield(n, _), [arg1; arg2]) -> Psetfield(n, maybe_pointer arg2)
      | (Parraylength Pgenarray, [arg])   -> Parraylength(array_kind arg)
      | (Parrayrefu Pgenarray, arg1 :: _) -> Parrayrefu(array_kind arg1)
      | (Parraysetu Pgenarray, arg1 :: _) -> Parraysetu(array_kind arg1)
      | (Parrayrefs Pgenarray, arg1 :: _) -> Parrayrefs(array_kind arg1)
      | (Parraysets Pgenarray, arg1 :: _) -> Parraysets(array_kind arg1)
      | _ -> p
    end
  with Not_found ->
    Pccall prim
@

<<function Translcore.transl_primitive>>=
(* Eta-expand a primitive without knowing the types of its arguments *)

let transl_primitive p =
  let prim =
    try
      let (gencomp, intcomp, floatcomp, stringcomp) =
        Hashtbl.find comparisons_table p.prim_name in
      gencomp
    with Not_found ->
    try
      Hashtbl.find primitives_table p.prim_name
    with Not_found ->
      Pccall p in
  let rec make_params n =
    if n <= 0 then [] else Ident.create "prim" :: make_params (n-1) in
  let params = make_params p.prim_arity in
  Lfunction(Curried, params, Lprim(prim, List.map (fun id -> Lvar id) params))
@

<<function Translcore.check_recursive_lambda>>=
let check_recursive_lambda idlist lam =
  let rec check_top = function
      Lfunction(kind, params, body) as funct -> true
    | Lprim(Pmakeblock(tag, mut), args) -> List.for_all check args
    | Lprim(Pmakearray kind, args) -> List.for_all check args
    | Llet(str, id, arg, body) -> check arg & check_top body
    | Lletrec(bindings, body) ->
        List.for_all (fun (id, arg) -> check arg) bindings & check_top body
    | Levent (lam, _) -> check_top lam
    | _ -> false
  and check = function
      Lvar _ -> true
    | Lconst cst -> true
    | Lfunction(kind, params, body) -> true
    | Llet(str, id, arg, body) -> check arg & check body
    | Lletrec(bindings, body) ->
        List.for_all (fun (id, arg) -> check arg) bindings & check body
    | Lprim(Pmakeblock(tag, mut), args) -> List.for_all check args
    | Lprim(Pmakearray kind, args) -> List.for_all check args
    | Levent (lam, _) -> check lam
    | lam ->
        let fv = free_variables lam in
        List.for_all (fun id -> not(IdentSet.mem id fv)) idlist
  in check_top lam
@

<<exception Translcore.Not_constant>>=
(* To propagate structured constants *)

exception Not_constant
@

<<constant Translcore.extract_constant>>=
let extract_constant = function
    Lconst sc -> sc
  | _ -> raise Not_constant
@

<<constant Translcore.extract_float>>=
let extract_float = function
    Const_base(Const_float f) -> f
  | _ -> fatal_error "Translcore.extract_float"
@

<<function Translcore.name_pattern>>=
(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    [] -> Ident.create default
  | (p, e) :: rem ->
      match p.pat_desc with
        Tpat_var id -> id
      | Tpat_alias(p, id) -> id
      | _ -> name_pattern default rem
@

<<function Translcore.event_before>>=
(* Insertion of debugging events *)

let event_before exp lam =
  if !Clflags.debug && lam <> Lstaticfail
  then Levent(lam, {lev_loc = exp.exp_loc.Location.loc_start;
                    lev_kind = Lev_before;
                    lev_repr = None;
                    lev_env =  ()(* Env.summary exp.exp_env*)})
  else lam
@

<<function Translcore.event_after>>=
let event_after exp lam =
  if !Clflags.debug
  then Levent(lam, {lev_loc = exp.exp_loc.Location.loc_end;
                    lev_kind = Lev_after exp.exp_type;
                    lev_repr = None;
                    lev_env = () (* Env.summary exp.exp_env*)})
  else lam
@

<<function Translcore.event_function>>=
let event_function exp lam =
  if !Clflags.debug then
    let repr = Some (ref 0) in
    let (info, body) = lam repr in
    (info,
     Levent(body, {lev_loc = exp.exp_loc.Location.loc_start;
                   lev_kind = Lev_function;
                   lev_repr = repr;
                   lev_env = () (* Env.summary  exp.exp_env*)}))
  else
    lam None
@

<<function Translcore.transl_exception>>=
(* Compile an exception definition *)

let transl_exception id decl =
    Lprim(Pmakeblock(0, Immutable),
          [Lconst(Const_base(Const_string(Ident.name id)))])
@



%-------------------------------------------------------------

<<./bytecomp/translcore.ml>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Misc
open Asttypes
open Primitive
open Path
open Types
open Typedtree
open Lambda

<<type Translcore.error>>

<<exception Translcore.Error>>

<<constant Translcore.comparisons_table>>

<<constant Translcore.primitives_table>>

let same_base_type ty1 ty2 =
  match (Ctype.repr ty1, Ctype.repr ty2) with
    (Tconstr(p1, []), Tconstr(p2, [])) -> Path.same p1 p2
  | (_, _) -> false

let maybe_pointer arg =
  not(same_base_type arg.exp_type Predef.type_int or
      same_base_type arg.exp_type Predef.type_char)


let array_kind arg =
  match Ctype.repr arg.exp_type with
    Tconstr(p, [ty]) when Path.same p Predef.path_array ->
      begin match Ctype.repr ty with
        Tvar v -> Pgenarray
      | Tconstr(p, _) ->
          if Path.same p Predef.path_int or Path.same p Predef.path_char then
            Pintarray
          else if Path.same p Predef.path_float then
            Pfloatarray
          else
            Paddrarray
      | _ -> Paddrarray
      end
  | _ -> Pgenarray (* This can happen with abbreviations that we can't expand
                      here because the typing environment is lost *)

let has_base_type exp base_ty = 
  same_base_type exp.exp_type base_ty

<<function Translcore.has_base_type>>

<<function Translcore.maybe_pointer>>

<<function Translcore.array_element_kind>>

<<function Translcore.array_kind>>

<<constant Translcore.prim_makearray>>

<<function Translcore.transl_prim>>

<<function Translcore.transl_primitive>>

(* To check the well-formedness of r.h.s. of "let rec" definitions *)

module IdentSet = Set

<<function Translcore.check_recursive_lambda>>

<<exception Translcore.Not_constant>>

<<constant Translcore.extract_constant>>

<<constant Translcore.extract_float>>

<<function Translcore.name_pattern>>

<<function Translcore.event_before>>

<<function Translcore.event_after>>

<<function Translcore.event_function>>

(* Translation of expressions *)

let rec transl_exp e =
  match e.exp_desc with
    Texp_ident(path, {val_prim = Some p}) ->
      transl_primitive p
  | Texp_ident(path, desc) ->
      transl_path path
  | Texp_constant cst ->
      Lconst(Const_base cst)
  | Texp_let(rec_flag, pat_expr_list, body) ->
      transl_let rec_flag pat_expr_list (event_before body (transl_exp body))
  | Texp_function pat_expr_list ->
      let ((kind, params), body) =
        event_function e
          (function repr ->
             transl_function e.exp_loc !Clflags.native_code repr pat_expr_list)
      in
      Lfunction(kind, params, body)
  | Texp_apply({exp_desc = Texp_ident(path, {val_prim = Some p})}, args)
    when List.length args = p.prim_arity ->
      let prim = transl_prim p args in
      let lam = Lprim(prim, transl_list args) in
      begin match prim with Pccall _ -> event_after e lam | _ -> lam end
  | Texp_apply(funct, args) ->
      let lam =
        match transl_exp funct with
         lexp ->
            Lapply(lexp, transl_list args) in
      event_after e lam
  | Texp_match({exp_desc = Texp_tuple argl} as arg, pat_expr_list) ->
      Matching.for_multiple_match e.exp_loc
        (transl_list argl) (transl_cases pat_expr_list)
  | Texp_match(arg, pat_expr_list) ->
      Matching.for_function e.exp_loc None
        (transl_exp arg) (transl_cases pat_expr_list)
  | Texp_try(body, pat_expr_list) ->
      let id = name_pattern "exn" pat_expr_list in
      Ltrywith(transl_exp body, id,
               Matching.for_trywith (Lvar id) (transl_cases pat_expr_list))
  | Texp_tuple el ->
      let ll = transl_list el in
      begin try
        Lconst(Const_block(0, List.map extract_constant ll))
      with Not_constant ->
        Lprim(Pmakeblock(0, Immutable), ll)
      end
  | Texp_construct(cstr, args) ->
      let ll = transl_list args in
      begin match cstr.cstr_tag with
        Cstr_constant n ->
          Lconst(Const_pointer n)
      | Cstr_block n ->
          begin try
            Lconst(Const_block(n, List.map extract_constant ll))
          with Not_constant ->
            Lprim(Pmakeblock(n, Immutable), ll)
          end
      | Cstr_exception path ->
          Lprim(Pmakeblock(0, Immutable), transl_path path :: ll)
      end
  | Texp_record ((lbl1, _) :: _ as lbl_expr_list) ->
      let lv = Array.create (Array.length lbl1.lbl_all) Lstaticfail in
      List.iter
        (fun (lbl, expr) -> lv.(lbl.lbl_pos) <- transl_exp expr)
        lbl_expr_list;
      let ll = Array.to_list lv in
      if List.exists (fun (lbl, expr) -> lbl.lbl_mut = Mutable) lbl_expr_list
      then begin
        match lbl1.lbl_repres with
          Record_regular -> Lprim(Pmakeblock(0, Mutable), ll)
        | Record_float -> Lprim(Pmakearray Pfloatarray, ll)
      end else begin
        try
          let cl = List.map extract_constant ll in
          match lbl1.lbl_repres with
            Record_regular -> Lconst(Const_block(0, cl))
          | Record_float ->
              Lconst(Const_float_array(List.map extract_float cl))
        with Not_constant ->
          match lbl1.lbl_repres with
            Record_regular -> Lprim(Pmakeblock(0, Immutable), ll)
          | Record_float -> Lprim(Pmakearray Pfloatarray, ll)
      end
  | Texp_field(arg, lbl) ->
      let access =
        match lbl.lbl_repres with
          Record_regular -> Pfield lbl.lbl_pos
        | Record_float -> Pfloatfield lbl.lbl_pos in
      Lprim(access, [transl_exp arg])
  | Texp_setfield(arg, lbl, newval) ->
      let access =
        match lbl.lbl_repres with
          Record_regular -> Psetfield(lbl.lbl_pos, maybe_pointer newval)
        | Record_float -> Psetfloatfield lbl.lbl_pos in
      Lprim(access, [transl_exp arg; transl_exp newval])
  | Texp_array expr_list ->
      let kind = array_kind e in
      let len = List.length expr_list in
      if len <= Config.max_young_wosize then
        Lprim(Pmakearray kind, transl_list expr_list)
      else begin
        let v = Ident.create "makearray" in
        let rec fill_fields pos = function
          [] ->
            Lvar v
        | arg :: rem ->
            Lsequence(Lprim(Parraysetu kind,
                            [Lvar v;
                             Lconst(Const_base(Const_int pos));
                             transl_exp arg]),
                      fill_fields (pos+1) rem) in
        Llet(Strict, v,
             Lprim(Pccall prim_makearray,
                   [Lconst(Const_base(Const_int len));
                    transl_exp (List.hd expr_list)]),
             fill_fields 1 (List.tl expr_list))
      end
  | Texp_ifthenelse(cond, ifso, Some ifnot) ->
      Lifthenelse(transl_exp cond,
                  event_before ifso (transl_exp ifso),
                  event_before ifnot (transl_exp ifnot))
  | Texp_ifthenelse(cond, ifso, None) ->
      Lifthenelse(transl_exp cond,
                  event_before ifso (transl_exp ifso),
                  lambda_unit)
  | Texp_sequence(expr1, expr2) ->
      Lsequence(transl_exp expr1, event_before expr2 (transl_exp expr2))
  | Texp_while(cond, body) ->
      Lwhile(transl_exp cond, event_before body (transl_exp body))
  | Texp_for(param, low, high, dir, body) ->
      Lfor(param, transl_exp low, transl_exp high, dir,
           event_before body (transl_exp body))
  | Texp_when(cond, body) ->
      event_before cond
        (Lifthenelse(transl_exp cond, event_before body (transl_exp body),
                     Lstaticfail))
  | _ ->
      fatal_error "Translcore.transl"

and transl_list expr_list =
  List.map transl_exp expr_list

and transl_cases pat_expr_list =
  List.map
    (fun (pat, expr) -> (pat, event_before expr (transl_exp expr)))
    pat_expr_list

and transl_tupled_cases patl_expr_list =
  List.map (fun (patl, expr) -> (patl, transl_exp expr)) patl_expr_list

and transl_function loc untuplify_fn repr pat_expr_list =
  match pat_expr_list with
    [pat, ({exp_desc = Texp_function pl} as exp)] ->
      let param = name_pattern "param" pat_expr_list in
      let ((_, params), body) = transl_function exp.exp_loc false repr pl in
      ((Curried, param :: params),
       Matching.for_function loc None (Lvar param) [pat, body])
  | ({pat_desc = Tpat_tuple pl}, _) :: _ when untuplify_fn ->
      begin try
        let size = List.length pl in
        let pats_expr_list =
          List.map
            (fun (pat, expr) -> (Matching.flatten_pattern size pat, expr))
            pat_expr_list in
        let params = List.map (fun p -> Ident.create "param") pl in
        ((Tupled, params),
         Matching.for_tupled_function loc params
                                      (transl_tupled_cases pats_expr_list))
      with Matching.Cannot_flatten ->
        let param = name_pattern "param" pat_expr_list in
        ((Curried, [param]),
         Matching.for_function loc repr (Lvar param)
           (transl_cases pat_expr_list))
      end
  | _ ->
      let param = name_pattern "param" pat_expr_list in
      ((Curried, [param]),
       Matching.for_function loc repr (Lvar param)
         (transl_cases pat_expr_list))

and transl_let rec_flag pat_expr_list body =
  match rec_flag with
    Nonrecursive ->
      let rec transl = function
        [] ->
          body
      | (pat, expr) :: rem ->
          Matching.for_let pat.pat_loc (transl_exp expr) pat (transl rem)
      in transl pat_expr_list
  | Recursive ->
      let idlist =
        List.map
          (fun (pat, expr) -> 
            match pat.pat_desc with
              Tpat_var id -> id
            | _ -> raise(Error(pat.pat_loc, Illegal_letrec_pat)))
        pat_expr_list in
      let transl_case (pat, expr) id =
        let lam = transl_exp expr in
        if not (check_recursive_lambda idlist lam) then
          raise(Error(expr.exp_loc, Illegal_letrec_expr));
        (id, lam) in
      Lletrec(List.map2 transl_case pat_expr_list idlist, body)

<<function Translcore.transl_exception>>

(* Error report *)

open Format

<<constant Translcore.report_error>>
@


\subsection*{[[./bytecomp/bytegen.mli]]}


<<signature Bytegen.compile_phrase>>=
val compile_phrase: lambda -> instruction list * instruction list
@


%-------------------------------------------------------------

<<./bytecomp/bytegen.mli>>=
<<copyright header>>

(* Generation of bytecode from lambda terms *)

open Lambda
open Instruct

<<signature Bytegen.compile_implementation>>
<<signature Bytegen.compile_phrase>>
@


\subsection*{[[./bytecomp/bytegen.ml]]}

<<constant Bytegen.label_counter>>=
(**** Label generation ****)

let label_counter = ref 0
@

<<function Bytegen.new_label>>=
let new_label () =
  incr label_counter; !label_counter
@

<<constant Bytegen.empty_env>>=
(**** Operations on compilation environments. ****)

let empty_env =
  { ce_stack = Ident.empty; ce_heap = Ident.empty }
@

<<function Bytegen.add_var>>=
(* Add a stack-allocated variable *)

let add_var id pos env =
  { ce_stack = Ident.add id pos env.ce_stack;
    ce_heap = env.ce_heap }
@

<<constant Bytegen.label_code>>=
(* Return a label to the beginning of the given continuation.
   If the sequence starts with a branch, use the target of that branch
   as the label, thus avoiding a jump to a jump. *)

let label_code = function
    Kbranch lbl :: _ as cont -> (lbl, cont)
  | Klabel lbl :: _ as cont -> (lbl, cont)
  | cont -> let lbl = new_label() in (lbl, Klabel lbl :: cont)
@

<<function Bytegen.make_branch>>=
(* Return a branch to the continuation. That is, an instruction that,
   when executed, branches to the continuation or performs what the
   continuation performs. We avoid generating branches to branches and
   branches to returns. *)

let make_branch cont =
  match cont with
    (Kbranch _ as branch) :: _ -> (branch, cont)
  | (Kreturn _ as return) :: _ -> (return, cont)
  | Kraise :: _ -> (Kraise, cont)
  | Klabel lbl :: _ -> (Kbranch lbl, cont)
  | _ -> let lbl = new_label() in (Kbranch lbl, Klabel lbl :: cont)
@

<<constant Bytegen.discard_dead_code>>=
(* Discard all instructions up to the next label.
   This function is to be applied to the continuation before adding a
   non-terminating instruction (branch, raise, return) in front of it. *)

let rec discard_dead_code = function
    [] -> []
  | (Klabel _ | Krestart | Ksetglobal _) :: _ as cont -> cont
  | _ :: cont -> discard_dead_code cont
@

<<constant Bytegen.is_tailcall>>=
(* Check if we're in tailcall position *)

let rec is_tailcall = function
    Kreturn _ :: _ -> true
  | Klabel _ :: c -> is_tailcall c
  | Kpop _ :: c -> is_tailcall c
  | _ -> false
@

<<function Bytegen.add_pop>>=
(* Add a Kpop N instruction in front of a continuation *)

let rec add_pop n cont =
  if n = 0 then cont else
    match cont with
      Kpop m :: cont -> add_pop (n + m) cont
    | Kreturn m :: cont -> Kreturn(n + m) :: cont
    | Kraise :: _ -> cont
    | _ -> Kpop n :: cont
@

<<constant Bytegen.add_const_unit>>=
(* Add the constant "unit" in front of a continuation *)

let add_const_unit = function
    (Kacc _ | Kconst _ | Kgetglobal _ | Kpush_retaddr _) :: _ as cont -> cont
  | cont -> Kconst const_unit :: cont
@

<<constant Bytegen.size_of_lambda>>=
let rec size_of_lambda = function
  | Lfunction(kind, params, body) as funct ->
      1 + IdentSet.cardinal(free_variables funct)
  | Lprim(Pmakeblock(tag, mut), args) -> List.length args
  | Lprim(Pmakearray kind, args) -> List.length args
  | Llet(str, id, arg, body) -> size_of_lambda body
  | Lletrec(bindings, body) -> size_of_lambda body
  | Levent (lam, _) -> size_of_lambda lam
  | _ -> fatal_error "Bytegen.size_of_lambda"
@

<<function Bytegen.copy_event>>=
(**** Merging consecutive events ****)

let copy_event ev kind info repr =
  { ev_pos = 0;                   (* patched in emitcode *)
    ev_module = ev.ev_module;
    ev_char = ev.ev_char;
    ev_kind = kind;
    ev_info = info;
    ev_typenv = ev.ev_typenv;
    ev_compenv = ev.ev_compenv;
    ev_stacksize = ev.ev_stacksize;
    ev_repr = repr }
@

<<function Bytegen.merge_infos>>=
let merge_infos ev ev' =
  match ev.ev_info, ev'.ev_info with
    Event_other, info -> info
  | info, Event_other -> info
  | _                 -> fatal_error "Bytegen.merge_infos"
@

<<function Bytegen.merge_repr>>=
let merge_repr ev ev' =
  match ev.ev_repr, ev'.ev_repr with
    Event_none, x -> x
  | x, Event_none -> x
  | Event_parent r, Event_child r' when r == r' && !r = 1 -> Event_none
  | _, _          -> fatal_error "Bytegen.merge_repr"
@

<<function Bytegen.merge_events>>=
let merge_events ev ev' =
  let (maj, min) =
    match ev.ev_kind, ev'.ev_kind with
    (* Discard pseudo-events *)    
      Event_pseudo,  _                              -> ev', ev
    | _,             Event_pseudo                   -> ev,  ev'
    (* Keep following event, supposedly more informative *)
    | Event_before,  (Event_after _ | Event_before) -> ev',  ev
    (* Discard following events, supposedly less informative *)
    | Event_after _, (Event_after _ | Event_before) -> ev, ev'
  in
  copy_event maj maj.ev_kind (merge_infos maj min) (merge_repr maj min)
@

<<function Bytegen.weaken_event>>=
let weaken_event ev cont =
  match ev.ev_kind with
    Event_after _ ->
      begin match cont with
        Kpush :: Kevent ({ev_repr = Event_none} as ev') :: c ->
          begin match ev.ev_info with
            Event_return _ ->
              (* Weaken event *)
              let repr = ref 1 in
              let ev =
                copy_event ev Event_pseudo ev.ev_info (Event_parent repr)
              and ev' =
                copy_event ev' ev'.ev_kind ev'.ev_info (Event_child repr)
              in
              Kevent ev :: Kpush :: Kevent ev' :: c
          | _ ->
              (* Only keep following event, equivalent *)
              cont
          end
      | _ ->
          Kevent ev :: cont
      end
  | _ ->
      Kevent ev :: cont
@

<<function Bytegen.add_event>>=
let add_event ev =
  function
    Kevent ev' :: cont -> weaken_event (merge_events ev ev') cont
  | cont               -> weaken_event ev cont
@

<<constant Bytegen.functions_to_compile>>=
(* Function bodies that remain to be compiled *)

let functions_to_compile  =
@

<<constant Bytegen.compunit_name>>=
(* Name of current compilation unit (for debugging events) *)

let compunit_name = ref ""
@

<<function Bytegen.comp_function>>=
(**** Compilation of functions ****)

let comp_function (params, fun_body, entry_lbl, free_vars) cont =
  let arity = List.length params in
  let rec pos_args pos delta = function
      [] -> Ident.empty
    | id :: rem -> Ident.add id pos (pos_args (pos+delta) delta rem) in
  let env =
    { ce_stack = pos_args arity (-1) params;
      ce_heap = pos_args 0 1 free_vars } in
  let cont1 =
    comp_expr env fun_body arity (Kreturn arity :: cont) in
  if arity > 1 then
    Krestart :: Klabel entry_lbl :: Kgrab(arity - 1) :: cont1
  else
    Klabel entry_lbl :: cont1
@

<<function Bytegen.comp_remainder>>=
let comp_remainder cont =
  let c = ref cont in
  begin try
    while true do
      c := comp_function (Stack.pop functions_to_compile) !c
    done
  with Stack.Empty ->
    ()
  end;
  !c
@

<<function Bytegen.compile_implementation>>=
(**** Compilation of a lambda phrase ****)

let compile_implementation modulename expr =
  Stack.clear functions_to_compile;
  label_counter := 0;
  lbl_staticfail := 0;
  sz_staticfail := 0;
  compunit_name := modulename;
  let init_code = comp_expr empty_env expr 0 [] in
  if Stack.length functions_to_compile > 0 then begin
    let lbl_init = new_label() in
    Kbranch lbl_init :: comp_remainder (Klabel lbl_init :: init_code)
  end else
    init_code
@

<<function Bytegen.compile_phrase>>=
let compile_phrase expr =
  Stack.clear functions_to_compile;
  label_counter := 0;
  lbl_staticfail := 0;
  sz_staticfail := 0;
  let init_code = comp_expr empty_env expr 1 [Kreturn 1] in
  let fun_code = comp_remainder [] in
  (init_code, fun_code)
@


%-------------------------------------------------------------

<<./bytecomp/bytegen.ml>>=
<<copyright header>>

(*  bytegen.ml : translation of lambda terms to lists of instructions. *)

open Misc
open Asttypes
open Primitive
open Types
open Lambda
open Instruct

<<constant Bytegen.label_counter>>

<<function Bytegen.new_label>>

<<constant Bytegen.empty_env>>

<<function Bytegen.add_var>>

(**** Examination of the continuation ****)

<<constant Bytegen.label_code>>

<<function Bytegen.make_branch>>

<<constant Bytegen.discard_dead_code>>

<<constant Bytegen.is_tailcall>>

<<function Bytegen.add_pop>>

<<constant Bytegen.add_const_unit>>

(**** Auxiliary for compiling "let rec" ****)

module IdentSet = Set

<<constant Bytegen.size_of_lambda>>

<<function Bytegen.copy_event>>

<<function Bytegen.merge_infos>>

<<function Bytegen.merge_repr>>

<<function Bytegen.merge_events>>

<<function Bytegen.weaken_event>>
  
<<function Bytegen.add_event>>

(**** Compilation of a lambda expression ****)

(* The label to which Lstaticfail branches, and the stack size at that point.*)

let lbl_staticfail = ref 0
and sz_staticfail = ref 0

<<constant Bytegen.functions_to_compile>>
  (Stack.create () : (Ident.t list * lambda * label * Ident.t list) Stack.t)

<<constant Bytegen.compunit_name>>

(* Compile an expression.
   The value of the expression is left in the accumulator.
   env = compilation environment
   exp = the lambda expression to compile
   sz = current size of the stack frame
   cont = list of instructions to execute afterwards
   Result = list of instructions that evaluate exp, then perform cont. *)

let rec comp_expr env exp sz cont =
  match exp with
    Lvar id ->
      begin try
        let pos = Ident.find_same id env.ce_stack in
        Kacc(sz - pos) :: cont
      with Not_found ->
      try
        let pos = Ident.find_same id env.ce_heap in
        Kenvacc(pos) :: cont
      with Not_found ->
        Ident.print id; print_newline();
        fatal_error "Bytegen.comp_expr: var"
      end
  | Lconst cst ->
      Kconst cst :: cont
  | Lapply(func, args) ->
      let nargs = List.length args in
      if is_tailcall cont then
        comp_args env args sz
          (Kpush :: comp_expr env func (sz + nargs)
            (Kappterm(nargs, sz + nargs) :: discard_dead_code cont))
      else
        if nargs < 4 then
          comp_args env args sz
            (Kpush :: comp_expr env func (sz + nargs) (Kapply nargs :: cont))
        else begin
          let (lbl, cont1) = label_code cont in
          Kpush_retaddr lbl ::
          comp_args env args (sz + 3)
            (Kpush :: comp_expr env func (sz + 3 + nargs)
                      (Kapply nargs :: cont1))
        end
  | Lfunction(kind, params, body) -> (* assume kind = Curried *)
      let lbl = new_label() in
      let fv = IdentSet.elements(free_variables exp) in
      Stack.push (params, body, lbl, fv) functions_to_compile;
      comp_args env (List.map (fun n -> Lvar n) fv) sz
        (Kclosure(lbl, List.length fv) :: cont)
  | Llet(str, id, arg, body) ->
      comp_expr env arg sz
        (Kpush :: comp_expr (add_var id (sz+1) env) body (sz+1)
          (add_pop 1 cont))
  | Lletrec(([id, Lfunction(kind, params, funct_body)] as decl), let_body) ->
      let lbl = new_label() in
      let fv =
        IdentSet.elements (free_variables (Lletrec(decl, lambda_unit))) in
      Stack.push (params, funct_body, lbl, id :: fv) functions_to_compile;
      comp_args env (List.map (fun n -> Lvar n) fv) sz
        (Kclosurerec(lbl, List.length fv) :: Kpush ::
          (comp_expr (add_var id (sz+1) env) let_body (sz+1)
                     (add_pop 1 cont)))
  | Lletrec(decl, body) ->
      let ndecl = List.length decl in
      let decl_size =
        List.map (fun (id, exp) -> (id, exp, size_of_lambda exp)) decl in
      let rec comp_decl new_env sz i = function
          [] ->
            comp_expr new_env body sz (add_pop ndecl cont)
        | (id, exp, blocksize) :: rem ->
            comp_expr new_env exp sz
              (Kpush :: Kacc i :: Kupdate blocksize ::
               comp_decl new_env sz (i-1) rem) in
      let rec comp_init new_env sz = function
          [] ->
            comp_decl new_env sz ndecl decl_size
        | (id, exp, blocksize) :: rem ->
            Kdummy blocksize :: Kpush ::
            comp_init (add_var id (sz+1) new_env) (sz+1) rem in
      comp_init env sz decl_size
  | Lprim(Pidentity, [arg]) ->
      comp_expr env arg sz cont
  | Lprim(Pnot, [arg]) ->
      let newcont =
        match cont with
          Kbranchif lbl :: cont1 -> Kbranchifnot lbl :: cont1
        | Kbranchifnot lbl :: cont1 -> Kbranchif lbl :: cont1
        | _ -> Kboolnot :: cont in
      comp_expr env arg sz newcont
  | Lprim(Psequand, [exp1; exp2]) ->
      begin match cont with
        Kbranchifnot lbl :: _ ->
          comp_expr env exp1 sz (Kbranchifnot lbl ::
            comp_expr env exp2 sz cont)
      | Kbranchif lbl :: cont1 ->
          let (lbl2, cont2) = label_code cont1 in
          comp_expr env exp1 sz (Kbranchifnot lbl2 ::
            comp_expr env exp2 sz (Kbranchif lbl :: cont2))
      | _ ->
          let (lbl, cont1) = label_code cont in
          comp_expr env exp1 sz (Kstrictbranchifnot lbl ::
            comp_expr env exp2 sz cont1)
      end
  | Lprim(Psequor, [exp1; exp2]) ->
      begin match cont with
        Kbranchif lbl :: _ ->
          comp_expr env exp1 sz (Kbranchif lbl ::
            comp_expr env exp2 sz cont)
      | Kbranchifnot lbl :: cont1 ->
          let (lbl2, cont2) = label_code cont1 in
          comp_expr env exp1 sz (Kbranchif lbl2 ::
            comp_expr env exp2 sz (Kbranchifnot lbl :: cont2))
      | _ ->
          let (lbl, cont1) = label_code cont in
          comp_expr env exp1 sz (Kstrictbranchif lbl ::
            comp_expr env exp2 sz cont1)
      end
  | Lprim(Praise, [arg]) ->
      comp_expr env arg sz (Kraise :: discard_dead_code cont)
  | Lprim((Paddint | Psubint as prim), [arg; Lconst(Const_base(Const_int n))])
    when n >= immed_min & n <= immed_max ->
      let ofs = if prim == Paddint then n else -n in
      comp_expr env arg sz (Koffsetint ofs :: cont)
  | Lprim(p, args) ->
      let instr =
        match p with
          Pgetglobal id -> Kgetglobal id
        | Psetglobal id -> Ksetglobal id
        | Pintcomp cmp -> Kintcomp cmp
        | Pmakeblock(tag, mut) -> Kmakeblock(List.length args, tag)
        | Pfield n -> Kgetfield n
        | Psetfield(n, ptr) -> Ksetfield n
        | Pfloatfield n -> Kgetfield n
        | Psetfloatfield n -> Ksetfield n
        | Pccall p -> Kccall(p.prim_name, p.prim_arity)
        | Pnegint -> Knegint
        | Paddint -> Kaddint
        | Psubint -> Ksubint
        | Pmulint -> Kmulint
        | Pdivint -> Kdivint
        | Pmodint -> Kmodint
        | Pandint -> Kandint
        | Porint -> Korint
        | Pxorint -> Kxorint
        | Plslint -> Klslint
        | Plsrint -> Klsrint
        | Pasrint -> Kasrint
        | Poffsetint n -> Koffsetint n
        | Poffsetref n -> Koffsetref n
        | Pintoffloat -> Kccall("int_of_float", 1)
        | Pfloatofint -> Kccall("float_of_int", 1)
        | Pnegfloat -> Kccall("neg_float", 1)
        | Pabsfloat -> Kccall("abs_float", 1)
        | Paddfloat -> Kccall("add_float", 2)
        | Psubfloat -> Kccall("sub_float", 2)
        | Pmulfloat -> Kccall("mul_float", 2)
        | Pdivfloat -> Kccall("div_float", 2)
        | Pfloatcomp Ceq -> Kccall("eq_float", 2)
        | Pfloatcomp Cneq -> Kccall("neq_float", 2)
        | Pfloatcomp Clt -> Kccall("lt_float", 2)
        | Pfloatcomp Cgt -> Kccall("gt_float", 2)
        | Pfloatcomp Cle -> Kccall("le_float", 2)
        | Pfloatcomp Cge -> Kccall("ge_float", 2)
        | Pstringlength -> Kccall("ml_string_length", 1)
        | Pstringrefs -> Kccall("string_get", 2)
        | Pstringsets -> Kccall("string_set", 3)
        | Pstringrefu -> Kgetstringchar
        | Pstringsetu -> Ksetstringchar
        | Pmakearray kind -> Kmakeblock(List.length args, 0)
        | Parraylength kind -> Kvectlength
        | Parrayrefs kind -> Kccall("array_get", 2)
        | Parraysets kind -> Kccall("array_set", 3)
        | Parrayrefu kind -> Kgetvectitem
        | Parraysetu kind -> Ksetvectitem
        | Pbittest -> Kccall("bitvect_test", 2)
        | _ -> fatal_error "Bytegen.comp_expr: prim" in
      comp_args env args sz (instr :: cont)
  | Lcatch(body, Lstaticfail) ->
      comp_expr env body sz cont
  | Lcatch(body, handler) ->
      let (branch1, cont1) = make_branch cont in
      let (lbl_handler, cont2) = label_code (comp_expr env handler sz cont1) in
      let saved_lbl_staticfail = !lbl_staticfail
      and saved_sz_staticfail = !sz_staticfail in
      lbl_staticfail := lbl_handler;
      sz_staticfail := sz;
      let cont3 = comp_expr env body sz (branch1 :: cont2) in
      lbl_staticfail := saved_lbl_staticfail;
      sz_staticfail := saved_sz_staticfail;
      cont3
  | Lstaticfail ->
      add_pop (sz - !sz_staticfail)
              (Kbranch !lbl_staticfail :: discard_dead_code cont)
  | Ltrywith(body, id, handler) ->
      let (branch1, cont1) = make_branch cont in
      let lbl_handler = new_label() in
      Kpushtrap lbl_handler :: 
        comp_expr env body (sz+4) (Kpoptrap :: branch1 :: 
          Klabel lbl_handler :: Kpush ::
            comp_expr (add_var id (sz+1) env) handler (sz+1) (add_pop 1 cont1))
  | Lifthenelse(cond, ifso, ifnot) ->
      comp_binary_test env cond ifso ifnot sz cont
  | Lsequence(exp1, exp2) ->
      comp_expr env exp1 sz (comp_expr env exp2 sz cont)
  | Lwhile(cond, body) ->
      let lbl_loop = new_label() in
      let lbl_test = new_label() in
      Kbranch lbl_test :: Klabel lbl_loop :: Kcheck_signals ::
        comp_expr env body sz
          (Klabel lbl_test ::
            comp_expr env cond sz (Kbranchif lbl_loop :: add_const_unit cont))
  | Lfor(param, start, stop, dir, body) ->
      let lbl_loop = new_label() in
      let lbl_test = new_label() in
      let offset = match dir with Upto -> 1 | Downto -> -1 in
      let comp = match dir with Upto -> Cle | Downto -> Cge in
      comp_expr env start sz
        (Kpush :: comp_expr env stop (sz+1)
          (Kpush :: Kbranch lbl_test ::
           Klabel lbl_loop :: Kcheck_signals ::
           comp_expr (add_var param (sz+1) env) body (sz+2)
             (Kacc 1 :: Koffsetint offset :: Kassign 1 ::
              Klabel lbl_test ::
              Kacc 0 :: Kpush :: Kacc 2 :: Kintcomp comp ::
              Kbranchif lbl_loop ::
              add_const_unit (add_pop 2 cont))))
  | Lswitch(arg, sw) ->
      let (branch, cont1) = make_branch cont in
      let c = ref (discard_dead_code cont1) in
      let act_consts = Array.create sw.sw_numconsts Lstaticfail in
      List.iter (fun (n, act) -> act_consts.(n) <- act) sw.sw_consts;
      let act_blocks = Array.create sw.sw_numblocks Lstaticfail in
      List.iter (fun (n, act) -> act_blocks.(n) <- act) sw.sw_blocks;
      let lbl_consts = Array.create sw.sw_numconsts 0 in
      let lbl_blocks = Array.create sw.sw_numblocks 0 in
      for i = sw.sw_numblocks - 1 downto 0 do
        let (lbl, c1) =
          label_code(comp_expr env act_blocks.(i) sz (branch :: !c)) in
        lbl_blocks.(i) <- lbl;
        c := discard_dead_code c1
      done;
      for i = sw.sw_numconsts - 1 downto 0 do
        let (lbl, c1) =
          label_code(comp_expr env act_consts.(i) sz (branch :: !c)) in
        lbl_consts.(i) <- lbl;
        c := discard_dead_code c1
      done;
      if sw.sw_checked then c := comp_expr env Lstaticfail sz !c;        
      comp_expr env arg sz (Kswitch(lbl_consts, lbl_blocks) :: !c)
  | Lassign(id, expr) ->
      begin try
        let pos = Ident.find_same id env.ce_stack in
        comp_expr env expr sz (Kassign(sz - pos) :: cont)
      with Not_found ->
        fatal_error "Bytegen.comp_expr: assign"
      end
  | Levent(lam, lev) ->
      let event kind info =
        { ev_pos = 0;                   (* patched in emitcode *)
          ev_module = !compunit_name;
          ev_char = lev.lev_loc;
          ev_kind = kind;
          ev_info = info;
          ev_typenv = lev.lev_env;
          ev_compenv = env;
          ev_stacksize = sz;
          ev_repr =
            begin match lev.lev_repr with
              None ->
                Event_none
            | Some ({contents = 1} as repr) when lev.lev_kind = Lev_function ->
                Event_child repr
            | Some ({contents = 1} as repr) ->
                Event_parent repr
            | Some repr when lev.lev_kind = Lev_function ->
                Event_parent repr
            | Some repr ->
                Event_child repr
            end }
      in
      begin match lev.lev_kind with
        Lev_before ->
          let c = comp_expr env lam sz cont in
          let ev = event Event_before Event_other in
          add_event ev c
      | Lev_function ->
          let c = comp_expr env lam sz cont in
          let ev = event Event_pseudo Event_function in
          add_event ev c
      | Lev_after _ when is_tailcall cont -> (* don't destroy tail call opt *)
          comp_expr env lam sz cont
      | Lev_after ty ->
          let info =
            match lam with
              Lapply(_, args)   -> Event_return (List.length args)
            | _                 -> Event_other
          in
          let ev = event (Event_after ty) info in
          let cont1 = add_event ev cont in
          comp_expr env lam sz cont1
      end

(* Compile a list of arguments [e1; ...; eN] to a primitive operation.
   The values of eN ... e2 are pushed on the stack, e2 at top of stack,
   then e3, then ... The value of e1 is left in the accumulator. *)

and comp_args env argl sz cont =
  comp_expr_list env (List.rev argl) sz cont

and comp_expr_list env exprl sz cont =
  match exprl with
    [] -> cont
  | [exp] -> comp_expr env exp sz cont
  | exp :: rem ->
      comp_expr env exp sz (Kpush :: comp_expr_list env rem (sz+1) cont)

(* Compile an if-then-else test. *)

and comp_binary_test env cond ifso ifnot sz cont =
  let cont_cond =
    if ifnot = Lconst const_unit then begin
      let (lbl_end, cont1) = label_code cont in
      Kstrictbranchifnot lbl_end :: comp_expr env ifso sz cont1
    end else
    if ifso = Lstaticfail & sz = !sz_staticfail then
      Kbranchif !lbl_staticfail :: comp_expr env ifnot sz cont
    else
    if ifnot = Lstaticfail & sz = !sz_staticfail then
      Kbranchifnot !lbl_staticfail :: comp_expr env ifso sz cont
    else begin
      let (branch_end, cont1) = make_branch cont in
      let (lbl_not, cont2) = label_code(comp_expr env ifnot sz cont1) in
      Kbranchifnot lbl_not :: comp_expr env ifso sz (branch_end :: cont2)
    end in
  comp_expr env cond sz cont_cond

<<function Bytegen.comp_function>>

<<function Bytegen.comp_remainder>>

<<function Bytegen.compile_implementation>>

<<function Bytegen.compile_phrase>>

@


\subsection*{[[./bytecomp/translmod.mli]]}




%-------------------------------------------------------------

<<./bytecomp/translmod.mli>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Typedtree
open Lambda

<<signature Translmod.transl_implementation>>
<<signature Translmod.transl_store_implementation>>
<<signature Translmod.transl_toplevel_definition>>

<<signature Translmod.primitive_declarations>>
@


\subsection*{[[./bytecomp/translmod.ml]]}

<<function Translmod.reset_labels>>=
let reset_labels () =
  ()
@
% (*  used_methods := [] *)

<<function Translmod.transl_label_init>>=
let transl_label_init expr =
  expr
@
%(*
%  if !used_methods = [] then
%    expr
%  else
%    let init = Ident.create "new_method" in
%    let expr' =
%      Llet(StrictOpt, init, oo_prim "new_method",
%      List.fold_right
%        (fun (lab, id) expr ->
%           Llet(StrictOpt, id, Lapply(Lvar init, [string lab]), expr))
%        !used_methods
%        expr)
%    in
%    reset_labels ();
%    expr'
%*)

<<function Translmod.compose_coercions>>=
(* Compose two coercions
   apply_coercion c1 (apply_coercion c2 e) behaves like
   apply_coercion (compose_coercions c1 c2) e. *)

let rec compose_coercions c1 c2 =
  match (c1, c2) with
    (Tcoerce_none, c2) -> c2
  | (c1, Tcoerce_none) -> c1
  | (Tcoerce_structure pc1, Tcoerce_structure pc2) ->
      let v2 = Array.of_list pc2 in
      Tcoerce_structure
        (List.map (fun (p1, c1) ->
                let (p2, c2) = v2.(p1) in (p2, compose_coercions c1 c2))
             pc1)
  | (_, _) ->
      fatal_error "Translmod.compose_coercions"
@


<<function Translmod.transl_implementation>>=
(* Compile an implementation *)

let transl_implementation module_name str cc =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  Lprim(Psetglobal module_id, [transl_label_init (transl_structure [] cc str)])
@

<<function Translmod.transl_store_structure>>=
(* A variant of transl_structure used to compile toplevel structure definitions
   for the native-code compiler. Store the defined values in the fields
   of the global as soon as they are defined, in order to reduce register
   pressure.
   "map" is a table from idents to (position in global block, coercion).
   "prim" is a list of (position in global block, primitive declaration). *)

let transl_store_structure glob map prims str =
  let rec transl_store = function
    [] ->
      lambda_unit
  | Tstr_eval expr :: rem ->
      Lsequence(transl_exp expr, transl_store rem)
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      transl_let rec_flag pat_expr_list
        (store_idents glob map (let_bound_idents pat_expr_list)
          (transl_store rem))
  | Tstr_primitive(id, descr) :: rem ->
      begin match descr.val_prim with
        Some p -> primitive_declarations :=
                        p.Primitive.prim_name :: !primitive_declarations
      | _ -> ()
      end;
      transl_store rem
  | Tstr_type(decls) :: rem ->
      transl_store rem
  | Tstr_exception(id, decl) :: rem ->
      Llet(Strict, id, transl_exception id decl,
           store_ident glob map id (transl_store rem))
  | Tstr_module(id, modl) :: rem ->
      Llet(Strict, id, transl_module Tcoerce_none modl,
           store_ident glob map id (transl_store rem))
  | Tstr_open path :: rem ->
      transl_store rem

  and store_ident glob map id cont =
    try
      let (pos, cc) = Ident.find_same id map in
      let init_val = apply_coercion cc (Lvar id) in
      Lsequence
       (Lprim(Psetfield(pos, false), [Lprim(Pgetglobal glob, []); init_val]),
        cont)
    with Not_found ->
      cont

  and store_idents glob map idlist cont =
    List.fold_right (store_ident glob map) idlist cont

  and store_primitive (pos, prim) cont =
    Lsequence(Lprim(Psetfield(pos, false),
                    [Lprim(Pgetglobal glob, []); transl_primitive prim]),
              cont)
  in
    List.fold_right store_primitive prims (transl_store str)
@

<<constant Translmod.defined_idents>>=
(* Build the list of value identifiers defined by a toplevel structure *)

let rec defined_idents = function
    [] -> []
  | Tstr_eval expr :: rem -> defined_idents rem
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      let_bound_idents pat_expr_list @ defined_idents rem
  | Tstr_primitive(id, descr) :: rem -> defined_idents rem
  | Tstr_type decls :: rem -> defined_idents rem
  | Tstr_exception(id, decl) :: rem -> id :: defined_idents rem
  | Tstr_module(id, modl) :: rem -> id :: defined_idents rem
  | Tstr_open path :: rem -> defined_idents rem
@

<<function Translmod.build_ident_map>>=
(* Transform a coercion and the list of value identifiers built above
   into a table id -> (pos, coercion), with [pos] being the position
   in the global block where the value of [id] must be stored,
   and [coercion] the coercion to be applied to it.
   A given identifier may appear several times
   in the coercion (if it occurs several times in the signature); remember
   to assign it the position of its last occurrence.
   Also buid a list of primitives and their positions in the global block,
   and the total size of the global block. *)

let build_ident_map restr idlist =
  match restr with
    Tcoerce_none ->
      let rec build_map pos map = function
        [] ->
          (map, [], pos)
      | id :: rem ->
          build_map (pos+1) (Ident.add id (pos, Tcoerce_none) map) rem
      in build_map 0 Ident.empty idlist
  | Tcoerce_structure pos_cc_list ->
      let idarray = Array.of_list idlist in
      let rec build_map pos map prims = function
        [] ->
          (map, prims, pos)
      | (source_pos, Tcoerce_primitive p) :: rem ->
          build_map (pos+1) map ((pos, p) :: prims) rem
      | (source_pos, cc) :: rem ->
          build_map (pos+1) (Ident.add idarray.(source_pos) (pos, cc) map)
                    prims rem
      in build_map 0 Ident.empty [] pos_cc_list
  | _ ->
      fatal_error "Translmod.build_ident_map"
@

<<function Translmod.transl_store_implementation>>=
(* Compile an implementation using transl_store_structure 
   (for the native-code compiler). *)

let transl_store_implementation module_name str restr =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  let (map, prims, size) = build_ident_map restr (defined_idents str) in
  (size, transl_label_init (transl_store_structure module_id map prims str))
@

<<function Translmod.make_sequence>>=
(* Compile a sequence of expressions *)

let rec make_sequence fn = function
    [] -> lambda_unit
  | [x] -> fn x
  | x::rem ->
      let lam = fn x in Lsequence(lam, make_sequence fn rem)
@

<<constant Translmod.transl_toplevel_item>>=
(* Compile a toplevel phrase *)

let transl_toplevel_item = function
    Tstr_eval expr ->
      transl_exp expr
  | Tstr_value(rec_flag, pat_expr_list) ->
      let idents = let_bound_idents pat_expr_list in
      let lam =
        transl_let rec_flag pat_expr_list
          (make_sequence (fun id -> Lprim(Psetglobal id, [Lvar id])) idents) in
      List.iter Ident.make_global idents;
      lam
  | Tstr_primitive(id, descr) ->
      lambda_unit
  | Tstr_type(decls) ->
      lambda_unit
  | Tstr_exception(id, decl) ->
      Ident.make_global id;
      Lprim(Psetglobal id, [transl_exception id decl])
  | Tstr_module(id, modl) ->
      Ident.make_global id;
      Lprim(Psetglobal id, [transl_module Tcoerce_none modl])
  | Tstr_open path ->
      lambda_unit
@

<<function Translmod.transl_toplevel_definition>>=
let transl_toplevel_definition str =
  reset_labels ();
  transl_label_init (make_sequence transl_toplevel_item str)
@


%-------------------------------------------------------------

<<./bytecomp/translmod.ml>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Misc
open Asttypes
open Types
open Typedtree
open Lambda
open Translcore

<<function Translmod.reset_labels>>

<<function Translmod.transl_label_init>>

(* Compile a coercion *)

let rec apply_coercion restr arg =
  match restr with
    Tcoerce_none ->
      arg
  | Tcoerce_structure pos_cc_list ->
      name_lambda arg (fun id ->
        Lprim(Pmakeblock(0, Immutable),
              List.map (apply_coercion_field id) pos_cc_list))
  | Tcoerce_primitive p ->
      fatal_error "Translmod.apply_coercion"

and apply_coercion_field id (pos, cc) =
  match cc with
    Tcoerce_primitive p -> transl_primitive p
  | _ -> apply_coercion cc (Lprim(Pfield pos, [Lvar id]))

<<function Translmod.compose_coercions>>

<<constant Translmod.primitive_declarations>>

(* Compile a module expression *)

let rec transl_module cc mexp =
  match mexp.mod_desc with
    Tmod_ident path ->
      apply_coercion cc (transl_path path)
  | Tmod_structure str ->
      transl_structure [] cc str
  | Tmod_constraint(arg, mty, ccarg) ->
      transl_module (compose_coercions cc ccarg) arg

and transl_structure fields cc = function
    [] ->
      begin match cc with
        Tcoerce_none ->
          Lprim(Pmakeblock(0, Immutable),
                List.map (fun id -> Lvar id) (List.rev fields))
      | Tcoerce_structure pos_cc_list ->
          let v = Array.of_list (List.rev fields) in
          Lprim(Pmakeblock(0, Immutable),
                List.map
                  (fun (pos, cc) ->
                    match cc with
                      Tcoerce_primitive p -> transl_primitive p
                    | _ -> apply_coercion cc (Lvar v.(pos)))
                  pos_cc_list)
      | _ ->
          fatal_error "Translmod.transl_structure"
      end
  | Tstr_eval expr :: rem ->
      Lsequence(transl_exp expr, transl_structure fields cc rem)
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      let ext_fields = rev_let_bound_idents pat_expr_list @ fields in
      transl_let rec_flag pat_expr_list (transl_structure ext_fields cc rem)
  | Tstr_primitive(id, descr) :: rem ->
      begin match descr.val_prim with
        Some p -> primitive_declarations :=
                        p.Primitive.prim_name :: !primitive_declarations
      | _ -> ()
      end;
      transl_structure fields cc rem
  | Tstr_type(decls) :: rem ->
      transl_structure fields cc rem
  | Tstr_exception(id, decl) :: rem ->
      Llet(Strict, id, transl_exception id decl,
           transl_structure (id :: fields) cc rem)
  | Tstr_module(id, modl) :: rem ->
      Llet(Strict, id, transl_module Tcoerce_none modl,
           transl_structure (id :: fields) cc rem)
  | Tstr_open path :: rem ->
      transl_structure fields cc rem

<<function Translmod.transl_implementation>>

<<function Translmod.transl_store_structure>>

<<constant Translmod.defined_idents>>

<<function Translmod.build_ident_map>>
        
<<function Translmod.transl_store_implementation>>

<<function Translmod.make_sequence>>

<<constant Translmod.transl_toplevel_item>>

<<function Translmod.transl_toplevel_definition>>
@


\subsection*{[[./bytecomp/emitcode.mli]]}


<<signature Emitcode.to_memory>>=
val to_memory: instruction list -> instruction list ->
                    string * int * (reloc_info * int) list
        (* Arguments:
             initialization code (terminated by STOP)
             function code
           Results:
             block of relocatable bytecode
             size of this block
             relocation information *)
@


%-------------------------------------------------------------

<<./bytecomp/emitcode.mli>>=
<<copyright header>>

(* Generation of bytecode for .cmo files *)

open Lambda
open Instruct

<<type Emitcode.reloc_info>>

<<type Emitcode.compilation_unit>>

<<signature Emitcode.to_file>>
<<signature Emitcode.to_memory>>

@


\subsection*{[[./bytecomp/emitcode.ml]]}



<<function Emitcode.out_word>>=
let out_word b1 b2 b3 b4 =
  let p = !out_position in
  if p >= String.length !out_buffer then begin
    let len = String.length !out_buffer in
    let new_buffer = String.create (2 * len) in
    String.blit !out_buffer 0 new_buffer 0 len;
    out_buffer := new_buffer
  end;
  String.unsafe_set !out_buffer p (Char.unsafe_chr b1);
  String.unsafe_set !out_buffer (p+1) (Char.unsafe_chr b2);
  String.unsafe_set !out_buffer (p+2) (Char.unsafe_chr b3);
  String.unsafe_set !out_buffer (p+3) (Char.unsafe_chr b4);
  out_position := p + 4
@

<<function Emitcode.out>>=
let out opcode =
  out_word opcode 0 0 0
@

<<function Emitcode.out_int>>=
let out_int n =
  out_word n (n asr 8) (n asr 16) (n asr 24)
@

<<type Emitcode.label_definition>>=
(* Handling of local labels and backpatching *)

type label_definition =
    Label_defined of int
  | Label_undefined of (int * int) list
@


<<function Emitcode.extend_label_table>>=
let extend_label_table needed =
  let new_size = ref(Array.length !label_table) in
  while needed >= !new_size do new_size := 2 * !new_size done;
  let new_table = Array.create !new_size (Label_undefined []) in
  Array.blit !label_table 0 new_table 0 (Array.length !label_table);
  label_table := new_table
@

<<function Emitcode.backpatch>>=
let backpatch (pos, orig) =
  let displ = (!out_position - orig) asr 2 in
  !out_buffer.[pos] <- Char.unsafe_chr displ;
  !out_buffer.[pos+1] <- Char.unsafe_chr (displ asr 8);
  !out_buffer.[pos+2] <- Char.unsafe_chr (displ asr 16);
  !out_buffer.[pos+3] <- Char.unsafe_chr (displ asr 24)
@

<<function Emitcode.define_label>>=
let define_label lbl =
  if lbl >= Array.length !label_table then extend_label_table lbl;
  match (!label_table).(lbl) with
    Label_defined _ ->
      fatal_error "Emitcode.define_label"
  | Label_undefined patchlist ->
      List.iter backpatch patchlist;
      (!label_table).(lbl) <- Label_defined !out_position
@

<<function Emitcode.out_label_with_orig>>=
let out_label_with_orig orig lbl =
  if lbl >= Array.length !label_table then extend_label_table lbl;
  match (!label_table).(lbl) with
    Label_defined def ->
      out_int((def - orig) asr 2)
  | Label_undefined patchlist ->
      (!label_table).(lbl) <-
         Label_undefined((!out_position, orig) :: patchlist);
      out_int 0
@

<<function Emitcode.out_label>>=
let out_label l = out_label_with_orig !out_position l
@


<<function Emitcode.enter>>=
let enter info =
  reloc_info := (info, !out_position) :: !reloc_info
@



<<constant Emitcode.emit_instr>>=
(* Emission of one instruction *)

let emit_instr = function
    Klabel lbl -> define_label lbl
  | Kacc n ->
      if n < 8 then out(opACC0 + n) else (out opACC; out_int n)
  | Kenvacc n ->
      if n < 4 then out(opENVACC1 + n) else (out opENVACC; out_int (n+1))
  | Kpush ->
      out opPUSH
  | Kpop n ->
      out opPOP; out_int n
  | Kassign n ->
      out opASSIGN; out_int n
  | Kpush_retaddr lbl -> out opPUSH_RETADDR; out_label lbl
  | Kapply n ->
      if n < 4 then out(opAPPLY1 + n - 1) else (out opAPPLY; out_int n)
  | Kappterm(n, sz) ->
      if n < 4 then (out(opAPPTERM1 + n - 1); out_int sz)
               else (out opAPPTERM; out_int n; out_int sz)
  | Kreturn n -> out opRETURN; out_int n
  | Krestart -> out opRESTART
  | Kgrab n -> out opGRAB; out_int n
  | Kclosure(lbl, n) -> out opCLOSURE; out_int n; out_label lbl
  | Kclosurerec(lbl, n) -> out opCLOSUREREC; out_int n; out_label lbl
  | Kgetglobal q -> out opGETGLOBAL; slot_for_getglobal q
  | Ksetglobal q -> out opSETGLOBAL; slot_for_setglobal q
  | Kconst sc ->
      begin match sc with
        Const_base(Const_int i) when i >= immed_min & i <= immed_max ->
          if i >= 0 & i <= 3
          then out (opCONST0 + i)
          else (out opCONSTINT; out_int i)
      | Const_base(Const_char c) ->
          out opCONSTINT; out_int (Char.code c)
      | Const_pointer i ->
          if i >= 0 & i <= 3
          then out (opCONST0 + i)
          else (out opCONSTINT; out_int i)
      | Const_block(t, []) ->
          if t = 0 then out opATOM0 else (out opATOM; out_int t)
      | _ ->
          out opGETGLOBAL; slot_for_literal sc
      end
  | Kmakeblock(n, t) ->
      if n = 0 then
        if t < 4 then out (opATOM0 + t) else (out opATOM; out_int t)
      else if n < 4 then (out(opMAKEBLOCK1 + n - 1); out_int t)
      else (out opMAKEBLOCK; out_int n; out_int t)
  | Kgetfield n ->
      if n < 4 then out(opGETFIELD0 + n) else (out opGETFIELD; out_int n)
  | Ksetfield n ->
      if n < 4 then out(opSETFIELD0 + n) else (out opSETFIELD; out_int n)
  | Kdummy n ->
      if n = 0 then out opATOM0 else (out opDUMMY; out_int n)
  | Kupdate n -> out opUPDATE
  | Kvectlength -> out opVECTLENGTH
  | Kgetvectitem -> out opGETVECTITEM
  | Ksetvectitem -> out opSETVECTITEM
  | Kgetstringchar -> out opGETSTRINGCHAR
  | Ksetstringchar -> out opSETSTRINGCHAR
  | Kbranch lbl -> out opBRANCH; out_label lbl
  | Kbranchif lbl -> out opBRANCHIF; out_label lbl
  | Kbranchifnot lbl -> out opBRANCHIFNOT; out_label lbl
  | Kstrictbranchif lbl -> out opBRANCHIF; out_label lbl
  | Kstrictbranchifnot lbl -> out opBRANCHIFNOT; out_label lbl
  | Kswitch(tbl_const, tbl_block) ->
      out opSWITCH;
      out_int (Array.length tbl_const + (Array.length tbl_block lsl 16));
      let org = !out_position in
      Array.iter (out_label_with_orig org) tbl_const;
      Array.iter (out_label_with_orig org) tbl_block
  | Kboolnot -> out opBOOLNOT
  | Kpushtrap lbl -> out opPUSHTRAP; out_label lbl
  | Kpoptrap -> out opPOPTRAP
  | Kraise -> out opRAISE
  | Kcheck_signals -> out opCHECK_SIGNALS
  | Kccall(name, n) ->
      if n <= 5
      then (out (opC_CALL1 + n - 1); slot_for_c_prim name)
      else (out opC_CALLN; out_int n; slot_for_c_prim name)
  | Knegint -> out opNEGINT  | Kaddint -> out opADDINT
  | Ksubint -> out opSUBINT  | Kmulint -> out opMULINT
  | Kdivint -> out opDIVINT  | Kmodint -> out opMODINT
  | Kandint -> out opANDINT  | Korint -> out opORINT
  | Kxorint -> out opXORINT  | Klslint -> out opLSLINT
  | Klsrint -> out opLSRINT  | Kasrint -> out opASRINT
  | Kintcomp Ceq -> out opEQ         | Kintcomp Cneq -> out opNEQ
  | Kintcomp Clt -> out opLTINT      | Kintcomp Cle -> out opLEINT
  | Kintcomp Cgt -> out opGTINT      | Kintcomp Cge -> out opGEINT
  | Koffsetint n -> out opOFFSETINT; out_int n
  | Koffsetref n -> out opOFFSETREF; out_int n
  | Kevent ev -> record_event ev
  | Kstop -> out opSTOP
@

<<constant Emitcode.emit>>=
(* Emission of a list of instructions. Include some peephole optimization. *)

let rec emit = function
    [] -> ()
  (* Peephole optimizations *)
  | Kpush :: Kacc n :: c ->
      if n < 8 then out(opPUSHACC0 + n) else (out opPUSHACC; out_int n);
      emit c
  | Kpush :: Kenvacc n :: c ->
      if n < 4 then out(opPUSHENVACC1 + n)
               else (out opPUSHENVACC; out_int (n+1));
      emit c
  | Kpush :: Kgetglobal id :: Kgetfield n :: c ->
      out opPUSHGETGLOBALFIELD; slot_for_getglobal id; out_int n; emit c
  | Kpush :: Kgetglobal id :: c ->
      out opPUSHGETGLOBAL; slot_for_getglobal id; emit c
  | Kpush :: Kconst sc :: c ->
      begin match sc with
        Const_base(Const_int i) when i >= immed_min & i <= immed_max ->
          if i >= 0 & i <= 3
          then out (opPUSHCONST0 + i)
          else (out opPUSHCONSTINT; out_int i)
      | Const_base(Const_char c) ->
          out opPUSHCONSTINT; out_int(Char.code c)
      | Const_pointer i ->
          if i >= 0 & i <= 3
          then out (opPUSHCONST0 + i)
          else (out opPUSHCONSTINT; out_int i)
      | Const_block(t, []) ->
          if t = 0 then out opPUSHATOM0 else (out opPUSHATOM; out_int t)
      | _ ->
          out opPUSHGETGLOBAL; slot_for_literal sc
      end;
      emit c
  | Kpush :: (Kevent {ev_kind = Event_before} as ev) ::
    (Kgetglobal _ as instr1) :: (Kgetfield _ as instr2) :: c ->
      emit (Kpush :: instr1 :: instr2 :: ev :: c)
  | Kpush :: (Kevent {ev_kind = Event_before} as ev) ::
    (Kacc _ | Kenvacc _ | Kgetglobal _ | Kconst _ as instr) :: c ->
      emit (Kpush :: instr :: ev :: c)
  | Kgetglobal id :: Kgetfield n :: c ->
      out opGETGLOBALFIELD; slot_for_getglobal id; out_int n; emit c
  (* Default case *)
  | instr :: c ->
      emit_instr instr; emit c
@


<<function Emitcode.to_memory>>=
(* Emission to a memory block *)

let to_memory init_code fun_code =
  init();
  emit init_code;
  emit fun_code;
  let code = Meta.static_alloc !out_position in
  String.unsafe_blit !out_buffer 0 code 0 !out_position;
  let reloc = List.rev !reloc_info
  and code_size = !out_position in
  init();
  (code, code_size, reloc)
@


%-------------------------------------------------------------

<<./bytecomp/emitcode.ml>>=
<<copyright header>>

(* Generation of bytecode + relocation information *)

open Config
open Misc
open Asttypes
open Lambda
open Instruct
open Opcodes


<<type Emitcode.reloc_info>>

<<type Emitcode.compilation_unit>>

(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     compilation unit descriptor *)

(* Buffering of bytecode *)

let out_buffer = ref(String.create 1024)
and out_position = ref 0

<<function Emitcode.out_word>>

<<function Emitcode.out>>

<<function Emitcode.out_int>>

<<type Emitcode.label_definition>>

<<constant Emitcode.label_table>>

<<function Emitcode.extend_label_table>>

<<function Emitcode.backpatch>>

<<function Emitcode.define_label>>

<<function Emitcode.out_label_with_orig>>

<<function Emitcode.out_label>>

<<constant Emitcode.reloc_info>>

<<function Emitcode.enter>>

let slot_for_literal sc =
  enter (Reloc_literal sc);
  out_int 0
and slot_for_getglobal id =
  enter (Reloc_getglobal id);
  out_int 0
and slot_for_setglobal id =
  enter (Reloc_setglobal id);
  out_int 0
and slot_for_c_prim name =
  enter (Reloc_primitive name);
  out_int 0

<<constant Emitcode.events>>

<<function Emitcode.record_event>>

<<function Emitcode.init>>

<<constant Emitcode.emit_instr>>

<<constant Emitcode.emit>>

<<function Emitcode.to_file>>

<<function Emitcode.to_memory>>
@


\subsection*{[[./bytecomp/bytelibrarian.mli]]}




%-------------------------------------------------------------

<<./bytecomp/bytelibrarian.mli>>=
<<copyright header>>

(* Build libraries of .cmo files *)

<<signature Bytelibrarian.create_archive>>

<<type Bytelibrarian.error>>

<<exception Bytelibrarian.Error>>

<<signature Bytelibrarian.report_error>>
@


\subsection*{[[./bytecomp/bytelibrarian.ml]]}

<<function Bytelibrarian.copy_compunit>>=
let copy_compunit ic oc compunit =
  seek_in ic compunit.cu_pos;
  compunit.cu_pos <- pos_out oc;
  compunit.cu_force_link <- !Clflags.link_everything;
  copy_file_chunk ic oc compunit.cu_codesize;
  if compunit.cu_debug > 0 then begin
    seek_in ic compunit.cu_debug;
    compunit.cu_debug <- pos_out oc;
    copy_file_chunk ic oc compunit.cu_debugsize
  end
@

<<function Bytelibrarian.copy_object_file>>=
let copy_object_file oc name =
  let file_name =
    try
      find_in_path !load_path name
    with Not_found ->
      raise(Error(File_not_found name)) in
  let ic = open_in_bin file_name in
  try
    let buffer = String.create (String.length cmo_magic_number) in
    really_input ic buffer 0 (String.length cmo_magic_number);
    if buffer = cmo_magic_number then begin
      let compunit_pos = input_binary_int ic in
      seek_in ic compunit_pos;
      let compunit = (input_value ic : compilation_unit) in
      copy_compunit ic oc compunit;
      close_in ic;
      [compunit]
    end else
    if buffer = cma_magic_number then begin
      let toc_pos = input_binary_int ic in
      seek_in ic toc_pos;
      let toc = (input_value ic : compilation_unit list) in
      List.iter (copy_compunit ic oc) toc;
      close_in ic;
      toc
    end else
      raise(Error(Not_an_object_file file_name))
  with x ->
    close_in ic;
    raise x
@

<<function Bytelibrarian.create_archive>>=
let create_archive file_list lib_name =
  let outchan = open_out_bin lib_name in
  try
    output_string outchan cma_magic_number;
    let ofs_pos_toc = pos_out outchan in
    output_binary_int outchan 0;
    let toc = List.flatten(List.map (copy_object_file outchan) file_list) in
    let pos_toc = pos_out outchan in
    output_value outchan toc;
    seek_out outchan ofs_pos_toc;
    output_binary_int outchan pos_toc;
    close_out outchan
  with x ->
    close_out outchan;
    remove_file lib_name;
    raise x
@


%-------------------------------------------------------------

<<./bytecomp/bytelibrarian.ml>>=
<<copyright header>>

(* Build libraries of .cmo files *)

open Misc
open Config
open Emitcode

<<type Bytelibrarian.error>>

<<exception Bytelibrarian.Error>>

<<function Bytelibrarian.copy_compunit>>

<<function Bytelibrarian.copy_object_file>>

<<function Bytelibrarian.create_archive>>

open Format

<<constant Bytelibrarian.report_error>>

@


\subsection*{[[./bytecomp/symtable.mli]]}

<<signature Symtable.init>>=
(* Functions for batch linking *)

val init: unit -> unit
@

<<signature Symtable.patch_object>>=
val patch_object: string -> (reloc_info * int) list -> unit
@

<<signature Symtable.require_primitive>>=
val require_primitive: string -> unit
@

<<signature Symtable.initial_global_table>>=
val initial_global_table: unit -> Obj.t array
@

<<signature Symtable.output_global_map>>=
val output_global_map: out_channel -> unit
@

<<signature Symtable.output_primitive_names>>=
val output_primitive_names: out_channel -> unit
@

<<signature Symtable.output_primitive_table>>=
val output_primitive_table: out_channel -> unit
@

<<signature Symtable.init_toplevel>>=
(* Functions for the toplevel *)

val init_toplevel: unit -> unit
@

<<signature Symtable.update_global_table>>=
val update_global_table: unit -> unit
@

<<signature Symtable.get_global_value>>=
val get_global_value: Ident.t -> Obj.t
@

<<signature Symtable.get_global_position>>=
val get_global_position: Ident.t -> int
@

<<signature Symtable.current_state>>=
val current_state: unit -> global_map
@

<<signature Symtable.restore_state>>=
val restore_state: global_map -> unit
@

<<signature Symtable.hide_additions>>=
val hide_additions: global_map -> unit
@

<<signature Symtable.filter_global_map>>=
val filter_global_map: (Ident.t -> bool) -> global_map -> global_map
@

<<type Symtable.error>>=
(* Error report *)

type error =
    Undefined_global of string
  | Unavailable_primitive of string
@

<<exception Symtable.Error>>=
exception Error of error
@

<<signature Symtable.report_error>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<./bytecomp/symtable.mli>>=
<<copyright header>>

(* Assign locations and numbers to globals and primitives *)

open Emitcode

<<signature Symtable.init>>
<<signature Symtable.patch_object>>
<<signature Symtable.require_primitive>>
<<signature Symtable.initial_global_table>>
<<signature Symtable.output_global_map>>
<<signature Symtable.output_primitive_names>>
<<signature Symtable.output_primitive_table>>

<<signature Symtable.init_toplevel>>
<<signature Symtable.update_global_table>>
<<signature Symtable.get_global_value>>
<<signature Symtable.get_global_position>>

type global_map

<<signature Symtable.current_state>>
<<signature Symtable.restore_state>>
<<signature Symtable.hide_additions>>
<<signature Symtable.filter_global_map>>

<<type Symtable.error>>

<<exception Symtable.Error>>

<<signature Symtable.report_error>>
@


\subsection*{[[./bytecomp/symtable.ml]]}

<<type Symtable.numtable>>=
(* Tables for numbering objects *)

type 'a numtable =
  { num_cnt: int;               (* The next number *)
    num_tbl: ('a, int) Tbl.t } (* The table of already numbered objects *)
@

<<constant Symtable.empty_numtable>>=
let empty_numtable = { num_cnt = 0; num_tbl = Tbl.empty }
@

<<function Symtable.find_numtable>>=
let find_numtable nt key =
  Tbl.find key nt.num_tbl
@

<<function Symtable.enter_numtable>>=
let enter_numtable nt key =
  let n = !nt.num_cnt in
  nt := { num_cnt = n + 1; num_tbl = Tbl.add key n !nt.num_tbl };
  n
@

<<function Symtable.incr_numtable>>=
let incr_numtable nt =
  let n = !nt.num_cnt in
  nt := { num_cnt = n + 1; num_tbl = !nt.num_tbl };
  n
@

<<function Symtable.slot_for_getglobal>>=
let slot_for_getglobal id =
  try
    find_numtable !global_table id
  with Not_found ->
    raise(Error(Undefined_global(Ident.name id)))
@

<<function Symtable.slot_for_setglobal>>=
let slot_for_setglobal id =
  enter_numtable global_table id
@

<<function Symtable.slot_for_literal>>=
let slot_for_literal cst =
  let n = incr_numtable global_table in
  literal_table := (n, cst) :: !literal_table;
  n
@

<<constant Symtable.c_prim_table>>=
(* The C primitives *)

let c_prim_table = ref(empty_numtable : string numtable)
@

<<function Symtable.num_of_prim>>=
let num_of_prim name =
  try
    find_numtable !c_prim_table name
  with Not_found ->
    if !Clflags.custom_runtime
    then enter_numtable c_prim_table name
    else raise(Error(Unavailable_primitive name))
@

<<function Symtable.require_primitive>>=
let require_primitive name =
  if name.[0] <> '%' then begin num_of_prim name; () end
@

<<function Symtable.all_primitives>>=
let all_primitives () =
  let prim = Array.create !c_prim_table.num_cnt "" in
  Tbl.iter (fun name number -> prim.(number) <- name) !c_prim_table.num_tbl;
  prim
@

<<function Symtable.output_primitive_names>>=
let output_primitive_names outchan =
  let prim = all_primitives() in
  for i = 0 to Array.length prim - 1 do
    output_string outchan prim.(i); output_char outchan '\000'
  done
@

<<function Symtable.output_primitive_table>>=
let output_primitive_table outchan =
  let prim = all_primitives() in
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "extern long %s();\n" prim.(i)
  done;
  fprintf outchan "typedef long (*primitive)();\n";
  fprintf outchan "primitive cprim[] = {\n";
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "  %s,\n" prim.(i)
  done;
  fprintf outchan "  (primitive) 0 };\n";
  fprintf outchan "char * names_of_cprim[] = {\n";
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "  \"%s\",\n" prim.(i)
  done;
  fprintf outchan "  (char *) 0 };\n"
@

<<function Symtable.init>>=
(* Initialization for batch linking *)

let init () =
  (* Enter the predefined exceptions *)
  Array.iter 
    (fun name -> 
      let id =
        try List.assoc name Predef.builtin_values
        with Not_found -> fatal_error "Symtable.init" in
      let c = slot_for_setglobal id in
      let cst = Const_block(0, [Const_base(Const_string name)]) in
      literal_table := (c, cst) :: !literal_table)
    Runtimedef.builtin_exceptions;
  (* Enter the known C primitives *)
  Array.iter (fun x -> enter_numtable c_prim_table x; ())
             Runtimedef.builtin_primitives
@

<<function Symtable.patch_int>>=
(* Must use the unsafe String.set here because the block may be
   a "fake" string as returned by Meta.static_alloc. *)

let patch_int buff pos n =
  String.unsafe_set buff pos (Char.unsafe_chr n);
  String.unsafe_set buff (pos + 1) (Char.unsafe_chr (n asr 8));
  String.unsafe_set buff (pos + 2) (Char.unsafe_chr (n asr 16));
  String.unsafe_set buff (pos + 3) (Char.unsafe_chr (n asr 24))
@

<<function Symtable.patch_object>>=
let patch_object buff patchlist = 
  List.iter
    (function
        (Reloc_literal sc, pos) ->
          patch_int buff pos (slot_for_literal sc)
      | (Reloc_getglobal id, pos) ->
          patch_int buff pos (slot_for_getglobal id)
      | (Reloc_setglobal id, pos) ->
          patch_int buff pos (slot_for_setglobal id)
      | (Reloc_primitive name, pos) ->
          patch_int buff pos (num_of_prim name))
    patchlist
@

<<constant Symtable.transl_const>>=
(* Translate structured constants *)

let rec transl_const = function
    Const_base(Const_int i) -> Obj.repr i
  | Const_base(Const_char c) -> Obj.repr c
  | Const_base(Const_string s) -> Obj.repr s
  | Const_base(Const_float f) -> Obj.repr(float_of_string f)
  | Const_pointer i -> Obj.repr i
  | Const_block(tag, fields) ->
      let block = Obj.new_block tag (List.length fields) in
      let pos = ref 0 in
      List.iter
        (fun c -> Obj.set_field block !pos (transl_const c); incr pos)
        fields;
      block
  | Const_float_array fields ->
      transl_const
        (Const_block(0, List.map (fun f -> Const_base(Const_float f)) fields))
@

<<function Symtable.initial_global_table>>=
(* Build the initial table of globals *)

let initial_global_table () =
  let glob = Array.create !global_table.num_cnt (Obj.repr 0) in
  List.iter
    (fun (slot, cst) -> glob.(slot) <- transl_const cst)
    !literal_table;
  literal_table := [];
  glob
@

<<function Symtable.output_global_map>>=
(* Save the table of globals *)

let output_global_map oc =
  output_value oc !global_table
@

<<function Symtable.update_global_table>>=
(* Update the in-core table of globals *)

let update_global_table () =
  let ng = !global_table.num_cnt in
  if ng > Array.length(Meta.global_data()) then Meta.realloc_global_data ng;
  let glob = Meta.global_data() in
  List.iter
    (fun (slot, cst) -> glob.(slot) <- transl_const cst)
    !literal_table;
  literal_table := []
@

<<function Symtable.init_toplevel>>=
(* Initialize the linker for toplevel use *)

let init_toplevel () =
  (* Read back the known global symbols from the executable file *)
  let ic = open_in_bin Sys.argv.(0) in
  let pos_trailer =
    in_channel_length ic - 20 - String.length Config.exec_magic_number in
  seek_in ic pos_trailer;
  let code_size = input_binary_int ic in
  let prim_size = input_binary_int ic in
  let data_size = input_binary_int ic in
  let symbol_size = input_binary_int ic in
  let debug_size = input_binary_int ic in
  seek_in ic (pos_trailer - debug_size - symbol_size);
  global_table := (input_value ic : Ident.t numtable);
  close_in ic;
  (* Enter the known C primitives *)
  Array.iter (fun x -> enter_numtable c_prim_table x; ())
             (Meta.available_primitives())
@

<<function Symtable.get_global_position>>=
(* @Scheck: used by the debugger *)
let get_global_position id = slot_for_getglobal id
@

<<function Symtable.get_global_value>>=
let get_global_value id =
@

<<type Symtable.global_map>>=
(* Save and restore the current state *)

type global_map = Ident.t numtable
@

<<function Symtable.current_state>>=
let current_state () = !global_table
@

<<function Symtable.restore_state>>=
let restore_state st = global_table := st
@

<<function Symtable.hide_additions>>=
(* @Scheck: used by dynlink *)
let hide_additions st =
  if st.num_cnt > !global_table.num_cnt then
    fatal_error "Symtable.hide_additions";
  global_table :=
    { num_cnt = !global_table.num_cnt;
      num_tbl = st.num_tbl }
@

<<function Symtable.filter_global_map>>=
(* "Filter" the global map according to some predicate.
   Used to expunge the global map for the toplevel. *)

let filter_global_map p gmap =
  let newtbl = ref Tbl.empty in
  Tbl.iter
    (fun id num -> if p id then newtbl := Tbl.add id num !newtbl)
    gmap.num_tbl;
  {num_cnt = gmap.num_cnt; num_tbl = !newtbl}
@

<<constant Symtable.report_error>>=
let report_error = function
    Undefined_global s ->
      print_string "Reference to undefined global `"; print_string s;
      print_string "'"
  | Unavailable_primitive s ->
      print_string "The external function `"; print_string s;
      print_string "' is not available"
@


%-------------------------------------------------------------

<<./bytecomp/symtable.ml>>=
<<copyright header>>

(* To assign numbers to globals and primitives *)

open Misc
open Asttypes
open Lambda
open Emitcode


<<type Symtable.error>>

<<exception Symtable.Error>>

<<type Symtable.numtable>>

<<constant Symtable.empty_numtable>>

<<function Symtable.find_numtable>>

<<function Symtable.enter_numtable>>

<<function Symtable.incr_numtable>>

(* Global variables *)

let global_table = ref(empty_numtable : Ident.t numtable)
and literal_table = ref([] : (int * structured_constant) list)

<<function Symtable.slot_for_getglobal>>

<<function Symtable.slot_for_setglobal>>

<<function Symtable.slot_for_literal>>

<<constant Symtable.c_prim_table>>

<<function Symtable.num_of_prim>>

<<function Symtable.require_primitive>>

<<function Symtable.all_primitives>>

<<function Symtable.output_primitive_names>>

open Printf

<<function Symtable.output_primitive_table>>

<<function Symtable.init>>

(* Relocate a block of object bytecode *)

<<function Symtable.patch_int>>

<<function Symtable.patch_object>>

<<constant Symtable.transl_const>>

<<function Symtable.initial_global_table>>

<<function Symtable.output_global_map>>

(* Functions for toplevel use *)

<<function Symtable.update_global_table>>

<<function Symtable.init_toplevel>>

(* Find the value of a global identifier *)

<<function Symtable.get_global_position>>

<<function Symtable.get_global_value>>
  (Meta.global_data()).(slot_for_getglobal id)

<<type Symtable.global_map>>

<<function Symtable.current_state>>

<<function Symtable.restore_state>>

<<function Symtable.hide_additions>>

<<function Symtable.filter_global_map>>

(* Error report *)

open Format

<<constant Symtable.report_error>>
@


\subsection*{[[./bytecomp/bytelink.mli]]}





%-------------------------------------------------------------

<<./bytecomp/bytelink.mli>>=
<<copyright header>>

<<signature Bytelink.link>>

<<signature Bytelink.check_consistency>>

<<type Bytelink.error>>

<<exception Bytelink.Error>>

<<signature Bytelink.report_error>>
@


\subsection*{[[./bytecomp/bytelink.ml]]}


<<constant Bytelink.missing_globals>>=
let missing_globals = ref IdentSet.empty
@

<<function Bytelink.is_required>>=
let is_required (rel, pos) =
  match rel with
    Reloc_setglobal id ->
      IdentSet.mem id !missing_globals
  | _ -> false
@

<<function Bytelink.add_required>>=
let add_required (rel, pos) =
  match rel with
    Reloc_getglobal id ->
      missing_globals := IdentSet.add id !missing_globals
  | _ -> ()
@

<<function Bytelink.remove_required>>=
let remove_required (rel, pos) =
  match rel with
    Reloc_setglobal id ->
      missing_globals := IdentSet.remove id !missing_globals
  | _ -> ()
@

<<function Bytelink.scan_file>>=
let scan_file obj_name tolink =
  let file_name =
    try
      find_in_path !load_path obj_name
    with Not_found ->
      raise(Error(File_not_found obj_name)) in
  let ic = open_in_bin file_name in
  try
    let buffer = String.create (String.length cmo_magic_number) in
    really_input ic buffer 0 (String.length cmo_magic_number);
    if buffer = cmo_magic_number then begin
      (* This is a .cmo file. It must be linked in any case.
         Read the relocation information to see which modules it
         requires. *)
      let compunit_pos = input_binary_int ic in  (* Go to descriptor *)
      seek_in ic compunit_pos;
      let compunit = (input_value ic : compilation_unit) in
      close_in ic;
      List.iter add_required compunit.cu_reloc;
      Link_object(file_name, compunit) :: tolink
    end
    else if buffer = cma_magic_number then begin
      (* This is an archive file. Each unit contained in it will be linked
         in only if needed. *)
      let pos_toc = input_binary_int ic in    (* Go to table of contents *)
      seek_in ic pos_toc;
      let toc = (input_value ic : compilation_unit list) in
      close_in ic;
      let required =
        List.fold_right
          (fun compunit reqd ->
            if compunit.cu_force_link
            or !Clflags.link_everything
            or List.exists is_required compunit.cu_reloc
            then begin
              List.iter remove_required compunit.cu_reloc;
              List.iter add_required compunit.cu_reloc;
              compunit :: reqd
            end else
              reqd)
          toc [] in
      Link_archive(file_name, required) :: tolink
    end
    else raise(Error(Not_an_object_file file_name))
  with x ->
    close_in ic; raise x
@


<<function Bytelink.link_compunit>>=
(* Link in a compilation unit *)

let link_compunit output_fun currpos_fun inchan file_name compunit =
  check_consistency file_name compunit;
  seek_in inchan compunit.cu_pos;
  let code_block = String.create compunit.cu_codesize in
  really_input inchan code_block 0 compunit.cu_codesize;
  Symtable.patch_object code_block compunit.cu_reloc;
  if !Clflags.debug && compunit.cu_debug > 0 then begin
    seek_in inchan compunit.cu_debug;
    record_events (currpos_fun()) (input_value inchan : debug_event list)
  end;
  output_fun code_block;
  if !Clflags.link_everything then
    List.iter Symtable.require_primitive compunit.cu_primitives
@

<<function Bytelink.link_object>>=
(* Link in a .cmo file *)

let link_object output_fun currpos_fun file_name compunit =
  let inchan = open_in_bin file_name in
  try
    link_compunit output_fun currpos_fun inchan file_name compunit;
    close_in inchan
  with
    Symtable.Error msg ->
      close_in inchan; raise(Error(Symbol_error(file_name, msg)))
  | x ->
      close_in inchan; raise x
@

<<function Bytelink.link_archive>>=
(* Link in a .cma file *)

let link_archive output_fun currpos_fun file_name units_required =
  let inchan = open_in_bin file_name in
  try
    List.iter
      (fun cu ->
         let name = file_name ^ "(" ^ cu.cu_name ^ ")" in
         try
           link_compunit output_fun currpos_fun inchan name cu
         with Symtable.Error msg ->
           raise(Error(Symbol_error(name, msg))))
      units_required;
    close_in inchan
  with x -> close_in inchan; raise x
@

<<type Bytelink.link_action>>=
type link_action =
    Link_object of string * compilation_unit
      (* Name of .cmo file and descriptor of the unit *)
  | Link_archive of string * compilation_unit list
      (* Name of .cma file and descriptors of the units to be linked. *)
@

<<function Bytelink.link_file>>=
(* Link in a .cmo or .cma file *)

let link_file output_fun currpos_fun = function
    Link_object(file_name, unit) ->
      link_object output_fun currpos_fun file_name unit
  | Link_archive(file_name, units) ->
      link_archive output_fun currpos_fun file_name units
@


<<constant Bytelink.output_code_string_counter>>=
(* Output a string as a C array of unsigned ints *)

let output_code_string_counter = ref 0
@

<<function Bytelink.output_code_string>>=
let output_code_string outchan code =
  let pos = ref 0 in
  let len = String.length code in
  while !pos < len do
    let c1 = Char.code(code.[!pos]) in
    let c2 = Char.code(code.[!pos + 1]) in
    let c3 = Char.code(code.[!pos + 2]) in
    let c4 = Char.code(code.[!pos + 3]) in
    pos := !pos + 4;
    Printf.fprintf outchan "0x%02x%02x%02x%02x, " c4 c3 c2 c1;
    incr output_code_string_counter;
    if !output_code_string_counter >= 6 then begin
      output_char outchan '\n';
      output_code_string_counter := 0
    end
  done
@

<<function Bytelink.output_data_string>>=
(* Output a string as a C string *)

let output_data_string outchan data =
  let counter = ref 0 in
  output_string outchan "\"";
  for i = 0 to String.length data - 1 do
    Printf.fprintf outchan "\\%03o" (Char.code(data.[i]));
    incr counter;
    if !counter >= 16 then begin
      output_string outchan "\\\n";
      counter := 0
    end
  done;
  output_string outchan "\";\n\n"
@

<<function Bytelink.link_bytecode_as_c>>=
(* Output a bytecode executable as a C file *)

let link_bytecode_as_c objfiles outfile =
  let tolink = List.fold_right scan_file objfiles [] in
  let outchan = open_out outfile in
  try
    (* The bytecode *)
    output_string outchan "static int caml_code[] = {\n";
    Symtable.init();
    Hashtbl.clear crc_interfaces;
    let output_fun = output_code_string outchan
    and currpos_fun () = fatal_error "Bytelink.link_bytecode_as_c" in
    List.iter (link_file output_fun currpos_fun) tolink;
    (* The final STOP instruction *)
    Printf.fprintf outchan "\n0x%x};\n\n" Opcodes.opSTOP;
    (* The table of global data *)
    output_string outchan "static char * caml_data =\n";
    output_data_string outchan
      (Marshal.to_string (Symtable.initial_global_table()) []);
    (* The table of primitives *)
    Symtable.output_primitive_table outchan;
    (* The entry point *)
    output_string outchan "\n
void caml_startup(argv)
        char ** argv;
{
  caml_startup_code(caml_code, sizeof(caml_code), caml_data, argv);
}\n";
    close_out outchan
  with x ->
    close_out outchan;
    raise x
@

<<function Bytelink.extract>>=
(* Build a custom runtime *)

let rec extract suffix l =
  match l with
  | [] -> []
  | h::t when Filename.check_suffix h suffix -> h :: (extract suffix t)
  | h::t -> extract suffix t
@


<<function Bytelink.append_bytecode_and_cleanup>>=
let append_bytecode_and_cleanup bytecode_name exec_name prim_name =
  match Sys.os_type with
  | _ ->
      let oc =
        open_out_gen [Open_wronly; Open_append; Open_binary] 0
                                 !Clflags.exec_name in
      let ic = open_in_bin bytecode_name in
      copy_file ic oc;
      close_in ic;
      close_out oc;
      remove_file bytecode_name;
      remove_file prim_name
@

<<function Bytelink.fix_exec_name>>=
(* Fix the name of the output file, if the C compiler changes it behind
   our back. *)

let fix_exec_name name =
  match Sys.os_type with
  | _ -> name
@


%-------------------------------------------------------------

<<./bytecomp/bytelink.ml>>=
<<copyright header>>

(* Link a set of .cmo files and produce a bytecode executable. *)

open Sys
open Misc
open Config
open Instruct
open Emitcode

<<type Bytelink.error>>

<<exception Bytelink.Error>>

<<type Bytelink.link_action>>

(* First pass: determine which units are needed *)

module IdentSet = Set

<<constant Bytelink.missing_globals>>

<<function Bytelink.is_required>>

<<function Bytelink.add_required>>

<<function Bytelink.remove_required>>

<<function Bytelink.scan_file>>

<<constant Bytelink.debug_info>>

<<constant Bytelink.crc_interfaces>>

<<function Bytelink.check_consistency>>

<<constant Bytelink.debug_info (./bytecomp/bytelink.ml)>>

<<function Bytelink.record_events>>

<<function Bytelink.link_compunit>>

<<function Bytelink.link_object>>

<<function Bytelink.link_archive>>

<<function Bytelink.link_file>>

<<function Bytelink.link_bytecode>>

<<constant Bytelink.output_code_string_counter>>

<<function Bytelink.output_code_string>>

<<function Bytelink.output_data_string>>

<<function Bytelink.link_bytecode_as_c>>

<<function Bytelink.extract>>
;;

<<function Bytelink.build_custom_runtime>>

<<function Bytelink.append_bytecode_and_cleanup>>

<<function Bytelink.fix_exec_name>>

<<function Bytelink.link>>

(* Error report *)

open Format

<<constant Bytelink.report_error>>
@


\section{[[./driver/]]}

\subsection*{[[./driver/compile.mli]]}


%-------------------------------------------------------------

<<./driver/compile.mli>>=
<<copyright header>>

(* Compile a .ml or .mli file *)

<<signature Compile.interface>>
<<signature Compile.implementation>>
<<signature Compile.c_file>>

<<signature Compile.initial_env>>
<<signature Compile.init_path>>
@


\subsection*{[[./driver/compile.ml]]}

<<function Compile.init_path>>=
(* Initialize the search path.
   The current directory is always searched first,
   then the directories specified with the -I option (in command-line order),
   then the standard library directory. *)

let init_path () =
  let dirs =
    if !Clflags.thread_safe then
     Filename.concat Config.standard_library "threads" :: !Clflags.include_dirs
    else
     !Clflags.include_dirs in
  load_path := "" :: List.rev (Config.standard_library :: dirs);
  Env.reset_cache()
@

<<signature Env.reset_cache>>=
(* Reset the cache of in-core module interfaces.
   To be called in particular when load_path changes. *)
val reset_cache: unit -> unit
@
% init_path | -> <> ??
<<function Env.reset_cache>>=
let reset_cache() =
  Hashtbl.clear persistent_structures;
  imported_units := []
@


<<function Compile.initial_env>>=
(* Return the initial environment in which compilation proceeds. *)

let initial_env () =
  try
    if !Clflags.nopervasives
    then Env.initial
    else Env.open_pers_signature "Pervasives" Env.initial
  with Not_found ->
    fatal_error "cannot open Pervasives.cmi"
@

<<signature Env.open_pers_signature>>=
val open_pers_signature: string -> t -> t
@

<<function Env.open_pers_signature>>=
(* Open a signature from a file *)

let open_pers_signature name env =
  let ps = find_pers_struct name in
  open_signature (Pident(Ident.create_persistent name)) ps.ps_sig env
@


<<exception Compile.Outdated_version>>=
(* Parse a file or get a dumped syntax tree in it *)

exception Outdated_version
@

<<function Compile.print_if>>=
(* Compile a .ml file *)

let print_if flag printer arg =
  if !flag then begin printer arg; print_newline() end;
  arg
@




%-------------------------------------------------------------

<<./driver/compile.ml>>=
<<copyright header>>

(* The batch compiler *)

open Misc
open Config
open Format
open Typedtree

<<function Compile.init_path>>

<<function Compile.initial_env>>

<<function Compile.preprocess>>

<<function Compile.remove_preprocessed>>

<<exception Compile.Outdated_version>>

<<function Compile.parse_file>>

<<function Compile.interface>>

<<function Compile.print_if>>

<<function Compile.implementation>>

<<function Compile.c_file>>
@


\subsection*{[[./driver/errors.mli]]}



%-------------------------------------------------------------

<<./driver/errors.mli>>=
<<copyright header>>

<<signature Errors.report_error>>
@


\subsection*{[[./driver/errors.ml]]}

%-------------------------------------------------------------

<<./driver/errors.ml>>=
<<copyright header>>

(* Error report *)

open Format
open Location

<<function Errors.report_error>>
@


\subsection*{[[./driver/main.ml]]}


%-------------------------------------------------------------

<<./driver/main.ml>>=
<<copyright header>>

open Config
open Clflags

<<function Main.process_interface_file>>

<<function Main.process_implementation_file>>

<<function Main.process_file>>

<<function Main.print_version_number>>

<<constant Main.usage>>

<<function Main.main>>

<<toplevel Main._1>>
@


\section{NATIVE CODE START}

\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/arch.ml]]}

<<type Arch.addressing_mode>>=
(* Addressing modes *)

type addressing_mode =
    Iindexed of int                     (* reg + displ *)
@

<<type Arch.specific_operation>>=
type specific_operation =
    Ishiftarith of arith_operation * int
  | Ishiftcheckbound of int
  | Irevsubimm of int
@

<<type Arch.arith_operation>>=
and arith_operation =
    Ishiftadd
  | Ishiftsub
  | Ishiftsubrev
@

<<type Arch.float_operation>>=
type float_operation = unit
@

<<constant Arch.big_endian>>=
(* Sizes, endianness *)

let big_endian = false
@

<<constant Arch.size_addr>>=
let size_addr = 4
@

<<constant Arch.size_int>>=
let size_int = 4
@

<<constant Arch.size_float>>=
let size_float = 8
@

<<constant Arch.identity_addressing>>=
(* Operations on addressing modes *)

let identity_addressing = Iindexed 0
@

<<function Arch.offset_addressing>>=
let offset_addressing (Iindexed n) delta = Iindexed(n + delta)
@

<<function Arch.num_args_addressing>>=
let num_args_addressing (Iindexed n) = 1
@

<<function Arch.print_addressing>>=
(* Printing operations and addressing modes *)

let print_addressing printreg addr arg =
  match addr with
    Iindexed n ->
      printreg arg.(0);
      if n <> 0 then begin print_string " + "; print_int n end
@

<<function Arch.print_specific_operation>>=
let print_specific_operation printreg op arg =
  match op with
    Ishiftarith(op, shift) ->
      printreg arg.(0);
      begin match op with
        Ishiftadd -> print_string " + "
      | Ishiftsub -> print_string " - "
      | Ishiftsubrev -> print_string " -rev "
      end;
      printreg arg.(1);
      if shift >= 0
      then begin print_string " << "; print_int shift end
      else begin print_string " >> "; print_int (-shift) end
  | Ishiftcheckbound n ->
      print_string "check ";
      printreg arg.(0);
      print_string " >> "; print_int n; print_string " > ";
      printreg arg.(1)
  | Irevsubimm n ->
      print_int n; print_string " - "; printreg arg.(0)
@


%-------------------------------------------------------------

<<asmcomp/arm/arch.ml>>=
<<copyright header 1998>>

(* Specific operations for the ARM processor *)

open Misc
open Format

<<type Arch.addressing_mode>>

(* We do not support the reg + shifted reg addressing mode, because
   what we really need is reg + shifted reg + displ,
   and this is decomposed in two instructions (reg + shifted reg -> tmp,
   then addressing tmp + displ). *)

(* Specific operations *)

<<type Arch.specific_operation>>

<<type Arch.arith_operation>>

<<type Arch.float_operation>>

<<constant Arch.big_endian>>

<<constant Arch.size_addr>>
<<constant Arch.size_int>>
<<constant Arch.size_float>>

<<constant Arch.identity_addressing>>

<<function Arch.offset_addressing>>

<<function Arch.num_args_addressing>>

<<function Arch.print_addressing>>

<<function Arch.print_specific_operation>>
@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/clambda.mli]]}

<<type Clambda.function_label>>=
type function_label = string
@

<<type Clambda.ulambda>>=
type ulambda =
    Uvar of Ident.t
  | Uconst of structured_constant
  | Udirect_apply of function_label * ulambda list
  | Ugeneric_apply of ulambda * ulambda list
  | Uclosure of (function_label * int * Ident.t list * ulambda) list
              * ulambda list
  | Uoffset of ulambda * int
  | Ulet of Ident.t * ulambda * ulambda
  | Uletrec of (Ident.t * ulambda) list * ulambda
  | Uprim of primitive * ulambda list
  | Uswitch of ulambda * ulambda_switch
  | Ustaticfail
  | Ucatch of ulambda * ulambda
  | Utrywith of ulambda * Ident.t * ulambda
  | Uifthenelse of ulambda * ulambda * ulambda
  | Usequence of ulambda * ulambda
  | Uwhile of ulambda * ulambda
  | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
  | Uassign of Ident.t * ulambda
@

<<type Clambda.ulambda_switch>>=
and ulambda_switch =
  { us_index_consts: int array;
    us_cases_consts: ulambda array;
    us_index_blocks: int array;
    us_cases_blocks: ulambda array;
    us_checked: bool }
@

<<type Clambda.function_description>>=
(* Description of known functions *)

type function_description =
  { fun_label: function_label;          (* Label of direct entry point *)
    fun_arity: int;                     (* Number of arguments *)
    mutable fun_closed: bool;           (* True if environment not used *)
    mutable fun_inline: (Ident.t list * ulambda) option }
@

<<type Clambda.value_approximation>>=
(* Approximation of values *)

type value_approximation =
    Value_closure of function_description * value_approximation
  | Value_tuple of value_approximation array
  | Value_unknown
@


%-------------------------------------------------------------

<<asmcomp/clambda.mli>>=
<<copyright header>>

(* A variant of the "lambda" code with direct / indirect calls explicit
   and closures explicit too *)

open Asttypes
open Lambda

<<type Clambda.function_label>>

<<type Clambda.ulambda>>

<<type Clambda.ulambda_switch>>

<<type Clambda.function_description>>

<<type Clambda.value_approximation>>
@


\subsection*{[[asmcomp/clambda.ml]]}

<<type Clambda.function_label (asmcomp/clambda.ml)>>=
type function_label = string
@

<<type Clambda.ulambda (asmcomp/clambda.ml)>>=
type ulambda =
    Uvar of Ident.t
  | Uconst of structured_constant
  | Udirect_apply of function_label * ulambda list
  | Ugeneric_apply of ulambda * ulambda list
  | Uclosure of (function_label * int * Ident.t list * ulambda) list
              * ulambda list
  | Uoffset of ulambda * int
  | Ulet of Ident.t * ulambda * ulambda
  | Uletrec of (Ident.t * ulambda) list * ulambda
  | Uprim of primitive * ulambda list
  | Uswitch of ulambda * ulambda_switch
  | Ustaticfail
  | Ucatch of ulambda * ulambda
  | Utrywith of ulambda * Ident.t * ulambda
  | Uifthenelse of ulambda * ulambda * ulambda
  | Usequence of ulambda * ulambda
  | Uwhile of ulambda * ulambda
  | Ufor of Ident.t * ulambda * ulambda * direction_flag * ulambda
  | Uassign of Ident.t * ulambda
@

<<type Clambda.ulambda_switch (asmcomp/clambda.ml)>>=
and ulambda_switch =
  { us_index_consts: int array;
    us_cases_consts: ulambda array;
    us_index_blocks: int array;
    us_cases_blocks: ulambda array;
    us_checked: bool }
@

<<type Clambda.function_description (asmcomp/clambda.ml)>>=
(* Description of known functions *)

type function_description =
  { fun_label: function_label;          (* Label of direct entry point *)
    fun_arity: int;                     (* Number of arguments *)
    mutable fun_closed: bool;           (* True if environment not used *)
    mutable fun_inline: (Ident.t list * ulambda) option }
@

<<type Clambda.value_approximation (asmcomp/clambda.ml)>>=
(* Approximation of values *)

type value_approximation =
    Value_closure of function_description * value_approximation
  | Value_tuple of value_approximation array
  | Value_unknown
@


%-------------------------------------------------------------

<<asmcomp/clambda.ml>>=
<<copyright header>>

(* A variant of the "lambda" code with direct / indirect calls explicit
   and closures explicit too *)

open Asttypes
open Lambda

<<type Clambda.function_label (asmcomp/clambda.ml)>>

<<type Clambda.ulambda (asmcomp/clambda.ml)>>

<<type Clambda.ulambda_switch (asmcomp/clambda.ml)>>

<<type Clambda.function_description (asmcomp/clambda.ml)>>

<<type Clambda.value_approximation (asmcomp/clambda.ml)>>
@


\subsection*{[[asmcomp/emitaux.mli]]}

<<signature Emitaux.output_channel>>=
(* Common functions for emitting assembly code *)

val output_channel: out_channel ref
@

<<signature Emitaux.emit_string>>=
val emit_string: string -> unit
@

<<signature Emitaux.emit_int>>=
val emit_int: int -> unit
@

<<signature Emitaux.emit_nativeint>>=
val emit_nativeint: Nativeint.t -> unit
@

<<signature Emitaux.emit_symbol>>=
val emit_symbol: char -> string -> unit
@

<<signature Emitaux.emit_printf>>=
val emit_printf: ('a, out_channel, unit) format -> 'a
@

<<signature Emitaux.emit_char>>=
val emit_char: char -> unit
@

<<signature Emitaux.emit_string_literal>>=
val emit_string_literal: string -> unit
@

<<signature Emitaux.emit_string_directive>>=
val emit_string_directive: string -> string -> unit
@

<<signature Emitaux.emit_bytes_directive>>=
val emit_bytes_directive: string -> string -> unit
@


%-------------------------------------------------------------

<<asmcomp/emitaux.mli>>=
<<copyright header>>

<<signature Emitaux.output_channel>>
<<signature Emitaux.emit_string>>
<<signature Emitaux.emit_int>>
<<signature Emitaux.emit_nativeint>>
<<signature Emitaux.emit_symbol>>
<<signature Emitaux.emit_printf>>
<<signature Emitaux.emit_char>>
<<signature Emitaux.emit_string_literal>>
<<signature Emitaux.emit_string_directive>>
<<signature Emitaux.emit_bytes_directive>>
@


\subsection*{[[asmcomp/emitaux.ml]]}

<<constant Emitaux.output_channel>>=
(* Common functions for emitting assembly code *)

let output_channel = ref stdout
@

<<function Emitaux.emit_string>>=
let emit_string s = output_string !output_channel s
@

<<function Emitaux.emit_int>>=
let emit_int n = output_string !output_channel (string_of_int n)
@

<<function Emitaux.emit_char>>=
let emit_char c = output_char !output_channel c
@

<<function Emitaux.emit_nativeint>>=
let emit_nativeint n = output_string !output_channel (Nativeint.to_string n)
@

<<function Emitaux.emit_printf>>=
(* @Scheck: used by mips backend *)
let emit_printf fmt =
  Printf.fprintf !output_channel fmt
@

<<function Emitaux.emit_symbol>>=
let emit_symbol esc s =
  for i = 0 to String.length s - 1 do
    let c = s.[i] in
    match c with
      'A'..'Z' | 'a'..'z' | '0'..'9' | '_' ->
        output_char !output_channel c
    | _ ->
        Printf.fprintf !output_channel "%c%02x" esc (Char.code c)
  done
@

<<function Emitaux.emit_string_literal>>=
let emit_string_literal s =
  let last_was_escape = ref false in
  emit_string "\"";
  for i = 0 to String.length s - 1 do
    let c = s.[i] in
    if c >= '0' && c <= '9' then
      if !last_was_escape
      then Printf.fprintf !output_channel "\\%o" (Char.code c)
      else output_char !output_channel c
    else if c >= ' ' && c <= '~' && c <> '"' (* '"' *) && c <> '\\' then begin
      output_char !output_channel c;
      last_was_escape := false
    end else begin
      Printf.fprintf !output_channel "\\%o" (Char.code c);
      last_was_escape := true
    end
  done;
  emit_string "\""
@

<<function Emitaux.emit_string_directive>>=
let emit_string_directive directive s =
  let l = String.length s in
  if l = 0 then ()
  else if l < 80 then begin
    emit_string directive;
    emit_string_literal s;
    emit_char '\n'
  end else begin
    let i = ref 0 in
    while !i < l do
      let n = min (l - !i) 80 in
      emit_string directive;
      emit_string_literal (String.sub s !i n);
      emit_char '\n';
      i := !i + n
    done
  end
@

<<function Emitaux.emit_bytes_directive>>=
let emit_bytes_directive directive s =
   let pos = ref 0 in
   for i = 0 to String.length s - 1 do
     if !pos = 0
     then emit_string directive
     else emit_char ',';
     emit_int(Char.code s.[i]);
     incr pos;
     if !pos >= 16 then begin emit_char '\n'; pos := 0 end
   done;
   if !pos > 0 then emit_char '\n'
@


%-------------------------------------------------------------

<<asmcomp/emitaux.ml>>=
<<copyright header>>

<<constant Emitaux.output_channel>>

<<function Emitaux.emit_string>>

<<function Emitaux.emit_int>>

<<function Emitaux.emit_char>>

<<function Emitaux.emit_nativeint>>

<<function Emitaux.emit_printf>>

<<function Emitaux.emit_symbol>>

<<function Emitaux.emit_string_literal>>

<<function Emitaux.emit_string_directive>>

<<function Emitaux.emit_bytes_directive>>

@


\subsection*{[[asmcomp/scheduling.mli]]}

<<signature Scheduling.fundecl>>=
(* Instruction scheduling *)

val fundecl: Linearize.fundecl -> Linearize.fundecl
@


%-------------------------------------------------------------

<<asmcomp/scheduling.mli>>=
<<copyright header>>

<<signature Scheduling.fundecl>>
@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/scheduling.ml]]}

<<function Scheduling.scheduler>>=
(* Instruction scheduling for the Sparc *)

let scheduler () = 

  let super = Schedgen.scheduler_generic () in
  {

  oper_in_basic_block = super.oper_in_basic_block;
  schedule_fundecl = super.schedule_fundecl;
  instr_in_basic_block = super.instr_in_basic_block;
  instr_latency = super.instr_latency;
  instr_issue_cycles = super.instr_issue_cycles;
  add_instruction = super.add_instruction;
  ready_instruction = super.ready_instruction;
  reschedule = super.reschedule;

(* Scheduling -- based roughly on the Strong ARM *)

 oper_latency = (function
    Ireload -> 2
  | Iload(_, _) -> 2
  | Iconst_symbol _ -> 2                (* turned into a load *)
  | Iconst_float _ -> 2                 (* turned into a load *)
  | Iintop(Imul) -> 3
  | Iintop_imm(Imul, _) -> 3
  (* No data available for floatops, let's make educated guesses *)
  | Iaddf -> 3
  | Isubf -> 3
  | Imulf -> 5
  | Idivf -> 15
  | _ -> 1
 );

(* Issue cycles.  Rough approximations *)

 oper_issue_cycles = (function
    Ialloc _ -> 4
  | Iintop(Icomp _) -> 3
  | Iintop(Icheckbound) -> 2
  | Iintop_imm(Idiv, _) -> 4
  | Iintop_imm(Imod, _) -> 6
  | Iintop_imm(Icomp _, _) -> 3
  | Iintop_imm(Icheckbound, _) -> 2
  | _ -> 1
 );
  }
@

<<function Scheduling.fundecl>>=
let fundecl f = 
  let s = scheduler () in
  s.schedule_fundecl s f
@


%-------------------------------------------------------------

<<asmcomp/arm/scheduling.ml>>=
<<copyright header>>
open Mach

open Schedgen

<<function Scheduling.scheduler>>

<<function Scheduling.fundecl>>
@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/cmm.mli]]}

<<type Cmm.machtype_component>>=
(* Second intermediate language (machine independent) *)

type machtype_component =
    Addr
  | Int
  | Float
@

<<type Cmm.machtype>>=
type machtype = machtype_component array
@

<<signature Cmm.typ_void>>=
val typ_void: machtype
@

<<signature Cmm.typ_addr>>=
val typ_addr: machtype
@

<<signature Cmm.typ_int>>=
val typ_int: machtype
@

<<signature Cmm.typ_float>>=
val typ_float: machtype
@

<<signature Cmm.size_component>>=
val size_component: machtype_component -> int
@

<<signature Cmm.size_machtype>>=
val size_machtype: machtype -> int
@

<<type Cmm.comparison>>=
type comparison =
    Ceq
  | Cne
  | Clt
  | Cle
  | Cgt
  | Cge
@

<<signature Cmm.negate_comparison>>=
val negate_comparison: comparison -> comparison
@

<<signature Cmm.swap_comparison>>=
val swap_comparison: comparison -> comparison
@

<<type Cmm.memory_chunk>>=
type memory_chunk =
    Byte_unsigned
  | Byte_signed
  | Sixteen_unsigned
  | Sixteen_signed
  | Word
@

<<type Cmm.operation>>=
type operation =
    Capply of machtype
  | Cextcall of string * machtype * bool
  | Cproj of int * int
  | Cload of machtype
  | Cloadchunk of memory_chunk
  | Calloc
  | Cstore
  | Cstorechunk of memory_chunk
  | Caddi | Csubi | Cmuli | Cdivi | Cmodi
  | Cand | Cor | Cxor | Clsl | Clsr | Casr
  | Ccmpi of comparison
  | Cadda | Csuba
  | Ccmpa of comparison
  | Cnegf | Cabsf
  | Caddf | Csubf | Cmulf | Cdivf
  | Cfloatofint | Cintoffloat
  | Ccmpf of comparison
  | Craise
  | Ccheckbound
@

<<type Cmm.expression>>=
type expression =
    Cconst_int of int
  | Cconst_natint of Nativeint.t
  | Cconst_float of string
  | Cconst_symbol of string
  | Cconst_pointer of int
  | Cvar of Ident.t
  | Clet of Ident.t * expression * expression
  | Cassign of Ident.t * expression
  | Ctuple of expression list
  | Cop of operation * expression list
  | Csequence of expression * expression
  | Cifthenelse of expression * expression * expression
  | Cswitch of expression * int array * expression array
  | Cloop of expression
  | Ccatch of expression * expression
  | Cexit
  | Ctrywith of expression * Ident.t * expression
@

<<type Cmm.fundecl>>=
type fundecl =
  { fun_name: string;
    fun_args: (Ident.t * machtype) list;
    fun_body: expression;
    fun_fast: bool }
@

<<type Cmm.data_item>>=
type data_item =
    Cdefine_symbol of string
  | Cdefine_label of int
  | Cint8 of int
  | Cint16 of int
  | Cint of Nativeint.t
  | Cfloat of string
  | Csymbol_address of string
  | Clabel_address of int
  | Cstring of string
  | Cskip of int
  | Calign of int
@

<<type Cmm.phrase>>=
type phrase =
    Cfunction of fundecl
  | Cdata of data_item list
@


%-------------------------------------------------------------

<<asmcomp/cmm.mli>>=
<<copyright header>>

<<type Cmm.machtype_component>>

<<type Cmm.machtype>>

<<signature Cmm.typ_void>>
<<signature Cmm.typ_addr>>
<<signature Cmm.typ_int>>
<<signature Cmm.typ_float>>

<<signature Cmm.size_component>>
<<signature Cmm.size_machtype>>

<<type Cmm.comparison>>

<<signature Cmm.negate_comparison>>
<<signature Cmm.swap_comparison>>

<<type Cmm.memory_chunk>>

<<type Cmm.operation>>

<<type Cmm.expression>>

<<type Cmm.fundecl>>

<<type Cmm.data_item>>

<<type Cmm.phrase>>

@


\subsection*{[[asmcomp/cmm.ml]]}

<<type Cmm.machtype_component (asmcomp/cmm.ml)>>=

type machtype_component =
    Addr
  | Int
  | Float
@

<<type Cmm.machtype (asmcomp/cmm.ml)>>=
type machtype = machtype_component array
@

<<constant Cmm.typ_void>>=
let typ_void = ([||] : machtype_component array)
@

<<constant Cmm.typ_addr>>=
let typ_addr = [|Addr|]
@

<<constant Cmm.typ_int>>=
let typ_int = [|Int|]
@

<<constant Cmm.typ_float>>=
let typ_float = [|Float|]
@

<<function Cmm.size_component>>=
let size_component = function
    Addr -> Arch.size_addr
  | Int -> Arch.size_int
  | Float -> Arch.size_float
@

<<function Cmm.size_machtype>>=
let size_machtype mty =
  let size = ref 0 in
  for i = 0 to Array.length mty - 1 do
    size := !size + size_component mty.(i)
  done;
  !size
@

<<type Cmm.comparison (asmcomp/cmm.ml)>>=
type comparison =
    Ceq
  | Cne
  | Clt
  | Cle
  | Cgt
  | Cge
@

<<function Cmm.negate_comparison>>=
let negate_comparison = function
    Ceq -> Cne | Cne -> Ceq
  | Clt -> Cge | Cle -> Cgt
  | Cgt -> Cle | Cge -> Clt
@

<<function Cmm.swap_comparison>>=
let swap_comparison = function
    Ceq -> Ceq | Cne -> Cne
  | Clt -> Cgt | Cle -> Cge
  | Cgt -> Clt | Cge -> Cle
@

<<type Cmm.memory_chunk (asmcomp/cmm.ml)>>=
type memory_chunk =
    Byte_unsigned
  | Byte_signed
  | Sixteen_unsigned
  | Sixteen_signed
  | Word
@

<<type Cmm.operation (asmcomp/cmm.ml)>>=
type operation =
    Capply of machtype
  | Cextcall of string * machtype * bool
  | Cproj of int * int
  | Cload of machtype
  | Cloadchunk of memory_chunk
  | Calloc
  | Cstore
  | Cstorechunk of memory_chunk
  | Caddi | Csubi | Cmuli | Cdivi | Cmodi
  | Cand | Cor | Cxor | Clsl | Clsr | Casr
  | Ccmpi of comparison
  | Cadda | Csuba
  | Ccmpa of comparison
  | Cnegf | Cabsf
  | Caddf | Csubf | Cmulf | Cdivf
  | Cfloatofint | Cintoffloat
  | Ccmpf of comparison
  | Craise
  | Ccheckbound
@

<<type Cmm.expression (asmcomp/cmm.ml)>>=
type expression =
    Cconst_int of int
  | Cconst_natint of Nativeint.t
  | Cconst_float of string
  | Cconst_symbol of string
  | Cconst_pointer of int
  | Cvar of Ident.t
  | Clet of Ident.t * expression * expression
  | Cassign of Ident.t * expression
  | Ctuple of expression list
  | Cop of operation * expression list
  | Csequence of expression * expression
  | Cifthenelse of expression * expression * expression
  | Cswitch of expression * int array * expression array
  | Cloop of expression
  | Ccatch of expression * expression
  | Cexit
  | Ctrywith of expression * Ident.t * expression
@

<<type Cmm.fundecl (asmcomp/cmm.ml)>>=
type fundecl =
  { fun_name: string;
    fun_args: (Ident.t * machtype) list;
    fun_body: expression;
    fun_fast: bool }
@

<<type Cmm.data_item (asmcomp/cmm.ml)>>=
type data_item =
    Cdefine_symbol of string
  | Cdefine_label of int
  | Cint8 of int
  | Cint16 of int
  | Cint of Nativeint.t
  | Cfloat of string
  | Csymbol_address of string
  | Clabel_address of int
  | Cstring of string
  | Cskip of int
  | Calign of int
@

<<type Cmm.phrase (asmcomp/cmm.ml)>>=
type phrase =
    Cfunction of fundecl
  | Cdata of data_item list
@


%-------------------------------------------------------------

<<asmcomp/cmm.ml>>=
<<copyright header>>
<<type Cmm.machtype_component (asmcomp/cmm.ml)>>

<<type Cmm.machtype (asmcomp/cmm.ml)>>

<<constant Cmm.typ_void>>
<<constant Cmm.typ_addr>>
<<constant Cmm.typ_int>>
<<constant Cmm.typ_float>>

<<function Cmm.size_component>>

<<function Cmm.size_machtype>>

<<type Cmm.comparison (asmcomp/cmm.ml)>>

<<function Cmm.negate_comparison>>

<<function Cmm.swap_comparison>>

<<type Cmm.memory_chunk (asmcomp/cmm.ml)>>

<<type Cmm.operation (asmcomp/cmm.ml)>>

<<type Cmm.expression (asmcomp/cmm.ml)>>

<<type Cmm.fundecl (asmcomp/cmm.ml)>>

<<type Cmm.data_item (asmcomp/cmm.ml)>>

<<type Cmm.phrase (asmcomp/cmm.ml)>>

@


\subsection*{[[asmcomp/printcmm.mli]]}

<<signature Printcmm.machtype_component>>=
(* Pretty-printing of C-- code *)

val machtype_component : Cmm.machtype_component -> unit
@

<<signature Printcmm.machtype>>=
val machtype : Cmm.machtype_component array -> unit
@

<<signature Printcmm.comparison>>=
val comparison : Cmm.comparison -> unit
@

<<signature Printcmm.chunk>>=
val chunk : Cmm.memory_chunk -> unit
@

<<signature Printcmm.operation>>=
val operation : Cmm.operation -> unit
@

<<signature Printcmm.expression>>=
val expression : Cmm.expression -> unit
@

<<signature Printcmm.fundecl>>=
val fundecl : Cmm.fundecl -> unit
@

<<signature Printcmm.data>>=
val data : Cmm.data_item list -> unit
@

<<signature Printcmm.phrase>>=
val phrase : Cmm.phrase -> unit
@


%-------------------------------------------------------------

<<asmcomp/printcmm.mli>>=
<<copyright header>>

<<signature Printcmm.machtype_component>>
<<signature Printcmm.machtype>>
<<signature Printcmm.comparison>>
<<signature Printcmm.chunk>>
<<signature Printcmm.operation>>
<<signature Printcmm.expression>>
<<signature Printcmm.fundecl>>
<<signature Printcmm.data>>
<<signature Printcmm.phrase>>
@


\subsection*{[[asmcomp/printcmm.ml]]}

<<function Printcmm.machtype_component>>=
let machtype_component = function
    Addr -> print_string "addr"
  | Int -> print_string "int"
  | Float -> print_string "float"
@

<<function Printcmm.machtype>>=
let machtype mty =
  match Array.length mty with
    0 -> print_string "unit"
  | n -> machtype_component mty.(0);
         for i = 1 to n-1 do
           print_string "*"; machtype_component mty.(i)
         done
@

<<function Printcmm.comparison>>=
let comparison = function
    Ceq -> print_string "=="
  | Cne -> print_string "!="
  | Clt -> print_string "<"
  | Cle -> print_string "<="
  | Cgt -> print_string ">"
  | Cge -> print_string ">="
@

<<function Printcmm.chunk>>=
let chunk = function
    Byte_unsigned -> print_string "unsigned byte"
  | Byte_signed -> print_string "signed byte"
  | Sixteen_unsigned -> print_string "unsigned half"
  | Sixteen_signed -> print_string "signed half"
  | Word -> ()
@

<<function Printcmm.operation>>=
let operation = function
    Capply ty -> print_string "app"
  | Cextcall(lbl, ty, alloc) ->
      print_string "extcall \""; print_string lbl; print_string "\""
  | Cproj(ofs, len) ->
      print_string "proj "; print_int ofs;
      if len > 1 then begin print_string "-"; print_int (ofs + len - 1) end
  | Cload mty -> print_string "load"
  | Cloadchunk c -> print_string "load "; chunk c
  | Calloc -> print_string "alloc"
  | Cstore -> print_string "store"
  | Cstorechunk c -> print_string "store "; chunk c
  | Caddi -> print_string "+"
  | Csubi -> print_string "-"
  | Cmuli -> print_string "*"
  | Cdivi -> print_string "/"
  | Cmodi -> print_string "mod"
  | Cand -> print_string "and"
  | Cor -> print_string "or"
  | Cxor -> print_string "xor"
  | Clsl -> print_string "<<"
  | Clsr -> print_string ">>u"
  | Casr -> print_string ">>s"
  | Ccmpi c -> comparison c
  | Cadda -> print_string "+a"
  | Csuba -> print_string "-a"
  | Ccmpa c -> comparison c; print_string "a"
  | Cnegf -> print_string "~f"
  | Cabsf -> print_string "absf"
  | Caddf -> print_string "+f"
  | Csubf -> print_string "-f"
  | Cmulf -> print_string "*f"
  | Cdivf -> print_string "/f"
  | Cfloatofint -> print_string "floatofint"
  | Cintoffloat -> print_string "intoffloat"
  | Ccmpf c -> comparison c; print_string "f"
  | Craise -> print_string "raise"
  | Ccheckbound -> print_string "checkbound"
@

<<function Printcmm.fundecl>>=
let fundecl f =
  open_box 1;
  print_string "(function "; print_string f.fun_name; print_break 1 4;
  open_box 1;
  print_string "(";
  let first = ref true in
  List.iter
    (fun (id, ty) -> 
      if !first then first := false else print_space();
      Ident.print id; print_string ": "; machtype ty)
    f.fun_args;
  print_string ")"; close_box(); print_space();
  open_box 0;
  sequence f.fun_body;
  print_string ")";
  close_box(); close_box(); print_newline()
@

<<function Printcmm.data_item>>=
let data_item = function
    Cdefine_symbol s -> print_string "\""; print_string s; print_string "\":"
  | Cdefine_label l -> print_string "L"; print_int l; print_string ":"
  | Cint8 n -> print_string "byte "; print_int n
  | Cint16 n -> print_string "half "; print_int n
  | Cint n -> print_string "int "; print_string(Nativeint.to_string n)
  | Cfloat f -> print_string "float "; print_string f
  | Csymbol_address s ->
      print_string "addr \""; print_string s; print_string "\""
  | Clabel_address l -> print_string "addr L"; print_int l
  | Cstring s -> print_string "string \""; print_string s; print_string "\""
  | Cskip n -> print_string "skip "; print_int n
  | Calign n -> print_string "align "; print_int n
@

<<function Printcmm.data>>=
let data dl =
  open_hvbox 1;
  print_string "(data";
  List.iter (fun d -> print_space(); data_item d) dl;
  print_string ")"; close_box()
@

<<function Printcmm.phrase>>=
let phrase = function
    Cfunction f -> fundecl f
  | Cdata dl -> data dl
@


%-------------------------------------------------------------

<<asmcomp/printcmm.ml>>=
<<copyright header>>

(* Pretty-printing of C-- code *)

open Format
open Cmm

<<function Printcmm.machtype_component>>

<<function Printcmm.machtype>>

<<function Printcmm.comparison>>

<<function Printcmm.chunk>>

<<function Printcmm.operation>>

let rec expression = function
    Cconst_int n -> print_int n
  | Cconst_natint n -> print_string(Nativeint.to_string n)
  | Cconst_float s -> print_string s
  | Cconst_symbol s -> print_string "\""; print_string s; print_string "\""
  | Cconst_pointer n -> print_int n; print_string "a"
  | Cvar id -> Ident.print id
  | Clet(id, def, (Clet(_, _, _) as body)) ->
      open_box 2;
      print_string "(let"; print_space();
      open_box 1;
      print_string "(";
      open_box 2;
      Ident.print id; print_space(); expression def;
      close_box();
      let rec letdef = function
        Clet(id, def, body) ->
          print_space();
          open_box 2;
          Ident.print id; print_space(); expression def;
          close_box();
          letdef body
      | exp ->
          print_string ")"; close_box();
          print_space(); sequence exp
      in letdef body;
      print_string ")"; close_box()
  | Clet(id, def, body) ->
      open_box 2;
      print_string "(let"; print_space();
      open_box 2;
      Ident.print id; print_space(); expression def;
      close_box(); print_space();
      sequence body;
      print_string ")"; close_box()
  | Cassign(id, exp) ->
      open_box 2;
      print_string "(assign ";
      open_box 2;
      Ident.print id; print_space(); expression exp;
      close_box();
      print_string ")"; close_box()
  | Ctuple el ->
      open_box 1;
      print_string "[";
      let first = ref true in
      List.iter
        (fun e ->
          if !first then first := false else print_space();
          expression e)
        el;
      print_string "]";
      close_box()
  | Cop(op, el) ->
      open_box 2;
      print_string "("; operation op;
      List.iter (fun e -> print_space(); expression e) el;
      begin match op with
        Capply mty -> print_space(); machtype mty
      | Cextcall(_, mty, _) -> print_space(); machtype mty
      | Cload mty -> print_space(); machtype mty
      | _ -> ()
      end;
      print_string ")";
      close_box()
  | Csequence(e1, e2) ->
      open_box 2;
      print_string "(seq "; print_space();
      sequence e1; print_space();
      sequence e2; print_string ")"; close_box()
  | Cifthenelse(e1, e2, e3) ->
      open_box 2;
      print_string "(if";
      print_space(); expression e1;
      print_space(); expression e2;
      print_space(); expression e3;
      print_string ")"; close_box()
  | Cswitch(e1, index, cases) ->
      open_vbox 0;
      open_box 2;
      print_string "(switch"; print_space(); expression e1; print_space();
      close_box();
      for i = 0 to Array.length cases - 1 do
        print_space();
        open_box 2;
        for j = 0 to Array.length index - 1 do
          if index.(j) = i then begin
            print_string "case "; print_int j; print_string ":"; print_space()
          end
        done;
        sequence cases.(i);
        close_box()
      done;
      close_box()
  | Cloop e ->
      open_box 2;
      print_string "(loop";
      print_space(); sequence e;
      print_string ")"; close_box()
  | Ccatch(e1, e2) ->
      open_box 2;
      print_string "(catch";
      print_space(); sequence e1;
      print_break 1 (-2); print_string "with";
      print_space(); sequence e2;
      print_string ")"; close_box()
  | Cexit ->
      print_string "exit"
  | Ctrywith(e1, id, e2) ->
      open_box 2;
      print_string "(try";
      print_space(); sequence e1;
      print_break 1 (-2); print_string "with "; Ident.print id;
      print_space(); sequence e2;
      print_string ")"; close_box()

and sequence = function
    Csequence(e1, e2) ->
      sequence e1; print_space(); sequence e2
  | e ->
      expression e

<<function Printcmm.fundecl>>

<<function Printcmm.data_item>>

<<function Printcmm.data>>

<<function Printcmm.phrase>>
@


\subsection*{[[asmcomp/compilenv.mli]]}

<<type Compilenv.unit_infos>>=
type unit_infos =
  { mutable ui_name: string;                    (* Name of unit implemented *)
    mutable ui_imports_cmi: (string * Digest.t) list; (* Interfaces imported *)
    mutable ui_imports_cmx: (string * Digest.t) list; (* Infos imported *)
    mutable ui_approx: value_approximation;     (* Approx of the structure *)
    mutable ui_curry_fun: int list;             (* Currying functions needed *)
    mutable ui_apply_fun: int list;             (* Apply functions needed *)
    mutable ui_force_link: bool }               (* Always linked *)
@

<<signature Compilenv.reset>>=
val reset: string -> unit
        (* Reset the environment and record the name of the unit being
           compiled (arg). *)
@

<<signature Compilenv.current_unit_name>>=
val current_unit_name: unit -> string
        (* Return the name of the unit being compiled *)
@

<<signature Compilenv.global_approx>>=
val global_approx: Ident.t -> Clambda.value_approximation
        (* Return the approximation for the given global identifier *)
@

<<signature Compilenv.set_global_approx>>=
val set_global_approx: Clambda.value_approximation -> unit
        (* Record the approximation of the unit being compiled *)
@

<<signature Compilenv.need_curry_fun>>=
val need_curry_fun: int -> unit
@

<<signature Compilenv.need_apply_fun>>=
val need_apply_fun: int -> unit
        (* Record the need of a currying (resp. application) function
           with the given arity *)
@

<<signature Compilenv.read_unit_info>>=
val read_unit_info: string -> unit_infos * Digest.t
        (* Read infos and CRC from a [.cmx] file. *)
@

<<signature Compilenv.save_unit_info>>=
val save_unit_info: string -> unit
        (* Save the infos for the current unit in the given file *)
@

<<signature Compilenv.cmx_not_found_crc>>=
val cmx_not_found_crc: Digest.t
        (* Special digest used in the [ui_imports_cmx] list to signal
           that no [.cmx] file was found and used for the imported unit *)
@

<<type Compilenv.error>>=
type error =
    Not_a_unit_info of string
  | Corrupted_unit_info of string
  | Illegal_renaming of string * string
@

<<exception Compilenv.Error>>=
exception Error of error
@

<<signature Compilenv.report_error>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/compilenv.mli>>=
<<copyright header>>

(* Compilation environments for compilation units *)

open Clambda

<<type Compilenv.unit_infos>>

<<signature Compilenv.reset>>

<<signature Compilenv.current_unit_name>>

<<signature Compilenv.global_approx>>
<<signature Compilenv.set_global_approx>>

<<signature Compilenv.need_curry_fun>>
<<signature Compilenv.need_apply_fun>>

<<signature Compilenv.read_unit_info>>
<<signature Compilenv.save_unit_info>>

<<signature Compilenv.cmx_not_found_crc>>

<<type Compilenv.error>>

<<exception Compilenv.Error>>

<<signature Compilenv.report_error>>
@


\subsection*{[[asmcomp/compilenv.ml]]}

<<type Compilenv.error (asmcomp/compilenv.ml)>>=
type error =
    Not_a_unit_info of string
  | Corrupted_unit_info of string
  | Illegal_renaming of string * string
@

<<exception Compilenv.Error (asmcomp/compilenv.ml)>>=
exception Error of error
@

<<type Compilenv.unit_infos (asmcomp/compilenv.ml)>>=
(* Each .o file has a matching .cmx file that provides the following infos
   on the compilation unit:
     - list of other units imported, with CRCs of their .cmx files
     - approximation of the structure implemented
       (includes descriptions of known functions: arity and direct entry
        points)
     - list of currying functions and application functions needed
   The .cmx file contains these infos (as an externed record) plus a CRC
   of these infos *)

type unit_infos =
  { mutable ui_name: string;                    (* Name of unit implemented *)
    mutable ui_imports_cmi: (string * Digest.t) list; (* Interfaces imported *)
    mutable ui_imports_cmx: (string * Digest.t) list; (* Infos imported *)
    mutable ui_approx: value_approximation;     (* Approx of the structure *)
    mutable ui_curry_fun: int list;             (* Currying functions needed *)
    mutable ui_apply_fun: int list;             (* Apply functions needed *)
    mutable ui_force_link: bool }               (* Always linked *)
@

<<constant Compilenv.global_approx_table>>=
let global_approx_table =
@

<<constant Compilenv.current_unit>>=
let current_unit =
  { ui_name = "";
    ui_imports_cmi = [];
    ui_imports_cmx = [];
    ui_approx = Value_unknown;
    ui_curry_fun = [];
    ui_apply_fun = [];
    ui_force_link = false }
@

<<function Compilenv.reset>>=
let reset name =
  Hashtbl.clear global_approx_table;
  current_unit.ui_name <- name;
  current_unit.ui_imports_cmi <- [];
  current_unit.ui_imports_cmx <- [];
  current_unit.ui_curry_fun <- [];
  current_unit.ui_apply_fun <- [];
  current_unit.ui_force_link <- false
@

<<function Compilenv.current_unit_name>>=
let current_unit_name () =
  current_unit.ui_name
@

<<function Compilenv.read_unit_info>>=
let read_unit_info filename =
  let ic = open_in_bin filename in
  try
    let buffer = String.create (String.length cmx_magic_number) in
    really_input ic buffer 0 (String.length cmx_magic_number);
    if buffer <> cmx_magic_number then begin
      close_in ic;
      raise(Error(Not_a_unit_info filename))
    end;
    let ui = (input_value ic : unit_infos) in
    let crc = Digest.input ic in
    close_in ic;
    (ui, crc)
  with End_of_file | Failure _ ->
    close_in ic;
    raise(Error(Corrupted_unit_info(filename)))
@

<<constant Compilenv.cmx_not_found_crc>>=
(* Return the approximation of a global identifier *)

let cmx_not_found_crc =
  "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
@

<<function Compilenv.global_approx>>=
let global_approx global_ident =
  let modname = Ident.name global_ident in
  try
    Hashtbl.find global_approx_table modname
  with Not_found ->
    let (approx, crc) =
      try
        let filename =
          find_in_path !load_path (String.uncapitalize modname ^ ".cmx") in
        let (ui, crc) = read_unit_info filename in
        if ui.ui_name <> modname then
          raise(Error(Illegal_renaming(modname, filename)));
        (ui.ui_approx, crc)
      with Not_found ->
        (Value_unknown, cmx_not_found_crc) in
    current_unit.ui_imports_cmx <-
      (modname, crc) :: current_unit.ui_imports_cmx;
    Hashtbl.add global_approx_table modname approx;
    approx
@

<<function Compilenv.set_global_approx>>=
(* Register the approximation of the module being compiled *)

let set_global_approx approx =
  current_unit.ui_approx <- approx
@

<<function Compilenv.need_curry_fun>>=
(* Record that a currying function or application function is needed *)

let need_curry_fun n =
  if not (List.mem n current_unit.ui_curry_fun) then
    current_unit.ui_curry_fun <- n :: current_unit.ui_curry_fun
@

<<function Compilenv.need_apply_fun>>=
let need_apply_fun n =
  if not (List.mem n current_unit.ui_apply_fun) then
    current_unit.ui_apply_fun <- n :: current_unit.ui_apply_fun
@

<<function Compilenv.save_unit_info>>=
(* Write the description of the current unit *)

let save_unit_info filename =
  current_unit.ui_imports_cmi <- Env.imported_units();
  let oc = open_out_bin filename in
  output_string oc cmx_magic_number;
  output_value oc current_unit;
  flush oc;
  let crc = Digest.file filename in
  Digest.output oc crc;
  close_out oc
@

<<function Compilenv.report_error>>=
let report_error = function
    Not_a_unit_info filename ->
      print_string filename; print_space();
      print_string "is not a compilation unit description."
  | Corrupted_unit_info filename ->
      print_string "Corrupted compilation unit description"; print_space();
      print_string filename
  | Illegal_renaming(modname, filename) ->
      print_string filename; print_space();
      print_string "contains the description for unit"; print_space();
      print_string modname
@


%-------------------------------------------------------------

<<asmcomp/compilenv.ml>>=
<<copyright header>>

(* Compilation environments for compilation units *)

open Config
open Misc
open Clambda

<<type Compilenv.error (asmcomp/compilenv.ml)>>

<<exception Compilenv.Error (asmcomp/compilenv.ml)>>

<<type Compilenv.unit_infos (asmcomp/compilenv.ml)>>

<<constant Compilenv.global_approx_table>>
  (Hashtbl.create 17 : (string, value_approximation) Hashtbl.t)

<<constant Compilenv.current_unit>>

<<function Compilenv.reset>>

<<function Compilenv.current_unit_name>>

<<function Compilenv.read_unit_info>>

<<constant Compilenv.cmx_not_found_crc>>

<<function Compilenv.global_approx>>

<<function Compilenv.set_global_approx>>

<<function Compilenv.need_curry_fun>>

<<function Compilenv.need_apply_fun>>

<<function Compilenv.save_unit_info>>

(* Error report *)

open Format

<<function Compilenv.report_error>>

@


\subsection*{[[asmcomp/reg.mli]]}

<<type Reg.t>>=
type t =
  { mutable name: string;               (* Name (for printing) *)
    stamp: int;                         (* Unique stamp *)
    typ: Cmm.machtype_component;        (* Type of contents *)
    mutable loc: location;              (* Actual location *)
    mutable spill: bool;                (* "true" to force stack allocation  *)
    mutable interf: t list;             (* Other regs live simultaneously *)
    mutable prefer: (t * int) list;     (* Preferences for other regs *)
    mutable degree: int;                (* Number of other regs live sim. *)
    mutable spill_cost: int;            (* Estimate of spilling cost *)
    mutable visited: bool }             (* For graph walks *)
@

<<type Reg.location>>=
and location =
    Unknown
  | Reg of int
  | Stack of stack_location
@

<<type Reg.stack_location>>=
and stack_location =
    Local of int
  | Incoming of int
  | Outgoing of int
@

<<signature Reg.dummy>>=
val dummy: t
@

<<signature Reg.create>>=
val create: Cmm.machtype_component -> t
@

<<signature Reg.createv>>=
val createv: Cmm.machtype -> t array
@

<<signature Reg.clone>>=
val clone: t -> t
@

<<signature Reg.at_location>>=
val at_location: Cmm.machtype_component -> location -> t
@

<<signature Reg.add_set_array>>=
val add_set_array: t Set.t -> t array -> t Set.t
@

<<signature Reg.diff_set_array>>=
val diff_set_array: t Set.t -> t array -> t Set.t
@

<<signature Reg.inter_set_array>>=
val inter_set_array: t Set.t -> t array -> t Set.t
@

<<signature Reg.set_of_array>>=
val set_of_array: t array -> t Set.t
@

<<signature Reg.reset>>=
val reset: unit -> unit
@

<<signature Reg.all_registers>>=
val all_registers: unit -> t list
@

<<signature Reg.num_registers>>=
val num_registers: unit -> int
@

<<signature Reg.reinit>>=
val reinit: unit -> unit
@


%-------------------------------------------------------------

<<asmcomp/reg.mli>>=
<<copyright header>>

(* Pseudo-registers *)

<<type Reg.t>>

<<type Reg.location>>

<<type Reg.stack_location>>

<<signature Reg.dummy>>
<<signature Reg.create>>
<<signature Reg.createv>>
<<signature Reg.clone>>
<<signature Reg.at_location>>

<<signature Reg.add_set_array>>
<<signature Reg.diff_set_array>>
<<signature Reg.inter_set_array>>
<<signature Reg.set_of_array>>

<<signature Reg.reset>>
<<signature Reg.all_registers>>
<<signature Reg.num_registers>>
<<signature Reg.reinit>>
@


\subsection*{[[asmcomp/reg.ml]]}

<<type Reg.t (asmcomp/reg.ml)>>=
type t =
  { mutable name: string;
    stamp: int;
    typ: Cmm.machtype_component;
    mutable loc: location;
    mutable spill: bool;
    mutable interf: t list;
    mutable prefer: (t * int) list;
    mutable degree: int;
    mutable spill_cost: int;
    mutable visited: bool }
@

<<type Reg.location (asmcomp/reg.ml)>>=
and location =
    Unknown
  | Reg of int
  | Stack of stack_location
@

<<type Reg.stack_location (asmcomp/reg.ml)>>=
and stack_location =
    Local of int
  | Incoming of int
  | Outgoing of int
@

<<type Reg.reg>>=
type reg = t
@

<<constant Reg.dummy>>=
let dummy =
  { name = ""; stamp = 0; typ = Int; loc = Unknown; spill = false;
    interf = []; prefer = []; degree = 0; spill_cost = 0; visited = false }
@

<<constant Reg.currstamp>>=
let currstamp = ref 0
@

<<constant Reg.reg_list>>=
let reg_list = ref([] : t list)
@

<<function Reg.create>>=
let create ty =
  let r = { name = ""; stamp = !currstamp; typ = ty; loc = Unknown;
            spill = false; interf = []; prefer = []; degree = 0;
            spill_cost = 0; visited = false } in
  reg_list := r :: !reg_list;
  incr currstamp;
  r
@

<<function Reg.createv>>=
let createv tyv =
  let n = Array.length tyv in
  let rv = Array.create n dummy in
  for i = 0 to n-1 do rv.(i) <- create tyv.(i) done;
  rv
@

<<function Reg.clone>>=
let clone r =
  let nr = create r.typ in
  nr.name <- r.name;
  nr
@

<<function Reg.at_location>>=
let at_location ty loc =
  let r = { name = "R"; stamp = !currstamp; typ = ty; loc = loc; spill = false;
            interf = []; prefer = []; degree = 0; spill_cost = 0;
            visited = false } in
  incr currstamp;
  r
@

<<function Reg.reset>>=
let reset() = currstamp := 100; reg_list := []
@

<<function Reg.all_registers>>=
let all_registers() = !reg_list
@

<<function Reg.num_registers>>=
let num_registers() = !currstamp
@

<<function Reg.reinit_reg>>=
let reinit_reg r =
  r.loc <- Unknown;
  r.interf <- [];
  r.prefer <- [];
  r.degree <- 0;
  (* Preserve the very high spill costs introduced by the reloading pass *)
  if r.spill_cost >= 100000
  then r.spill_cost <- 100000
  else r.spill_cost <- 0
@

<<function Reg.reinit>>=
let reinit() =
  List.iter reinit_reg !reg_list
@

<<function Reg.add_set_array>>=
(*
TODO good enough?
module RegOrder =
  struct
    type t = reg
    let compare r1 r2 = r1.stamp - r2.stamp
  end
module Set = Set.Make(RegOrder)
module Map = Map.Make(RegOrder)
*)


let add_set_array s v =
  match Array.length v with
    0 -> s
  | 1 -> Set.add v.(0) s
  | n -> let rec add_all i =
           if i >= n then s else Set.add v.(i) (add_all(i+1))
         in add_all 0
@

<<function Reg.diff_set_array>>=
let diff_set_array s v =
  match Array.length v with
    0 -> s
  | 1 -> Set.remove v.(0) s
  | n -> let rec remove_all i =
           if i >= n then s else Set.remove v.(i) (remove_all(i+1))
         in remove_all 0
@

<<function Reg.inter_set_array>>=
let inter_set_array s v =
  match Array.length v with
    0 -> Set.empty
  | 1 -> if Set.mem v.(0) s
         then Set.add v.(0) Set.empty
         else Set.empty
  | n -> let rec inter_all i =
           if i >= n then Set.empty
           else if Set.mem v.(i) s then Set.add v.(i) (inter_all(i+1))
           else inter_all(i+1)
         in inter_all 0
@

<<function Reg.set_of_array>>=
let set_of_array v =
  match Array.length v with
    0 -> Set.empty
  | 1 -> Set.add v.(0) Set.empty
  | n -> let rec add_all i =
           if i >= n then Set.empty else Set.add v.(i) (add_all(i+1))
         in add_all 0
@


%-------------------------------------------------------------

<<asmcomp/reg.ml>>=
<<copyright header>>

open Cmm

<<type Reg.t (asmcomp/reg.ml)>>

<<type Reg.location (asmcomp/reg.ml)>>

<<type Reg.stack_location (asmcomp/reg.ml)>>

<<type Reg.reg>>

<<constant Reg.dummy>>

<<constant Reg.currstamp>>
<<constant Reg.reg_list>>

<<function Reg.create>>

<<function Reg.createv>>

<<function Reg.clone>>

<<function Reg.at_location>>

<<function Reg.reset>>
<<function Reg.all_registers>>
<<function Reg.num_registers>>

<<function Reg.reinit_reg>>

<<function Reg.reinit>>

<<function Reg.add_set_array>>

<<function Reg.diff_set_array>>

<<function Reg.inter_set_array>>

<<function Reg.set_of_array>>
@


\subsection*{[[asmcomp/asmlibrarian.mli]]}

<<signature Asmlibrarian.create_archive>>=
(* Build libraries of .cmx files *)

val create_archive: string list -> string -> unit
@

<<type Asmlibrarian.error>>=
type error =
    File_not_found of string
  | Archiver_error of string
@

<<exception Asmlibrarian.Error>>=
exception Error of error
@

<<signature Asmlibrarian.report_error>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/asmlibrarian.mli>>=
<<copyright header>>

<<signature Asmlibrarian.create_archive>>

<<type Asmlibrarian.error>>

<<exception Asmlibrarian.Error>>

<<signature Asmlibrarian.report_error>>
@


\subsection*{[[asmcomp/asmlibrarian.ml]]}

<<type Asmlibrarian.error (asmcomp/asmlibrarian.ml)>>=
type error =
    File_not_found of string
  | Archiver_error of string
@

<<exception Asmlibrarian.Error (asmcomp/asmlibrarian.ml)>>=
exception Error of error
@

<<function Asmlibrarian.read_info>>=
let read_info name =
  let filename =
    try
      find_in_path !load_path name
    with Not_found ->
      raise(Error(File_not_found name)) in
  let (info, crc) = Compilenv.read_unit_info filename in
  info.ui_force_link <- !Clflags.link_everything;
  (* There is no need to keep the approximation in the .cmxa file,
     since the compiler will go looking directly for .cmx files.
     The linker, which is the only one that reads .cmxa files, does not
     need the approximation. *)
  info.ui_approx <- Clambda.Value_unknown;
  (Filename.chop_suffix filename ".cmx" ^ ext_obj, (info, crc))
@

<<function Asmlibrarian.create_archive>>=
let create_archive file_list lib_name =
  let archive_name = Filename.chop_suffix lib_name ".cmxa" ^ ext_lib in
  let outchan = open_out_bin lib_name in
  try
    output_string outchan cmxa_magic_number;
    let (objfile_list, descr_list) =
      List.split (List.map read_info file_list) in
    output_value outchan descr_list;
    if Ccomp.create_archive archive_name objfile_list <> 0
    then raise(Error(Archiver_error archive_name));
    close_out outchan
  with x ->
    close_out outchan;
    remove_file lib_name;
    remove_file archive_name;
    raise x
@

<<function Asmlibrarian.report_error>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Archiver_error name ->
      print_string "Error while creating the library ";
      print_string name
@


%-------------------------------------------------------------

<<asmcomp/asmlibrarian.ml>>=
<<copyright header>>

(* Build libraries of .cmx files *)

open Misc
open Config
open Compilenv

<<type Asmlibrarian.error (asmcomp/asmlibrarian.ml)>>

<<exception Asmlibrarian.Error (asmcomp/asmlibrarian.ml)>>

<<function Asmlibrarian.read_info>>

<<function Asmlibrarian.create_archive>>

open Format

<<function Asmlibrarian.report_error>>

@


\subsection*{[[asmcomp/closure.mli]]}

<<signature Closure.intro>>=
(* Introduction of closures, uncurrying, recognition of direct calls *)

val intro: int -> Lambda.lambda -> Clambda.ulambda
@


%-------------------------------------------------------------

<<asmcomp/closure.mli>>=
<<copyright header>>

<<signature Closure.intro>>

@


\subsection*{[[asmcomp/closure.ml]]}

<<function Closure.split_list>>=
(* Auxiliaries for compiling functions *)

let rec split_list n l =
  if n <= 0 then ([], l) else begin
    match l with
      [] -> fatal_error "Closure.split_list"
    | a::l -> let (l1, l2) = split_list (n-1) l in (a::l1, l2)
  end
@

<<function Closure.build_closure_env>>=
let rec build_closure_env env_param pos = function
    [] -> Tbl.empty
  | id :: rem ->
      Tbl.add id (Uprim(Pfield pos, [Uvar env_param])) 
              (build_closure_env env_param (pos+1) rem)
@

<<function Closure.occurs_var>>=
(* Check if a variable occurs in a [clambda] term. *)

let occurs_var var u =
  let rec occurs = function
      Uvar v -> v = var
    | Uconst cst -> false
    | Udirect_apply(lbl, args) -> List.exists occurs args
    | Ugeneric_apply(funct, args) -> occurs funct or List.exists occurs args
    | Uclosure(fundecls, clos) -> List.exists occurs clos
    | Uoffset(u, ofs) -> occurs u
    | Ulet(id, def, body) -> occurs def or occurs body
    | Uletrec(decls, body) ->
        List.exists (fun (id, u) -> occurs u) decls or occurs body
    | Uprim(p, args) -> List.exists occurs args
    | Uswitch(arg, s) ->
        occurs arg or occurs_array s.us_cases_consts
                   or occurs_array s.us_cases_blocks
    | Ustaticfail -> false
    | Ucatch(body, hdlr) -> occurs body or occurs hdlr
    | Utrywith(body, exn, hdlr) -> occurs body or occurs hdlr
    | Uifthenelse(cond, ifso, ifnot) ->
        occurs cond or occurs ifso or occurs ifnot
    | Usequence(u1, u2) -> occurs u1 or occurs u2
    | Uwhile(cond, body) -> occurs cond or occurs body
    | Ufor(id, lo, hi, dir, body) -> occurs lo or occurs hi or occurs body
    | Uassign(id, u) -> id = var or occurs u
  and occurs_array a =
    try
      for i = 0 to Array.length a - 1 do
        if occurs a.(i) then raise Exit
      done;
      false
    with Exit ->
      true
  in occurs u
@

<<function Closure.prim_size>>=
(* Determine whether the estimated size of a clambda term is below
   some threshold *)

let prim_size prim args =
  match prim with
    Pidentity -> 0
  | Pgetglobal id -> 1
  | Psetglobal id -> 1
  | Pmakeblock(tag, mut) -> 5 + List.length args
  | Pfield f -> 1
  | Psetfield(f, isptr) -> if isptr then 4 else 1
  | Pfloatfield f -> 1
  | Psetfloatfield f -> 1
  | Pccall p -> (if p.prim_alloc then 10 else 4) + List.length args
  | Praise -> 4
  | Pstringlength -> 5
  | Pstringrefs | Pstringsets -> 6
  | Pmakearray kind -> 5 + List.length args
  | Parraylength kind -> if kind = Pgenarray then 6 else 2
  | Parrayrefu kind -> if kind = Pgenarray then 12 else 2
  | Parraysetu kind -> if kind = Pgenarray then 16 else 4
  | Parrayrefs kind -> if kind = Pgenarray then 18 else 8
  | Parraysets kind -> if kind = Pgenarray then 22 else 10
  | Pbittest -> 3
  | _ -> 2 (* arithmetic and comparisons *)
@

<<function Closure.lambda_smaller>>=
let lambda_smaller lam threshold =
  let size = ref 0 in
  let rec lambda_size lam =
    if !size > threshold then raise Exit;
    match lam with
      Uvar v -> ()
    | Uconst(Const_base(Const_int _ | Const_char _ | Const_float _) |
             Const_pointer _) -> incr size
    | Uconst _ ->
        raise Exit (* avoid duplication of structured constants *)
    | Udirect_apply(fn, args) ->
        size := !size + 4; lambda_list_size args
    | Ugeneric_apply(fn, args) ->
        size := !size + 6; lambda_size fn; lambda_list_size args
    | Uclosure(defs, vars) ->
        raise Exit (* inlining would duplicate function definitions *)
    | Uoffset(lam, ofs) ->
        incr size; lambda_size lam
    | Ulet(id, lam, body) ->
        lambda_size lam; lambda_size body
    | Uletrec(bindings, body) ->
        raise Exit (* usually too large *)
    | Uprim(prim, args) ->
        size := !size + prim_size prim args;
        lambda_list_size args
    | Uswitch(lam, cases) ->
        if Array.length cases.us_cases_consts > 0 then size := !size + 5;
        if Array.length cases.us_cases_blocks > 0 then size := !size + 5;
        if cases.us_checked then size := !size + 2;
        lambda_size lam;
        lambda_array_size cases.us_cases_consts;
        lambda_array_size cases.us_cases_blocks
    | Ustaticfail -> ()
    | Ucatch(body, handler) ->
        incr size; lambda_size body; lambda_size handler
    | Utrywith(body, id, handler) ->
        size := !size + 8; lambda_size body; lambda_size handler
    | Uifthenelse(cond, ifso, ifnot) ->
        size := !size + 2;
        lambda_size cond; lambda_size ifso; lambda_size ifnot
    | Usequence(lam1, lam2) ->
        lambda_size lam1; lambda_size lam2
    | Uwhile(cond, body) ->
        size := !size + 2; lambda_size cond; lambda_size body
    | Ufor(id, low, high, dir, body) ->
        size := !size + 4; lambda_size low; lambda_size high; lambda_size body
    | Uassign(id, lam) ->
        incr size;  lambda_size lam
  and lambda_list_size l = List.iter lambda_size l
  and lambda_array_size a = Array.iter lambda_size a in
  try
    lambda_size lam; !size <= threshold
  with Exit ->
    false
@

<<function Closure.is_pure>>=
(* Check if a lambda term denoting a function is ``pure'',
   that is without side-effects *and* not containing function definitions *)

let rec is_pure = function
    Lvar v -> true
  | Lprim(Pgetglobal id, _) -> true
  | Lprim(Pfield n, [arg]) -> is_pure arg
  | _ -> false
@

<<function Closure.direct_apply>>=
(* Generate a direct application *)

let direct_apply fundesc funct ufunct uargs =
  let app_args =
    if fundesc.fun_closed then uargs else uargs @ [ufunct] in
  let app =
    match fundesc.fun_inline with
      None -> Udirect_apply(fundesc.fun_label, app_args)
    | Some(params, body) ->
        List.fold_right2
          (fun param arg body -> Ulet(param, arg, body))
          params app_args body in
  (if is_pure funct then app else Usequence(ufunct, app))
@

<<constant Closure.global_approx>>=
(* Maintain the approximation of the global structure being defined *)

let global_approx = ref([||] : value_approximation array)
@

<<function Closure.close_var>>=
(* Uncurry an expression and explicitate closures.
   Also return the approximation of the expression.
   The approximation environment [fenv] maps idents to approximations.
   Idents not bound in [fenv] approximate to [Value_unknown].
   The closure environment [cenv] maps idents to [ulambda] terms.
   It is used to substitute environment accesses for free identifiers. *)

let close_var cenv id =
  try Tbl.find id cenv with Not_found -> Uvar id
@

<<function Closure.approx_var>>=
let approx_var fenv id =
  try Tbl.find id fenv with Not_found -> Value_unknown 
@

<<function Closure.intro>>=
(* The entry point *)

let intro size lam =
  global_approx := Array.create size Value_unknown;
  let (ulam, approx) = close Tbl.empty Tbl.empty lam in
  Compilenv.set_global_approx(Value_tuple !global_approx);
  global_approx := [||];
  ulam
@


%-------------------------------------------------------------

<<asmcomp/closure.ml>>=
<<copyright header>>

(* Introduction of closures, uncurrying, recognition of direct calls *)

open Misc
open Asttypes
open Primitive
open Lambda
open Clambda

module IdentSet = Set

<<function Closure.split_list>>

<<function Closure.build_closure_env>>

<<function Closure.occurs_var>>

<<function Closure.prim_size>>

<<function Closure.lambda_smaller>>

<<function Closure.is_pure>>

<<function Closure.direct_apply>>

<<constant Closure.global_approx>>

<<function Closure.close_var>>

<<function Closure.approx_var>>

<<function Closure.close>>

<<function Closure.intro>>
@




\subsection*{[[asmcomp/mach.mli]]}

<<type Mach.integer_comparison>>=
(* Representation of machine code by sequences of pseudoinstructions *)

type integer_comparison =
    Isigned of Cmm.comparison
  | Iunsigned of Cmm.comparison
@

<<type Mach.integer_operation>>=
type integer_operation =
    Iadd | Isub | Imul | Idiv | Imod
  | Iand | Ior | Ixor | Ilsl | Ilsr | Iasr
  | Icomp of integer_comparison
  | Icheckbound
@

<<type Mach.test>>=
type test =
    Itruetest
  | Ifalsetest
  | Iinttest of integer_comparison
  | Iinttest_imm of integer_comparison * int
  | Ifloattest of Cmm.comparison * bool
  | Ioddtest
  | Ieventest
@

<<type Mach.operation>>=
type operation =
    Imove
  | Ispill
  | Ireload
  | Iconst_int of Nativeint.t
  | Iconst_float of string
  | Iconst_symbol of string
  | Icall_ind
  | Icall_imm of string
  | Itailcall_ind
  | Itailcall_imm of string
  | Iextcall of string * bool
  | Istackoffset of int
  | Iload of Cmm.memory_chunk * Arch.addressing_mode
  | Istore of Cmm.memory_chunk * Arch.addressing_mode
  | Ialloc of int
  | Iintop of integer_operation
  | Iintop_imm of integer_operation * int
  | Inegf | Iabsf | Iaddf | Isubf | Imulf | Idivf
  | Ifloatofint | Iintoffloat
  | Ispecific of Arch.specific_operation
@

<<type Mach.instruction>>=
type instruction =
  { desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    mutable live: Reg.t Set.t }
@

<<type Mach.instruction_desc>>=
and instruction_desc =
    Iend
  | Iop of operation
  | Ireturn
  | Iifthenelse of test * instruction * instruction
  | Iswitch of int array * instruction array
  | Iloop of instruction
  | Icatch of instruction * instruction
  | Iexit
  | Itrywith of instruction * instruction
  | Iraise
@

<<type Mach.fundecl>>=
type fundecl =
  { fun_name: string;
    fun_args: Reg.t array;
    fun_body: instruction;
    fun_fast: bool }
@

<<signature Mach.dummy_instr>>=
val dummy_instr: instruction
@

<<signature Mach.end_instr>>=
val end_instr: unit -> instruction
@

<<signature Mach.instr_cons>>=
val instr_cons: 
      instruction_desc -> Reg.t array -> Reg.t array -> instruction ->
        instruction
@

<<signature Mach.instr_cons_live>>=
val instr_cons_live: 
      instruction_desc -> Reg.t array -> Reg.t array -> Reg.t Set.t ->
        instruction -> instruction
@

<<signature Mach.instr_iter>>=
val instr_iter: (instruction -> unit) -> instruction -> unit
@


%-------------------------------------------------------------

<<asmcomp/mach.mli>>=
<<copyright header>>

<<type Mach.integer_comparison>>

<<type Mach.integer_operation>>

<<type Mach.test>>

<<type Mach.operation>>

<<type Mach.instruction>>

<<type Mach.instruction_desc>>

<<type Mach.fundecl>>

<<signature Mach.dummy_instr>>
<<signature Mach.end_instr>>
<<signature Mach.instr_cons>>
<<signature Mach.instr_cons_live>>
<<signature Mach.instr_iter>>

@


\subsection*{[[asmcomp/mach.ml]]}

<<type Mach.integer_comparison (asmcomp/mach.ml)>>=
(* Representation of machine code by sequences of pseudoinstructions *)

type integer_comparison =
    Isigned of Cmm.comparison
  | Iunsigned of Cmm.comparison
@

<<type Mach.integer_operation (asmcomp/mach.ml)>>=
type integer_operation =
    Iadd | Isub | Imul | Idiv | Imod
  | Iand | Ior | Ixor | Ilsl | Ilsr | Iasr
  | Icomp of integer_comparison
  | Icheckbound
@

<<type Mach.test (asmcomp/mach.ml)>>=
type test =
    Itruetest
  | Ifalsetest
  | Iinttest of integer_comparison
  | Iinttest_imm of integer_comparison * int
  | Ifloattest of Cmm.comparison * bool
  | Ioddtest
  | Ieventest
@

<<type Mach.operation (asmcomp/mach.ml)>>=
type operation =
    Imove
  | Ispill
  | Ireload
  | Iconst_int of Nativeint.t
  | Iconst_float of string
  | Iconst_symbol of string
  | Icall_ind
  | Icall_imm of string
  | Itailcall_ind
  | Itailcall_imm of string
  | Iextcall of string * bool
  | Istackoffset of int
  | Iload of Cmm.memory_chunk * Arch.addressing_mode
  | Istore of Cmm.memory_chunk * Arch.addressing_mode
  | Ialloc of int
  | Iintop of integer_operation
  | Iintop_imm of integer_operation * int
  | Inegf | Iabsf | Iaddf | Isubf | Imulf | Idivf
  | Ifloatofint | Iintoffloat
  | Ispecific of Arch.specific_operation
@

<<type Mach.instruction (asmcomp/mach.ml)>>=
type instruction =
  { desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    mutable live: Reg.t Set.t }
@

<<type Mach.instruction_desc (asmcomp/mach.ml)>>=
and instruction_desc =
    Iend
  | Iop of operation
  | Ireturn
  | Iifthenelse of test * instruction * instruction
  | Iswitch of int array * instruction array
  | Iloop of instruction
  | Icatch of instruction * instruction
  | Iexit
  | Itrywith of instruction * instruction
  | Iraise
@

<<type Mach.fundecl (asmcomp/mach.ml)>>=
type fundecl =
  { fun_name: string;
    fun_args: Reg.t array;
    fun_body: instruction;
    fun_fast: bool }
@

<<constant Mach.dummy_instr>>=
let rec dummy_instr =
  { desc = Iend; 
    next = dummy_instr;
    arg = [||]; 
    res = [||];
    live = (*Reg.*)Set.empty }
@

<<function Mach.end_instr>>=
let end_instr () =
  { desc = Iend; 
    next = dummy_instr;
    arg = [||]; 
    res = [||];
    live = (*Reg.*)Set.empty }
@

<<function Mach.instr_cons>>=
let instr_cons d a r n =
  { desc = d; next = n; arg = a; res = r; live = (*Reg.*)Set.empty }
@

<<function Mach.instr_cons_live>>=
let instr_cons_live d a r l n =
  { desc = d; next = n; arg = a; res = r; live = l }
@

<<function Mach.instr_iter>>=
let rec instr_iter f i =
  match i.desc with
    Iend -> ()
  | _ ->
      f i;
      match i.desc with
        Iend -> ()
      | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) -> ()
      | Iifthenelse(tst, ifso, ifnot) ->
          instr_iter f ifso; instr_iter f ifnot; instr_iter f i.next
      | Iswitch(index, cases) ->
          for i = 0 to Array.length cases - 1 do
            instr_iter f cases.(i)
          done;
          instr_iter f i.next
      | Iloop(body) ->
          instr_iter f body; instr_iter f i.next
      | Icatch(body, handler) ->
          instr_iter f body; instr_iter f handler; instr_iter f i.next
      | Iexit -> ()
      | Itrywith(body, handler) ->
          instr_iter f body; instr_iter f handler; instr_iter f i.next
      | Iraise -> ()
      | _ ->
          instr_iter f i.next      
@


%-------------------------------------------------------------

<<asmcomp/mach.ml>>=
<<copyright header>>

<<type Mach.integer_comparison (asmcomp/mach.ml)>>

<<type Mach.integer_operation (asmcomp/mach.ml)>>

<<type Mach.test (asmcomp/mach.ml)>>

<<type Mach.operation (asmcomp/mach.ml)>>

<<type Mach.instruction (asmcomp/mach.ml)>>

<<type Mach.instruction_desc (asmcomp/mach.ml)>>

<<type Mach.fundecl (asmcomp/mach.ml)>>

<<constant Mach.dummy_instr>>

<<function Mach.end_instr>>

<<function Mach.instr_cons>>

<<function Mach.instr_cons_live>>

<<function Mach.instr_iter>>

@


\subsection*{[[asmcomp/printmach.mli]]}

<<signature Printmach.reg>>=
(* Pretty-printing of pseudo machine code *)

val reg: Reg.t -> unit
@

<<signature Printmach.regs>>=
val regs: Reg.t array -> unit
@

<<signature Printmach.regset>>=
val regset: Reg.t Set.t -> unit
@

<<signature Printmach.regsetaddr>>=
val regsetaddr: Reg.t Set.t -> unit
@

<<signature Printmach.operation>>=
val operation: Mach.operation -> Reg.t array -> Reg.t array -> unit
@

<<signature Printmach.test>>=
val test: Mach.test -> Reg.t array -> unit
@

<<signature Printmach.instr>>=
val instr: Mach.instruction -> unit
@

<<signature Printmach.fundecl>>=
val fundecl: Mach.fundecl -> unit
@

<<signature Printmach.phase>>=
val phase: string -> Mach.fundecl -> unit
@

<<signature Printmach.interferences>>=
val interferences: unit -> unit
@

<<signature Printmach.preferences>>=
val preferences: unit -> unit
@

<<signature Printmach.print_live>>=
val print_live: bool ref
@


%-------------------------------------------------------------

<<asmcomp/printmach.mli>>=
<<copyright header>>

<<signature Printmach.reg>>
<<signature Printmach.regs>>
<<signature Printmach.regset>>
<<signature Printmach.regsetaddr>>
<<signature Printmach.operation>>
<<signature Printmach.test>>
<<signature Printmach.instr>>
<<signature Printmach.fundecl>>
<<signature Printmach.phase>>
<<signature Printmach.interferences>>
<<signature Printmach.preferences>>

<<signature Printmach.print_live>>
@


\subsection*{[[asmcomp/printmach.ml]]}

<<function Printmach.reg>>=
let reg r =
  if String.length r.name > 0 then
    print_string r.name
  else
    print_string(match r.typ with Addr -> "A" | Int -> "I" | Float -> "F");
  print_string "/";
  print_int r.stamp;
  begin match r.loc with
    Unknown -> ()
  | Reg r -> 
      print_string "["; print_string(Proc.register_name r); print_string "]"
  | Stack(Local s) ->
      print_string "[s"; print_int s; print_string "]"
  | Stack(Incoming s) ->
      print_string "[si"; print_int s; print_string "]"
  | Stack(Outgoing s) ->
      print_string "[so"; print_int s; print_string "]"
  end
@

<<function Printmach.regs>>=
let regs v =
  match Array.length v with
    0 -> ()
  | 1 -> reg v.(0)
  | n -> reg v.(0);
         for i = 1 to n-1 do print_string " "; reg v.(i) done
@

<<function Printmach.regset>>=
let regset s =
  let first = ref true in
  (*Reg.*)Set.iter
    (fun r ->
      if !first then first := false else print_space();
      reg r)
    s
@

<<function Printmach.regsetaddr>>=
let regsetaddr s =
  let first = ref true in
  (*Reg.*)Set.iter
    (fun r ->
      if !first then first := false else print_space();
      reg r;
      match r.typ with Addr -> print_string "*" | _ -> ())
    s
@

<<function Printmach.intcomp>>=
let intcomp = function
    Isigned c -> print_string " "; Printcmm.comparison c; print_string "s "
  | Iunsigned c -> print_string " "; Printcmm.comparison c; print_string "u "
@

<<function Printmach.floatcomp>>=
let floatcomp c =
    print_string " "; Printcmm.comparison c; print_string "f "
@

<<function Printmach.intop>>=
let intop = function
    Iadd -> print_string " + "
  | Isub -> print_string " - "
  | Imul -> print_string " * "
  | Idiv -> print_string " div "
  | Imod -> print_string " mod "
  | Iand -> print_string " & "
  | Ior -> print_string " | "
  | Ixor -> print_string " ^ "
  | Ilsl -> print_string " << "
  | Ilsr -> print_string " >>u "
  | Iasr -> print_string " >>s "
  | Icomp cmp -> intcomp cmp
  | Icheckbound -> print_string " check > "
@

<<function Printmach.test>>=
let test tst arg =
  match tst with
    Itruetest -> reg arg.(0)
  | Ifalsetest -> print_string "not "; reg arg.(0)
  | Iinttest cmp -> reg arg.(0); intcomp cmp; reg arg.(1)
  | Iinttest_imm(cmp, n) -> reg arg.(0); intcomp cmp; print_int n
  | Ifloattest(cmp, neg) ->
      if neg then print_string "not ";
      reg arg.(0); floatcomp cmp; reg arg.(1)
  | Ieventest -> reg arg.(0); print_string " & 1 == 0"
  | Ioddtest -> reg arg.(0); print_string " & 1 == 1"
@

<<constant Printmach.print_live>>=
let print_live = ref false
@

<<function Printmach.operation>>=
let operation op arg res =
  if Array.length res > 0 then begin regs res; print_string " := " end;
  match op with
    Imove -> regs arg
  | Ispill -> regs arg; print_string " (spill)"
  | Ireload -> regs arg; print_string " (reload)"
  | Iconst_int n -> print_string(Nativeint.to_string n)
  | Iconst_float s -> print_string s
  | Iconst_symbol s -> print_string "\""; print_string s; print_string "\""
  | Icall_ind -> print_string "call "; regs arg
  | Icall_imm lbl ->
      print_string "call \""; print_string lbl;
      print_string "\" "; regs arg
  | Itailcall_ind -> print_string "tailcall "; regs arg
  | Itailcall_imm lbl ->
      print_string "tailcall \""; print_string lbl;
      print_string "\" "; regs arg
  | Iextcall(lbl, alloc) ->
      print_string "extcall \""; print_string lbl;
      print_string "\" "; regs arg;
      if not alloc then print_string " (noalloc)"
  | Istackoffset n ->
      print_string "offset stack "; print_int n
  | Iload(chunk, addr) ->
      Printcmm.chunk chunk;
      print_string "[";
      Arch.print_addressing reg addr arg;
      print_string "]"
  | Istore(chunk, addr) ->
      Printcmm.chunk chunk;
      print_string "[";
      Arch.print_addressing reg addr (Array.sub arg 1 (Array.length arg - 1));
      print_string "] := ";
      reg arg.(0)
  | Ialloc n -> print_string "alloc "; print_int n
  | Iintop(op) -> reg arg.(0); intop op; reg arg.(1)
  | Iintop_imm(op, n) -> reg arg.(0); intop op; print_int n
  | Inegf -> print_string "-f "; reg arg.(0)
  | Iabsf -> print_string "absf "; reg arg.(0)
  | Iaddf -> reg arg.(0); print_string " +f "; reg arg.(1)
  | Isubf -> reg arg.(0); print_string " -f "; reg arg.(1)
  | Imulf -> reg arg.(0); print_string " *f "; reg arg.(1)
  | Idivf -> reg arg.(0); print_string " /f "; reg arg.(1)
  | Ifloatofint -> print_string "floatofint "; reg arg.(0)
  | Iintoffloat -> print_string "intoffloat "; reg arg.(0)
  | Ispecific op ->
      Arch.print_specific_operation reg op arg
@

<<function Printmach.instr>>=
let rec instr i =
  if !print_live then begin
    open_box 1;
    print_string "{";
    regsetaddr i.live;
    if Array.length i.arg > 0 then begin
      print_space(); print_string "+"; print_space(); regs i.arg
    end;
    print_string "}";
    close_box();
    print_cut()
  end;
  begin match i.desc with
    Iend -> ()
  | Iop op ->
      operation op i.arg i.res
  | Ireturn ->
      print_string "return "; regs i.arg
  | Iifthenelse(tst, ifso, ifnot) ->
      open_vbox 2;
      print_string "if "; test tst i.arg; print_string " then"; print_cut();
      instr ifso;
      begin match ifnot.desc with
        Iend -> ()
      | _ -> print_break 0 (-2); print_string "else"; print_cut(); instr ifnot
      end;
      print_break 0 (-2); print_string "endif";
      close_box()
  | Iswitch(index, cases) ->
      print_string "switch "; reg i.arg.(0);
      for i = 0 to Array.length cases - 1 do
        print_cut();
        open_vbox 2;
        open_box 0;
        for j = 0 to Array.length index - 1 do
          if index.(j) = i then begin
            print_string "case "; print_int j; print_string ":";
            print_cut()
          end
        done;
        close_box(); print_cut();
        instr cases.(i);
        close_box()
      done;
      print_cut(); print_string "endswitch"
  | Iloop(body) ->
      open_vbox 2;
      print_string "loop"; print_cut();
      instr body; print_break 0 (-2); 
      print_string "endloop ";
      close_box()
  | Icatch(body, handler) ->
      open_vbox 2;
      print_string "catch"; print_cut();
      instr body;
      print_break 0 (-2);  print_string "with"; print_cut();
      instr handler;
      print_break 0 (-2); print_string "endcatch";
      close_box()
  | Iexit ->
      print_string "exit"
  | Itrywith(body, handler) ->
      open_vbox 2;
      print_string "try"; print_cut();
      instr body;
      print_break 0 (-2);  print_string "with"; print_cut();
      instr handler;
      print_break 0 (-2); print_string "endtry";
      close_box()
  | Iraise ->
      print_string "raise "; reg i.arg.(0)
  end;
  begin match i.next.desc with
    Iend -> ()
  | _ -> print_cut(); instr i.next
  end
@

<<function Printmach.fundecl>>=
let fundecl f =
  open_vbox 2;
  print_string f.fun_name;
  print_string "("; regs f.fun_args; print_string ")";
  print_cut();
  instr f.fun_body;
  close_box()
@

<<function Printmach.phase>>=
let phase msg f =
  print_string "*** "; print_string msg; print_newline(); 
  fundecl f; print_newline()
@

<<function Printmach.interference>>=
let interference r =
  open_box 2;
  reg r; print_string ":";
  List.iter
    (fun r -> print_space(); reg r)
    r.interf;
  close_box();
  print_newline()
@

<<function Printmach.interferences>>=
let interferences () =
  print_string "*** Interferences"; print_newline();
  List.iter interference (Reg.all_registers())
@

<<function Printmach.preference>>=
let preference r =
  open_box 2;
  reg r; print_string ": ";
  List.iter
    (fun (r, w) -> print_space(); reg r; print_string " weight " ; print_int w)
    r.prefer;
  close_box();
  print_newline()
@

<<function Printmach.preferences>>=
let preferences () =
  print_string "*** Preferences"; print_newline();
  List.iter preference (Reg.all_registers())
@


%-------------------------------------------------------------

<<asmcomp/printmach.ml>>=
<<copyright header>>

(* Pretty-printing of pseudo machine code *)

open Format
open Cmm
open Reg
open Mach

<<function Printmach.reg>>

<<function Printmach.regs>>

<<function Printmach.regset>>

<<function Printmach.regsetaddr>>

<<function Printmach.intcomp>>

<<function Printmach.floatcomp>>

<<function Printmach.intop>>
    
<<function Printmach.test>>

<<constant Printmach.print_live>>

<<function Printmach.operation>>

<<function Printmach.instr>>

<<function Printmach.fundecl>>

<<function Printmach.phase>>

<<function Printmach.interference>>

<<function Printmach.interferences>>

<<function Printmach.preference>>

<<function Printmach.preferences>>
@


\subsection*{[[asmcomp/split.mli]]}

<<signature Split.fundecl>>=
(* Renaming of registers at reload points to split live ranges. *)

val fundecl: Mach.fundecl -> Mach.fundecl
@


%-------------------------------------------------------------

<<asmcomp/split.mli>>=
<<copyright header>>

<<signature Split.fundecl>>
@


\subsection*{[[asmcomp/split.ml]]}

<<type Split.subst>>=
(* Substitutions are represented by register maps *)

type subst = (Reg.t, Reg.t) Map.t
@

<<function Split.subst_reg>>=
let subst_reg r sub =
  try
    (*Reg.*)Map.find r sub
  with Not_found ->
    r
@

<<function Split.subst_regs>>=
let subst_regs rv sub =
  match sub with
    None -> rv
  | Some s ->
      let n = Array.length rv in
      let nv = Array.create n Reg.dummy in
      for i = 0 to n-1 do nv.(i) <- subst_reg rv.(i) s done;
      nv
@

<<constant Split.equiv_classes>>=
(* We maintain equivalence classes of registers using a standard
   union-find algorithm *)

let equiv_classes = ref ((*Reg.*)Map.empty : (Reg.t, Reg.t) Map.t)
@

<<function Split.repres_reg>>=
let rec repres_reg r =
  try
    repres_reg((*Reg.*)Map.find r !equiv_classes)
  with Not_found ->
    r
@

<<function Split.repres_regs>>=
let repres_regs rv =
  let n = Array.length rv in
  for i = 0 to n-1 do rv.(i) <- repres_reg rv.(i) done
@

<<function Split.identify>>=
(* Identify two registers.
   The second register is chosen as canonical representative. *)

let identify r1 r2 =
  let repres1 = repres_reg r1 in
  let repres2 = repres_reg r2 in
  if repres1.stamp = repres2.stamp then () else begin
    equiv_classes := (*Reg.*)Map.add repres1 repres2 !equiv_classes
  end
@

<<function Split.identify_sub>>=
(* Identify the image of a register by two substitutions.
   Be careful to use the original register as canonical representative
   in case it does not belong to the domain of one of the substitutions. *)

let identify_sub sub1 sub2 reg =
  try
    let r1 = (*Reg.*)Map.find reg sub1 in
    try
      let r2 = (*Reg.*)Map.find reg sub2 in
      identify r1 r2
    with Not_found ->
      identify r1 reg
  with Not_found ->
    try
      let r2 = (*Reg.*)Map.find reg sub2 in
      identify r2 reg
    with Not_found ->
      ()
@

<<function Split.merge_substs>>=
(* Identify registers so that the two substitutions agree on the
   registers live before the given instruction. *)

let merge_substs sub1 sub2 i =
  match (sub1, sub2) with
    (None, None) -> None
  | (Some s1, None) -> sub1
  | (None, Some s2) -> sub2
  | (Some s1, Some s2) ->
      (*Reg.*)Set.iter (identify_sub s1 s2) (Reg.add_set_array i.live i.arg);
      sub1
@

<<function Split.merge_subst_array>>=
(* Same, for N substitutions *)

let merge_subst_array subv instr =
  let rec find_one_subst i =
    if i >= Array.length subv then None else begin
      match subv.(i) with
        None -> find_one_subst (i+1)
      | Some si as sub ->
          for j = i+1 to Array.length subv - 1 do
            match subv.(j) with
              None -> ()
            | Some sj ->
                (*Reg.*)Set.iter (identify_sub si sj)
                             (Reg.add_set_array instr.live instr.arg)
          done;
          sub
    end in
  find_one_subst 0
@

<<constant Split.exit_subst>>=
(* First pass: rename registers at reload points *)

let exit_subst = ref (None: subst option)
@

<<function Split.rename>>=
let rec rename i sub =
  match i.desc with
    Iend ->
      (i, sub)
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (instr_cons i.desc (subst_regs i.arg sub) [||] i.next,
       None)
  | Iop Ireload when i.res.(0).loc = Unknown ->
      begin match sub with
        None -> rename i.next sub
      | Some s ->
          let oldr = i.res.(0) in
          let newr = Reg.clone i.res.(0) in
          let (new_next, sub_next) =
            rename i.next (Some((*Reg.*)Map.add oldr newr s)) in
          (instr_cons i.desc i.arg [|newr|] new_next,
           sub_next)
      end
  | Iop _ ->
      let (new_next, sub_next) = rename i.next sub in
      (instr_cons i.desc (subst_regs i.arg sub) (subst_regs i.res sub)
                         new_next,
       sub_next)
  | Iifthenelse(tst, ifso, ifnot) ->
      let (new_ifso, sub_ifso) = rename ifso sub in
      let (new_ifnot, sub_ifnot) = rename ifnot sub in
      let (new_next, sub_next) =
        rename i.next (merge_substs sub_ifso sub_ifnot i.next) in
      (instr_cons (Iifthenelse(tst, new_ifso, new_ifnot))
                  (subst_regs i.arg sub) [||] new_next,
       sub_next)
  | Iswitch(index, cases) ->
      let new_sub_cases = Array.map (fun c -> rename c sub) cases in
      let sub_merge =
        merge_subst_array (Array.map (fun (n, s) -> s) new_sub_cases) i.next in
      let (new_next, sub_next) = rename i.next sub_merge in
      (instr_cons (Iswitch(index, Array.map (fun (n, s) -> n) new_sub_cases))
                  (subst_regs i.arg sub) [||] new_next,
       sub_next)
  | Iloop(body) ->
      let (new_body, sub_body) = rename body sub in
      let (new_next, sub_next) = rename i.next (merge_substs sub sub_body i) in
      (instr_cons (Iloop(new_body)) [||] [||] new_next,
       sub_next)
  | Icatch(body, handler) ->
      let saved_exit_subst = !exit_subst in
      exit_subst := None;
      let (new_body, sub_body) = rename body sub in
      let sub_entry_handler = !exit_subst in
      exit_subst := saved_exit_subst;
      let (new_handler, sub_handler) = rename handler sub_entry_handler in
      let (new_next, sub_next) =
        rename i.next (merge_substs sub_body sub_handler i.next) in
      (instr_cons (Icatch(new_body, new_handler)) [||] [||] new_next,
       sub_next)
  | Iexit ->
      exit_subst := merge_substs !exit_subst sub i;
      (i, None)
  | Itrywith(body, handler) ->
      let (new_body, sub_body) = rename body sub in
      let (new_handler, sub_handler) = rename handler sub in
      let (new_next, sub_next) =
        rename i.next (merge_substs sub_body sub_handler i.next) in
      (instr_cons (Itrywith(new_body, new_handler)) [||] [||] new_next,
       sub_next)
  | Iraise ->
      (instr_cons Iraise (subst_regs i.arg sub) [||] i.next,
       None)
@

<<function Split.set_repres>>=
(* Second pass: replace registers by their final representatives *)

let set_repres i =
  instr_iter (fun i -> repres_regs i.arg; repres_regs i.res) i
@

<<function Split.fundecl>>=
(* Entry point *)

let fundecl f =
  equiv_classes := (*Reg.*)Map.empty;
  let new_args = Array.copy f.fun_args in
  let (new_body, sub_body) = rename f.fun_body (Some (*Reg.*)Map.empty) in
  repres_regs new_args;
  set_repres new_body;
  equiv_classes := (*Reg.*)Map.empty;
  { fun_name = f.fun_name;
    fun_args = new_args;
    fun_body = new_body;
    fun_fast = f.fun_fast }
@


%-------------------------------------------------------------

<<asmcomp/split.ml>>=
<<copyright header>>

(* Renaming of registers at reload points to split live ranges. *)

open Reg
open Mach

<<type Split.subst>>

<<function Split.subst_reg>>

<<function Split.subst_regs>>

<<constant Split.equiv_classes>>

<<function Split.repres_reg>>

<<function Split.repres_regs>>

<<function Split.identify>>

<<function Split.identify_sub>>

<<function Split.merge_substs>>

<<function Split.merge_subst_array>>

<<constant Split.exit_subst>>

<<function Split.rename>>
      
<<function Split.set_repres>>

<<function Split.fundecl>>
@


\subsection*{[[asmcomp/proc.mli]]}

<<signature Proc.word_addressed>>=
(* Instruction selection *)
val word_addressed: bool
@

<<signature Proc.num_register_classes>>=
(* Registers available for register allocation *)
val num_register_classes: int
@

<<signature Proc.register_class>>=
val register_class: Reg.t -> int
@

<<signature Proc.num_available_registers>>=
val num_available_registers: int array
@

<<signature Proc.first_available_register>>=
val first_available_register: int array
@

<<signature Proc.register_name>>=
val register_name: int -> string
@

<<signature Proc.phys_reg>>=
val phys_reg: int -> Reg.t
@

<<signature Proc.rotate_registers>>=
val rotate_registers: bool
@

<<signature Proc.loc_arguments>>=
(* Calling conventions *)
val loc_arguments: Reg.t array -> Reg.t array * int
@

<<signature Proc.loc_results>>=
val loc_results: Reg.t array -> Reg.t array
@

<<signature Proc.loc_parameters>>=
val loc_parameters: Reg.t array -> Reg.t array
@

<<signature Proc.loc_external_arguments>>=
val loc_external_arguments: Reg.t array -> Reg.t array * int
@

<<signature Proc.loc_external_results>>=
val loc_external_results: Reg.t array -> Reg.t array
@

<<signature Proc.loc_exn_bucket>>=
val loc_exn_bucket: Reg.t
@

<<signature Proc.safe_register_pressure>>=
(* Maximal register pressures for pre-spilling *)
val safe_register_pressure: Mach.operation -> int
@

<<signature Proc.max_register_pressure>>=
val max_register_pressure: Mach.operation -> int array
@

<<signature Proc.destroyed_at_oper>>=
(* Registers destroyed by operations *)
val destroyed_at_oper: Mach.instruction_desc -> Reg.t array
@

<<signature Proc.destroyed_at_raise>>=
val destroyed_at_raise: Reg.t array
@

<<signature Proc.num_stack_slots>>=
(* Info for laying out the stack frame *)
val num_stack_slots: int array
@

<<signature Proc.contains_calls>>=
val contains_calls: bool ref
@

<<signature Proc.assemble_file>>=
(* Calling the assembler *)
val assemble_file: string -> string -> int
@


%-------------------------------------------------------------

<<asmcomp/proc.mli>>=
<<copyright header>>

(* Processor descriptions *)

<<signature Proc.word_addressed>>

<<signature Proc.num_register_classes>>
<<signature Proc.register_class>>
<<signature Proc.num_available_registers>>
<<signature Proc.first_available_register>>
<<signature Proc.register_name>>
<<signature Proc.phys_reg>>
<<signature Proc.rotate_registers>>

<<signature Proc.loc_arguments>>
<<signature Proc.loc_results>>
<<signature Proc.loc_parameters>>
<<signature Proc.loc_external_arguments>>
<<signature Proc.loc_external_results>>
<<signature Proc.loc_exn_bucket>>

<<signature Proc.safe_register_pressure>>
<<signature Proc.max_register_pressure>>

<<signature Proc.destroyed_at_oper>>
<<signature Proc.destroyed_at_raise>>

<<signature Proc.num_stack_slots>>
<<signature Proc.contains_calls>>

<<signature Proc.assemble_file>>
@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/proc.ml]]}

<<constant Proc.word_addressed>>=
(* Instruction selection *)

let word_addressed = false
@

<<constant Proc.int_reg_name>>=
(* Register map:
    r0 - r7                     general purpose (r4 - r7 preserved by C)
    r8                          allocation pointer (preserved by C)
    r9                          allocation limit (preserved by C)
    r10                         general purpose
    r11                         trap pointer (preserved by C)
    r12                         general purpose
    r13                         stack pointer
    r14                         return address
    r15                         program counter

    f0 - f7                     general purpose (f4 - f7 preserved by C)
*)

let int_reg_name = [|
@

<<constant Proc.float_reg_name>>=
let float_reg_name = [|
@

<<constant Proc.num_register_classes>>=
let num_register_classes = 2
@

<<function Proc.register_class>>=
let register_class r =
  match r.typ with
    Int -> 0
  | Addr -> 0
  | Float -> 1
@

<<constant Proc.num_available_registers>>=
let num_available_registers = [| 10; 8 |]
@

<<constant Proc.first_available_register>>=
let first_available_register = [| 0; 100 |]
@

<<function Proc.register_name>>=
let register_name r =
  if r < 100 then int_reg_name.(r) else float_reg_name.(r - 100)
@

<<constant Proc.rotate_registers>>=
let rotate_registers = true
@

<<constant Proc.hard_int_reg>>=
(* Representation of hard registers by pseudo-registers *)

let hard_int_reg =
  let v = Array.create 10 Reg.dummy in
  for i = 0 to 9 do v.(i) <- Reg.at_location Int (Reg i) done;
  v
@

<<constant Proc.hard_float_reg>>=
let hard_float_reg =
  let v = Array.create 8 Reg.dummy in
  for i = 0 to 7 do v.(i) <- Reg.at_location Float (Reg(100 + i)) done;
  v
@

<<constant Proc.all_phys_regs>>=
let all_phys_regs =
  Array.append hard_int_reg hard_float_reg
@

<<function Proc.phys_reg>>=
let phys_reg n =
  if n < 100 then hard_int_reg.(n) else hard_float_reg.(n - 100)
@

<<function Proc.stack_slot>>=
let stack_slot slot ty =
  Reg.at_location ty (Stack slot)
@

<<function Proc.calling_conventions>>=
(* Calling conventions *)

let calling_conventions first_int last_int first_float last_float
                        make_stack arg =
  let loc = Array.create (Array.length arg) Reg.dummy in
  let int = ref first_int in
  let float = ref first_float in
  let ofs = ref 0 in
  for i = 0 to Array.length arg - 1 do
    match arg.(i).typ with
      Int | Addr as ty ->
        if !int <= last_int then begin
          loc.(i) <- phys_reg !int;
          incr int
        end else begin
          loc.(i) <- stack_slot (make_stack !ofs) ty;
          ofs := !ofs + size_int
        end
    | Float ->
        if !float <= last_float then begin
          loc.(i) <- phys_reg !float;
          incr float
        end else begin
          loc.(i) <- stack_slot (make_stack !ofs) Float;
          ofs := !ofs + size_float
        end
  done;
  (loc, !ofs)
@

<<function Proc.incoming>>=
let incoming ofs = Incoming ofs
@

<<function Proc.outgoing>>=
let outgoing ofs = Outgoing ofs
@

<<function Proc.not_supported>>=
let not_supported ofs = fatal_error "Proc.loc_results: cannot call"
@

<<function Proc.loc_arguments>>=
let loc_arguments arg =
  calling_conventions 0 7 100 103 outgoing arg
@

<<function Proc.loc_parameters>>=
let loc_parameters arg =
  let (loc, ofs) = calling_conventions 0 7 100 103 incoming arg in loc
@

<<function Proc.loc_results>>=
let loc_results res =
  let (loc, ofs) = calling_conventions 0 7 100 103 not_supported res in loc
@

<<function Proc.loc_external_arguments>>=
(* Calling conventions for C are as for Caml, except that float arguments
   are passed in pairs of integer registers. *)

let loc_external_arguments arg =
  let loc = Array.create (Array.length arg) Reg.dummy in
  let reg = ref 0 in
  let ofs = ref 0 in
  for i = 0 to Array.length arg - 1 do
    match arg.(i).typ with
      Int | Addr as ty ->
        if !reg <= 3 then begin
          loc.(i) <- phys_reg !reg;
          incr reg
        end else begin
          loc.(i) <- stack_slot (outgoing !ofs) ty;
          ofs := !ofs + size_int
        end
    | Float ->
        if !reg <= 2 then begin
          loc.(i) <- phys_reg !reg;
          reg := !reg + 2
        end else begin
          loc.(i) <- stack_slot (outgoing !ofs) Float;
          ofs := !ofs + size_float
        end
  done;
  (loc, !ofs)
@

<<function Proc.loc_external_results>>=
let loc_external_results res =
  let (loc, ofs) = calling_conventions 0 0 100 100 not_supported res in loc
@

<<constant Proc.loc_exn_bucket>>=
let loc_exn_bucket = phys_reg 0
@

<<constant Proc.destroyed_at_c_call>>=
(* Registers destroyed by operations *)

let destroyed_at_c_call =               (* r4-r9, f4-f7 preserved *)
  Array.of_list(List.map phys_reg [0;1;2;3;8;9; 100;101;102;103])
@

<<function Proc.destroyed_at_oper>>=
let destroyed_at_oper = function
    Iop(Icall_ind | Icall_imm _ | Iextcall(_, true)) -> all_phys_regs
  | Iop(Iextcall(_, false)) -> destroyed_at_c_call
  | Iop(Ialloc(_)) -> [|phys_reg 8|]	(* r10 destroyed *)
  | _ -> [||]
@

<<constant Proc.destroyed_at_raise>>=
let destroyed_at_raise = all_phys_regs
@

<<function Proc.safe_register_pressure>>=
(* Maximal register pressure *)

let safe_register_pressure = function
    Iextcall(_, _) -> 4
  | _ -> 8
@

<<function Proc.max_register_pressure>>=
let max_register_pressure = function
    Iextcall(_, _) -> [| 4; 4 |]
  | _ -> [| 10; 8 |]
@

<<constant Proc.num_stack_slots>>=
(* Layout of the stack *)

let num_stack_slots = [| 0; 0 |]
@

<<constant Proc.contains_calls>>=
let contains_calls = ref false
@

<<function Proc.assemble_file>>=
(* Calling the assembler *)

let assemble_file infile outfile =
  Sys.command ("as -o " ^ outfile ^ " " ^ infile)
@


%-------------------------------------------------------------

<<asmcomp/arm/proc.ml>>=
<<copyright header 1998>>

(* Description of the ARM processor *)

open Misc
open Cmm
open Reg
open Arch
open Mach

<<constant Proc.word_addressed>>

(* Registers available for register allocation *)

<<constant Proc.int_reg_name>>
  "r0"; "r1"; "r2"; "r3"; "r4"; "r5"; "r6"; "r7"; "r10"; "r12"
|]
  
<<constant Proc.float_reg_name>>
  "f0"; "f1"; "f2"; "f3"; "f4"; "f5"; "f6"; "f7"
|]

<<constant Proc.num_register_classes>>

<<function Proc.register_class>>

<<constant Proc.num_available_registers>>

<<constant Proc.first_available_register>>

<<function Proc.register_name>>

<<constant Proc.rotate_registers>>

<<constant Proc.hard_int_reg>>

<<constant Proc.hard_float_reg>>

<<constant Proc.all_phys_regs>>

<<function Proc.phys_reg>>

<<function Proc.stack_slot>>

<<function Proc.calling_conventions>>

<<function Proc.incoming>>
<<function Proc.outgoing>>
<<function Proc.not_supported>>

<<function Proc.loc_arguments>>
<<function Proc.loc_parameters>>
<<function Proc.loc_results>>

<<function Proc.loc_external_arguments>>

<<function Proc.loc_external_results>>

<<constant Proc.loc_exn_bucket>>

<<constant Proc.destroyed_at_c_call>>

<<function Proc.destroyed_at_oper>>

<<constant Proc.destroyed_at_raise>>

<<function Proc.safe_register_pressure>>
<<function Proc.max_register_pressure>>

<<constant Proc.num_stack_slots>>
<<constant Proc.contains_calls>>

<<function Proc.assemble_file>>

@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/reloadgen.mli]]}

<<type Reloadgen.reloader>>=

type reloader = {
 reload_operation :
    reloader ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array * Reg.t array;
 reload_test: 
    reloader ->
    Mach.test -> Reg.t array -> Reg.t array;
    (* Can be overriden to reflect instructions that can operate
       directly on stack locations *)
 makereg : Reg.t -> Reg.t;
    (* Can be overriden to avoid creating new registers of some class
       (i.e. if all "registers" of that class are actually on stack) *)
 fundecl : 
   reloader ->
   Mach.fundecl -> Mach.fundecl * bool;
    (* The entry point *)

 (* old: protected *)

 makeregs : reloader -> Reg.t array -> Reg.t array;
 makereg1 : reloader -> Reg.t array -> Reg.t array;
 
 reload:  
   reloader -> Mach.instruction -> Mach.instruction;
 
}
@

<<signature Reloadgen.reload_generic>>=
val reload_generic: unit -> reloader
@


%-------------------------------------------------------------

<<asmcomp/reloadgen.mli>>=
<<copyright header 1997>>

<<type Reloadgen.reloader>>

<<signature Reloadgen.reload_generic>>

(*
 reload_operation = super.eload_operation;
 reload_test: = super.eload_test:; makereg : Reg.t -> Reg.t;
 fundecl = super.undecl;
 makeregs = super.akeregs;
 makereg1 = super.akereg1;
 reload: = super.eload:;
*)
@


\subsection*{[[asmcomp/reloadgen.ml]]}

<<function Reloadgen.insert_move>>=
let insert_move src dst next =
  if src.loc = dst.loc
  then next
  else instr_cons (Iop Imove) [|src|] [|dst|] next
@

<<function Reloadgen.insert_moves>>=
let insert_moves src dst next =
  let rec insmoves i =
    if i >= Array.length src
    then next
    else insert_move src.(i) dst.(i) (insmoves (i+1))
  in insmoves 0
@

<<type Reloadgen.reloader (asmcomp/reloadgen.ml)>>=
type reloader = {
 reload_operation :
    reloader ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array * Reg.t array;
 reload_test: 
    reloader ->
    Mach.test -> Reg.t array -> Reg.t array;
    (* Can be overriden to reflect instructions that can operate
       directly on stack locations *)
 makereg : Reg.t -> Reg.t;
    (* Can be overriden to avoid creating new registers of some class
       (i.e. if all "registers" of that class are actually on stack) *)
 fundecl : 
   reloader ->
   Mach.fundecl -> Mach.fundecl * bool;
    (* The entry point *)

 (* old: protected *)

 makeregs : reloader -> Reg.t array -> Reg.t array;
 makereg1 : reloader -> Reg.t array -> Reg.t array;
 
 reload:  
   reloader -> Mach.instruction -> Mach.instruction;
 
}
@

<<function Reloadgen.reload_generic>>=
let reload_generic () =
  let redo_regalloc = ref false in
  {
  makereg = (fun r ->
  match r.loc with
    Unknown -> fatal_error "Reload.makereg"
  | Reg _ -> r
  | Stack _ ->
      redo_regalloc := true;
      let newr = Reg.clone r in
      (* Strongly discourage spilling this register *)
      newr.spill_cost <- 100000;
      newr
  );

  makeregs = (fun self rv ->
  let n = Array.length rv in
  let newv = Array.create n Reg.dummy in
  for i = 0 to n-1 do newv.(i) <- self.makereg rv.(i) done;
  newv
  );

  makereg1 = (fun self rv ->
  let newv = Array.copy rv in
  newv.(0) <- self.makereg rv.(0);
  newv
  );

 reload_operation = (fun self op arg res ->
  (* By default, assume that arguments and results must reside
     in hardware registers. For moves, allow one arg or one
     res to be stack-allocated, but do something for
     stack-to-stack moves *)
  match op with
    Imove | Ireload | Ispill ->
      begin match arg.(0), res.(0) with
        {loc = Stack s1}, {loc = Stack s2} when s1 <> s2 ->
          ([| self.makereg arg.(0) |], res)
      | _ ->
          (arg, res)
      end
  | _ ->
      (self.makeregs self arg, self.makeregs self res)
 );

 reload_test = (fun self tst args ->
  self.makeregs self args
 );

 reload = (fun self i ->
  match i.desc with
    (* For function calls, returns, etc: the arguments and results are
       already at the correct position (e.g. on stack for some arguments).
       However, something needs to be done for the function pointer in
       indirect calls. *)
    Iend | Ireturn | Iop(Itailcall_imm _) | Iraise -> i
  | Iop(Itailcall_ind) ->
      let newarg = self.makereg1 self i.arg in
      insert_moves i.arg newarg
        (instr_cons_live i.desc newarg i.res i.live i.next)
  | Iop(Icall_imm _ | Iextcall(_, _)) ->
      instr_cons_live i.desc i.arg i.res i.live (self.reload self i.next)
  | Iop(Icall_ind) ->
      let newarg = self.makereg1 self i.arg in
      insert_moves i.arg newarg
        (instr_cons_live i.desc newarg i.res i.live (self.reload self i.next))
  | Iop op ->
      let (newarg, newres) = self.reload_operation self op i.arg i.res in
      insert_moves i.arg newarg
        (instr_cons_live i.desc newarg newres i.live
          (insert_moves newres i.res
            (self.reload self i.next)))
  | Iifthenelse(tst, ifso, ifnot) ->
      let newarg = self.reload_test self tst i.arg in
      insert_moves i.arg newarg      
        (instr_cons
          (Iifthenelse(tst, self.reload self ifso, self.reload self ifnot)) newarg [||]
          (self.reload self i.next))
  | Iswitch(index, cases) ->
      let newarg = self.makeregs self i.arg in
      insert_moves i.arg newarg      
        (instr_cons (Iswitch(index, Array.map (self.reload self) cases)) newarg [||]
          (self.reload self i.next))
  | Iloop body ->
      instr_cons (Iloop(self.reload self body)) [||] [||] (self.reload self i.next)
  | Icatch(body, handler) ->
      instr_cons (Icatch(self.reload self body, self.reload self handler)) [||] [||]
        (self.reload self i.next)
  | Iexit ->
      instr_cons Iexit [||] [||] dummy_instr
  | Itrywith(body, handler) ->
      instr_cons (Itrywith(self.reload self body, self.reload self handler)) [||] [||]
        (self.reload self i.next)
 );

 fundecl = (fun self f ->
  redo_regalloc := false;
  let new_body = self.reload self f.fun_body in
  ({fun_name = f.fun_name; fun_args = f.fun_args;
    fun_body = new_body; fun_fast = f.fun_fast},
   !redo_regalloc)
 );
 }
@


%-------------------------------------------------------------

<<asmcomp/reloadgen.ml>>=
<<copyright header>>

(* Insert load/stores for pseudoregs that got assigned to stack locations. *)

open Misc
open Reg
open Mach

<<function Reloadgen.insert_move>>

<<function Reloadgen.insert_moves>>



<<type Reloadgen.reloader (asmcomp/reloadgen.ml)>>


<<function Reloadgen.reload_generic>>
@


\subsection*{[[asmcomp/interf.mli]]}

<<signature Interf.build_graph>>=
(* Construction of the interference graph.
   Annotate pseudoregs with interference lists and preference lists. *)

val build_graph: Mach.fundecl -> unit
@


%-------------------------------------------------------------

<<asmcomp/interf.mli>>=
<<copyright header>>

<<signature Interf.build_graph>>
@


\subsection*{[[asmcomp/reload.mli]]}

<<signature Reload.fundecl>>=
(* Insert load/stores for pseudoregs that got assigned to stack locations. *)

val fundecl: Mach.fundecl -> Mach.fundecl * bool
@


%-------------------------------------------------------------

<<asmcomp/reload.mli>>=
<<copyright header>>

<<signature Reload.fundecl>>

@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/reload.ml]]}

<<function Reload.fundecl>>=
(* Reloading for the ARM *)

let fundecl f =
  let reloader = Reloadgen.reload_generic () in
  reloader.fundecl reloader f
@


%-------------------------------------------------------------

<<asmcomp/arm/reload.ml>>=
<<copyright header 1998>>

open Reloadgen

<<function Reload.fundecl>>
@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/interf.ml]]}

<<function Interf.build_graph>>=
let build_graph fundecl =

  (* The interference graph is represented in two ways:
     - by adjacency lists for each register
     - by a triangular bit matrix *)

  let num_regs = Reg.num_registers() in
  let mat =
    String.make (((num_regs * (num_regs + 1)) lsr 1 + 7) lsr 3) '\000' in

  (* Record an interference between two registers *)
  let add_interf ri rj =
    let i = ri.stamp and j = rj.stamp in
    if i = j then () else begin
      let n = if i < j then ((j * (j + 1)) lsr 1) + i
                       else ((i * (i + 1)) lsr 1) + j in
      let b = Char.code(mat.[n lsr 3]) in
      let msk = 1 lsl (n land 7) in
      if b land msk = 0 then begin
        mat.[n lsr 3] <- Char.unsafe_chr(b lor msk);
        begin match ri.loc with
          Unknown -> ri.interf <- rj :: ri.interf | _ -> ()
        end;
        begin match rj.loc with
          Unknown -> rj.interf <- ri :: rj.interf | _ -> ()
        end
      end
    end in

  (* Record interferences between a register array and a set of registers *)
  let add_interf_set v s =
    for i = 0 to Array.length v - 1 do
      let r1 = v.(i) in
      (*Reg.*)Set.iter (add_interf r1) s
    done in

  (* Record interferences between elements of an array *)
  let add_interf_self v =
    for i = 0 to Array.length v - 2 do
      let ri = v.(i) in
      for j = i+1 to Array.length v - 1 do
        add_interf ri v.(j)
      done
    done in

  (* Record interferences between the destination of a move and a set
     of live registers. Since the destination is equal to the source,
     do not add an interference between them if the source is still live
     afterwards. *)
  let add_interf_move src dst s =
    (*Reg.*)Set.iter (fun r -> if r.stamp <> src.stamp then add_interf dst r) s in

  (* Compute interferences *)

  let rec interf i =
    let destroyed = Proc.destroyed_at_oper i.desc in
    if Array.length destroyed > 0 then add_interf_set destroyed i.live;
    match i.desc with
      Iend -> ()
    | Ireturn -> ()
    | Iop(Imove | Ispill | Ireload) ->
        add_interf_move i.arg.(0) i.res.(0) i.live;
        interf i.next
    | Iop(Itailcall_ind) -> ()
    | Iop(Itailcall_imm lbl) -> ()
    | Iop op ->
        add_interf_set i.res i.live;
        add_interf_self i.res;
        interf i.next
    | Iifthenelse(tst, ifso, ifnot) ->
        interf ifso;
        interf ifnot;
        interf i.next
    | Iswitch(index, cases) ->
        for i = 0 to Array.length cases - 1 do
          interf cases.(i)
        done;
        interf i.next
    | Iloop body ->
        interf body; interf i.next
    | Icatch(body, handler) ->
        interf body; interf handler; interf i.next
    | Iexit ->
        ()
    | Itrywith(body, handler) ->
        add_interf_set Proc.destroyed_at_raise handler.live;    
        interf body; interf handler; interf i.next
    | Iraise -> () in

  (* Add a preference from one reg to another.
     Do not add anything if the two registers conflict,
     or if the source register already has a location. *)

  let add_pref weight r1 r2 =
    if weight > 0 then begin
      let i = r1.stamp and j = r2.stamp in
      if i = j then () else begin
        match r1.loc with
          Unknown ->
            let n = if i < j then ((j * (j + 1)) lsr 1) + i
                             else ((i * (i + 1)) lsr 1) + j in
            let b = Char.code(mat.[n lsr 3]) in
            let msk = 1 lsl (n land 7) in
            if b land msk = 0 then r1.prefer <- (r2, weight) :: r1.prefer
        | _ -> ()
      end
    end in

  (* Add a mutual preference between two regs *)
  let add_mutual_pref weight r1 r2 =
    add_pref weight r1 r2; add_pref weight r2 r1 in

  (* Update the spill cost of the registers involved in an operation *)

  let add_spill_cost cost arg =
    for i = 0 to Array.length arg - 1 do
      let r = arg.(i) in r.spill_cost <- r.spill_cost + cost
    done in

  (* Compute preferences and spill costs *)

  let rec prefer weight i =
    add_spill_cost weight i.arg;
    add_spill_cost weight i.res;
    match i.desc with
      Iend -> ()
    | Ireturn -> ()
    | Iop(Imove) ->
        add_mutual_pref weight i.arg.(0) i.res.(0);
        prefer weight i.next
    | Iop(Ispill) ->
        add_pref (weight / 4) i.arg.(0) i.res.(0);
        prefer weight i.next
    | Iop(Ireload) ->
        add_pref (weight / 4) i.res.(0) i.arg.(0);
        prefer weight i.next
    | Iop(Itailcall_ind) -> ()
    | Iop(Itailcall_imm lbl) -> ()
    | Iop op ->
        prefer weight i.next
    | Iifthenelse(tst, ifso, ifnot) ->
        prefer (weight / 2) ifso;
        prefer (weight / 2) ifnot;
        prefer weight i.next
    | Iswitch(index, cases) ->
        for i = 0 to Array.length cases - 1 do
          prefer (weight / 2) cases.(i)
        done;
        prefer weight i.next
    | Iloop body ->
        (* Avoid overflow of weight and spill_cost *)
        prefer (if weight < 1000 then 8 * weight else weight) body;
        prefer weight i.next
    | Icatch(body, handler) ->
        prefer weight body; prefer weight handler; prefer weight i.next
    | Iexit ->
        ()
    | Itrywith(body, handler) ->
        prefer weight body; prefer weight handler; prefer weight i.next
    | Iraise -> ()
  in

  interf fundecl.fun_body; prefer 8 fundecl.fun_body
@


%-------------------------------------------------------------

<<asmcomp/interf.ml>>=
<<copyright header>>

(* Construction of the interference graph.
   Annotate pseudoregs with interference lists and preference lists. *)

open Reg
open Mach

<<function Interf.build_graph>>

@


\subsection*{[[asmcomp/coloring.mli]]}

<<signature Coloring.allocate_registers>>=
(* Register allocation by coloring of the interference graph *)

val allocate_registers: unit -> unit
@


%-------------------------------------------------------------

<<asmcomp/coloring.mli>>=
<<copyright header>>

<<signature Coloring.allocate_registers>>
@


\subsection*{[[asmcomp/coloring.ml]]}

<<function Coloring.allocate_spilled>>=
(* Preallocation of spilled registers in the stack. *)

let allocate_spilled reg =
  if reg.spill then begin
    let cl = Proc.register_class reg in
    let nslots = Proc.num_stack_slots.(cl) in
    let conflict = Array.create nslots false in
    List.iter
      (fun r ->
        match r.loc with
          Stack(Local n) ->
            if Proc.register_class r = cl then conflict.(n) <- true
        | _ -> ())
      reg.interf;
    let slot = ref 0 in
    while !slot < nslots & conflict.(!slot) do incr slot done;
    reg.loc <- Stack(Local !slot);
    if !slot >= nslots then Proc.num_stack_slots.(cl) <- !slot + 1
  end
@

<<constant Coloring.unconstrained>>=
(* Compute the degree (= number of neighbours of the same type)
   of each register, and split them in two sets:
   unconstrained (degree < number of available registers)
   and constrained (degree >= number of available registers).
   Spilled registers are ignored in the process. *)

let unconstrained = ref (*Reg.*)Set.empty
@

<<constant Coloring.constrained>>=
let constrained = ref (*Reg.*)Set.empty
@

<<function Coloring.find_degree>>=
let find_degree reg =
  if reg.spill then () else begin
    let cl = Proc.register_class reg in
    let avail_regs = Proc.num_available_registers.(cl) in
    if avail_regs = 0 then
      (* Don't bother computing the degree if there are no regs 
         in this class *)
      unconstrained := (*Reg.*)Set.add reg !unconstrained
    else begin
      let deg = ref 0 in
      List.iter
        (fun r -> if not r.spill & Proc.register_class r = cl then incr deg)
        reg.interf;
      reg.degree <- !deg;
      if !deg >= avail_regs
      then constrained := (*Reg.*)Set.add reg !constrained
      else unconstrained := (*Reg.*)Set.add reg !unconstrained
    end
  end
@

<<function Coloring.remove_all_regs>>=
(* Remove all registers one by one, unconstrained if possible, otherwise
   constrained with lowest spill cost. Return the list of registers removed
   in reverse order.
   The spill cost measure is [r.spill_cost / r.degree].
   [r.spill_cost] estimates the number of accesses to this register. *)

let rec remove_all_regs stack =
  if not ((*Reg.*)Set.is_empty !unconstrained) then begin
    (* Pick any unconstrained register *)
    let r = (*Reg.*)Set.choose !unconstrained in
    unconstrained := (*Reg.*)Set.remove r !unconstrained;
    remove_all_regs (r :: stack)
  end else
  if not ((*Reg.*)Set.is_empty !constrained) then begin
    (* Find a constrained reg with minimal cost *)
    let r = ref Reg.dummy in
    let min_degree = ref 0 and min_spill_cost = ref 1 in
      (* initially !min_spill_cost / !min_degree is +infty *)
    (*Reg.*)Set.iter
      (fun r2 ->
        (* if r2.spill_cost / r2.degree < !min_spill_cost / !min_degree *)
        if r2.spill_cost * !min_degree < !min_spill_cost * r2.degree
        then begin
          r := r2; min_degree := r2.degree; min_spill_cost := r2.spill_cost
        end)
      !constrained;
    constrained := (*Reg.*)Set.remove !r !constrained;
    remove_all_regs (!r :: stack)
  end else
    stack                             (* All regs have been removed *)
@

<<function Coloring.iter_preferred>>=
(* Iterate over all registers preferred by the given register (transitively) *)

let iter_preferred f reg =
  let rec walk r w =
    if not r.visited then begin
      f r w;
      begin match r.prefer with
          [] -> ()
        | p  -> r.visited <- true;
                List.iter (fun (r1, w1) -> walk r1 (min w w1)) p;
                r.visited <- false
      end
    end in
  reg.visited <- true;
  List.iter (fun (r, w) -> walk r w) reg.prefer;
  reg.visited <- false
@

<<constant Coloring.start_register>>=
(* Where to start the search for a suitable register. 
   Used to introduce some "randomness" in the choice between registers
   with equal scores. This offers more opportunities for scheduling. *)

let start_register = Array.create Proc.num_register_classes 0
@

<<function Coloring.assign_location>>=
(* Assign a location to a register, the best we can *)

let assign_location reg =
  let cl = Proc.register_class reg in
  let first_reg = Proc.first_available_register.(cl) in
  let num_regs = Proc.num_available_registers.(cl) in
  let last_reg = first_reg + num_regs in
  let score = Array.create num_regs 0 in
  let best_score = ref (-1000000) and best_reg = ref (-1) in
  let start = start_register.(cl) in
  if num_regs > 0 then begin
    (* Favor the registers that have been assigned to pseudoregs for which
       we have a preference. If these pseudoregs have not been assigned
       already, avoid the registers with which they conflict. *)
    iter_preferred
      (fun r w ->
        match r.loc with
          Reg n -> if n >= first_reg & n < last_reg then
                     score.(n - first_reg) <- score.(n - first_reg) + w
        | Unknown ->
            List.iter
              (fun neighbour ->
                match neighbour.loc with
                  Reg n -> if n >= first_reg & n < last_reg then
                           score.(n - first_reg) <- score.(n - first_reg) - w
                | _ -> ())
              r.interf
        | _ -> ())
      reg;
    List.iter
      (fun neighbour ->
        (* Prohibit the registers that have been assigned
           to our neighbours *)
        begin match neighbour.loc with
          Reg n -> if n >= first_reg & n < last_reg then
                     score.(n - first_reg) <- (-1000000)
        | _ -> ()
        end;
        (* Avoid the registers that have been assigned to pseudoregs
           for which our neighbours have a preference *)
        iter_preferred
          (fun r w ->
            match r.loc with
              Reg n -> if n >= first_reg & n < last_reg then
                         score.(n - first_reg) <- score.(n - first_reg) - (w - 1)
                       (* w-1 to break the symmetry when two conflicting regs
                          have the same preference for a third reg. *)
            | _ -> ())
          neighbour)
      reg.interf;
    (* Pick the register with the best score *)
    for n = start to num_regs - 1 do
      if score.(n) > !best_score then begin
        best_score := score.(n);
        best_reg := n
      end
    done;
    for n = 0 to start - 1 do
      if score.(n) > !best_score then begin
        best_score := score.(n);
        best_reg := n
      end
    done
  end;
  (* Found a register? *)
  if !best_reg >= 0 then begin
    reg.loc <- Reg(first_reg + !best_reg);
    if Proc.rotate_registers then
      start_register.(cl) <- (if start+1 >= num_regs then 0 else start+1)
  end else begin
    (* Sorry, we must put the pseudoreg in a stack location *)
    (* First, check if we have a preference for an incoming location
       we do not conflict with. *)
    let best_score = ref 0 and best_incoming_loc = ref (-1) in
    List.iter
      (fun (r, w) ->
        match r.loc with
          Stack(Incoming n) ->
            if w > !best_score
             & List.for_all (fun neighbour -> neighbour.loc <> r.loc)
                            reg.interf
            then begin
              best_score := w;
              best_incoming_loc := n
            end
        | _ -> ())
      reg.prefer;
    if !best_incoming_loc >= 0 then
      reg.loc <- Stack(Incoming !best_incoming_loc)
    else begin
      (* Now, look for a location in the local area *)
      let nslots = Proc.num_stack_slots.(cl) in
      let score = Array.create nslots 0 in
      (* Compute the scores as for registers *)
      List.iter
        (fun (r, w) ->
          match r.loc with
            Stack(Local n) -> if Proc.register_class r = cl then
                              score.(n) <- score.(n) + w
          | Unknown ->
              List.iter
                (fun neighbour ->
                  match neighbour.loc with
                    Stack(Local n) ->
                      if Proc.register_class neighbour = cl
                      then score.(n) <- score.(n) - w
                  | _ -> ())
                r.interf
          | _ -> ())
        reg.prefer;
      List.iter
        (fun neighbour ->
          begin match neighbour.loc with
              Stack(Local n) ->
                if Proc.register_class neighbour = cl then
                score.(n) <- (-1000000)
          | _ -> ()
          end;
          List.iter
            (fun (r, w) ->
              match r.loc with
                Stack(Local n) -> if Proc.register_class r = cl then
                                  score.(n) <- score.(n) - w
              | _ -> ())
            neighbour.prefer)
        reg.interf;
      (* Pick the location with the best score *)
      let best_score = ref (-1000000) and best_slot = ref (-1) in
      for n = 0 to nslots - 1 do
        if score.(n) > !best_score then begin
          best_score := score.(n);
          best_slot := n
        end
      done;
      (* Found one? *)
      if !best_slot >= 0 then
        reg.loc <- Stack(Local !best_slot)
      else begin
        (* Allocate a new stack slot *)
        reg.loc <- Stack(Local nslots);
        Proc.num_stack_slots.(cl) <- nslots + 1
      end
    end
  end;
  (* Cancel the preferences of this register so that they don't influence
     transitively the allocation of registers that prefer this reg. *)
  reg.prefer <- []
@

<<function Coloring.allocate_registers>>=
let allocate_registers() =
  (* First pass: preallocate spill registers
     Second pass: compute the degrees
     Third pass: determine coloring order by successive removals of regs
     Fourth pass: assign registers in that order *)
  for i = 0 to Proc.num_register_classes - 1 do
    Proc.num_stack_slots.(i) <- 0;
    start_register.(i) <- 0
  done;
  List.iter allocate_spilled (Reg.all_registers());
  List.iter find_degree (Reg.all_registers());
  List.iter assign_location (remove_all_regs [])
@


%-------------------------------------------------------------

<<asmcomp/coloring.ml>>=
<<copyright header>>

(* Register allocation by coloring of the interference graph *)

open Reg

<<function Coloring.allocate_spilled>>

<<constant Coloring.unconstrained>>
<<constant Coloring.constrained>>

<<function Coloring.find_degree>>

<<function Coloring.remove_all_regs>>

<<function Coloring.iter_preferred>>

<<constant Coloring.start_register>>

<<function Coloring.assign_location>>

<<function Coloring.allocate_registers>>
@


\subsection*{[[asmcomp/linearize.mli]]}

<<type Linearize.label>>=
(* Transformation of Mach code into a list of pseudo-instructions. *)

type label = int
@

<<signature Linearize.new_label>>=
val new_label: unit -> label
@

<<type Linearize.instruction>>=
type instruction =
  { mutable desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    live: Reg.t Set.t }
@

<<type Linearize.instruction_desc>>=
and instruction_desc =
    Lend
  | Lop of Mach.operation
  | Lreloadretaddr
  | Lreturn
  | Llabel of label
  | Lbranch of label
  | Lcondbranch of Mach.test * label
  | Lcondbranch3 of label option * label option * label option
  | Lswitch of label array
  | Lsetuptrap of label
  | Lpushtrap
  | Lpoptrap
  | Lraise
@

<<signature Linearize.end_instr>>=
val end_instr: instruction
@

<<signature Linearize.instr_cons>>=
val instr_cons: 
  instruction_desc -> Reg.t array -> Reg.t array -> instruction -> instruction
@

<<type Linearize.fundecl>>=
type fundecl =
  { fun_name: string;
    fun_body: instruction;
    fun_fast: bool }
@

<<signature Linearize.fundecl>>=
val fundecl: Mach.fundecl -> fundecl
@


%-------------------------------------------------------------

<<asmcomp/linearize.mli>>=
<<copyright header>>

<<type Linearize.label>>
<<signature Linearize.new_label>>

<<type Linearize.instruction>>

<<type Linearize.instruction_desc>>

<<signature Linearize.end_instr>>
<<signature Linearize.instr_cons>>

<<type Linearize.fundecl>>

<<signature Linearize.fundecl>>

@


\subsection*{[[asmcomp/linearize.ml]]}

<<type Linearize.label (asmcomp/linearize.ml)>>=
type label = int
@

<<constant Linearize.label_counter>>=
let label_counter = ref 99
@

<<function Linearize.new_label>>=
let new_label() = incr label_counter; !label_counter
@

<<type Linearize.instruction (asmcomp/linearize.ml)>>=
type instruction =
  { mutable desc: instruction_desc;
    next: instruction;
    arg: Reg.t array;
    res: Reg.t array;
    live: Reg.t Set.t }
@

<<type Linearize.instruction_desc (asmcomp/linearize.ml)>>=
and instruction_desc =
    Lend
  | Lop of operation
  | Lreloadretaddr
  | Lreturn
  | Llabel of label
  | Lbranch of label
  | Lcondbranch of test * label
  | Lcondbranch3 of label option * label option * label option
  | Lswitch of label array
  | Lsetuptrap of label
  | Lpushtrap
  | Lpoptrap
  | Lraise
@

<<type Linearize.fundecl (asmcomp/linearize.ml)>>=
type fundecl =
  { fun_name: string;
    fun_body: instruction;
    fun_fast: bool }
@

<<function Linearize.invert_integer_test>>=
(* Invert a test *)

let invert_integer_test = function
    Isigned cmp -> Isigned(Cmm.negate_comparison cmp)
  | Iunsigned cmp -> Iunsigned(Cmm.negate_comparison cmp)
@

<<function Linearize.invert_test>>=
let invert_test = function
    Itruetest -> Ifalsetest
  | Ifalsetest -> Itruetest
  | Iinttest(cmp) -> Iinttest(invert_integer_test cmp)
  | Iinttest_imm(cmp, n) -> Iinttest_imm(invert_integer_test cmp, n)
  | Ifloattest(cmp, neg) -> Ifloattest(cmp, not neg)
  | Ieventest -> Ioddtest
  | Ioddtest -> Ieventest
@

<<constant Linearize.end_instr>>=
(* The "end" instruction *)

let rec end_instr =
  { desc = Lend;
    next = end_instr;
    arg = [||];
    res = [||];
    live = (*Reg.*)Set.empty }
@

<<function Linearize.instr_cons>>=
(* Cons an instruction (live empty) *)

let instr_cons d a r n =
  { desc = d; next = n; arg = a; res = r; live = (*Reg.*)Set.empty }
@

<<function Linearize.cons_instr>>=
(* Cons a simple instruction (arg, res, live empty) *)

let cons_instr d n =
  { desc = d; next = n; arg = [||]; res = [||]; live = (*Reg.*)Set.empty }
@

<<function Linearize.copy_instr>>=
(* Build an instruction with arg, res, live taken from
   the given Mach.instruction *)

let copy_instr d i n =
  { desc = d; next = n;
    arg = i.Mach.arg; res = i.Mach.res; live = i.Mach.live }
@

<<function Linearize.get_label>>=
(* Label the beginning of the given instruction sequence.
   If the sequence starts with a branch, jump over it. *)

let get_label n =
  match n.desc with
    Lbranch lbl -> (lbl, n)
  | Llabel lbl -> (lbl, n)
  | _ -> let lbl = new_label() in (lbl, cons_instr (Llabel lbl) n)
@

<<function Linearize.discard_dead_code>>=
(* Discard all instructions up to the next label.
   This function is to be called before adding a non-terminating 
   instruction. *)

let rec discard_dead_code n =
  match n.desc with
    Lend -> n
  | Llabel _ -> n
(* Do not discard Lpoptrap or Istackoffset instructions,
   as this may cause a stack imbalance later during assembler generation. *)
  | Lpoptrap -> n
  | Lop(Istackoffset _) -> n
  | _ -> discard_dead_code n.next
@

<<function Linearize.add_branch>>=
(* Add a branch in front of a continuation.
   Discard dead code in the continuation.
   Does not insert anything if we're just falling through. *)

let add_branch lbl n =
  let n1 = discard_dead_code n in
  match n1.desc with
    Llabel lbl1 when lbl1 = lbl -> n1
  | _ -> cons_instr (Lbranch lbl) n1
@

<<constant Linearize.exit_label>>=
(* Current label for exit handler *)

let exit_label = ref 99
@

<<function Linearize.linear>>=
(* Linearize an instruction [i]: add it in front of the continuation [n] *)

let rec linear i n =
  match i.Mach.desc with
    Iend -> n
  | Iop(Itailcall_ind | Itailcall_imm _ as op) ->
      copy_instr (Lop op) i (discard_dead_code n)
  | Iop(Imove | Ireload | Ispill)
    when i.Mach.arg.(0).loc = i.Mach.res.(0).loc ->
      linear i.Mach.next n
  | Iop op ->
      copy_instr (Lop op) i (linear i.Mach.next n)
  | Ireturn ->
      let n1 = copy_instr Lreturn i (discard_dead_code n) in
      if !Proc.contains_calls
      then cons_instr Lreloadretaddr n1
      else n1
  | Iifthenelse(test, ifso, ifnot) ->
      let n1 = linear i.Mach.next n in
      begin match (ifso.Mach.desc, ifnot.Mach.desc) with
        Iexit, _ ->
          copy_instr (Lcondbranch(test, !exit_label)) i
            (linear ifnot n1)
      | _,  Iexit ->
          copy_instr (Lcondbranch(invert_test test, !exit_label)) i
            (linear ifso n1)
      | Iend, _ ->
          let (lbl_end, n2) = get_label n1 in
          copy_instr (Lcondbranch(test, lbl_end)) i
            (linear ifnot n2)
      | _,  Iend ->
          let (lbl_end, n2) = get_label n1 in
          copy_instr (Lcondbranch(invert_test test, lbl_end)) i
            (linear ifso n2)
      | _, _ ->
        (* Should attempt branch prediction here *)
          let (lbl_end, n2) = get_label n1 in
          let (lbl_else, nelse) = get_label (linear ifnot n2) in
          copy_instr (Lcondbranch(invert_test test, lbl_else)) i
            (linear ifso (add_branch lbl_end nelse))
      end
  | Iswitch(index, cases) ->
      let lbl_cases = Array.create (Array.length cases) 0 in
      let (lbl_end, n1) = get_label(linear i.Mach.next n) in
      let n2 = ref (discard_dead_code n1) in
      for i = Array.length cases - 1 downto 0 do
        let (lbl_case, ncase) =
                get_label(linear cases.(i) (add_branch lbl_end !n2)) in
        lbl_cases.(i) <- lbl_case;
        n2 := discard_dead_code ncase
      done;
      (* Switches with 1 and 2 branches have been eliminated earlier.
         Here, we do something for switches with 3 branches. *)
      if Array.length index = 3 then begin
        let fallthrough_lbl =
          match !n2.desc with Llabel lbl -> lbl | _ -> -1 in
        let find_label n =
          let lbl = lbl_cases.(index.(n)) in
          if lbl = fallthrough_lbl then None else Some lbl in
        copy_instr (Lcondbranch3(find_label 0, find_label 1, find_label 2))
                   i !n2
      end else
        copy_instr (Lswitch(Array.map (fun n -> lbl_cases.(n)) index)) i !n2
  | Iloop body ->
      let lbl_head = new_label() in
      let n1 = linear i.Mach.next n in
      let n2 = linear body (cons_instr (Lbranch lbl_head) n1) in
      cons_instr (Llabel lbl_head) n2
  | Icatch(body, handler) ->
      let (lbl_end, n1) = get_label(linear i.Mach.next n) in
      let (lbl_handler, n2) = get_label(linear handler n1) in
      let saved_exit_label = !exit_label in
      exit_label := lbl_handler;
      let n3 = linear body (add_branch lbl_end n2) in
      exit_label := saved_exit_label;
      n3
  | Iexit ->
      add_branch !exit_label (linear i.Mach.next n)
  | Itrywith(body, handler) ->
      let (lbl_join, n1) = get_label (linear i.Mach.next n) in
      let (lbl_body, n2) =
        get_label (cons_instr Lpushtrap
                    (linear body (cons_instr Lpoptrap n1))) in
      cons_instr (Lsetuptrap lbl_body)
        (linear handler (add_branch lbl_join n2))
  | Iraise ->
      copy_instr Lraise i (discard_dead_code n)
@

<<function Linearize.fundecl>>=
let fundecl f =
  { fun_name = f.Mach.fun_name;
    fun_body = linear f.Mach.fun_body end_instr;
    fun_fast = f.Mach.fun_fast }
@


%-------------------------------------------------------------

<<asmcomp/linearize.ml>>=
<<copyright header>>

(* Transformation of Mach code into a list of pseudo-instructions. *)

open Reg
open Mach

<<type Linearize.label (asmcomp/linearize.ml)>>

<<constant Linearize.label_counter>>

<<function Linearize.new_label>>

<<type Linearize.instruction (asmcomp/linearize.ml)>>

<<type Linearize.instruction_desc (asmcomp/linearize.ml)>>

<<type Linearize.fundecl (asmcomp/linearize.ml)>>

<<function Linearize.invert_integer_test>>

<<function Linearize.invert_test>>

<<constant Linearize.end_instr>>

<<function Linearize.instr_cons>>

<<function Linearize.cons_instr>>

<<function Linearize.copy_instr>>

<<function Linearize.get_label>>

<<function Linearize.discard_dead_code>>

<<function Linearize.add_branch>>

<<constant Linearize.exit_label>>

<<function Linearize.linear>>

<<function Linearize.fundecl>>

@


\subsection*{[[asmcomp/printlinear.mli]]}

<<signature Printlinear.instr>>=
val instr: instruction -> unit
@

<<signature Printlinear.fundecl>>=
val fundecl: fundecl -> unit
@


%-------------------------------------------------------------

<<asmcomp/printlinear.mli>>=
<<copyright header>>

(* Pretty-printing of linearized machine code *)

open Linearize

<<signature Printlinear.instr>>
<<signature Printlinear.fundecl>>
@


\subsection*{[[asmcomp/printlinear.ml]]}

<<function Printlinear.label>>=
let label l =
  print_string "L"; print_int l
@

<<function Printlinear.instr>>=
let instr i =
  match i.desc with
    Lend -> ()
  | Lop op ->
      begin match op with
        Ialloc _ | Icall_ind | Icall_imm _ | Iextcall(_, _) ->
          open_box 1;
          print_string "{";
          regsetaddr i.live;
          print_string "}";
          close_box();
          print_cut()
      | _ -> ()
      end;
      operation op i.arg i.res
  | Lreloadretaddr ->
      print_string "reload retaddr"
  | Lreturn ->
      print_string "return "; regs i.arg
  | Llabel lbl ->
      label lbl; print_string ":"
  | Lbranch lbl ->
      print_string "goto "; label lbl
  | Lcondbranch(tst, lbl) ->
      print_string "if "; test tst i.arg; print_string " goto "; label lbl
  | Lcondbranch3(lbl0, lbl1, lbl2) ->
      print_string "switch3 "; reg i.arg.(0);
      let case n = function
        None -> ()
      | Some lbl ->
          print_cut();
          print_string "case "; print_int n;
          print_string ": goto "; label lbl in
      case 0 lbl0; case 1 lbl1; case 2 lbl2;
      print_cut(); print_string "endswitch"
  | Lswitch lblv ->
      print_string "switch "; reg i.arg.(0);
      for i = 0 to Array.length lblv - 1 do
        print_cut();
        print_string "case "; print_int i;
        print_string ": goto "; label lblv.(i)
      done;
      print_cut(); print_string "endswitch"
  | Lsetuptrap lbl ->
      print_string "setup trap "; label lbl
  | Lpushtrap ->
      print_string "push trap"
  | Lpoptrap ->
      print_string "pop trap"
  | Lraise ->
      print_string "raise "; reg i.arg.(0)
@

<<function Printlinear.all_instr>>=
let rec all_instr i =
  match i.desc with
    Lend -> ()
  | _ -> instr i; print_cut(); all_instr i.next
@

<<function Printlinear.fundecl>>=
let fundecl f =
  open_vbox 2;
  print_string f.fun_name; print_string ":"; print_cut();
  all_instr f.fun_body;
  close_box()
@


%-------------------------------------------------------------

<<asmcomp/printlinear.ml>>=
<<copyright header>>

(* Pretty-printing of linearized machine code *)

open Format
open Mach
open Printmach
open Linearize

<<function Printlinear.label>>

<<function Printlinear.instr>>

<<function Printlinear.all_instr>>

<<function Printlinear.fundecl>>
@


\subsection*{[[asmcomp/spill.mli]]}

<<signature Spill.fundecl>>=
(* Insertion of moves to suggest possible spilling / reloading points 
   before register allocation. *)

val fundecl: Mach.fundecl -> Mach.fundecl
@


%-------------------------------------------------------------

<<asmcomp/spill.mli>>=
<<copyright header>>

<<signature Spill.fundecl>>
@


\subsection*{[[asmcomp/spill.ml]]}

<<constant Spill.spill_env>>=
(* Association of spill registers to registers *)

let spill_env = ref ((*Reg.*)Map.empty: (Reg.t , Reg.t) (*Reg.*)Map.t)
@

<<function Spill.spill_reg>>=
let spill_reg r =
  try
    (*Reg.*)Map.find r !spill_env
  with Not_found ->
    let spill_r = Reg.create r.typ in
    spill_r.spill <- true;
    if String.length r.name > 0 then spill_r.name <- "spilled-" ^ r.name;
    spill_env := (*Reg.*)Map.add r spill_r !spill_env;
    spill_r
@

<<constant Spill.use_date>>=
(* Record the position of last use of registers *)

let use_date = ref ((*Reg.*)Map.empty: (Reg.t, int) (*Reg.*)Map.t)
@

<<constant Spill.current_date>>=
let current_date = ref 0
@

<<function Spill.record_use>>=
let record_use regv =
  for i = 0 to Array.length regv - 1 do
    let r = regv.(i) in
    let prev_date = try (*Reg.*)Map.find r !use_date with Not_found -> 0 in
    if !current_date > prev_date then
      use_date := (*Reg.*)Map.add r !current_date !use_date
  done
@

<<function Spill.add_superpressure_regs>>=
(* Check if the register pressure overflows the maximum pressure allowed
   at that point. If so, spill enough registers to lower the pressure. *)

let add_superpressure_regs op live_regs res_regs spilled =
  let max_pressure = Proc.max_register_pressure op in
  let regs = Reg.add_set_array live_regs res_regs in
  (* Compute the pressure in each register class *)
  let pressure = Array.create Proc.num_register_classes 0 in
  (*Reg.*)Set.iter
    (fun r ->
      if (*Reg.*)Set.mem r spilled then () else begin
        match r.loc with
          Stack s -> ()
        | _ -> let c = Proc.register_class r in
               pressure.(c) <- pressure.(c) + 1
      end)
    regs;
  (* Check if pressure is exceeded for each class. *)
  let rec check_pressure cl spilled =
    if cl >= Proc.num_register_classes then
      spilled
    else if pressure.(cl) <= max_pressure.(cl) then
      check_pressure (cl+1) spilled
    else begin
      (* Find the least recently used, unspilled, unallocated, live register
         in the class *)
      let lru_date = ref 1000000 and lru_reg = ref Reg.dummy in
      (*Reg.*)Set.iter
        (fun r ->
          if Proc.register_class r = cl &
             not ((*Reg.*)Set.mem r spilled) &
             r.loc = Unknown then begin
            try
              let d = (*Reg.*)Map.find r !use_date in
              if d < !lru_date then begin
                lru_date := d;
                lru_reg := r
              end
            with Not_found ->                 (* Should not happen *)
              ()
          end)
        live_regs;
      pressure.(cl) <- pressure.(cl) - 1;
      check_pressure cl ((*Reg.*)Set.add !lru_reg spilled)
    end in
  check_pressure 0 spilled
@

<<constant Spill.destroyed_at_fork>>=
(* A-list recording what is destroyed at if-then-else points. *)

let destroyed_at_fork = ref ([] : (instruction * Reg.t Set.t) list)
@

<<function Spill.add_reloads>>=
(* First pass: insert reload instructions based on an approximation of
   what is destroyed at pressure points. *)

let add_reloads regset i =
  (*Reg.*)Set.fold
    (fun r i -> instr_cons (Iop Ireload) [|spill_reg r|] [|r|] i)
    regset i
@

<<constant Spill.reload_at_exit>>=
let reload_at_exit = ref (*Reg.*)Set.empty
@

<<constant Spill.reload_at_break>>=
let reload_at_break = ref (*Reg.*)Set.empty
@

<<function Spill.reload>>=
let rec reload i before =
  incr current_date;
  record_use i.arg;
  record_use i.res;
  match i.desc with
    Iend ->
      (i, before)
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (add_reloads (Reg.inter_set_array before i.arg) i,
       (*Reg.*)Set.empty)
  | Iop(Icall_ind | Icall_imm _ | Iextcall(_, true)) ->
      (* All regs live across must be spilled *)
      let (new_next, finally) = reload i.next i.live in
      (add_reloads (Reg.inter_set_array before i.arg)
                   (instr_cons i.desc i.arg i.res new_next),
       finally)
  | Iop op ->
      let new_before =
        (* Quick check to see if the register pressure is below the maximum *)
        if (*Reg.*)Set.cardinal i.live + Array.length i.res <=
           Proc.safe_register_pressure op
        then before
        else add_superpressure_regs op i.live i.res before in
      let after =
        Reg.diff_set_array (Reg.diff_set_array new_before i.arg) i.res in
      let (new_next, finally) = reload i.next after in
      (add_reloads (Reg.inter_set_array new_before i.arg)
                   (instr_cons i.desc i.arg i.res new_next),
       finally)
  | Iifthenelse(test, ifso, ifnot) ->
      let at_fork = Reg.diff_set_array before i.arg in
      let date_fork = !current_date in
      let (new_ifso, after_ifso) = reload ifso at_fork in
      let date_ifso = !current_date in
      current_date := date_fork;
      let (new_ifnot, after_ifnot) = reload ifnot at_fork in
      current_date := max date_ifso !current_date;
      let (new_next, finally) =
        reload i.next ((*Reg.*)Set.union after_ifso after_ifnot) in
      let new_i =
        instr_cons (Iifthenelse(test, new_ifso, new_ifnot))
        i.arg i.res new_next in
      destroyed_at_fork := (new_i, at_fork) :: !destroyed_at_fork;
      (add_reloads (Reg.inter_set_array before i.arg) new_i,
       finally)
  | Iswitch(index, cases) ->
      let at_fork = Reg.diff_set_array before i.arg in
      let date_fork = !current_date in
      let date_join = ref 0 in
      let after_cases = ref (*Reg.*)Set.empty in
      let new_cases =
        Array.map
          (fun c ->
            current_date := date_fork;
            let (new_c, after_c) = reload c at_fork in
            after_cases := (*Reg.*)Set.union !after_cases after_c;
            date_join := max !date_join !current_date;
            new_c)
          cases in
      current_date := !date_join;
      let (new_next, finally) = reload i.next !after_cases in
      (add_reloads (Reg.inter_set_array before i.arg)
                   (instr_cons (Iswitch(index, new_cases))
                               i.arg i.res new_next),
       finally)
  | Iloop(body) ->
      let date_start = !current_date in
      let at_head = ref before in
      let final_body = ref body in
      begin try
        while true do
          current_date := date_start;
          let (new_body, new_at_head) = reload body !at_head in
          let merged_at_head = (*Reg.*)Set.union !at_head new_at_head in
          if (*Reg.*)Set.equal merged_at_head !at_head then begin
            final_body := new_body;
            raise Exit
          end;
          at_head := merged_at_head
        done
      with Exit -> ()
      end;
      let (new_next, finally) = reload i.next (*Reg.*)Set.empty in
      (instr_cons (Iloop(!final_body)) i.arg i.res new_next,
       finally)
  | Icatch(body, handler) ->
      let saved_reload_at_exit = !reload_at_exit in
      reload_at_exit := (*Reg.*)Set.empty;
      let (new_body, after_body) = reload body before in
      let at_exit = !reload_at_exit in
      reload_at_exit := saved_reload_at_exit;
      let (new_handler, after_handler) = reload handler at_exit in
      let (new_next, finally) =
        reload i.next ((*Reg.*)Set.union after_body after_handler) in
      (instr_cons (Icatch(new_body, new_handler)) i.arg i.res new_next,
       finally)
  | Iexit ->
      reload_at_exit := (*Reg.*)Set.union !reload_at_exit before;
      (i, (*Reg.*)Set.empty)
  | Itrywith(body, handler) ->
      let (new_body, after_body) = reload body before in
      let (new_handler, after_handler) = reload handler handler.live in
      let (new_next, finally) =
        reload i.next ((*Reg.*)Set.union after_body after_handler) in
      (instr_cons (Itrywith(new_body, new_handler)) i.arg i.res new_next,
       finally)
  | Iraise ->
      (add_reloads (Reg.inter_set_array before i.arg) i, (*Reg.*)Set.empty)
@

<<constant Spill.spill_at_exit>>=
(* As an optimization, if a register needs to be spilled in one branch of
   a conditional but not in the other, then we spill it late on entrance
   in the branch that needs it spilled.
   This strategy is turned off in loops, as it may prevent a spill from
   being lifted up all the way out of the loop. *)

let spill_at_exit = ref (*Reg.*)Set.empty
@

<<constant Spill.spill_at_raise>>=
let spill_at_raise = ref (*Reg.*)Set.empty
@

<<constant Spill.inside_loop>>=
let inside_loop = ref false
@

<<function Spill.add_spills>>=
let add_spills regset i =
  (*Reg.*)Set.fold
    (fun r i -> instr_cons (Iop Ispill) [|r|] [|spill_reg r|] i)
    regset i
@

<<function Spill.spill>>=
let rec spill i finally =
  match i.desc with
    Iend ->
      (i, finally)
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (i, (*Reg.*)Set.empty)
  | Iop Ireload ->
      let (new_next, after) = spill i.next finally in
      let before1 = Reg.diff_set_array after i.res in
      (instr_cons i.desc i.arg i.res new_next,
       Reg.add_set_array before1 i.res)
  | Iop _ ->
      let (new_next, after) = spill i.next finally in
      let before1 = Reg.diff_set_array after i.res in
      let before =
        match i.desc with
          Iop(Icall_ind) | Iop(Icall_imm _) | Iop(Iextcall(_, _)) ->
            (*Reg.*)Set.union before1 !spill_at_raise
        | _ ->
            before1 in
      (instr_cons i.desc i.arg i.res
                  (add_spills (Reg.inter_set_array after i.res) new_next),
       before)
  | Iifthenelse(test, ifso, ifnot) ->
      let (new_next, at_join) = spill i.next finally in
      let (new_ifso, before_ifso) = spill ifso at_join in
      let (new_ifnot, before_ifnot) = spill ifnot at_join in
      if !inside_loop then
        (instr_cons (Iifthenelse(test, new_ifso, new_ifnot))
                     i.arg i.res new_next,
         (*Reg.*)Set.union before_ifso before_ifnot)
      else begin
        let destroyed = List.assq i !destroyed_at_fork in
        let spill_ifso_branch =
          (*Reg.*)Set.diff ((*Reg.*)Set.diff before_ifso before_ifnot) destroyed
        and spill_ifnot_branch =
          (*Reg.*)Set.diff ((*Reg.*)Set.diff before_ifnot before_ifso) destroyed in
        (instr_cons
            (Iifthenelse(test, add_spills spill_ifso_branch new_ifso,
                               add_spills spill_ifnot_branch new_ifnot))
            i.arg i.res new_next,
         (*Reg.*)Set.diff ((*Reg.*)Set.diff ((*Reg.*)Set.union before_ifso before_ifnot)
                                    spill_ifso_branch)
                       spill_ifnot_branch)
      end
  | Iswitch(index, cases) ->
      let (new_next, at_join) = spill i.next finally in
      let before = ref (*Reg.*)Set.empty in
      let new_cases =
        Array.map
          (fun c ->
            let (new_c, before_c) = spill c at_join in
            before := (*Reg.*)Set.union !before before_c;
            new_c)
          cases in
      (instr_cons (Iswitch(index, new_cases)) i.arg i.res new_next,
       !before)
  | Iloop(body) ->
      let (new_next, _) = spill i.next finally in
      let saved_inside_loop = !inside_loop in
      inside_loop := true;
      let at_head = ref (*Reg.*)Set.empty in
      let final_body = ref body in
      begin try
        while true do
          let (new_body, before_body) = spill body !at_head in
          let new_at_head = (*Reg.*)Set.union !at_head before_body in
          if (*Reg.*)Set.equal new_at_head !at_head then begin
            final_body := new_body; raise Exit
          end;
          at_head := new_at_head
        done
      with Exit -> ()
      end;
      inside_loop := saved_inside_loop;
      (instr_cons (Iloop(!final_body)) i.arg i.res new_next,
       !at_head)
  | Icatch(body, handler) ->
      let (new_next, at_join) = spill i.next finally in
      let (new_handler, at_exit) = spill handler at_join in
      let saved_spill_at_exit = !spill_at_exit in
      spill_at_exit := at_exit;
      let (new_body, before) = spill body at_join in
      spill_at_exit := saved_spill_at_exit;
      (instr_cons (Icatch(new_body, new_handler)) i.arg i.res new_next,
       before)
  | Iexit ->
      (i, !spill_at_exit)
  | Itrywith(body, handler) ->
      let (new_next, at_join) = spill i.next finally in
      let (new_handler, before_handler) = spill handler at_join in
      let saved_spill_at_raise = !spill_at_raise in
      spill_at_raise := before_handler;
      let (new_body, before_body) = spill body at_join in
      spill_at_raise := saved_spill_at_raise;
      (instr_cons (Itrywith(new_body, new_handler)) i.arg i.res new_next,
       before_body)
  | Iraise ->
      (i, !spill_at_raise)
@

<<function Spill.fundecl>>=
(* Entry point *)

let fundecl f =
  spill_env := (*Reg.*)Map.empty;
  use_date := (*Reg.*)Map.empty;
  current_date := 0;
  let (body1, _) = reload f.fun_body (*Reg.*)Set.empty in
  let (body2, tospill_at_entry) = spill body1 (*Reg.*)Set.empty in
  let new_body =
    add_spills (Reg.inter_set_array tospill_at_entry f.fun_args) body2 in
  spill_env := (*Reg.*)Map.empty;
  use_date := (*Reg.*)Map.empty;
  { fun_name = f.fun_name;
    fun_args = f.fun_args;
    fun_body = new_body;
    fun_fast = f.fun_fast }
@


%-------------------------------------------------------------

<<asmcomp/spill.ml>>=
<<copyright header>>

(* Insertion of moves to suggest possible spilling / reloading points 
   before register allocation. *)

open Reg
open Mach

(* We say that a register is "destroyed" if it is live across a construct
   that potentially destroys all physical registers: function calls or
   try...with constructs.

   The "destroyed" registers must therefore reside in the stack during
   these instructions.. We will insert spills (stores) just after they
   are defined, and reloads just before their first use following a
   "destroying" construct.

   Instructions with more live registers than actual registers also
   "destroy" registers: we mark as "destroyed" the registers live
   across the instruction that haven't been used for the longest time.
   These registers will be spilled and reloaded as described above. *)

<<constant Spill.spill_env>>

<<function Spill.spill_reg>>

<<constant Spill.use_date>>
<<constant Spill.current_date>>

<<function Spill.record_use>>

<<function Spill.add_superpressure_regs>>

<<constant Spill.destroyed_at_fork>>

<<function Spill.add_reloads>>

<<constant Spill.reload_at_exit>>
<<constant Spill.reload_at_break>>

<<function Spill.reload>>

(* Second pass: add spill instructions based on what we've decided to reload.
   That is, any register that may be reloaded in the future must be spilled
   just after its definition. *)

<<constant Spill.spill_at_exit>>
<<constant Spill.spill_at_raise>>
<<constant Spill.inside_loop>>

<<function Spill.add_spills>>

<<function Spill.spill>>

<<function Spill.fundecl>>
  
@


\subsection*{[[asmcomp/selectgen.mli]]}

<<type Selectgen.environment>>=
(* Selection of pseudo-instructions, assignment of pseudo-registers,
   sequentialization. *)

type environment = (Ident.t, Reg.t array) Tbl.t
@

<<signature Selectgen.size_expr>>=
val size_expr : environment -> Cmm.expression -> int
@

<<type Selectgen.selector>>=
type selector = {
  (* old: virtuals *)

  (* The following methods must or can be overriden by the processor
     description *)
  is_immediate : (int -> bool);
    (* Must be defined to indicate whether a constant is a suitable
       immediate operand to arithmetic instructions *)
  select_addressing :
    (Cmm.expression -> Arch.addressing_mode * Cmm.expression);
    (* Must be defined to select addressing modes *)

  (* old: regular *)

  select_operation :
    selector ->
    Cmm.operation ->
    Cmm.expression list -> Mach.operation * Cmm.expression list;
    (* Can be overriden to deal with special arithmetic instructions *)
  select_condition : 
    selector ->
    Cmm.expression -> Mach.test * Cmm.expression;
    (* Can be overriden to deal with special test instructions *)
  select_store :
    Arch.addressing_mode -> Cmm.expression -> Mach.operation * Cmm.expression;
    (* Can be overriden to deal with special store constant instructions *)
  insert_op :
    selector ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array;
    (* Can be overriden to deal with 2-address instructions
       or instructions with hardwired input/output registers *)
  emit_extcall_args :
    selector ->
    environment -> Cmm.expression list -> Reg.t array * int;
    (* Can be overriden to deal with stack-based calling conventions *)

  (* The following method is the entry point and should not be overriden *)
  emit_fundecl : 
    selector ->
    Cmm.fundecl -> Mach.fundecl;
  
  (* The following methods should not be overriden.  They cannot be
     declared "private" in the current implementation because they
     are not always applied to "self", but ideally they should be private. *)
  extract : Mach.instruction;
  insert : Mach.instruction_desc -> Reg.t array -> Reg.t array -> unit;
  insert_move : 
    selector ->
    Reg.t -> Reg.t -> unit;
  insert_move_args : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_move_results : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_moves : 
    selector ->
    Reg.t array -> Reg.t array -> unit;
  emit_expr :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> Reg.t array;

  emit_tail : 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> unit;


  (* old: protected *)

  select_arith_comm: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_shift: 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith_comp: 
     selector -> 
     Mach.integer_comparison -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;


  emit_let :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Ident.t -> Cmm.expression -> 
     (Ident.t, Reg.t array) Tbl.t;
  emit_parts_list:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Cmm.expression list * (Ident.t, Reg.t array) Tbl.t;
  emit_parts:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Cmm.expression * (Ident.t, Reg.t array) Tbl.t;
  emit_tuple:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Reg.t array;
  emit_stores: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> Reg.t array -> 
     Arch.addressing_mode -> unit;
  emit_sequence: 
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Reg.t array * selector;

  emit_return: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     unit;

  emit_tail_sequence: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
    Mach.instruction;

  (* old: in children *)

  select_floatarith: 
   selector ->
   Mach.operation -> 
   Mach.operation -> 
   Arch.float_operation -> 
   Arch.float_operation -> 
   Cmm.expression list -> 
   Mach.operation * Cmm.expression list;

  select_push:
   selector ->
   Cmm.expression -> Mach.operation * Cmm.expression;

}
@

<<signature Selectgen.selector_generic>>=
val selector_generic: unit -> selector
@


%-------------------------------------------------------------

<<asmcomp/selectgen.mli>>=
<<copyright header>>

<<type Selectgen.environment>>

<<signature Selectgen.size_expr>>


<<type Selectgen.selector>>

<<signature Selectgen.selector_generic>>


(*
  is_immediate = super.is_immediate;
  select_addressing = super.select_addressing;
  select_operation = super.select_operation;
  select_condition = super.select_condition;
  select_store = super.select_store;
  insert_op = super.insert_op;
  emit_extcall_args = super.emit_extcall_args;
  emit_fundecl = super.emit_fundecl;
  extract = super.extract;
  insert = super.insert;
  insert_move = super.insert_move;
  insert_move_args = super.insert_move_args;
  insert_move_results = super.insert_move_results;
  insert_moves = super.insert_moves;
  emit_expr = super.emit_expr;
  emit_tail = super.emit_tail;
  select_arith_comm = super.select_arith_comm;
  select_arith = super.select_arith;
  select_shift = super.select_shift;
  select_arith_comp = super.select_arith_comp;
  emit_let = super.emit_let;
  emit_parts_list = super.emit_parts_list;
  emit_parts = super.emit_parts;
  emit_tuple = super.emit_tuple;
  emit_stores = super.emit_stores;
  emit_sequence = super.emit_sequence;
  emit_return = super.emit_return;
  emit_tail_sequence = super.emit_tail_sequence;
  select_floatarith = super.select_floatarith;
  select_push = super.select_push;
*)
@


\subsection*{[[asmcomp/selectgen.ml]]}

<<type Selectgen.environment (asmcomp/selectgen.ml)>>=
type environment = (Ident.t, Reg.t array) Tbl.t
@

<<type Selectgen.selector (asmcomp/selectgen.ml)>>=
type selector = {
  (* The following methods must or can be overriden by the processor
     description *)
  is_immediate : (int -> bool);
    (* Must be defined to indicate whether a constant is a suitable
       immediate operand to arithmetic instructions *)
  select_addressing :
    (Cmm.expression -> Arch.addressing_mode * Cmm.expression);
    (* Must be defined to select addressing modes *)

  select_operation :
    selector ->
    Cmm.operation ->
    Cmm.expression list -> Mach.operation * Cmm.expression list;
    (* Can be overriden to deal with special arithmetic instructions *)
  select_condition : 
    selector ->
    Cmm.expression -> Mach.test * Cmm.expression;
    (* Can be overriden to deal with special test instructions *)
  select_store :
    Arch.addressing_mode -> Cmm.expression -> Mach.operation * Cmm.expression;
    (* Can be overriden to deal with special store constant instructions *)
  insert_op :
    selector ->
    Mach.operation -> Reg.t array -> Reg.t array -> Reg.t array;
    (* Can be overriden to deal with 2-address instructions
       or instructions with hardwired input/output registers *)
  emit_extcall_args :
    selector ->
    environment -> Cmm.expression list -> Reg.t array * int;
    (* Can be overriden to deal with stack-based calling conventions *)

  (* The following method is the entry point and should not be overriden *)
  emit_fundecl : 
    selector ->
    Cmm.fundecl -> Mach.fundecl;
  
  (* The following methods should not be overriden.  They cannot be
     declared "private" in the current implementation because they
     are not always applied to "self", but ideally they should be private. *)
  extract : Mach.instruction;
  insert : Mach.instruction_desc -> Reg.t array -> Reg.t array -> unit;
  insert_move : 
    selector ->
    Reg.t -> Reg.t -> unit;
  insert_move_args : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_move_results : 
    selector ->
    Reg.t array -> Reg.t array -> int -> unit;
  insert_moves : 
    selector ->
    Reg.t array -> Reg.t array -> unit;
  emit_expr :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> Reg.t array;

  emit_tail : 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> unit;



  select_arith_comm: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith: 
     selector -> 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_shift: 
     Mach.integer_operation -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;
  select_arith_comp: 
     selector -> 
     Mach.integer_comparison -> Cmm.expression list -> 
     Mach.operation * Cmm.expression list;


  emit_let :
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Ident.t -> Cmm.expression -> 
     (Ident.t, Reg.t array) Tbl.t;
  emit_parts_list:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Cmm.expression list * (Ident.t, Reg.t array) Tbl.t;
  emit_parts:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Cmm.expression * (Ident.t, Reg.t array) Tbl.t;
  emit_tuple:
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> 
     Reg.t array;
  emit_stores: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression list -> Reg.t array -> 
     Arch.addressing_mode -> unit;
  emit_sequence: 
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     Reg.t array * selector;

  emit_return: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
     unit;

  emit_tail_sequence: 
    selector ->
    (Ident.t, Reg.t array) Tbl.t -> Cmm.expression -> 
    Mach.instruction;


   (* in children *)
  select_floatarith:
   selector ->
   Mach.operation -> 
   Mach.operation -> 
   Arch.float_operation -> 
   Arch.float_operation -> 
   Cmm.expression list -> 
   Mach.operation * Cmm.expression list;

  select_push:
   selector ->
   Cmm.expression -> Mach.operation * Cmm.expression;

}
@

<<function Selectgen.oper_result_type>>=
(* Infer the type of the result of an operation *)

let oper_result_type = function
    Capply ty -> ty
  | Cextcall(s, ty, alloc) -> ty
  | Cload ty -> ty
  | Cloadchunk c -> typ_int
  | Calloc -> typ_addr
  | Cstore -> typ_void
  | Cstorechunk c -> typ_void
  | Caddi | Csubi | Cmuli | Cdivi | Cmodi
  | Cand | Cor | Cxor | Clsl | Clsr | Casr
  | Ccmpi _ | Ccmpa _ | Ccmpf _ -> typ_int
  | Cadda | Csuba -> typ_addr
  | Cnegf | Cabsf | Caddf | Csubf | Cmulf | Cdivf -> typ_float
  | Cfloatofint -> typ_float
  | Cintoffloat -> typ_int
  | Craise -> typ_void
  | Ccheckbound -> typ_void
  | _ -> fatal_error "Selection.oper_result_type"
@

<<function Selectgen.size_expr>>=
(* Infer the size in bytes of the result of a simple expression *)

let size_expr env exp =
  let rec size localenv = function
      Cconst_int _ | Cconst_natint _ -> Arch.size_int
    | Cconst_symbol _ | Cconst_pointer _ -> Arch.size_addr
    | Cconst_float _ -> Arch.size_float
    | Cvar id ->
        begin try
          Tbl.find id localenv
        with Not_found ->
        try
          let regs = Tbl.find id env in
          size_machtype (Array.map (fun r -> r.typ) regs)
        with Not_found ->
          fatal_error("Selection.size_expr: unbound var " ^ Ident.name id)
        end
    | Ctuple el ->
        List.fold_right (fun e sz -> size localenv e + sz) el 0
    | Cop(op, args) ->
        size_machtype(oper_result_type op)
    | Clet(id, arg, body) ->
        size (Tbl.add id (size localenv arg) localenv) body
    | _ ->
        fatal_error "Selection.size_expr"
  in size Tbl.empty exp
@

<<function Selectgen.is_simple_expr>>=
(* Says if an expression is "simple". A "simple" expression has no
   side-effects and its execution can be delayed until its value
   is really needed. In the case of e.g. an [alloc] instruction,
   the non-simple arguments are computed in right-to-left order
   first, then the block is allocated, then the simple arguments are
   evaluated and stored. *)

let rec is_simple_expr = function
    Cconst_int _ -> true
  | Cconst_natint _ -> true
  | Cconst_float _ -> true
  | Cconst_symbol _ -> true
  | Cconst_pointer _ -> true
  | Cvar _ -> true
  | Ctuple el -> List.for_all is_simple_expr el
  | Clet(id, arg, body) -> is_simple_expr arg && is_simple_expr body
  | Cop(op, args) ->
      begin match op with
        (* The following may have side effects *)
        Capply _ | Cextcall(_, _, _) | Calloc | Cstore | Cstorechunk _ | 
        Craise -> false
        (* The remaining operations are simple if their args are *)
      | _ -> List.for_all is_simple_expr args
      end
  | _ -> false
@

<<function Selectgen.swap_intcomp>>=
(* Swap the two arguments of an integer comparison *)

let swap_intcomp = function
    Isigned cmp -> Isigned(swap_comparison cmp)
  | Iunsigned cmp -> Iunsigned(swap_comparison cmp)
@

<<function Selectgen.all_regs_anonymous>>=
(* Naming of registers *)

let all_regs_anonymous rv =
  try
    for i = 0 to Array.length rv - 1 do
      if String.length rv.(i).name > 0 then raise Exit
    done;
    true
  with Exit ->
    false
@

<<function Selectgen.name_regs>>=
let name_regs id rv =
  if Array.length rv = 1 then
    rv.(0).name <- Ident.name id
  else
    for i = 0 to Array.length rv - 1 do
      rv.(i).name <- Ident.name id ^ "#" ^ string_of_int i
    done
@

<<function Selectgen.join>>=
(* "Join" two instruction sequences, making sure they return their results
   in the same registers. *)

let join r1 seq1 r2 seq2 =
  let l1 = Array.length r1 and l2 = Array.length r2 in
  if l1 = 0 then r2
  else if l2 = 0 then r1
  else begin
    let r = Array.create l1 Reg.dummy in
    for i = 0 to l1-1 do
      if String.length r1.(i).name = 0 then begin
        r.(i) <- r1.(i);
        seq2.insert_move seq2 r2.(i) r1.(i)
      end else if String.length r2.(i).name = 0 then begin
        r.(i) <- r2.(i);
        seq1.insert_move seq1 r1.(i) r2.(i)
      end else begin
        r.(i) <- Reg.create r1.(i).typ;
        seq1.insert_move seq1 r1.(i) r.(i);
        seq2.insert_move seq1 r2.(i) r.(i)
      end
    done;
    r
  end
@

<<function Selectgen.join_array>>=
(* Same, for N branches *)

let join_array rs =
  let some_res = ref [||] in
  for i = 0 to Array.length rs - 1 do
    let (r, s) = rs.(i) in
    if Array.length r > 0 then some_res := r
  done;
  let size_res = Array.length !some_res in
  if size_res = 0 then [||] else begin
    let res = Array.create size_res Reg.dummy in
    for i = 0 to size_res - 1 do
      res.(i) <- Reg.create (!some_res).(i).typ
    done;
    for i = 0 to Array.length rs - 1 do
      let (r, s) = rs.(i) in
      if Array.length r > 0 then s.insert_moves s r res
    done;
    res
  end
@

<<function Selectgen.selector_generic>>=
(* The default instruction selection class *)

let selector_generic () =
 let instr_seq = ref dummy_instr in
 {

(* Says whether an integer constant is a suitable immediate argument *)

 is_immediate = (fun _ -> 
  failwith "virtual: selector_generic.is_immediate");

(* Selection of addressing modes *)

 select_addressing = (fun _ -> 
   failwith "virtual: selector_generic.select_addr");

(* Default instruction selection for stores *)

 select_store = (fun addr arg ->
  (Istore(Word, addr), arg)
 );

(* Default instruction selection for operators *)

 select_operation = (fun self op args ->
  match (op, args) with
    (Capply ty, Cconst_symbol s :: rem) -> (Icall_imm s, rem)
  | (Capply ty, _) -> (Icall_ind, args)
  | (Cextcall(s, ty, alloc), _) -> (Iextcall(s, alloc), args)
  | (Cload ty, [arg]) ->
      let (addr, eloc) = self.select_addressing arg in
      (Iload(Word, addr), [eloc])
  | (Cloadchunk chunk, [arg]) ->
      let (addr, eloc) = self.select_addressing arg in
      (Iload(chunk, addr), [eloc])
  | (Cstore, [arg1; arg2]) ->
      let (addr, eloc) = self.select_addressing arg1 in
      let (op, newarg2) = self.select_store addr arg2 in
      (op, [newarg2; eloc])
      (* Inversion addr/datum in Istore *)
  | (Cstorechunk chunk, [arg1; arg2]) ->
      let (addr, eloc) = self.select_addressing arg1 in
      (Istore(chunk, addr), [arg2; eloc])
      (* Inversion addr/datum in Istore *)
  | (Calloc, _) -> (Ialloc 0, args)
  | (Caddi, _) -> self.select_arith_comm self Iadd args
  | (Csubi, _) -> self.select_arith self Isub args
  | (Cmuli, [arg1; Cconst_int n]) ->
      let l = Misc.log2 n in
      if n = 1 lsl l
      then (Iintop_imm(Ilsl, l), [arg1])
      else self.select_arith_comm self Imul args
  | (Cmuli, [Cconst_int n; arg1]) ->
      let l = Misc.log2 n in
      if n = 1 lsl l
      then (Iintop_imm(Ilsl, l), [arg1])
      else self.select_arith_comm self Imul args
  | (Cmuli, _) -> self.select_arith_comm self Imul args
  | (Cdivi, _) -> self.select_arith self Idiv args
  | (Cmodi, _) -> self.select_arith_comm self Imod args
  | (Cand, _) -> self.select_arith_comm self Iand args
  | (Cor, _) -> self.select_arith_comm self Ior args
  | (Cxor, _) -> self.select_arith_comm self Ixor args
  | (Clsl, _) -> self.select_shift Ilsl args
  | (Clsr, _) -> self.select_shift Ilsr args
  | (Casr, _) -> self.select_shift Iasr args
  | (Ccmpi comp, _) -> self.select_arith_comp self (Isigned comp) args
  | (Cadda, _) -> self.select_arith_comm self Iadd args
  | (Csuba, _) -> self.select_arith self Isub args
  | (Ccmpa comp, _) -> self.select_arith_comp self (Iunsigned comp) args
  | (Cnegf, _) -> (Inegf, args)
  | (Cabsf, _) -> (Iabsf, args)
  | (Caddf, _) -> (Iaddf, args)
  | (Csubf, _) -> (Isubf, args)  
  | (Cmulf, _) -> (Imulf, args)  
  | (Cdivf, _) -> (Idivf, args)
  | (Cfloatofint, _) -> (Ifloatofint, args)
  | (Cintoffloat, _) -> (Iintoffloat, args)
  | (Ccheckbound, _) -> self.select_arith self Icheckbound args
  | _ -> fatal_error "Selection.select_oper"
 );

 select_arith_comm = (fun self op -> function
    [arg; Cconst_int n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [arg; Cconst_pointer n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [Cconst_int n; arg] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [Cconst_pointer n; arg] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | args ->
       (Iintop op, args)
 );

 select_arith = (fun self op -> function
    [arg; Cconst_int n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | [arg; Cconst_pointer n] when self.is_immediate n ->
      (Iintop_imm(op, n), [arg])
  | args ->
      (Iintop op, args)
 );

 select_shift = (fun op -> function
    [arg; Cconst_int n] when n >= 0 & n < Arch.size_int * 8 ->
      (Iintop_imm(op, n), [arg])
  | args ->
      (Iintop op, args)
 );

 select_arith_comp = (fun self cmp -> function
    [arg; Cconst_int n] when self.is_immediate n ->
      (Iintop_imm(Icomp cmp, n), [arg])
  | [arg; Cconst_pointer n] when self.is_immediate n ->
      (Iintop_imm(Icomp cmp, n), [arg])
  | [Cconst_int n; arg] when self.is_immediate n ->
      (Iintop_imm(Icomp(swap_intcomp cmp), n), [arg])
  | [Cconst_pointer n; arg] when self.is_immediate n ->
      (Iintop_imm(Icomp(swap_intcomp cmp), n), [arg])
  | args ->
      (Iintop(Icomp cmp), args)
 );

(* Instruction selection for conditionals *)

 select_condition = (fun self -> function
    Cop(Ccmpi cmp, [arg1; Cconst_int n]) when self.is_immediate n ->
      (Iinttest_imm(Isigned cmp, n), arg1)
  | Cop(Ccmpi cmp, [Cconst_int n; arg2]) when self.is_immediate n ->
      (Iinttest_imm(Isigned(swap_comparison cmp), n), arg2)
  | Cop(Ccmpi cmp, args) ->
      (Iinttest(Isigned cmp), Ctuple args)
  | Cop(Ccmpa cmp, [arg1; Cconst_pointer n]) when self.is_immediate n ->
      (Iinttest_imm(Iunsigned cmp, n), arg1)
  | Cop(Ccmpa cmp, [Cconst_pointer n; arg2]) when self.is_immediate n ->
      (Iinttest_imm(Iunsigned(swap_comparison cmp), n), arg2)
  | Cop(Ccmpa cmp, args) ->
      (Iinttest(Iunsigned cmp), Ctuple args)
  | Cop(Ccmpf cmp, args) ->
      (Ifloattest(cmp, false), Ctuple args)
  | Cop(Cand, [arg; Cconst_int 1]) ->
      (Ioddtest, arg)
  | arg ->
      (Itruetest, arg)
 );

(* Buffering of instruction sequences *)


 insert = (fun desc arg res ->
  instr_seq := instr_cons desc arg res !instr_seq
 );

 extract = (
  let rec extract res i =
    if i == dummy_instr
    then res
    else extract (instr_cons i.desc i.arg i.res res) i.next in
  extract (end_instr()) !instr_seq
 );

(* Insert a sequence of moves from one pseudoreg set to another. *)

 insert_move = (fun self src dst ->
  if src.stamp <> dst.stamp then
    self.insert (Iop Imove) [|src|] [|dst|]
 ); 

 insert_moves = (fun self src dst ->
  for i = 0 to Array.length src - 1 do
    self.insert_move self src.(i) dst.(i)
  done
 );

(* Insert moves and stack offsets for function arguments and results *)

 insert_move_args = (fun self arg loc stacksize ->
  if stacksize <> 0 then self.insert (Iop(Istackoffset stacksize)) [||] [||];
  self.insert_moves self arg loc
 );

 insert_move_results = (fun self loc res stacksize ->
  if stacksize <> 0 then self.insert(Iop(Istackoffset(-stacksize))) [||] [||];
  self.insert_moves self loc res
 );

(* Add an Iop opcode. Can be overriden by processor description
   to insert moves before and after the operation, i.e. for two-address 
   instructions, or instructions using dedicated registers. *)

 insert_op = (fun self op rs rd ->
  self.insert (Iop op) rs rd;
  rd
 );

(* Add the instructions for the given expression
   at the end of the self sequence *)

 emit_expr = (fun self env exp ->
  match exp with
    Cconst_int n ->
      let r = Reg.createv typ_int in
      self.insert_op self (Iconst_int(Nativeint.from n)) [||] r
  | Cconst_natint n ->
      let r = Reg.createv typ_int in
      self.insert_op self (Iconst_int n) [||] r
  | Cconst_float n ->
      let r = Reg.createv typ_float in
      self.insert_op self (Iconst_float n) [||] r
  | Cconst_symbol n ->
      let r = Reg.createv typ_addr in
      self.insert_op self (Iconst_symbol n) [||] r
  | Cconst_pointer n ->
      let r = Reg.createv typ_addr in
      self.insert_op self (Iconst_int(Nativeint.from n)) [||] r
  | Cvar v ->
      begin try
        Tbl.find v env
      with Not_found ->
        fatal_error("Selection.emit_expr: unbound var " ^ Ident.name v)
      end
  | Clet(v, e1, e2) ->
      self.emit_expr self (self.emit_let self env v e1) e2
  | Cassign(v, e1) ->
      let rv =
        try
          Tbl.find v env
        with Not_found ->
          fatal_error ("Selection.emit_expr: unbound var " ^ Ident.name v) in
      let r1 = self.emit_expr self env e1 in
      self.insert_moves self r1 rv;
      [||]
  | Ctuple [] ->
      [||]
  | Ctuple exp_list ->
      let (simple_list, ext_env) = self.emit_parts_list self env exp_list in
      self.emit_tuple self ext_env simple_list
  | Cop(Cproj(ofs, len), [Cop(Cload ty, [arg])]) ->
      let byte_offset = size_machtype(Array.sub ty 0 ofs) in
      self.emit_expr self env
        (Cop(Cload(Array.sub ty ofs len),
             [Cop(Cadda, [arg; Cconst_int byte_offset])]))
  | Cop(Cproj(ofs, len), [arg]) ->
      let r = self.emit_expr self env arg in
      Array.sub r ofs len
  | Cop(Craise, [arg]) ->
      let r1 = self.emit_expr self  env arg in
      let rd = [|Proc.loc_exn_bucket|] in
      self.insert (Iop Imove) r1 rd;
      self.insert Iraise rd [||];
      [||]
  | Cop(Ccmpf comp, args) ->
      self.emit_expr self  env (Cifthenelse(exp, Cconst_int 1, Cconst_int 0))
  | Cop(op, args) ->
      let (simple_args, env) = self.emit_parts_list self env args in
      let ty = oper_result_type op in
      let (new_op, new_args) = self.select_operation self op simple_args in
      begin match new_op with
        Icall_ind ->
          Proc.contains_calls := true;
          let r1 = self.emit_tuple self env new_args in
          let rarg = Array.sub r1 1 (Array.length r1 - 1) in
          let rd = Reg.createv ty in
          let (loc_arg, stack_ofs) = Proc.loc_arguments rarg in
          let loc_res = Proc.loc_results rd in
          self.insert_move_args self rarg loc_arg stack_ofs;
          self.insert (Iop Icall_ind)
                      (Array.append [|r1.(0)|] loc_arg) loc_res;
          self.insert_move_results self loc_res rd stack_ofs;
          rd
      | Icall_imm lbl ->
          Proc.contains_calls := true;
          let r1 = self.emit_tuple self env new_args in
          let rd = Reg.createv ty in
          let (loc_arg, stack_ofs) = Proc.loc_arguments r1 in
          let loc_res = Proc.loc_results rd in
          self.insert_move_args self r1 loc_arg stack_ofs;
          self.insert (Iop(Icall_imm lbl)) loc_arg loc_res;
          self.insert_move_results self loc_res rd stack_ofs;
          rd
      | Iextcall(lbl, alloc) ->
          Proc.contains_calls := true;
          let (loc_arg, stack_ofs) = self.emit_extcall_args self env new_args in
          let rd = Reg.createv ty in
          let loc_res = Proc.loc_external_results rd in
          self.insert (Iop(Iextcall(lbl, alloc))) loc_arg loc_res;
          self.insert_move_results self loc_res rd stack_ofs;
          rd
      | Ialloc _ ->
          Proc.contains_calls := true;
          let rd = Reg.createv typ_addr in
          let size = size_expr env (Ctuple new_args) in
          self.insert (Iop(Ialloc size)) [||] rd;
          self.emit_stores self env new_args rd 
            (Arch.offset_addressing Arch.identity_addressing (-Arch.size_int));
          rd
      | op ->
          let r1 = self.emit_tuple self env new_args in
          let rd = Reg.createv ty in
          self.insert_op self op r1 rd
      end        
  | Csequence(e1, e2) ->
      self.emit_expr self  env e1;
      self.emit_expr self  env e2
  | Cifthenelse(econd, eif, eelse) ->
      let (cond, earg) = self.select_condition self econd in
      let rarg = self.emit_expr self  env earg in
      let (rif, sif) = self.emit_sequence env eif in
      let (relse, selse) = self.emit_sequence env eelse in
      let r = join rif sif relse selse in
      self.insert (Iifthenelse(cond, sif.extract, selse.extract)) rarg [||];
      r
  | Cswitch(esel, index, ecases) ->
      let rsel = self.emit_expr self  env esel in
      let rscases = Array.map (self.emit_sequence env) ecases in
      let r = join_array rscases in
      self.insert (Iswitch(index, Array.map (fun (r, s) -> s.extract) rscases))
                  rsel [||];
      r
  | Cloop(ebody) ->
      let (rarg, sbody) = self.emit_sequence env ebody in
      self.insert (Iloop(sbody.extract)) [||] [||];
      [||]
  | Ccatch(e1, e2) ->
      let (r1, s1) = self.emit_sequence env e1 in
      let (r2, s2) = self.emit_sequence env e2 in
      let r = join r1 s1 r2 s2 in
      self.insert (Icatch(s1.extract, s2.extract)) [||] [||];
      r
  | Cexit ->
      self.insert Iexit [||] [||];
      [||]
  | Ctrywith(e1, v, e2) ->
      Proc.contains_calls := true;
      let (r1, s1) = self.emit_sequence env e1 in
      let rv = Reg.createv typ_addr in
      let (r2, s2) = self.emit_sequence (Tbl.add v rv env) e2 in
      let r = join r1 s1 r2 s2 in
      self.insert
        (Itrywith(s1.extract,
                  instr_cons (Iop Imove) [|Proc.loc_exn_bucket|] rv
                             s2.extract))
        [||] [||];
      r
 );

 emit_sequence = (fun env exp ->
  let s =
   (* {< instr_seq = dummy_instr >}  *)
    failwith "Selectgen.emit_sequence:TODO"
  in
  let r = s.emit_expr s env exp in
  (r, s)
 );

 emit_let = (fun self env v e1 ->
  let r1 = self.emit_expr self  env e1 in
  if all_regs_anonymous r1 then begin
    name_regs v r1;
    Tbl.add v r1 env
  end else begin
    let rv = Array.create (Array.length r1) Reg.dummy in
    for i = 0 to Array.length r1 - 1 do rv.(i) <- Reg.create r1.(i).typ done;
    name_regs v rv;
    self.insert_moves self r1 rv;
    Tbl.add v rv env
  end
 );

 emit_parts = (fun self env exp ->
  if is_simple_expr exp then
    (exp, env)
  else begin
    let r = self.emit_expr self  env exp in
    if Array.length r = 0 then
      (Ctuple [], env)
    else begin
      let id = Ident.create "bind" in
      if all_regs_anonymous r then
        (Cvar id, Tbl.add id r env)
      else begin
        let rv = Array.create (Array.length r) Reg.dummy in
        for i = 0 to Array.length r - 1 do
          rv.(i) <- Reg.create r.(i).typ
        done;
        self.insert_moves self r rv;
        (Cvar id, Tbl.add id rv env)
      end          
    end
  end
 );

 emit_parts_list = (fun self env exp_list ->
  match exp_list with
    [] -> ([], env)
  | exp :: rem ->
      (* This ensures right-to-left evaluation, consistent with the
         bytecode compiler *)
      let (new_rem, new_env) = self.emit_parts_list self env rem in
      let (new_exp, fin_env) = self.emit_parts self new_env exp in
      (new_exp :: new_rem, fin_env)
 );

 emit_tuple = (fun self env exp_list ->
  let rec emit_list = function
    [] -> []
  | exp :: rem ->
      (* Again, force right-to-left evaluation *)
      let loc_rem = emit_list rem in
      let loc_exp = self.emit_expr self  env exp in
      loc_exp :: loc_rem in
  Array.concat(emit_list exp_list)
 );

 emit_extcall_args = (fun self env args ->
  let r1 = self.emit_tuple self env args in
  let (loc_arg, stack_ofs as arg_stack) = Proc.loc_external_arguments r1 in
  self.insert_move_args self r1 loc_arg stack_ofs;
  arg_stack
 );

 emit_stores = (fun self env data regs_addr addr ->
  let a = ref addr in
  List.iter
    (fun e ->
      let (op, arg) = self.select_store !a e in
      let r = self.emit_expr self  env arg in
      self.insert (Iop op) (Array.append r regs_addr) [||];
      a := Arch.offset_addressing !a (size_expr env e))
    data
 );

(* Same, but in tail position *)

 emit_return = (fun self env exp ->
  let r = self.emit_expr self  env exp in
  let loc = Proc.loc_results r in
  self.insert_moves self r loc;
  self.insert Ireturn loc [||]
 );

 emit_tail = (fun self env exp ->
  match exp with
    Clet(v, e1, e2) ->
      self.emit_tail self (self.emit_let self env v e1) e2
  | Cop(Capply ty as op, args) ->
      let (simple_args, env) = self.emit_parts_list self env args in
      let (new_op, new_args) = self.select_operation self op simple_args in
      begin match new_op with
        Icall_ind ->
          let r1 = self.emit_tuple self env new_args in
          let rarg = Array.sub r1 1 (Array.length r1 - 1) in
          let (loc_arg, stack_ofs) = Proc.loc_arguments rarg in
          if stack_ofs = 0 then begin
            self.insert_moves self rarg loc_arg;
            self.insert (Iop Itailcall_ind)
                        (Array.append [|r1.(0)|] loc_arg) [||]
          end else begin
            Proc.contains_calls := true;
            let rd = Reg.createv ty in
            let loc_res = Proc.loc_results rd in
            self.insert_move_args self rarg loc_arg stack_ofs;
            self.insert (Iop Icall_ind)
                        (Array.append [|r1.(0)|] loc_arg) loc_res;
            self.insert(Iop(Istackoffset(-stack_ofs))) [||] [||];
            self.insert Ireturn loc_res [||]
          end
      | Icall_imm lbl ->
          let r1 = self.emit_tuple self env new_args in
          let (loc_arg, stack_ofs) = Proc.loc_arguments r1 in
          if stack_ofs = 0 then begin
            self.insert_moves self r1 loc_arg;
            self.insert (Iop(Itailcall_imm lbl)) loc_arg [||]
          end else begin
            Proc.contains_calls := true;
            let rd = Reg.createv ty in
            let loc_res = Proc.loc_results rd in
            self.insert_move_args self r1 loc_arg stack_ofs;
            self.insert (Iop(Icall_imm lbl)) loc_arg loc_res;
            self.insert(Iop(Istackoffset(-stack_ofs))) [||] [||];
            self.insert Ireturn loc_res [||]
          end
      | _ -> fatal_error "Selection.emit_tail"
      end
  | Cop(Craise, [e1]) ->
      let r1 = self.emit_expr self  env e1 in
      let rd = [|Proc.loc_exn_bucket|] in
      self.insert (Iop Imove) r1 rd;
      self.insert Iraise rd [||]
  | Csequence(e1, e2) ->
      self.emit_expr self env e1;
      self.emit_tail self env e2
  | Cifthenelse(econd, eif, eelse) ->
      let (cond, earg) = self.select_condition self econd in
      let rarg = self.emit_expr self  env earg in
      self.insert (Iifthenelse(cond, self.emit_tail_sequence self env eif,
                                     self.emit_tail_sequence self env eelse))
                  rarg [||]
  | Cswitch(esel, index, ecases) ->
      let rsel = self.emit_expr self  env esel in
      self.insert
        (Iswitch(index, Array.map (self.emit_tail_sequence self env) ecases))
        rsel [||]
  | Ccatch(e1, e2) ->
      self.insert (Icatch(self.emit_tail_sequence self env e1,
                          self.emit_tail_sequence self env e2))
                  [||] [||]
  | Cexit ->
      self.insert Iexit [||] [||]
  | Ctrywith(e1, v, e2) ->
      Proc.contains_calls := true;
      let (r1, s1) = self.emit_sequence env e1 in
      let rv = Reg.createv typ_addr in
      let s2 = self.emit_tail_sequence self (Tbl.add v rv env) e2 in
      let loc = Proc.loc_results r1 in
      self.insert
        (Itrywith(s1.extract,
                  instr_cons (Iop Imove) [|Proc.loc_exn_bucket|] rv s2))
        [||] [||];
      self.insert_moves self r1 loc;
      self.insert Ireturn loc [||]
  | _ ->
      self.emit_return self env exp
 );

 emit_tail_sequence = (fun self env exp ->
  let s = 
   (* {< instr_seq = dummy_instr >}  *)
    failwith "emit_tail_sequence:TODO"
  in
  s.emit_tail s env exp;
  s.extract
 );

(* Sequentialization of a function definition *)

 emit_fundecl = (fun self f ->
  Proc.contains_calls := false;
  let rargs =
    List.map
      (fun (id, ty) -> let r = Reg.createv ty in name_regs id r; r)
      f.Cmm.fun_args in
  let rarg = Array.concat rargs in
  let loc_arg = Proc.loc_parameters rarg in
  let env =
    List.fold_right2
      (fun (id, ty) r env -> Tbl.add id r env)
      f.Cmm.fun_args rargs Tbl.empty in
  self.insert_moves self loc_arg rarg;
  self.emit_tail self env f.Cmm.fun_body;
  { fun_name = f.Cmm.fun_name;
    fun_args = loc_arg;
    fun_body = self.extract;
    fun_fast = f.Cmm.fun_fast }
 );

  select_floatarith = (fun _ -> failwith "select_floatarith");
  select_push = (fun _ -> failwith "select_floatarith");
 }
@


%-------------------------------------------------------------

<<asmcomp/selectgen.ml>>=
<<copyright header>>

(* Selection of pseudo-instructions, assignment of pseudo-registers,
   sequentialization. *)

open Misc
open Cmm
open Reg
open Mach

<<type Selectgen.environment (asmcomp/selectgen.ml)>>

<<type Selectgen.selector (asmcomp/selectgen.ml)>>




<<function Selectgen.oper_result_type>>

<<function Selectgen.size_expr>>

<<function Selectgen.is_simple_expr>>

<<function Selectgen.swap_intcomp>>

<<function Selectgen.all_regs_anonymous>>

<<function Selectgen.name_regs>>

<<function Selectgen.join>>

<<function Selectgen.join_array>>

<<function Selectgen.selector_generic>>

@


\subsection*{[[asmcomp/cmmgen.mli]]}

<<signature Cmmgen.compunit>>=
(* Translation from closed lambda to C-- *)

val compunit: int -> Clambda.ulambda -> Cmm.phrase list
@

<<signature Cmmgen.apply_function>>=
val apply_function: int -> Cmm.phrase
@

<<signature Cmmgen.curry_function>>=
val curry_function: int -> Cmm.phrase list
@

<<signature Cmmgen.entry_point>>=
val entry_point: string list -> Cmm.phrase
@

<<signature Cmmgen.global_table>>=
val global_table: string list -> Cmm.phrase
@

<<signature Cmmgen.frame_table>>=
val frame_table: string list -> Cmm.phrase
@

<<signature Cmmgen.data_segment_table>>=
val data_segment_table: string list -> Cmm.phrase
@

<<signature Cmmgen.code_segment_table>>=
val code_segment_table: string list -> Cmm.phrase
@

<<signature Cmmgen.predef_exception>>=
val predef_exception: string -> Cmm.phrase
@


%-------------------------------------------------------------

<<asmcomp/cmmgen.mli>>=
<<copyright header>>

<<signature Cmmgen.compunit>>

<<signature Cmmgen.apply_function>>
<<signature Cmmgen.curry_function>>
<<signature Cmmgen.entry_point>>
<<signature Cmmgen.global_table>>
<<signature Cmmgen.frame_table>>
<<signature Cmmgen.data_segment_table>>
<<signature Cmmgen.code_segment_table>>
<<signature Cmmgen.predef_exception>>
@


\subsection*{[[asmcomp/cmmgen.ml]]}

<<function Cmmgen.bind>>=
(* Local binding of complex expressions *)

let bind name arg fn =
  match arg with
    Cvar _ | Cconst_int _ | Cconst_natint _ | Cconst_symbol _
  | Cconst_pointer _ -> fn arg
  | _ -> let id = Ident.create name in Clet(id, arg, fn (Cvar id))
@

<<constant Cmmgen.float_tag>>=
(* Block headers. Meaning of the tag field:
       0 - 248: regular blocks
       249: infix closure
       250: closures
       251: abstract
       252: string
       253: float
       254: float array
       255: finalized *)

let float_tag = Cconst_int 253
@

<<constant Cmmgen.floatarray_tag>>=
let floatarray_tag = Cconst_int 254
@

<<function Cmmgen.block_header>>=
let block_header tag sz =
  Nativeint.add (Nativeint.shift (Nativeint.from sz) 10) (Nativeint.from tag)
@

<<function Cmmgen.closure_header>>=
let closure_header sz = block_header 250 sz
@

<<function Cmmgen.infix_header>>=
let infix_header ofs = block_header 249 ofs
@

<<constant Cmmgen.float_header>>=
let float_header = block_header 253 (size_float / size_addr)
@

<<function Cmmgen.floatarray_header>>=
let floatarray_header len = block_header 254 (len * size_float / size_addr)
@

<<function Cmmgen.string_header>>=
let string_header len = block_header 252 ((len + size_addr) / size_addr)
@

<<function Cmmgen.alloc_block_header>>=
let alloc_block_header tag sz = Cconst_natint(block_header tag sz)
@

<<constant Cmmgen.alloc_float_header>>=
let alloc_float_header = Cconst_natint(float_header)
@

<<function Cmmgen.alloc_floatarray_header>>=
let alloc_floatarray_header len = Cconst_natint(floatarray_header len)
@

<<function Cmmgen.alloc_closure_header>>=
let alloc_closure_header sz = Cconst_natint(closure_header sz)
@

<<function Cmmgen.alloc_infix_header>>=
let alloc_infix_header ofs = Cconst_natint(infix_header ofs)
@

<<constant Cmmgen.max_repr_int>>=
(* Integers *)

let max_repr_int = max_int asr 1
@

<<constant Cmmgen.min_repr_int>>=
let min_repr_int = min_int asr 1
@

<<function Cmmgen.int_const>>=
let int_const n =
  if n <= max_repr_int & n >= min_repr_int
  then Cconst_int((n lsl 1) + 1)
  else Cconst_natint(Nativeint.add (Nativeint.shift (Nativeint.from n) 1)
                                   (Nativeint.from 1))
@

<<function Cmmgen.add_const>>=
let add_const c n =
  if n = 0 then c else Cop(Caddi, [c; Cconst_int n])
@

<<function Cmmgen.incr_int>>=
let incr_int = function
    Cconst_int n when n < max_int -> Cconst_int(n+1)
  | Cop(Caddi, [c; Cconst_int n]) when n < max_int -> add_const c (n+1)
  | c -> add_const c 1
@

<<function Cmmgen.decr_int>>=
let decr_int = function
    Cconst_int n when n > min_int -> Cconst_int(n-1)
  | Cop(Caddi, [c; Cconst_int n]) when n > min_int -> add_const c (n-1)
  | c -> add_const c (-1)
@

<<function Cmmgen.add_int>>=
let add_int c1 c2 =
  match (c1, c2) with
    (Cop(Caddi, [c1; Cconst_int n1]),
     Cop(Caddi, [c2; Cconst_int n2])) when no_overflow_add n1 n2 ->
      add_const (Cop(Caddi, [c1; c2])) (n1 + n2)
  | (Cop(Caddi, [c1; Cconst_int n1]), c2) ->
      add_const (Cop(Caddi, [c1; c2])) n1
  | (c1, Cop(Caddi, [c2; Cconst_int n2])) ->
      add_const (Cop(Caddi, [c1; c2])) n2
  | (c1, c2) ->
      Cop(Caddi, [c1; c2])
@

<<function Cmmgen.sub_int>>=
let sub_int c1 c2 =
  match (c1, c2) with
    (Cop(Caddi, [c1; Cconst_int n1]),
     Cop(Caddi, [c2; Cconst_int n2])) when no_overflow_sub n1 n2 ->
      add_const (Cop(Csubi, [c1; c2])) (n1 - n2)
  | (Cop(Caddi, [c1; Cconst_int n1]), c2) ->
      add_const (Cop(Csubi, [c1; c2])) n1
  | (c1, Cop(Caddi, [c2; Cconst_int n2])) when n2 <> min_int ->
      add_const (Cop(Csubi, [c1; c2])) (-n2)
  | (c1, Cconst_int n) when n <> min_int ->
      add_const c1 (-n)
  | (c1, c2) ->
      Cop(Csubi, [c1; c2])
@

<<function Cmmgen.tag_int>>=
let tag_int = function
    Cconst_int n -> int_const n
  | c -> Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1])
@

<<function Cmmgen.untag_int>>=
let untag_int = function
    Cconst_int n -> Cconst_int(n asr 1)
  | Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1]) -> c
  | c -> Cop(Casr, [c; Cconst_int 1])
@

<<function Cmmgen.test_bool>>=
(* Bool *)

let test_bool = function
    Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1]) -> c
  | Cop(Clsl, [c; Cconst_int 1]) -> c
  | c -> Cop(Ccmpi Cne, [c; Cconst_int 1])
@

<<function Cmmgen.box_float>>=
(* Float *)

let box_float c = Cop(Calloc, [alloc_float_header; c])
@

<<function Cmmgen.unbox_float>>=
let unbox_float = function
    Cop(Calloc, [header; c]) -> c
  | c -> Cop(Cload typ_float, [c])
@

<<function Cmmgen.is_unboxed_float>>=
let is_unboxed_float = function
    Uconst(Const_base(Const_float f)) -> true
  | Uprim(p, _) ->
      begin match p with
          Pccall p -> p.prim_native_float
        | Pfloatfield _ | Pfloatofint | Pnegfloat | Pabsfloat
        | Paddfloat | Psubfloat | Pmulfloat | Pdivfloat
        | Parrayrefu Pfloatarray | Parrayrefs Pfloatarray -> true
        | _ -> false
      end
  | _ -> false
@

<<exception Cmmgen.Cannot_subst_float>>=
exception Cannot_subst_float
@

<<function Cmmgen.subst_boxed_float>>=
let subst_boxed_float boxed_id unboxed_id exp =
  let need_boxed = ref false in
  let assigned = ref false in
  let rec subst = function
      Cvar id as e ->
        if Ident.same id boxed_id then need_boxed := true; e
    | Clet(id, arg, body) -> Clet(id, subst arg, subst body)
    | Cassign(id, arg) -> 
        if Ident.same id boxed_id then begin
          assigned := true;
          Cassign(unboxed_id, subst(unbox_float arg))
        end else
          Cassign(id, subst arg)
    | Ctuple argl -> Ctuple(List.map subst argl)
    | Cop(Cload _, [Cvar id]) as e ->
        if Ident.same id boxed_id then Cvar unboxed_id else e
    | Cop(op, argl) -> Cop(op, List.map subst argl)
    | Csequence(e1, e2) -> Csequence(subst e1, subst e2)
    | Cifthenelse(e1, e2, e3) -> Cifthenelse(subst e1, subst e2, subst e3)
    | Cswitch(arg, index, cases) ->
        Cswitch(subst arg, index, Array.map subst cases)
    | Cloop e -> Cloop(subst e)
    | Ccatch(e1, e2) -> Ccatch(subst e1, subst e2)
    | Ctrywith(e1, id, e2) -> Ctrywith(subst e1, id, subst e2)
    | e -> e in
  let res = subst exp in
  (res, !need_boxed, !assigned)  
@

<<function Cmmgen.return_unit>>=
(* Unit *)

let return_unit c = Csequence(c, Cconst_pointer 1)
@

<<function Cmmgen.remove_unit>>=
let rec remove_unit = function
    Cconst_pointer 1 -> Ctuple []
  | Csequence(c, Cconst_pointer 1) -> c
  | Csequence(c1, c2) ->
      Csequence(c1, remove_unit c2)
  | Cifthenelse(cond, ifso, ifnot) ->
      Cifthenelse(cond, remove_unit ifso, remove_unit ifnot)
  | Cswitch(sel, index, cases) ->
      Cswitch(sel, index, Array.map remove_unit cases)
  | Ccatch(body, handler) ->
      Ccatch(remove_unit body, remove_unit handler)
  | Ctrywith(body, exn, handler) ->
      Ctrywith(remove_unit body, exn, remove_unit handler)
  | Clet(id, c1, c2) ->
      Clet(id, c1, remove_unit c2)
  | Cop(Capply mty, args) ->
      Cop(Capply [||], args)
  | Cop(Cextcall(proc, mty, alloc), args) ->
      Cop(Cextcall(proc, [||], alloc), args)
  | Cexit -> Cexit
  | Ctuple [] as c -> c
  | c -> Csequence(c, Ctuple [])
@

<<function Cmmgen.field_address>>=
(* Access to block fields *)

let field_address ptr n =
  if n = 0
  then ptr
  else Cop(Cadda, [ptr; Cconst_int(n * size_addr)])
@

<<function Cmmgen.get_field>>=
let get_field ptr n =
  Cop(Cload typ_addr, [field_address ptr n])
@

<<function Cmmgen.set_field>>=
let set_field ptr n newval =
  Cop(Cstore, [field_address ptr n; newval])
@

<<function Cmmgen.header>>=
let header ptr =
  Cop(Cload typ_int, [Cop(Cadda, [ptr; Cconst_int(-size_int)])])
@

<<constant Cmmgen.tag_offset>>=
let tag_offset =
  if big_endian then -1 else -size_int
@

<<function Cmmgen.get_tag>>=
let get_tag ptr =
  if Proc.word_addressed then           (* If byte loads are slow *)
    Cop(Cand, [header ptr; Cconst_int 255])
  else                                  (* If byte loads are efficient *)
    Cop(Cloadchunk Byte_unsigned,
        [Cop(Cadda, [ptr; Cconst_int(tag_offset)])])
@

<<constant Cmmgen.log2_size_addr>>=
(* Array indexing *)

let log2_size_addr = Misc.log2 size_addr
@

<<constant Cmmgen.log2_size_float>>=
let log2_size_float = Misc.log2 size_float
@

<<constant Cmmgen.wordsize_shift>>=
let wordsize_shift = 9
@

<<constant Cmmgen.numfloat_shift>>=
let numfloat_shift = 9 + log2_size_float - log2_size_addr
@

<<function Cmmgen.is_addr_array>>=
let is_addr_array hdr =
  Cop(Ccmpi Cne, [Cop(Cand, [hdr; Cconst_int 255]); floatarray_tag])
@

<<function Cmmgen.addr_array_length>>=
let addr_array_length hdr = Cop(Clsr, [hdr; Cconst_int wordsize_shift])
@

<<function Cmmgen.float_array_length>>=
let float_array_length hdr = Cop(Clsr, [hdr; Cconst_int numfloat_shift])
@

<<function Cmmgen.lsl_const>>=
let lsl_const c n =
  Cop(Clsl, [c; Cconst_int n])
@

<<function Cmmgen.array_indexing>>=
let array_indexing log2size ptr ofs =
  match ofs with
    Cconst_int n ->
      let i = n asr 1 in
      if i = 0 then ptr else Cop(Cadda, [ptr; Cconst_int(i lsl log2size)])
  | Cop(Caddi, [Cop(Clsl, [c; Cconst_int 1]); Cconst_int 1]) ->
      Cop(Cadda, [ptr; lsl_const c log2size])
  | Cop(Caddi, [c; Cconst_int n]) ->
      Cop(Cadda, [Cop(Cadda, [ptr; lsl_const c (log2size - 1)]);
                  Cconst_int((n-1) lsl (log2size - 1))])
  | _ ->
      Cop(Cadda, [Cop(Cadda, [ptr; lsl_const ofs (log2size - 1)]);
                  Cconst_int((-1) lsl (log2size - 1))])
@

<<function Cmmgen.addr_array_ref>>=
let addr_array_ref arr ofs =
  Cop(Cload typ_addr, [array_indexing log2_size_addr arr ofs])
@

<<function Cmmgen.unboxed_float_array_ref>>=
let unboxed_float_array_ref arr ofs =
  Cop(Cload typ_float, [array_indexing log2_size_float arr ofs])
@

<<function Cmmgen.float_array_ref>>=
let float_array_ref arr ofs =
  box_float(unboxed_float_array_ref arr ofs)
@

<<function Cmmgen.addr_array_set>>=
let addr_array_set arr ofs newval =
  Cop(Cextcall("modify", typ_void, false),
      [array_indexing log2_size_addr arr ofs; newval])
@

<<function Cmmgen.int_array_set>>=
let int_array_set arr ofs newval =
  Cop(Cstore, [array_indexing log2_size_addr arr ofs; newval])
@

<<function Cmmgen.float_array_set>>=
let float_array_set arr ofs newval =
  Cop(Cstore, [array_indexing log2_size_float arr ofs; newval])
@

<<function Cmmgen.string_length>>=
(* String length *)

let string_length exp =
  bind "str" exp (fun str ->
    let tmp_var = Ident.create "tmp" in
    Clet(tmp_var,
         Cop(Csubi,
             [Cop(Clsl,
                  [Cop(Clsr, [get_field str (-1); Cconst_int 10]);
                   Cconst_int log2_size_addr]);
              Cconst_int 1]),
         Cop(Csubi,
             [Cvar tmp_var;
              Cop(Cloadchunk Byte_unsigned,
                  [Cop(Cadda, [str; Cvar tmp_var])])])))
@

<<function Cmmgen.fundecls_size>>=
(* To compile "let rec" over values *)

let fundecls_size fundecls =
  let sz = ref (-1) in
  List.iter
    (fun (label, arity, params, body) ->
      sz := !sz + 1 + (if arity = 1 then 2 else 3))
    fundecls;
  !sz
@

<<function Cmmgen.expr_size_and_tag>>=
let rec expr_size_and_tag = function
    Uclosure(fundecls, clos_vars) ->
      (fundecls_size fundecls + List.length clos_vars, 250)
  | Uprim(Pmakeblock(tag, mut), args) ->
      (List.length args, tag)
  | Uprim(Pmakearray(Paddrarray | Pintarray), args) ->
      (List.length args, 0)
  | Ulet(id, exp, body) ->
      expr_size_and_tag body
  | Uletrec(bindings, body) ->
      expr_size_and_tag body
  | _ ->
      fatal_error "Cmmgen.expr_size_and_tag"
@

<<function Cmmgen.dummy_block>>=
let dummy_block (size, tag) =
  let rec init_val i =
    if i >= size then [] else Cconst_int 0 :: init_val(i+1) in
  Cop(Calloc, alloc_block_header tag size :: init_val 0)
@

<<function Cmmgen.apply_function>>=
(* Record application and currying functions *)

let apply_function n =
  Compilenv.need_apply_fun n; "caml_apply" ^ string_of_int n
@

<<function Cmmgen.curry_function>>=
let curry_function n =
  Compilenv.need_curry_fun n;
  if n >= 0
  then "caml_curry" ^ string_of_int n
  else "caml_tuplify" ^ string_of_int (-n)
@

<<function Cmmgen.transl_comparison>>=
(* Comparisons *)

let transl_comparison = function
    Lambda.Ceq -> Ceq
  | Lambda.Cneq -> Cne
  | Lambda.Cge -> Cge
  | Lambda.Cgt -> Cgt
  | Lambda.Cle -> Cle
  | Lambda.Clt -> Clt
@

<<constant Cmmgen.const_label>>=
(* Translate structured constants *)

let const_label = ref 0
@

<<function Cmmgen.new_const_label>>=
let new_const_label () =
  incr const_label;
  !const_label
@

<<function Cmmgen.new_const_symbol>>=
let new_const_symbol () =
  incr const_label;
  Compilenv.current_unit_name () ^ "_" ^ string_of_int !const_label
@

<<constant Cmmgen.structured_constants>>=
let structured_constants =
@

<<function Cmmgen.transl_constant>>=
let transl_constant = function
    Const_base(Const_int n) ->
      int_const n
  | Const_base(Const_char c) ->
      Cconst_int(((Char.code c) lsl 1) + 1)
  | Const_pointer n ->
      Cconst_pointer((n lsl 1) + 1)
  | cst ->
      let lbl =
        try
          Hashtbl.find structured_constants cst
        with Not_found ->
          let lbl = new_const_symbol() in
          Hashtbl.add structured_constants cst lbl;
          lbl
      in Cconst_symbol lbl
@

<<constant Cmmgen.functions>>=
(* Translate an expression *)

let functions = (Queue.create() : (string * Ident.t list * ulambda) Queue.t)
@

<<function Cmmgen.transl_function>>=
(* Translate a function definition *)

let transl_function lbl params body =
  Cfunction {fun_name = lbl;
             fun_args = List.map (fun id -> (id, typ_addr)) params;
             fun_body = transl body;
             fun_fast = !Clflags.optimize_for_speed}
@

<<function Cmmgen.transl_all_functions>>=
let rec transl_all_functions already_translated cont =
  try
    let (lbl, params, body) = Queue.take functions in
    if StringSet.mem lbl already_translated then
      transl_all_functions already_translated cont
    else
      transl_all_functions (StringSet.add lbl already_translated)
                           (transl_function lbl params body :: cont)
  with Queue.Empty ->
    cont
@

<<function Cmmgen.emit_all_constants>>=
(* Emit all structured constants *)

let emit_all_constants cont =
  let c = ref cont in
  Hashtbl.iter
    (fun cst lbl -> c := Cdata(emit_constant lbl cst []) :: !c)
    structured_constants;
  Hashtbl.clear structured_constants;
  !c
@

<<function Cmmgen.compunit>>=
(* Translate a compilation unit *)

let compunit size ulam =
  let glob = Compilenv.current_unit_name () in
  let init_code = transl ulam in
  let c1 = [Cfunction {fun_name = glob ^ "_entry"; fun_args = [];
                       fun_body = init_code; fun_fast = false}] in
  let c2 = transl_all_functions StringSet.empty c1 in
  let c3 = emit_all_constants c2 in
  Cdata [Cint(block_header 0 size);
         Cdefine_symbol glob;
         Cskip(size * size_addr)] :: c3
@

<<function Cmmgen.apply_function (asmcomp/cmmgen.ml)>>=
(* Generate an application function:
     (defun caml_applyN (a1 ... aN clos)
       (if (= clos.arity N)
         (app clos.direct a1 ... aN clos)
         (let (clos1 (app clos.code a1 clos)
               clos2 (app clos1.code a2 clos)
               ...
               closN-1 (app closN-2.code aN-1 closN-2))
           (app closN-1.code aN closN-1))))
*)

let apply_function arity =
  let arg = Array.create arity (Ident.create "arg") in
  for i = 1 to arity - 1 do arg.(i) <- Ident.create "arg" done;
  let clos = Ident.create "clos" in
  let rec app_fun clos n =
    if n = arity-1 then
      Cop(Capply typ_addr,
          [get_field (Cvar clos) 0; Cvar arg.(n); Cvar clos])
    else begin
      let newclos = Ident.create "clos" in
      Clet(newclos,
           Cop(Capply typ_addr,
               [get_field (Cvar clos) 0; Cvar arg.(n); Cvar clos]),
           app_fun newclos (n+1))
    end in
  let all_args = Array.to_list arg @ [clos] in
  let body =
    Cifthenelse(
      Cop(Ccmpi Ceq, [get_field (Cvar clos) 1; int_const arity]),
      Cop(Capply typ_addr,
          get_field (Cvar clos) 2 :: List.map (fun s -> Cvar s) all_args),
      app_fun clos 0) in
  Cfunction
   {fun_name = "caml_apply" ^ string_of_int arity;
    fun_args = List.map (fun id -> (id, typ_addr)) all_args;
    fun_body = body;
    fun_fast = true}
@

<<function Cmmgen.tuplify_function>>=
(* Generate tuplifying functions:
      (defun caml_tuplifyN (arg clos)
        (app clos.direct #0(arg) ... #N-1(arg) clos)) *)

let tuplify_function arity =
  let arg = Ident.create "arg" in
  let clos = Ident.create "clos" in
  let rec access_components i =
    if i >= arity
    then []
    else get_field (Cvar arg) i :: access_components(i+1) in
  Cfunction
   {fun_name = "caml_tuplify" ^ string_of_int arity;
    fun_args = [arg, typ_addr; clos, typ_addr];
    fun_body =
      Cop(Capply typ_addr,
          get_field (Cvar clos) 2 :: access_components 0 @ [Cvar clos]);
    fun_fast = true}
@

<<function Cmmgen.final_curry_function>>=
(* Generate currying functions:
      (defun caml_curryN (arg clos)
         (alloc HDR caml_curryN_1 arg clos))
      (defun caml_curryN_1 (arg clos)
         (alloc HDR caml_curryN_2 arg clos))
      ...
      (defun caml_curryN_N-1 (arg clos)
         (let (closN-2 clos.cdr
               closN-3 closN-2.cdr
               ...
               clos1 clos2.cdr
               clos clos1.cdr)
           (app clos.direct
                clos1.car clos2.car ... closN-2.car clos.car arg clos))) *)

let final_curry_function arity =
  let last_arg = Ident.create "arg" in
  let last_clos = Ident.create "clos" in
  let rec curry_fun args clos n =
    if n = 0 then
      Cop(Capply typ_addr,
          get_field (Cvar clos) 2 ::
          args @ [Cvar last_arg; Cvar clos])
    else begin
      let newclos = Ident.create "clos" in
      Clet(newclos,
           get_field (Cvar clos) 3,
           curry_fun (get_field (Cvar clos) 2 :: args) newclos (n-1))
    end in
  Cfunction
   {fun_name = "caml_curry" ^ string_of_int arity ^
               "_" ^ string_of_int (arity-1);
    fun_args = [last_arg, typ_addr; last_clos, typ_addr];
    fun_body = curry_fun [] last_clos (arity-1);
    fun_fast = true}
@

<<function Cmmgen.intermediate_curry_functions>>=
let rec intermediate_curry_functions arity num =
  if num = arity - 1 then
    [final_curry_function arity]
  else begin
    let name1 = "caml_curry" ^ string_of_int arity in
    let name2 = if num = 0 then name1 else name1 ^ "_" ^ string_of_int num in
    let arg = Ident.create "arg" and clos = Ident.create "clos" in
    Cfunction
     {fun_name = name2;
      fun_args = [arg, typ_addr; clos, typ_addr];
      fun_body = Cop(Calloc,
                     [alloc_closure_header 4; 
                      Cconst_symbol(name1 ^ "_" ^ string_of_int (num+1));
                      int_const 1; Cvar arg; Cvar clos]);
      fun_fast = true}
    :: intermediate_curry_functions arity (num+1)
  end
@

<<function Cmmgen.curry_function (asmcomp/cmmgen.ml)>>=
let curry_function arity =
  if arity >= 0
  then intermediate_curry_functions arity 0
  else [tuplify_function (-arity)]
@

<<function Cmmgen.entry_point>>=
(* Generate the entry point *)

let entry_point namelist =
  let body =
    List.fold_right
      (fun name next ->
        Csequence(Cop(Capply typ_void, [Cconst_symbol(name ^ "_entry")]),
                  next))
      namelist (Ctuple []) in
  Cfunction {fun_name = "caml_program";
             fun_args = [];
             fun_body = body;
             fun_fast = false}
@

<<constant Cmmgen.cint_zero>>=
(* Generate the table of globals *)

let cint_zero = Cint(Nativeint.from 0)
@

<<function Cmmgen.global_table>>=
let global_table namelist =
  Cdata(Cdefine_symbol "caml_globals" ::
        List.map (fun name -> Csymbol_address name) namelist @
        [cint_zero])
@

<<function Cmmgen.frame_table>>=
(* Generate the master table of frame descriptors *)

let frame_table namelist =
  Cdata(Cdefine_symbol "caml_frametable" ::
        List.map (fun name -> Csymbol_address(name ^ "_frametable")) namelist @
        [cint_zero])
@

<<function Cmmgen.segment_table>>=
(* Generate the table of module data and code segments *)

let segment_table namelist symbol begname endname =
  Cdata(Cdefine_symbol symbol ::
        List.fold_right
          (fun name lst ->
            Csymbol_address(name ^ begname) ::
            Csymbol_address(name ^ endname) :: lst)
          namelist
          [cint_zero])
@

<<function Cmmgen.data_segment_table>>=
let data_segment_table namelist =
  segment_table namelist "caml_data_segments" "_data_begin" "_data_end"
@

<<function Cmmgen.code_segment_table>>=
let code_segment_table namelist =
  segment_table namelist "caml_code_segments" "_code_begin" "_code_end"
@

<<function Cmmgen.predef_exception>>=
(* Initialize a predefined exception *)

let predef_exception name =
  Cdata(emit_constant name (Const_block(0,[Const_base(Const_string name)])) [])
@


%-------------------------------------------------------------

<<asmcomp/cmmgen.ml>>=
<<copyright header>>

(* Translation from closed lambda to C-- *)

open Misc
open Arch
open Asttypes
open Primitive
open Types
open Lambda
open Clambda
open Cmm

<<function Cmmgen.bind>>

<<constant Cmmgen.float_tag>>
<<constant Cmmgen.floatarray_tag>>

<<function Cmmgen.block_header>>
<<function Cmmgen.closure_header>>
<<function Cmmgen.infix_header>>
<<constant Cmmgen.float_header>>
<<function Cmmgen.floatarray_header>>
<<function Cmmgen.string_header>>

<<function Cmmgen.alloc_block_header>>
<<constant Cmmgen.alloc_float_header>>
<<function Cmmgen.alloc_floatarray_header>>
<<function Cmmgen.alloc_closure_header>>
<<function Cmmgen.alloc_infix_header>>

<<constant Cmmgen.max_repr_int>>
<<constant Cmmgen.min_repr_int>>

<<function Cmmgen.int_const>>

<<function Cmmgen.add_const>>

<<function Cmmgen.incr_int>>

<<function Cmmgen.decr_int>>

<<function Cmmgen.add_int>>

<<function Cmmgen.sub_int>>

<<function Cmmgen.tag_int>>

<<function Cmmgen.untag_int>>

<<function Cmmgen.test_bool>>

<<function Cmmgen.box_float>>

<<function Cmmgen.unbox_float>>

<<function Cmmgen.is_unboxed_float>>

<<exception Cmmgen.Cannot_subst_float>>

<<function Cmmgen.subst_boxed_float>>

<<function Cmmgen.return_unit>>

<<function Cmmgen.remove_unit>>

<<function Cmmgen.field_address>>

<<function Cmmgen.get_field>>

<<function Cmmgen.set_field>>

<<function Cmmgen.header>>

<<constant Cmmgen.tag_offset>>

<<function Cmmgen.get_tag>>

<<constant Cmmgen.log2_size_addr>>
<<constant Cmmgen.log2_size_float>>

<<constant Cmmgen.wordsize_shift>>
<<constant Cmmgen.numfloat_shift>>

<<function Cmmgen.is_addr_array>>

<<function Cmmgen.addr_array_length>>
<<function Cmmgen.float_array_length>>

<<function Cmmgen.lsl_const>>

<<function Cmmgen.array_indexing>>

<<function Cmmgen.addr_array_ref>>
<<function Cmmgen.unboxed_float_array_ref>>
<<function Cmmgen.float_array_ref>>

<<function Cmmgen.addr_array_set>>
<<function Cmmgen.int_array_set>>
<<function Cmmgen.float_array_set>>

<<function Cmmgen.string_length>>

<<function Cmmgen.fundecls_size>>

<<function Cmmgen.expr_size_and_tag>>

<<function Cmmgen.dummy_block>>

let rec store_contents ptr = function
    Cop(Calloc, header :: fields) ->
      store_fields ptr 0 fields
  | Clet(id, exp, body) ->
      Clet(id, exp, store_contents ptr body)
  | _ ->
      fatal_error "Cmmgen.store_contents"

and store_fields ptr pos = function
    [] -> Ctuple []
  | c :: rem ->
      let store =
        match c with
          Cconst_int _ | Cconst_symbol _ | Cconst_pointer _ ->
            Cop(Cstore, [field_address ptr pos; c])
        | _ ->
            Cop(Cextcall("modify", typ_void, false),
                [field_address ptr pos; c]) in
      Csequence(store, store_fields ptr (pos + 1) rem)
            

<<function Cmmgen.apply_function>>
<<function Cmmgen.curry_function>>

<<function Cmmgen.transl_comparison>>

<<constant Cmmgen.const_label>>

<<function Cmmgen.new_const_label>>

<<function Cmmgen.new_const_symbol>>

<<constant Cmmgen.structured_constants>>
  (Hashtbl.create 19 : (structured_constant, string) Hashtbl.t)

<<function Cmmgen.transl_constant>>

<<constant Cmmgen.functions>>

let rec transl = function
    Uvar id ->
      Cvar id
  | Uconst sc ->
      transl_constant sc
  | Uclosure(fundecls, clos_vars) ->
      let block_size =
        fundecls_size fundecls + List.length clos_vars in
      let rec transl_fundecls pos = function
        [] ->
          List.map transl clos_vars
      | (label, arity, params, body) :: rem ->
          Queue.add (label, params, body) functions;
          let header =
            if pos = 0
            then alloc_closure_header block_size
            else alloc_infix_header pos in
          if arity = 1 then
            header ::
            Cconst_symbol label ::
            int_const 1 ::
            transl_fundecls (pos + 3) rem
          else
            header ::
            Cconst_symbol(curry_function arity) ::
            int_const arity ::
            Cconst_symbol label ::
            transl_fundecls (pos + 4) rem in
      Cop(Calloc, transl_fundecls 0 fundecls)
  | Uoffset(arg, offset) ->
      field_address (transl arg) offset
  | Udirect_apply(lbl, args) ->
      Cop(Capply typ_addr, Cconst_symbol lbl :: List.map transl args)
  | Ugeneric_apply(clos, [arg]) ->
      bind "fun" (transl clos) (fun clos ->
        Cop(Capply typ_addr, [get_field clos 0; transl arg; clos]))
  | Ugeneric_apply(clos, args) ->
      let arity = List.length args in
      Cop(Capply typ_addr,
          Cconst_symbol(apply_function arity) ::
          List.map transl (args @ [clos]))
  | Ulet(id, exp, body) ->
      if is_unboxed_float exp then begin
        let unboxed_id = Ident.create (Ident.name id) in
        let (tr_body, need_boxed, is_assigned) =
          subst_boxed_float id unboxed_id (transl body) in
        if need_boxed & is_assigned then
          Clet(id, transl exp, transl body)
        else
          Clet(unboxed_id, transl_unbox_float exp,
               if need_boxed
               then Clet(id, box_float(Cvar unboxed_id), tr_body)
               else tr_body)
      end else
        Clet(id, transl exp, transl body)
  | Uletrec(bindings, body) ->
      transl_letrec bindings (transl body)

  (* Primitives *)
  | Uprim(Pidentity, [arg]) ->
      transl arg
  | Uprim(Pgetglobal id, []) ->
      Cconst_symbol(Ident.name id)

  (* Heap blocks *)
  | Uprim(Pmakeblock(tag, mut), []) ->
      transl_constant(Const_block(tag, []))
  | Uprim(Pmakeblock(tag, mut), args) ->
      Cop(Calloc, alloc_block_header tag (List.length args) ::
                  List.map transl args)
  | Uprim(Pfield n, [arg]) ->
      get_field (transl arg) n
  | Uprim(Psetfield(n, ptr), [loc; newval]) ->
      if ptr then
        return_unit(Cop(Cextcall("modify", typ_void, false),
                        [field_address (transl loc) n; transl newval]))
      else
        return_unit(set_field (transl loc) n (transl newval))
  | Uprim(Pfloatfield n, [arg]) ->
      let ptr = transl arg in
      box_float(Cop(Cload typ_float,
                [if n = 0 then ptr
                          else Cop(Cadda, [ptr; Cconst_int(n * size_float)])]))
  | Uprim(Psetfloatfield n, [loc; newval]) ->
      let ptr = transl loc in
      return_unit(Cop(Cstore,
                  [if n = 0 then ptr
                            else Cop(Cadda, [ptr; Cconst_int(n * size_float)]);
                   transl_unbox_float newval]))

  (* External call *)
  | Uprim(Pccall prim, args) ->
      if prim.prim_native_float then
        box_float
          (Cop(Cextcall(prim.prim_native_name, typ_float, false),
               List.map transl_unbox_float args))
      else begin
        let name =
          if prim.prim_native_name <> ""
          then prim.prim_native_name
          else prim.prim_name in
        Cop(Cextcall(name, typ_addr, prim.prim_alloc), List.map transl args)
      end
  (* Exceptions *)
  | Uprim(Praise, [arg]) ->
      Cop(Craise, [transl arg])

  (* Boolean operations *)
  | Uprim(Psequand, [arg1; arg2]) ->
      Cifthenelse(test_bool(transl arg1), transl arg2, Cconst_int 1)
  | Uprim(Psequor, [arg1; arg2]) ->
      Cifthenelse(test_bool(transl arg1), Cconst_int 3, transl arg2)
  | Uprim(Pnot, [arg]) ->
      Cop(Csubi, [Cconst_int 4; transl arg]) (* 1 -> 3, 3 -> 1 *)

  (* Integer operations *)
  | Uprim(Pnegint, [arg]) ->
      Cop(Csubi, [Cconst_int 2; transl arg])
  | Uprim(Paddint, [arg1; arg2]) ->
      decr_int(add_int (transl arg1) (transl arg2))
  | Uprim(Psubint, [arg1; arg2]) ->
      incr_int(sub_int (transl arg1) (transl arg2))
  | Uprim(Pmulint, [arg1; arg2]) ->
      incr_int(Cop(Cmuli, [decr_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Pdivint, [arg1; arg2]) ->
      tag_int(Cop(Cdivi, [untag_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Pmodint, [arg1; arg2]) ->
      tag_int(Cop(Cmodi, [untag_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Pandint, [arg1; arg2]) ->
      Cop(Cand, [transl arg1; transl arg2])
  | Uprim(Porint, [arg1; arg2]) ->
      Cop(Cor, [transl arg1; transl arg2])
  | Uprim(Pxorint, [arg1; arg2]) ->
      incr_int(Cop(Cxor, [transl arg1; transl arg2]))
  | Uprim(Plslint, [arg1; arg2]) ->
      incr_int(Cop(Clsl, [decr_int(transl arg1); untag_int(transl arg2)]))
  | Uprim(Plsrint, [arg1; arg2]) ->
      Cop(Cor, [Cop(Clsr, [transl arg1; untag_int(transl arg2)]);
                Cconst_int 1])
  | Uprim(Pasrint, [arg1; arg2]) ->
      Cop(Cor, [Cop(Casr, [transl arg1; untag_int(transl arg2)]);
                Cconst_int 1])
  | Uprim(Pintcomp cmp, [arg1; arg2]) ->
      tag_int(Cop(Ccmpi(transl_comparison cmp), [transl arg1; transl arg2]))
  | Uprim(Poffsetint n, [arg]) ->
      add_const (transl arg) (n lsl 1)
  | Uprim(Poffsetref n, [arg]) ->
      return_unit
        (bind "ref" (transl arg) (fun arg ->
          Cop(Cstore,
              [arg; add_const (Cop(Cload typ_int, [arg])) (n lsl 1)])))

  (* Float operations *)
  | Uprim(Pfloatofint, [arg]) ->
      box_float(Cop(Cfloatofint, [untag_int(transl arg)]))
  | Uprim(Pintoffloat, [arg]) ->
     tag_int(Cop(Cintoffloat, [transl_unbox_float arg]))
  | Uprim(Pnegfloat, [arg]) ->
      box_float(Cop(Cnegf, [transl_unbox_float arg]))
  | Uprim(Pabsfloat, [arg]) ->
      box_float(Cop(Cabsf, [transl_unbox_float arg]))
  | Uprim(Paddfloat, [arg1; arg2]) ->
      box_float(Cop(Caddf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Psubfloat, [arg1; arg2]) ->
      box_float(Cop(Csubf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Pmulfloat, [arg1; arg2]) ->
      box_float(Cop(Cmulf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Pdivfloat, [arg1; arg2]) ->
      box_float(Cop(Cdivf, [transl_unbox_float arg1; transl_unbox_float arg2]))
  | Uprim(Pfloatcomp cmp, [arg1; arg2]) ->
      tag_int(Cop(Ccmpf(transl_comparison cmp),
                  [transl_unbox_float arg1; transl_unbox_float arg2]))

  (* String operations *)
  | Uprim(Pstringlength, [arg]) ->
      tag_int(string_length (transl arg))
  | Uprim(Pstringrefu, [arg1; arg2]) ->
      tag_int(Cop(Cloadchunk Byte_unsigned,
                  [add_int (transl arg1) (untag_int(transl arg2))]))
  | Uprim(Pstringsetu, [arg1; arg2; arg3]) ->
      return_unit(Cop(Cstorechunk Byte_unsigned,
                      [add_int (transl arg1) (untag_int(transl arg2));
                       untag_int(transl arg3)]))
  | Uprim(Pstringrefs, [arg1; arg2]) ->
      tag_int
        (bind "str" (transl arg1) (fun str ->
          bind "index" (untag_int (transl arg2)) (fun idx ->
            Csequence(
              Cop(Ccheckbound, [string_length str; idx]),
              Cop(Cloadchunk Byte_unsigned, [add_int str idx])))))
  | Uprim(Pstringsets, [arg1; arg2; arg3]) ->
      return_unit
        (bind "str" (transl arg1) (fun str ->
          bind "index" (untag_int (transl arg2)) (fun idx ->
            Csequence(
              Cop(Ccheckbound, [string_length str; idx]),
              Cop(Cstorechunk Byte_unsigned,
                  [add_int str idx; untag_int(transl arg3)])))))

  (* Array operations *)
  | Uprim(Pmakearray kind, []) ->
      transl_constant(Const_block(0, []))
  | Uprim(Pmakearray kind, args) ->
      begin match kind with
        Pgenarray ->
          Cop(Cextcall("make_array", typ_addr, true),
              [Cop(Calloc, alloc_block_header 0 (List.length args) ::
                           List.map transl args)])
      | Paddrarray | Pintarray ->
          Cop(Calloc, alloc_block_header 0 (List.length args) ::
                      List.map transl args)
      | Pfloatarray ->
          Cop(Calloc, alloc_floatarray_header (List.length args) ::
                      List.map transl_unbox_float args)
      end
  | Uprim(Parraylength kind, [arg]) ->
      begin match kind with
        Pgenarray ->
          let len =
            if wordsize_shift = numfloat_shift then
              Cop(Clsr, [header(transl arg); Cconst_int wordsize_shift])
            else
              bind "header" (header(transl arg)) (fun hdr ->
                Cifthenelse(is_addr_array hdr,
                            Cop(Clsr, [hdr; Cconst_int wordsize_shift]),
                            Cop(Clsr, [hdr; Cconst_int numfloat_shift]))) in
          Cop(Cor, [len; Cconst_int 1])
      | Paddrarray | Pintarray ->
          Cop(Cor, [addr_array_length(header(transl arg)); Cconst_int 1])
      | Pfloatarray ->
          Cop(Cor, [float_array_length(header(transl arg)); Cconst_int 1])
      end
  | Uprim(Parrayrefu kind, [arg1; arg2]) ->
      begin match kind with
        Pgenarray ->
          bind "arr" (transl arg1) (fun arr ->
            bind "index" (transl arg2) (fun idx ->
              Cifthenelse(is_addr_array(header arr),
                          addr_array_ref arr idx,
                          float_array_ref arr idx)))
      | Paddrarray | Pintarray ->
          addr_array_ref (transl arg1) (transl arg2)
      | Pfloatarray ->
          float_array_ref (transl arg1) (transl arg2)
      end
  | Uprim(Parraysetu kind, [arg1; arg2; arg3]) ->
      return_unit(begin match kind with
        Pgenarray ->
          bind "newval" (transl arg3) (fun newval ->
            bind "index" (transl arg2) (fun index ->
              bind "arr" (transl arg1) (fun arr ->
                Cifthenelse(is_addr_array(header arr),
                            addr_array_set arr index newval,
                            float_array_set arr index (unbox_float newval)))))
      | Paddrarray ->
          addr_array_set (transl arg1) (transl arg2) (transl arg3)
      | Pintarray ->
          int_array_set (transl arg1) (transl arg2) (transl arg3)
      | Pfloatarray ->
          float_array_set (transl arg1) (transl arg2) (transl_unbox_float arg3)
      end)
  | Uprim(Parrayrefs kind, [arg1; arg2]) ->
      begin match kind with
        Pgenarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              bind "header" (header arr) (fun hdr ->
                Cifthenelse(is_addr_array hdr,
                  Csequence(Cop(Ccheckbound, [addr_array_length hdr; idx]),
                            addr_array_ref arr idx),
                  Csequence(Cop(Ccheckbound, [float_array_length hdr; idx]),
                            float_array_ref arr idx)))))
      | Paddrarray | Pintarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [addr_array_length(header arr); idx]),
                        addr_array_ref arr idx)))
      | Pfloatarray ->
          box_float(
            bind "index" (transl arg2) (fun idx ->
              bind "arr" (transl arg1) (fun arr ->
                Csequence(Cop(Ccheckbound, 
                              [float_array_length(header arr); idx]),
                          unboxed_float_array_ref arr idx))))
      end
  | Uprim(Parraysets kind, [arg1; arg2; arg3]) ->
      return_unit(begin match kind with
        Pgenarray ->
          bind "newval" (transl arg3) (fun newval ->
            bind "index" (transl arg2) (fun idx ->
              bind "arr" (transl arg1) (fun arr ->
                bind "header" (header arr) (fun hdr ->
                  Cifthenelse(is_addr_array hdr,
                    Csequence(Cop(Ccheckbound, [addr_array_length hdr; idx]),
                              addr_array_set arr idx newval),
                    Csequence(Cop(Ccheckbound, [float_array_length hdr; idx]),
                              float_array_set arr idx
                                              (unbox_float newval)))))))
      | Paddrarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [addr_array_length(header arr); idx]),
                        addr_array_set arr idx (transl arg3))))
      | Pintarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [addr_array_length(header arr); idx]),
                        int_array_set arr idx (transl arg3))))
      | Pfloatarray ->
          bind "index" (transl arg2) (fun idx ->
            bind "arr" (transl arg1) (fun arr ->
              Csequence(Cop(Ccheckbound, [float_array_length(header arr);idx]),
                        float_array_set arr idx (transl_unbox_float arg3))))
      end)

  (* Operations on bitvects *)
  | Uprim(Pbittest, [arg1; arg2]) ->
      bind "index" (untag_int(transl arg2)) (fun idx ->
        tag_int(
          Cop(Cand, [Cop(Clsr, [Cop(Cloadchunk Byte_unsigned,
                                    [add_int (transl arg1)
                                      (Cop(Clsr, [idx; Cconst_int 3]))]);
                                Cop(Cand, [idx; Cconst_int 7])]);
                     Cconst_int 1])))

  | Uprim(_, _) ->
      fatal_error "Cmmgen.transl"

  | Uswitch(arg, s) ->
      (* As in the bytecode interpreter, only matching against constants
         can be checked *)
      if Array.length s.us_index_blocks = 0 then
        if s.us_checked then
          bind "switch" (untag_int (transl arg)) (fun idx ->
            Cifthenelse(
              Cop(Ccmpa Cge,
                  [idx; Cconst_pointer(Array.length s.us_index_consts)]),
              Cexit,
              transl_switch idx s.us_index_consts s.us_cases_consts))
        else
          transl_switch (untag_int (transl arg))
                        s.us_index_consts s.us_cases_consts
      else if Array.length s.us_index_consts = 0 then
        transl_switch (get_tag (transl arg))
                      s.us_index_blocks s.us_cases_blocks
      else
        bind "switch" (transl arg) (fun arg ->
          Cifthenelse(
            Cop(Cand, [arg; Cconst_int 1]),
            transl_switch (untag_int arg) s.us_index_consts s.us_cases_consts,
            transl_switch (get_tag arg) s.us_index_blocks s.us_cases_blocks))
  | Ustaticfail ->
      Cexit
  | Ucatch(body, handler) ->
      Ccatch(transl body, transl handler)
  | Utrywith(body, exn, handler) ->
      Ctrywith(transl body, exn, transl handler)
  | Uifthenelse(Uprim(Pnot, [arg]), ifso, ifnot) ->
      transl (Uifthenelse(arg, ifnot, ifso))
  | Uifthenelse(cond, ifso, Ustaticfail) ->
      exit_if_false cond (transl ifso)
  | Uifthenelse(cond, Ustaticfail, ifnot) ->
      exit_if_true cond (transl ifnot)
  | Uifthenelse(Uprim(Psequand, _) as cond, ifso, ifnot) ->
      Ccatch(exit_if_false cond (transl ifso), transl ifnot)
  | Uifthenelse(Uprim(Psequor, _) as cond, ifso, ifnot) ->
      Ccatch(exit_if_true cond (transl ifnot), transl ifso)
  | Uifthenelse(cond, ifso, ifnot) ->
      Cifthenelse(test_bool(transl cond), transl ifso, transl ifnot)
  | Usequence(exp1, exp2) ->
      Csequence(remove_unit(transl exp1), transl exp2)
  | Uwhile(cond, body) ->
      return_unit(Ccatch(Cloop(exit_if_false cond (remove_unit(transl body))),
                         Ctuple []))
  | Ufor(id, low, high, dir, body) ->
      let tst = match dir with Upto -> Cgt   | Downto -> Clt in
      let inc = match dir with Upto -> Caddi | Downto -> Csubi in
      return_unit
        (Clet(id, transl low,
          bind "bound" (transl high) (fun high ->
            Ccatch(
              Cloop(Cifthenelse(
                Cop(Ccmpi tst, [Cvar id; high]),
                Cexit,
                 Csequence(remove_unit(transl body),
                           Cassign(id, Cop(inc, 
                                           [Cvar id; Cconst_int 2]))))),
              Ctuple []))))
  | Uassign(id, exp) ->
      return_unit(Cassign(id, transl exp))

and transl_unbox_float = function
    Uconst(Const_base(Const_float f)) -> Cconst_float f
  | exp -> unbox_float(transl exp)

and exit_if_true cond otherwise =
  match cond with
    Uprim(Psequor, [arg1; arg2]) ->
      exit_if_true arg1 (exit_if_true arg2 otherwise)
  | Uprim(Psequand, [arg1; arg2]) ->
      Csequence(Ccatch(exit_if_true arg1 (Ctuple []),
                       exit_if_true arg2 (Ctuple [])),
                otherwise)
  | _ ->
      Cifthenelse(test_bool(transl cond), Cexit, otherwise)

and exit_if_false cond otherwise =
  match cond with
    Uprim(Psequand, [arg1; arg2]) ->
      exit_if_false arg1 (exit_if_false arg2 otherwise)
  | Uprim(Psequor, [arg1; arg2]) ->
      Csequence(Ccatch(exit_if_false arg1 (Ctuple []),
                       exit_if_false arg2 (Ctuple [])),
                otherwise)
  | _ ->
      Cifthenelse(test_bool(transl cond), otherwise, Cexit)

and transl_switch arg index cases =
  match Array.length index with
    1 -> transl cases.(0)
  | 2 -> Cifthenelse(arg, transl cases.(index.(1)), transl cases.(index.(0)))
  | _ ->
      (* Determine whether all actions minus one or two are equal to
         Ustaticfail *)
      let num_fail = ref 0 in
      let key1 = ref (-1) in
      let key2 = ref (-1) in
      for i = 0 to Array.length index - 1 do
        if cases.(index.(i)) = Ustaticfail then incr num_fail
        else if !key1 < 0 then key1 := i
        else if !key2 < 0 then key2 := i
      done;
      match Array.length index - !num_fail with
        0 -> Csequence(arg, Cexit)
      | 1 -> Cifthenelse(Cop(Ccmpi Ceq, [arg; Cconst_int !key1]),
                         transl cases.(index.(!key1)), Cexit)
      | 2 -> bind "test" arg (fun a ->
               Cifthenelse(Cop(Ccmpi Ceq, [a; Cconst_int !key1]),
                           transl cases.(index.(!key1)),
                           Cifthenelse(Cop(Ccmpi Ceq, [a; Cconst_int !key2]),
                                       transl cases.(index.(!key2)), Cexit)))
      | _ -> Cswitch(arg, index, Array.map transl cases)

and transl_letrec bindings cont =
  let rec init_blocks = function
      [] -> fill_blocks bindings
    | (id, exp) :: rem ->
        Clet(id, dummy_block(expr_size_and_tag exp), init_blocks rem)
  and fill_blocks = function
      [] -> cont
    | (id, exp) :: rem ->
        Csequence(store_contents (Cvar id) (transl exp), fill_blocks rem)
  in init_blocks bindings

<<function Cmmgen.transl_function>>

(* Translate all function definitions *)

module StringSet = Set

<<function Cmmgen.transl_all_functions>>

(* Emit structured constants *)

let rec emit_constant symb cst cont =
  match cst with
    Const_base(Const_float s) ->
      Cint(float_header) :: Cdefine_symbol symb :: Cfloat s :: cont
  | Const_base(Const_string s) ->
      Cint(string_header (String.length s)) ::
      Cdefine_symbol symb ::
      emit_string_constant s cont
  | Const_block(tag, fields) ->
      let (emit_fields, cont1) = emit_constant_fields fields cont in
      Cint(block_header tag (List.length fields)) ::
      Cdefine_symbol symb ::
      emit_fields @ cont1
  | Const_float_array(fields) ->
      Cint(floatarray_header (List.length fields)) ::
      Cdefine_symbol symb ::
      Misc.map_end (fun f -> Cfloat f) fields cont
  | _ -> fatal_error "gencmm.emit_constant"

and emit_constant_fields fields cont =
  match fields with
    [] -> ([], cont)
  | f1 :: fl ->
      let (data1, cont1) = emit_constant_field f1 cont in
      let (datal, contl) = emit_constant_fields fl cont1 in
      (data1 :: datal, contl)

and emit_constant_field field cont =
  match field with
    Const_base(Const_int n) ->
      (Cint(Nativeint.add (Nativeint.shift (Nativeint.from n) 1)
                          (Nativeint.from 1)),
       cont)
  | Const_base(Const_char c) ->
      (Cint(Nativeint.from(((Char.code c) lsl 1) + 1)), cont)
  | Const_base(Const_float s) ->
      let lbl = new_const_label() in
      (Clabel_address lbl,
       Cint(float_header) :: Cdefine_label lbl :: Cfloat s :: cont)
  | Const_base(Const_string s) ->
      let lbl = new_const_label() in
      (Clabel_address lbl,
       Cint(string_header (String.length s)) :: Cdefine_label lbl :: 
       emit_string_constant s cont)
  | Const_pointer n ->
      (Cint(Nativeint.from((n lsl 1) + 1)), cont)
  | Const_block(tag, fields) ->
      let lbl = new_const_label() in
      let (emit_fields, cont1) = emit_constant_fields fields cont in
      (Clabel_address lbl,
       Cint(block_header tag (List.length fields)) :: Cdefine_label lbl ::
       emit_fields @ cont1)
  | Const_float_array(fields) ->
      let lbl = new_const_label() in
      (Clabel_address lbl,
       Cint(floatarray_header (List.length fields)) :: Cdefine_label lbl ::
       Misc.map_end (fun f -> Cfloat f) fields cont)

and emit_string_constant s cont =
  let n = size_int - 1 - (String.length s) mod size_int in
  Cstring s :: Cskip n :: Cint8 n :: cont

<<function Cmmgen.emit_all_constants>>

<<function Cmmgen.compunit>>

<<function Cmmgen.apply_function (asmcomp/cmmgen.ml)>>

<<function Cmmgen.tuplify_function>>

<<function Cmmgen.final_curry_function>>

<<function Cmmgen.intermediate_curry_functions>>
    
<<function Cmmgen.curry_function (asmcomp/cmmgen.ml)>>

<<function Cmmgen.entry_point>>

<<constant Cmmgen.cint_zero>>

<<function Cmmgen.global_table>>

<<function Cmmgen.frame_table>>

<<function Cmmgen.segment_table>>

<<function Cmmgen.data_segment_table>>

<<function Cmmgen.code_segment_table>>

<<function Cmmgen.predef_exception>>
@


\subsection*{[[asmcomp/liveness.mli]]}

<<signature Liveness.fundecl>>=
(* Liveness analysis.
   Annotate mach code with the set of regs live at each point. *)

val fundecl: Mach.fundecl -> unit
@


%-------------------------------------------------------------

<<asmcomp/liveness.mli>>=
<<copyright header>>

<<signature Liveness.fundecl>>
@


\subsection*{[[asmcomp/liveness.ml]]}

<<constant Liveness.live_at_exit>>=
let live_at_exit = ref (*Reg.*)Set.empty
@

<<constant Liveness.live_at_break>>=
let live_at_break = ref (*Reg.*)Set.empty
@

<<constant Liveness.live_at_raise>>=
let live_at_raise = ref (*Reg.*)Set.empty
@

<<function Liveness.live>>=
let rec live i finally =
  (* finally is the set of registers live after execution of the
     instruction sequence.
     The result of the function is the set of registers live just
     before the instruction sequence.
     The instruction i is annotated by the set of registers live across
     the instruction. *)
  match i.desc with
    Iend ->
      i.live <- finally;
      finally
  | Ireturn | Iop(Itailcall_ind) | Iop(Itailcall_imm _) ->
      (* i.live remains empty since no regs are live across *)
      Reg.set_of_array i.arg
  | Iifthenelse(test, ifso, ifnot) ->
      let at_join = live i.next finally in
      let at_fork = (*Reg.*)Set.union (live ifso at_join) (live ifnot at_join) in
      i.live <- at_fork;
      Reg.add_set_array at_fork i.arg
  | Iswitch(index, cases) ->
      let at_join = live i.next finally in
      let at_fork = ref (*Reg.*)Set.empty in
      for i = 0 to Array.length cases - 1 do
        at_fork := (*Reg.*)Set.union !at_fork (live cases.(i) at_join)
      done;
      i.live <- !at_fork;
      Reg.add_set_array !at_fork i.arg
  | Iloop(body) ->
      let at_top = ref (*Reg.*)Set.empty in
      (* Yes, there are better algorithms, but we'll just iterate till
         reaching a fixpoint. *)
      begin try
        while true do
          let new_at_top = (*Reg.*)Set.union !at_top (live body !at_top) in
          if (*Reg.*)Set.equal !at_top new_at_top then raise Exit;
          at_top := new_at_top
        done
      with Exit -> ()
      end;
      i.live <- !at_top;
      !at_top
  | Icatch(body, handler) ->
      let at_join = live i.next finally in
      let before_handler = live handler at_join in
      let saved_live_at_exit = !live_at_exit in
      live_at_exit := before_handler;
      let before_body = live body at_join in
      live_at_exit := saved_live_at_exit;
      i.live <- before_body;
      before_body
  | Iexit ->
      i.live <- !live_at_exit;          (* These regs are live across *)
      !live_at_exit
  | Itrywith(body, handler) ->
      let at_join = live i.next finally in
      let before_handler = live handler at_join in
      let saved_live_at_raise = !live_at_raise in
      live_at_raise := (*Reg.*)Set.remove Proc.loc_exn_bucket before_handler;
      let before_body = live body at_join in
      live_at_raise := saved_live_at_raise;
      i.live <- before_body;
      before_body
  | Iraise ->
      (* i.live remains empty since no regs are live across *)
      Reg.add_set_array !live_at_raise i.arg
  | _ ->
      let across_after = Reg.diff_set_array (live i.next finally) i.res in
      let across =
        match i.desc with
          Iop(Icall_ind) | Iop(Icall_imm _) | Iop(Iextcall(_, _)) ->
            (* The function call may raise an exception, branching to the
               nearest enclosing try ... with. Hence, everything that must
               be live at the beginning of the exception handler must also
               be live across the call. *)
             (*Reg.*)Set.union across_after !live_at_raise
         | _ ->
             across_after in
      i.live <- across;
      Reg.add_set_array across i.arg
@

<<function Liveness.fundecl>>=
let fundecl f =
  let initially_live = live f.fun_body (*Reg.*)Set.empty in
  (* Sanity check: only function parameters can be live at entrypoint *)
  let wrong_live = (*Reg.*)Set.diff initially_live (Reg.set_of_array f.fun_args) in
  if not ((*Reg.*)Set.is_empty wrong_live) then begin
    Printmach.regset wrong_live; Format.print_newline();
    Misc.fatal_error "Liveness.fundecl"
  end
@


%-------------------------------------------------------------

<<asmcomp/liveness.ml>>=
<<copyright header>>

(* Liveness analysis.
   Annotate mach code with the set of regs live at each point. *)

open Mach

<<constant Liveness.live_at_exit>>
<<constant Liveness.live_at_break>>
<<constant Liveness.live_at_raise>>

<<function Liveness.live>>

<<function Liveness.fundecl>>
@


\subsection*{[[asmcomp/schedgen.mli]]}

<<type Schedgen.code_dag_node>>=
(* Instruction scheduling *)

type code_dag_node =
  { instr: Linearize.instruction;
    delay: int;
    mutable sons: (code_dag_node * int) list;
    mutable date: int;
    mutable length: int;
    mutable ancestors: int;
    mutable emitted_ancestors: int }
@

<<type Schedgen.scheduler>>=
type scheduler = {
  (* old: virtual *)
  (* Can be overriden by processor description *)
  oper_issue_cycles : Mach.operation -> int;
      (* Number of cycles needed to issue the given operation *)
  oper_latency : Mach.operation -> int;
      (* Number of cycles needed to complete the given operation *)
  oper_in_basic_block : Mach.operation -> bool;
      (* Says whether the given operation terminates a basic block *)

  (* Entry point *)
  schedule_fundecl : 
    scheduler ->
    Linearize.fundecl -> Linearize.fundecl;

  (* old: protected *)

  instr_in_basic_block: 
   scheduler -> Linearize.instruction -> bool;
  instr_latency:
   scheduler -> Linearize.instruction -> int;
  instr_issue_cycles:
   scheduler -> Linearize.instruction -> int;
  add_instruction:
   scheduler -> 
   code_dag_node list -> Linearize.instruction -> code_dag_node list;
  ready_instruction:
   int -> code_dag_node list -> code_dag_node option;
  reschedule:  
   scheduler -> 
   code_dag_node list -> int -> Linearize.instruction -> Linearize.instruction;
 
}
@

<<signature Schedgen.scheduler_generic>>=
val scheduler_generic: unit -> scheduler
@


%-------------------------------------------------------------

<<asmcomp/schedgen.mli>>=
<<copyright header 1997>>

<<type Schedgen.code_dag_node>>

<<type Schedgen.scheduler>>

<<signature Schedgen.scheduler_generic>>

(*
  oper_issue_cycles = super.oper_issue_cycles;
  oper_latency = super.oper_latency;
  oper_in_basic_block = super.oper_in_basic_block;
  schedule_fundecl = super.schedule_fundecl;
  instr_in_basic_block = super.instr_in_basic_block;
  instr_latency = super.instr_latency;
  instr_issue_cycles = super.instr_issue_cycles;
  add_instruction = super.add_instruction;
  ready_instruction = super.ready_instruction;
  reschedule = super.reschedule;
*)
@


\subsection*{[[asmcomp/selection.mli]]}

<<signature Selection.fundecl>>=
(* Selection of pseudo-instructions, assignment of pseudo-registers,
   sequentialization. *)

val fundecl: Cmm.fundecl -> Mach.fundecl
@


%-------------------------------------------------------------

<<asmcomp/selection.mli>>=
<<copyright header>>

<<signature Selection.fundecl>>
@


\section{[[asmcomp/arm/]]}

\subsection*{[[asmcomp/arm/selection.ml]]}

<<function Selection.is_immed>>=
(* Immediate operands are 8-bit immediate values, zero-extended, and rotated
   right by 0, 2, 4, ... 30 bits.
   To avoid problems with Caml's 31-bit arithmetic,
   we check only with 8-bit values shifted left 0 to 22 bits. *)

let rec is_immed n shift =
  if shift > 22 then false
  else if n land (0xFF lsl shift) = n then true
  else is_immed n (shift + 2)
@

<<function Selection.is_offset>>=
(* We have 12-bit signed offsets for word accesses,
   8-bit signed word offsets for float accesses,
   and 8-bit byte offsets for bytes and shorts.
   Use lowest common denominator. *)

let is_offset n = n < 128 && n > -128
@

<<function Selection.is_intconst>>=
let is_intconst = function Cconst_int n -> true | _ -> false
@

<<function Selection.select_shift_arith>>=
let select_shift_arith super self = (fun op shiftop shiftrevop args ->
  match args with
    [arg1; Cop(Clsl, [arg2; Cconst_int n])]
    when n > 0 && n < 32 && not(is_intconst arg2) ->
      (Ispecific(Ishiftarith(shiftop, n)), [arg1; arg2])
  | [arg1; Cop(Casr, [arg2; Cconst_int n])]
    when n > 0 && n < 32 && not(is_intconst arg2) ->
      (Ispecific(Ishiftarith(shiftop, -n)), [arg1; arg2])
  | [Cop(Clsl, [arg1; Cconst_int n]); arg2]
    when n > 0 && n < 32 && not(is_intconst arg1) ->
      (Ispecific(Ishiftarith(shiftrevop, n)), [arg2; arg1])
  | [Cop(Casr, [arg1; Cconst_int n]); arg2]
    when n > 0 && n < 32 && not(is_intconst arg1) ->
      (Ispecific(Ishiftarith(shiftrevop, -n)), [arg2; arg1])
  | _ ->
      super.select_operation self op args
 )
@

<<function Selection.selector>>=
(* Instruction selection *)

let selector () = 

 let super = Selectgen.selector_generic () in
 {

  (* todo: super with feature needed ... *)
  select_condition = super.select_condition;
  select_store = super.select_store;
  emit_extcall_args = super.emit_extcall_args;
  emit_fundecl = super.emit_fundecl;
  extract = super.extract;
  insert = super.insert;
  insert_move = super.insert_move;
  insert_move_args = super.insert_move_args;
  insert_move_results = super.insert_move_results;
  insert_moves = super.insert_moves;
  emit_expr = super.emit_expr;
  emit_tail = super.emit_tail;
  select_arith_comm = super.select_arith_comm;
  select_arith = super.select_arith;
  select_shift = super.select_shift;
  select_arith_comp = super.select_arith_comp;
  emit_let = super.emit_let;
  emit_parts_list = super.emit_parts_list;
  emit_parts = super.emit_parts;
  emit_tuple = super.emit_tuple;
  emit_stores = super.emit_stores;
  emit_sequence = super.emit_sequence;
  emit_return = super.emit_return;
  emit_tail_sequence = super.emit_tail_sequence;
  select_floatarith = super.select_floatarith;
  select_push = super.select_push;

 is_immediate = (fun n ->
  n land 0xFF = n || is_immed n 2
 );

 select_addressing = (function
    Cop(Cadda, [arg; Cconst_int n]) when is_offset n ->
      (Iindexed n, arg)
  | Cop(Cadda, [arg1; Cop(Caddi, [arg2; Cconst_int n])]) when is_offset n ->
      (Iindexed n, Cop(Cadda, [arg1; arg2]))
  | arg ->
      (Iindexed 0, arg)
 );
 

 select_operation = (fun self op args ->
  match op with
    Cadda | Caddi ->
      begin match args with
        [arg1; Cconst_int n] when n < 0 && self.is_immediate (-n) ->
          (Iintop_imm(Isub, -n), [arg1])
      | _ ->
          select_shift_arith super self op Ishiftadd Ishiftadd args
      end
  | Csuba | Csubi ->
      begin match args with
        [arg1; Cconst_int n] when n < 0 && self.is_immediate (-n) ->
          (Iintop_imm(Iadd, -n), [arg1])
      | [Cconst_int n; arg2] when self.is_immediate n ->
          (Ispecific(Irevsubimm n), [arg2])
      | _ ->
          select_shift_arith super self op Ishiftsub Ishiftsubrev args
      end
  | Cmuli ->			(* no multiply immediate *)
      (Iintop Imul, args)
  | Cdivi ->
      begin match args with
        [arg1; Cconst_int n] when n = 1 lsl (Misc.log2 n) ->
          (Iintop_imm(Idiv, n), [arg1])
      | _ ->
          (Iextcall("__divsi3", false), args)
      end
  | Cmodi ->
      begin match args with
        [arg1; Cconst_int n] when n = 1 lsl (Misc.log2 n) ->
          (Iintop_imm(Imod, n), [arg1])
      | _ ->
          (Iextcall("__modsi3", false), args)
      end
  | Ccheckbound ->
      begin match args with
        [Cop(Clsr, [arg1; Cconst_int n]); arg2]
    when n > 0 && n < 32 && not(is_intconst arg2) ->
      (Ispecific(Ishiftcheckbound n), [arg1; arg2])
      | _ ->
        super.select_operation self op args
      end
  | _ -> super.select_operation self op args
 );

(* In mul rd, rm, rs,  rm and rd must be different.
   We deal with this by pretending that rm is also a result of the mul
   operation. *)

 insert_op = (fun self op rs rd ->
  if op = Iintop(Imul) then begin
    self.insert (Iop op) rs [| rd.(0); rs.(0) |]; rd
  end else
    super.insert_op self op rs rd
 );
 }
@

<<function Selection.fundecl>>=
let fundecl f = 
  let s = selector () in
  s.emit_fundecl s f
@


%-------------------------------------------------------------

<<asmcomp/arm/selection.ml>>=
<<copyright header 1998>>

(* Instruction selection for the ARM processor *)

open Misc
open Cmm
open Reg
open Arch
open Mach

open Selectgen

<<function Selection.is_immed>>

<<function Selection.is_offset>>

<<function Selection.is_intconst>>




<<function Selection.select_shift_arith>>


<<function Selection.selector>>


<<function Selection.fundecl>>

@


\section{[[asmcomp/]]}

\subsection*{[[asmcomp/schedgen.ml]]}

<<type Schedgen.code_dag_node (asmcomp/schedgen.ml)>>=
(* Representation of the code DAG. *)

type code_dag_node =
  { instr: instruction;                 (* The instruction *)
    delay: int;           (* How many cycles before result is available *)
    mutable sons: (code_dag_node * int) list;
                                        (* Instructions that depend on it *)
    mutable date: int;                  (* Start date *)
    mutable length: int;                (* Length of longest path to result *)
    mutable ancestors: int;             (* Number of ancestors *)
    mutable emitted_ancestors: int }    (* Number of emitted ancestors *)
@

<<constant Schedgen.dummy_node>>=
let dummy_node =
  { instr = end_instr; delay = 0; sons = []; date = 0;
    length = -1; ancestors = 0; emitted_ancestors = 0 }
@

<<constant Schedgen.code_results>>=
(* The code dag itself is represented by two tables from registers to nodes:
   - "results" maps registers to the instructions that produced them;
   - "uses" maps registers to the instructions that use them. *)

let code_results = (Hashtbl.create 31 : (location, code_dag_node) Hashtbl.t)
@

<<constant Schedgen.code_uses>>=
let code_uses = (Hashtbl.create 31 : (location, code_dag_node) Hashtbl.t)
@

<<function Schedgen.clear_code_dag>>=
let clear_code_dag () =
  Hashtbl.clear code_results;
  Hashtbl.clear code_uses
@

<<function Schedgen.add_edge>>=
(* Add an edge to the code DAG *)

let add_edge ancestor son delay =
  ancestor.sons <- (son, delay) :: ancestor.sons;
  son.ancestors <- son.ancestors + 1
@

<<function Schedgen.is_critical>>=
(* Compute length of longest path to a result.
   For leafs of the DAG, see whether their result is used in the instruction
   immediately following the basic block (a "critical" output). *)

let is_critical critical_outputs results =
  try
    for i = 0 to Array.length results - 1 do
      let r = results.(i).loc in
      for j = 0 to Array.length critical_outputs - 1 do
        if critical_outputs.(j).loc = r then raise Exit
      done
    done;
    false
  with Exit ->
    true
@

<<function Schedgen.longest_path>>=
let rec longest_path critical_outputs node =
  if node.length < 0 then begin
    match node.sons with
      [] ->
        node.length <-
          if is_critical critical_outputs node.instr.res
          or node.instr.desc = Lreloadretaddr (* alway critical *)
          then node.delay
          else 0
    | sons ->
        node.length <- 
          List.fold_left
            (fun len (son, delay) ->
              max len (longest_path critical_outputs son + delay))
            0 sons
  end;
  node.length
@

<<function Schedgen.remove_instr>>=
(* Remove an instruction from the ready queue *)

let rec remove_instr node = function
    [] -> []
  | instr :: rem ->
      if instr == node then rem else instr :: remove_instr node rem
@

<<constant Schedgen.some_load>>=
(* We treat Lreloadretaddr as a word-sized load *)

let some_load = (Iload(Cmm.Word, Arch.identity_addressing))
@

<<type Schedgen.scheduler (asmcomp/schedgen.ml)>>=
type scheduler = {
  (* old: virtual *)
  (* Can be overriden by processor description *)
  oper_issue_cycles : Mach.operation -> int;
      (* Number of cycles needed to issue the given operation *)
  oper_latency : Mach.operation -> int;
      (* Number of cycles needed to complete the given operation *)
  oper_in_basic_block : Mach.operation -> bool;
      (* Says whether the given operation terminates a basic block *)

  (* Entry point *)
  schedule_fundecl : 
    scheduler ->
    Linearize.fundecl -> Linearize.fundecl;

  (* old: protected *)

  instr_in_basic_block: 
   scheduler -> Linearize.instruction -> bool;
  instr_latency:
   scheduler -> Linearize.instruction -> int;
  instr_issue_cycles:
   scheduler -> Linearize.instruction -> int;
  add_instruction:
   scheduler -> 
   code_dag_node list -> Linearize.instruction -> code_dag_node list;
  ready_instruction:
   int -> code_dag_node list -> code_dag_node option;
  reschedule:  
   scheduler -> 
   code_dag_node list -> int -> Linearize.instruction -> Linearize.instruction;
 
}
@

<<function Schedgen.scheduler_generic>>=
(* The generic scheduler *)

let scheduler_generic () =
 {

(* Determine whether an operation ends a basic block or not.
   Can be overriden for some processors to signal specific instructions
   that terminate a basic block, e.g. Istore_symbol for the 386. *)

 oper_in_basic_block = (function
    Icall_ind -> false
  | Icall_imm _ -> false
  | Itailcall_ind -> false
  | Itailcall_imm _ -> false
  | Iextcall(_, _) -> false
  | Istackoffset _ -> false
  | Istore(_, _) -> false
  | Ialloc _ -> false
  | _ -> true
 );

(* Determine whether an instruction ends a basic block or not *)

 instr_in_basic_block = (fun self instr ->
  match instr.desc with
    Lop op -> self.oper_in_basic_block op
  | Lreloadretaddr -> true
  | _ -> false
 );

(* Estimate the delay needed to evaluate an operation. *)

 oper_latency = (fun _ -> failwith "Schedgen.oper_lantency: virtual");

(* Estimate the delay needed to evaluate an instruction *)

 instr_latency = (fun self instr ->
  match instr.desc with
    Lop op ->
      self.oper_latency op
  | Lreloadretaddr ->
      self.oper_latency some_load
  | _ ->
      assert false
 );

(* Estimate the number of cycles consumed by emitting an operation. *)

 oper_issue_cycles = (fun _ -> failwith "Schedgen.oper_issue_cycles: virtual");

(* Estimate the number of cycles consumed by emitting an instruction. *)

 instr_issue_cycles = (fun self instr ->
  match instr.desc with
    Lop op ->
      self.oper_issue_cycles op
  | Lreloadretaddr ->
      self.oper_issue_cycles some_load
  | _ ->
      assert false
 );

(* Add an instruction to the code dag *)

 add_instruction = (fun self ready_queue instr ->
  let delay = self.instr_latency self instr in
  let node =
    { instr = instr;
      delay = delay;
      sons = [];
      date = 0;
      length = -1;
      ancestors = 0;
      emitted_ancestors = 0 } in
  (* Add edges from all instructions that define one of the registers used
     (RAW dependencies) *)
  for i = 0 to Array.length instr.arg - 1 do
    try
      let ancestor = Hashtbl.find code_results instr.arg.(i).loc in
      add_edge ancestor node ancestor.delay
    with Not_found ->
      ()
  done;
  (* Also add edges from all instructions that use one of the result regs
     of this instruction (WAR dependencies). *)
  for i = 0 to Array.length instr.res - 1 do
    let ancestors = Hashtbl.find_all code_uses instr.res.(i).loc in
    List.iter (fun ancestor -> add_edge ancestor node 0) ancestors
  done;
  (* Also add edges from all instructions that have already defined one
     of the results of this instruction (WAW dependencies). *)
  for i = 0 to Array.length instr.res - 1 do
    try
      let ancestor = Hashtbl.find code_results instr.res.(i).loc in
      add_edge ancestor node 0
    with Not_found ->
      ()
  done;
  (* Remember the registers used and produced by this instruction *)
  for i = 0 to Array.length instr.res - 1 do
    Hashtbl.add code_results instr.res.(i).loc node
  done;
  for i = 0 to Array.length instr.arg - 1 do
    Hashtbl.add code_uses instr.arg.(i).loc node
  done;
  (* If this is a root instruction (all arguments already computed),
     add it to the ready queue *)
  if node.ancestors = 0 then node :: ready_queue else ready_queue
 );

(* Given a list of instructions and a date, choose one or several
   that are ready to be computed (start date <= current date)
   and that we can emit in one cycle.  Favor instructions with
   maximal distance to result.  If we can't find any, return None.
   This does not take multiple issues into account, though. *)

 ready_instruction = (fun date queue ->
  let rec extract best = function
    [] ->
      if best == dummy_node then None else Some best
  | instr :: rem ->
      let new_best =
        if instr.date <= date && instr.length > best.length
        then instr else best in
      extract new_best rem in
  extract dummy_node queue
 );
  
(* Schedule a basic block, adding its instructions in front of the given
   instruction sequence *)

 reschedule = (fun self ready_queue date cont ->
  if ready_queue = [] then cont else begin
    match self.ready_instruction date ready_queue with
      None ->
        self.reschedule self ready_queue (date + 1) cont
    | Some node ->
        (* Remove node from queue *)
        let new_queue = ref (remove_instr node ready_queue) in
        (* Update the start date and number of ancestors emitted of
           all descendents of this node. Enter those that become ready
           in the queue. *)
        let issue_cycles = self.instr_issue_cycles self node.instr in
        List.iter
          (fun (son, delay) ->
            let completion_date = date + issue_cycles + delay - 1 in
            if son.date < completion_date then son.date <- completion_date;
            son.emitted_ancestors <- son.emitted_ancestors + 1;
            if son.emitted_ancestors = son.ancestors then
              new_queue := son :: !new_queue)
          node.sons;
        instr_cons node.instr.desc node.instr.arg node.instr.res
          (self.reschedule self !new_queue (date + issue_cycles) cont)
  end
 );

(* Entry point *)
(* Don't bother to schedule for initialization code and the like. *)

 schedule_fundecl = (fun self f ->

  let rec schedule i =
    match i.desc with
      Lend -> i
    | _ ->
        if self.instr_in_basic_block self i then begin
          clear_code_dag();
          schedule_block [] i
        end else
          { desc = i.desc; arg = i.arg; res = i.res; live = i.live;
            next = schedule i.next }

  and schedule_block ready_queue i =
    if self.instr_in_basic_block self i then
      schedule_block (self.add_instruction self ready_queue i) i.next
    else begin
      let critical_outputs =
        match i.desc with
          Lop(Icall_ind | Itailcall_ind) -> [| i.arg.(0) |]
        | Lop(Icall_imm _ | Itailcall_imm _ | Iextcall(_, _)) -> [||]
        | Lreturn -> [||]
        | _ -> i.arg in
      List.iter (fun x -> longest_path critical_outputs x; ()) ready_queue;
      self.reschedule self ready_queue 0 (schedule i)
    end in

  if f.fun_fast then begin
    let new_body = schedule f.fun_body in
    clear_code_dag();
    { fun_name = f.fun_name;
      fun_body = new_body;
      fun_fast = f.fun_fast }
  end else
    f
 );
 }
@


%-------------------------------------------------------------

<<asmcomp/schedgen.ml>>=
<<copyright header>>

(* Instruction scheduling *)

open Misc
open Reg
open Mach
open Linearize

<<type Schedgen.code_dag_node (asmcomp/schedgen.ml)>>

<<constant Schedgen.dummy_node>>

<<constant Schedgen.code_results>>
<<constant Schedgen.code_uses>>

<<function Schedgen.clear_code_dag>>

<<function Schedgen.add_edge>>

<<function Schedgen.is_critical>>

<<function Schedgen.longest_path>>

<<function Schedgen.remove_instr>>

<<constant Schedgen.some_load>>

<<type Schedgen.scheduler (asmcomp/schedgen.ml)>>

<<function Schedgen.scheduler_generic>>

@


\subsection*{[[asmcomp/emit.mli]]}

<<signature Emit.fundecl>>=
(* Generation of assembly code *)

val fundecl: Linearize.fundecl -> unit
@

<<signature Emit.data>>=
val data: Cmm.data_item list -> unit
@

<<signature Emit.begin_assembly>>=
val begin_assembly: unit -> unit
@

<<signature Emit.end_assembly>>=
val end_assembly: unit -> unit
@


%-------------------------------------------------------------

<<asmcomp/emit.mli>>=
<<copyright header>>

<<signature Emit.fundecl>>
<<signature Emit.data>>
<<signature Emit.begin_assembly>>
<<signature Emit.end_assembly>>
@


\subsection*{[[asmcomp/asmgen.mli]]}

<<signature Asmgen.compile_implementation>>=
(* From lambda to assembly code *)

val compile_implementation: string -> int -> Lambda.lambda -> unit
@

<<signature Asmgen.compile_phrase>>=
val compile_phrase: Cmm.phrase -> unit
@

<<type Asmgen.error>>=
type error = Assembler_error of string
@

<<exception Asmgen.Error>>=
exception Error of error
@

<<signature Asmgen.report_error>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/asmgen.mli>>=
<<copyright header>>

<<signature Asmgen.compile_implementation>>
<<signature Asmgen.compile_phrase>>

<<type Asmgen.error>>
<<exception Asmgen.Error>>
<<signature Asmgen.report_error>>


@


\subsection*{[[asmcomp/asmgen.ml]]}

<<type Asmgen.error (asmcomp/asmgen.ml)>>=
type error = Assembler_error of string
@

<<exception Asmgen.Error (asmcomp/asmgen.ml)>>=
exception Error of error
@

<<function Asmgen.liveness>>=
let liveness phrase =
  Liveness.fundecl phrase; phrase
@

<<function Asmgen.dump_if>>=
let dump_if flag message phrase =
  if !flag then Printmach.phase message phrase;
  phrase
@

<<function Asmgen.dump_linear_if>>=
let dump_linear_if flag message phrase =
  if !flag then begin
    print_string "*** "; print_string message; print_newline();
    Printlinear.fundecl phrase; print_newline()
  end;
  phrase
@

<<function Asmgen.regalloc>>=
let rec regalloc round fd =
  if round > 50 then
    fatal_error(fd.Mach.fun_name ^
                ": function too complex, cannot complete register allocation");
  dump_if dump_live "Liveness analysis" fd;
  Interf.build_graph fd;
  if !dump_interf then Printmach.interferences();
  if !dump_prefer then Printmach.preferences();
  Coloring.allocate_registers();
  dump_if dump_regalloc "After register allocation" fd;
  let (newfd, redo_regalloc) = Reload.fundecl fd in
  dump_if dump_reload "After insertion of reloading code" newfd;
  if redo_regalloc 
  then begin Reg.reinit(); Liveness.fundecl newfd; regalloc (round+1) newfd end
  else newfd
@

<<function Asmgen.TODOOPERATOR>>=
let (++) x f = f x
@

<<function Asmgen.compile_fundecl>>=
let compile_fundecl fd_cmm =
  Reg.reset();
  fd_cmm
  ++ Selection.fundecl
  ++ dump_if dump_selection "After instruction selection"
  ++ liveness
  ++ dump_if dump_live "Liveness analysis"
  ++ Spill.fundecl
  ++ liveness
  ++ dump_if dump_spill "After spilling"
  ++ Split.fundecl
  ++ dump_if dump_split "After live range splitting"
  ++ liveness
  ++ regalloc 1
  ++ Linearize.fundecl
  ++ dump_linear_if dump_linear "Linearized code"
  ++ Scheduling.fundecl
  ++ dump_linear_if dump_scheduling "After instruction scheduling"
  ++ Emit.fundecl
@

<<function Asmgen.compile_phrase>>=
let compile_phrase p =
  if !dump_cmm then begin Printcmm.phrase p; print_newline() end;
  match p with
    Cfunction fd -> compile_fundecl fd
  | Cdata dl -> Emit.data dl
@

<<function Asmgen.compile_implementation>>=
let compile_implementation prefixname size lam =
  let asmfile =
    if !keep_asm_file
    then prefixname ^ ext_asm
    else Filename.temp_file "camlasm" ext_asm in
  let oc = open_out asmfile in
  begin try
    Emitaux.output_channel := oc;
    Emit.begin_assembly();
    List.iter compile_phrase (Cmmgen.compunit size (Closure.intro size lam));
    Emit.end_assembly();
    close_out oc
  with x ->
    close_out oc;
    if !keep_asm_file then () else remove_file asmfile;
    raise x
  end;
  if Proc.assemble_file asmfile (prefixname ^ ext_obj) <> 0
  then raise(Error(Assembler_error asmfile));
  if !keep_asm_file then () else remove_file asmfile
@

<<function Asmgen.report_error>>=
(* Error report *)

let report_error = function
    Assembler_error file ->
      print_string "Assembler error, input left in file ";
      print_string file
@


%-------------------------------------------------------------

<<asmcomp/asmgen.ml>>=
<<copyright header>>

(* From lambda to assembly code *)

open Format
open Config
open Clflags
open Misc
open Cmm

<<type Asmgen.error (asmcomp/asmgen.ml)>>

<<exception Asmgen.Error (asmcomp/asmgen.ml)>>

<<function Asmgen.liveness>>

<<function Asmgen.dump_if>>

<<function Asmgen.dump_linear_if>>

<<function Asmgen.regalloc>>

<<function Asmgen.TODOOPERATOR>>

<<function Asmgen.compile_fundecl>>

<<function Asmgen.compile_phrase>>

<<function Asmgen.compile_implementation>>

<<function Asmgen.report_error>>
@


\subsection*{[[asmcomp/asmlink.mli]]}

<<signature Asmlink.link>>=
(* Link a set of .cmx/.o files and produce an executable *)

val link: string list -> unit
@

<<type Asmlink.error>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
  | Missing_implementations of string list
  | Inconsistent_interface of string * string * string
  | Inconsistent_implementation of string * string * string
  | Assembler_error of string
  | Linking_error
@

<<exception Asmlink.Error>>=
exception Error of error
@

<<signature Asmlink.report_error>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<asmcomp/asmlink.mli>>=
<<copyright header>>

<<signature Asmlink.link>>

<<type Asmlink.error>>

<<exception Asmlink.Error>>

<<signature Asmlink.report_error>>
@


\subsection*{[[asmcomp/asmlink.ml]]}

<<type Asmlink.error (asmcomp/asmlink.ml)>>=
type error =
    File_not_found of string
  | Not_an_object_file of string
  | Missing_implementations of string list
  | Inconsistent_interface of string * string * string
  | Inconsistent_implementation of string * string * string
  | Assembler_error of string
  | Linking_error
@

<<exception Asmlink.Error (asmcomp/asmlink.ml)>>=
exception Error of error
@

<<constant Asmlink.crc_interfaces>>=
(* Consistency check between interfaces and implementations *)

let crc_interfaces =
@

<<constant Asmlink.crc_implementations>>=
let crc_implementations =
@

<<function Asmlink.check_consistency>>=
let check_consistency file_name unit crc =
  List.iter
    (fun (name, crc) ->
      if name = unit.ui_name then begin
        Hashtbl.add crc_interfaces name (file_name, crc)
      end else begin
        try
          let (auth_name, auth_crc) = Hashtbl.find crc_interfaces name in
          if crc <> auth_crc then
            raise(Error(Inconsistent_interface(name, file_name, auth_name)))
        with Not_found ->
          (* Can only happen for unit for which only a .cmi file was used,
             but no .cmo is provided *)
          Hashtbl.add crc_interfaces name (file_name, crc)
      end)
    unit.ui_imports_cmi;
  List.iter
    (fun (name, crc) ->
      if crc <> cmx_not_found_crc then begin
      try
        let (auth_name, auth_crc) = Hashtbl.find crc_implementations name in
        if crc <> auth_crc then
          raise(Error(Inconsistent_implementation(name, file_name, auth_name)))
      with Not_found ->
        Hashtbl.add crc_implementations name (file_name, crc)
      end)
    unit.ui_imports_cmx;
  Hashtbl.add crc_implementations unit.ui_name (file_name, crc)
@

<<constant Asmlink.missing_globals>>=
let missing_globals = ref StringSet.empty
@

<<function Asmlink.is_required>>=
let is_required name =
  StringSet.mem name !missing_globals
@

<<function Asmlink.add_required>>=
let add_required (name, crc) =
  missing_globals := StringSet.add name !missing_globals
@

<<function Asmlink.remove_required>>=
let remove_required name =
  missing_globals := StringSet.remove name !missing_globals
@

<<function Asmlink.scan_file>>=
let scan_file obj_name tolink =
  let file_name =
    try
      find_in_path !load_path obj_name
    with Not_found ->
      raise(Error(File_not_found obj_name)) in
  if Filename.check_suffix file_name ".cmx" then begin
    (* This is a .cmx file. It must be linked in any case.
       Read the infos to see which modules it requires. *)
    let (info, crc) = Compilenv.read_unit_info file_name in
    check_consistency file_name info crc;
    remove_required info.ui_name;
    List.iter add_required info.ui_imports_cmx;
    info :: tolink
  end
  else if Filename.check_suffix file_name ".cmxa" then begin
    (* This is an archive file. Each unit contained in it will be linked
       in only if needed. *)
    let ic = open_in_bin file_name in
    let buffer = String.create (String.length cmxa_magic_number) in
    really_input ic buffer 0 (String.length cmxa_magic_number);
    if buffer <> cmxa_magic_number then
      raise(Error(Not_an_object_file file_name));
    let info_crc_list = (input_value ic : (unit_infos * Digest.t) list) in
    close_in ic;
    List.fold_right
      (fun (info, crc) reqd ->
        if info.ui_force_link
        or !Clflags.link_everything
        or is_required info.ui_name then begin
          check_consistency file_name info crc;
          remove_required info.ui_name;
          List.iter add_required info.ui_imports_cmx;
          info :: reqd
        end else
          reqd)
    info_crc_list tolink
  end
  else raise(Error(Not_an_object_file file_name))
@

<<function Asmlink.make_startup_file>>=
let make_startup_file filename info_list =
  let oc = open_out filename in
  Emitaux.output_channel := oc;
  Location.input_name := "startup"; (* set the name of the "current" input *)
  Compilenv.reset "startup"; (* set the name of the "current" compunit *)
  Emit.begin_assembly();
  let name_list = List.map (fun ui -> ui.ui_name) info_list in
  Asmgen.compile_phrase(Cmmgen.entry_point name_list);
  let apply_functions = ref (IntSet.add 2 (IntSet.add 3 IntSet.empty)) in
  (* The callback functions always reference caml_apply[23] *)
  let curry_functions =
    ref IntSet.empty in
  List.iter
    (fun info ->
      List.iter
        (fun n -> apply_functions := IntSet.add n !apply_functions)
        info.ui_apply_fun;
      List.iter
        (fun n -> curry_functions := IntSet.add n !curry_functions)
        info.ui_curry_fun)
    info_list;
  IntSet.iter
    (fun n -> Asmgen.compile_phrase(Cmmgen.apply_function n))
    !apply_functions;
  IntSet.iter
    (fun n -> List.iter Asmgen.compile_phrase (Cmmgen.curry_function n))
    !curry_functions;
  Array.iter
    (fun name -> Asmgen.compile_phrase(Cmmgen.predef_exception name))
    Runtimedef.builtin_exceptions;
  Asmgen.compile_phrase(Cmmgen.global_table name_list);
  Asmgen.compile_phrase(Cmmgen.data_segment_table name_list);
  Asmgen.compile_phrase(Cmmgen.code_segment_table name_list);
  Asmgen.compile_phrase
    (Cmmgen.frame_table("startup" :: "system" :: name_list));
  Emit.end_assembly();
  close_out oc
@

<<function Asmlink.call_linker>>=
let call_linker file_list startup_file =
  let libname = "libasmrun" ^ ext_lib in
  let runtime_lib =
    try
      find_in_path !load_path libname
    with Not_found ->
      raise(Error(File_not_found libname)) in
  let cmd =
    match Config.system with
    | _ ->
        if not !Clflags.output_c_object then
          Printf.sprintf "%s -o %s -I%s %s %s %s -L%s %s %s %s"
            Config.native_c_compiler
            !Clflags.exec_name
            Config.standard_library
            (String.concat " " (List.rev !Clflags.ccopts))
            startup_file
            (String.concat " " (List.rev file_list))
            Config.standard_library
            (String.concat " " (List.rev !Clflags.ccobjs))
            runtime_lib
            Config.c_libraries
        else
          Printf.sprintf "%s -o %s %s %s"
            Config.native_partial_linker
            !Clflags.object_name
            startup_file
            (String.concat " " (List.rev file_list))
  in if Ccomp.command cmd <> 0 then raise(Error Linking_error)
@

<<signature Config.native_partial_linker>>=
val native_partial_linker: string
        (* The linker to use for partial links (-output-obj option) *)
@

<<function Asmlink.object_file_name>>=
let object_file_name name =
  let file_name =
    try
      find_in_path !load_path name
    with Not_found ->
      fatal_error "Asmlink.object_file_name: not found" in
  if Filename.check_suffix file_name ".cmx" then
    Filename.chop_suffix file_name ".cmx" ^ ext_obj
  else if Filename.check_suffix file_name ".cmxa" then
    Filename.chop_suffix file_name ".cmxa" ^ ext_lib
  else
    fatal_error "Asmlink.object_file_name: bad ext"
@

<<function Asmlink.link>>=
(* Main entry point *)

let link objfiles =
  let objfiles = "stdlib.cmxa" :: (objfiles @ ["std_exit.cmx"]) in
  let units_tolink = List.fold_right scan_file objfiles [] in
  Array.iter remove_required Runtimedef.builtin_exceptions;
  if not (StringSet.is_empty !missing_globals) then
    raise(Error(Missing_implementations(StringSet.elements !missing_globals)));
  let startup = Filename.temp_file "camlstartup" ext_asm in
  make_startup_file startup units_tolink;
  let startup_obj = Filename.temp_file "camlstartup" ext_obj in
  if Proc.assemble_file startup startup_obj <> 0 then
    raise(Error(Assembler_error startup));
  try
    call_linker (List.map object_file_name objfiles) startup_obj;
    if not !Clflags.keep_startup_file then remove_file startup;
    remove_file startup_obj
  with x ->
    remove_file startup_obj;
    raise x
@

<<function Asmlink.report_error>>=
let report_error = function
    File_not_found name ->
      print_string "Cannot find file "; print_string name
  | Not_an_object_file name ->
      print_string "The file "; print_string name;
      print_string " is not a compilation unit description"
  | Missing_implementations l ->
      open_box 0;
      print_string
        "No implementation(s) provided for the following module(s):";
      List.iter (fun s -> print_space(); print_string s) l;
      close_box()
  | Inconsistent_interface(intf, file1, file2) ->
      open_hvbox 0;
      print_string "Files "; print_string file1; print_string " and ";
      print_string file2; print_space();
      print_string "make inconsistent assumptions over interface ";
      print_string intf;
      close_box()
  | Inconsistent_implementation(intf, file1, file2) ->
      open_hvbox 0;
      print_string "Files "; print_string file1; print_string " and ";
      print_string file2; print_space();
      print_string "make inconsistent assumptions over implementation ";
      print_string intf;
      close_box()
  | Assembler_error file ->
      print_string "Error while assembling "; print_string file
  | Linking_error ->
      print_string "Error during linking"
@


%-------------------------------------------------------------

<<asmcomp/asmlink.ml>>=
<<copyright header>>

(* Link a set of .cmx/.o files and produce an executable *)

open Sys
open Misc
open Config
open Compilenv

<<type Asmlink.error (asmcomp/asmlink.ml)>>

<<exception Asmlink.Error (asmcomp/asmlink.ml)>>

<<constant Asmlink.crc_interfaces>>
      (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)
<<constant Asmlink.crc_implementations>>
      (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)

<<function Asmlink.check_consistency>>

(* First pass: determine which units are needed *)

module StringSet = Set

<<constant Asmlink.missing_globals>>

<<function Asmlink.is_required>>

<<function Asmlink.add_required>>

<<function Asmlink.remove_required>>

<<function Asmlink.scan_file>>

(* Second pass: generate the startup file and link it with everything else *)

module IntSet = Set

<<function Asmlink.make_startup_file>>

<<function Asmlink.call_linker>>

<<function Asmlink.object_file_name>>

<<function Asmlink.link>>

(* Error report *)

open Format

<<function Asmlink.report_error>>
@


\section{[[./driver/]]}

\subsection*{[[./driver/optcompile.mli]]}

<<signature Optcompile.interface>>=
(* Compile a .ml or .mli file *)

val interface: string -> unit
@

<<signature Optcompile.implementation>>=
val implementation: string -> unit
@

<<signature Optcompile.c_file>>=
val c_file: string -> unit
@

<<signature Optcompile.initial_env>>=
val initial_env: unit -> Env.t
@

<<signature Optcompile.init_path>>=
val init_path: unit -> unit
@


%-------------------------------------------------------------

<<./driver/optcompile.mli>>=
<<copyright header>>

<<signature Optcompile.interface>>
<<signature Optcompile.implementation>>
<<signature Optcompile.c_file>>

<<signature Optcompile.initial_env>>
<<signature Optcompile.init_path>>
@


\subsection*{[[./driver/optcompile.ml]]}

<<function Optcompile.init_path>>=
(* Initialize the search path.
   The current directory is always searched first,
   then the directories specified with the -I option (in command-line order),
   then the standard library directory. *)

let init_path () =
  let dirs =
    if !Clflags.thread_safe then
     Filename.concat Config.standard_library "threads" :: !Clflags.include_dirs
    else
     !Clflags.include_dirs in
  load_path := "" :: List.rev (Config.standard_library :: dirs);
  Env.reset_cache()
@

<<function Optcompile.initial_env>>=
(* Return the initial environment in which compilation proceeds. *)

let initial_env () =
  init_path();
  try
    if !Clflags.nopervasives
    then Env.initial
    else Env.open_pers_signature "Pervasives" Env.initial
  with Not_found ->
    fatal_error "cannot open Pervasives.cmi"
@

<<function Optcompile.preprocess>>=
(* Optionally preprocess a source file *)

let preprocess sourcefile tmpfile =
  match !Clflags.preprocessor with
    None -> sourcefile
  | Some pp ->
      let comm = pp ^ " " ^ sourcefile ^ " > " ^ tmpfile in
      if Ccomp.command comm <> 0 then begin
        Printf.eprintf "Preprocessing error\n";
        flush stderr;
        exit 2
      end;
      tmpfile
@

<<function Optcompile.remove_preprocessed>>=
let remove_preprocessed inputfile =
  match !Clflags.preprocessor with
    None -> ()
  | Some _ -> remove_file inputfile
@

<<exception Optcompile.Outdated_version>>=
(* Parse a file or get a dumped syntax tree in it *)

exception Outdated_version
@

<<function Optcompile.parse_file>>=
let parse_file inputfile parse_fun ast_magic =
  let ic = open_in_bin inputfile in
  let is_ast_file =
    try
      let buffer = String.create (String.length ast_magic) in
      really_input ic buffer 0 (String.length ast_magic);
      if buffer = ast_magic then true
      else if String.sub buffer 0 9 = String.sub ast_magic 0 9 then
        raise Outdated_version
      else false
    with
      Outdated_version ->
        fatal_error "Ocaml and preprocessor have incompatible versions"
    | _ -> false
  in
  let ast =
    try
      if is_ast_file then begin
        Location.input_name := input_value ic;
        input_value ic
      end else begin
        seek_in ic 0;
        Location.input_name := inputfile;
        parse_fun (Lexing.from_channel ic)
      end
    with x -> close_in ic; raise x
  in
  close_in ic;
  ast
@

<<function Optcompile.interface>>=
(* Compile a .mli file *)

let interface sourcefile =
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppi") in
  let ast = parse_file inputfile Parse.interface ast_intf_magic_number in
  let sg = Typemod.transl_signature (initial_env()) ast in
  if !Clflags.print_types then (Printtyp.signature sg; print_newline());
  Env.save_signature sg modulename (prefixname ^ ".cmi");
  remove_preprocessed inputfile
@

<<function Optcompile.print_if>>=
(* Compile a .ml file *)

let print_if flag printer arg =
  if !flag then begin printer arg; print_newline() end;
  arg
@

<<function Optcompile.implementation>>=
let implementation sourcefile =
  let prefixname = Filename.chop_extension sourcefile in
  let modulename = String.capitalize(Filename.basename prefixname) in
  let inputfile = preprocess sourcefile (prefixname ^ ".ppo") in
  let ast = parse_file inputfile Parse.implementation ast_impl_magic_number in
  let (str, sg, finalenv) = Typemod.type_structure (initial_env()) ast in
  if !Clflags.print_types then (Printtyp.signature sg; print_newline());

(*
  let coercion =
    if Sys.file_exists (prefixname ^ ".mli") then begin
      let intf_file =
        try find_in_path !load_path (prefixname ^ ".cmi")
        with Not_found -> prefixname ^ ".cmi" in
      let dclsig = Env.read_signature modulename intf_file in
      Includemod.compunit sourcefile sg intf_file dclsig
    end else begin
      Typemod.check_nongen_schemes finalenv str;
      Env.save_signature sg modulename (prefixname ^ ".cmi");
      Tcoerce_none
    end in
*)

    let (coercion, crc) =
      if Sys.file_exists (prefixname ^ ".mli") then begin
        let intf_file =
          try find_in_path !load_path (prefixname ^ ".cmi")
          with Not_found -> prefixname ^ ".cmi" in
        let (dclsig, crc) = Env.read_signature modulename intf_file in
        (Includemod.compunit sourcefile sg intf_file dclsig, crc)
      end else begin
        let crc = Env.save_signature sg modulename (prefixname ^ ".cmi") in
        Typemod.check_nongen_schemes str;
        (Tcoerce_none, crc)
      end in

  Compilenv.reset modulename;
  let (compunit_size, lam) =
    Translmod.transl_store_implementation modulename str coercion in
  Asmgen.compile_implementation prefixname compunit_size
    (print_if Clflags.dump_lambda Printlambda.lambda
      (Simplif.simplify_lambda
        (print_if Clflags.dump_rawlambda Printlambda.lambda lam)));
  Compilenv.save_unit_info (prefixname ^ ".cmx");
  remove_preprocessed inputfile
@

<<function Optcompile.c_file>>=
let c_file name =
  if Ccomp.compile_file_native name <> 0 then exit 2
@


%-------------------------------------------------------------

<<./driver/optcompile.ml>>=
<<copyright header>>

(* The batch compiler *)

open Misc
open Config
open Format
open Typedtree

<<function Optcompile.init_path>>

<<function Optcompile.initial_env>>

<<function Optcompile.preprocess>>

<<function Optcompile.remove_preprocessed>>

<<exception Optcompile.Outdated_version>>

<<function Optcompile.parse_file>>

<<function Optcompile.interface>>

<<function Optcompile.print_if>>

<<function Optcompile.implementation>>

<<function Optcompile.c_file>>
@


\subsection*{[[./driver/opterrors.mli]]}

<<signature Opterrors.report_error>>=
(* Error report *)

val report_error: exn -> unit
@


%-------------------------------------------------------------

<<./driver/opterrors.mli>>=
<<copyright header>>

<<signature Opterrors.report_error>>
@


\subsection*{[[./driver/opterrors.ml]]}

<<function Opterrors.report_error>>=
(* Report an error *)

let report_error exn =
  open_box 0;
  begin match exn with
    Lexer.Error(err, start, stop) ->
      Location.print {loc_start = start; loc_end = stop};
      Lexer.report_error err
  | Syntaxerr.Error err ->
      Syntaxerr.report_error err
  | Env.Error err ->
      Env.report_error err
  | Typecore.Error(loc, err) ->
      Location.print loc; Typecore.report_error err
  | Typetexp.Error(loc, err) ->
      Location.print loc; Typetexp.report_error err
  | Typedecl.Error(loc, err) ->
      Location.print loc; Typedecl.report_error err
  | Includemod.Error err ->
      Includemod.report_error err
  | Typemod.Error(loc, err) ->
      Location.print loc; Typemod.report_error err
  | Translcore.Error(loc, err) ->
      Location.print loc; Translcore.report_error err
  | Compilenv.Error code ->
      Compilenv.report_error code
  | Asmgen.Error code ->
      Asmgen.report_error code
  | Asmlink.Error code ->
      Asmlink.report_error code
  | Asmlibrarian.Error code ->
      Asmlibrarian.report_error code
  | Sys_error msg ->
      print_string "I/O error: "; print_string msg
  | x ->
      close_box(); raise x
  end;
  close_box(); print_newline()
@


%-------------------------------------------------------------

<<./driver/opterrors.ml>>=
<<copyright header>>

(* Error report *)

open Format
open Location

<<function Opterrors.report_error>>
@


\subsection*{[[./driver/optmain.ml]]}

<<function Optmain.process_interface_file>>=
let process_interface_file name =
  Optcompile.interface name
@

<<function Optmain.process_implementation_file>>=
let process_implementation_file name =
  Optcompile.implementation name;
  objfiles := (Filename.chop_extension name ^ ".cmx") :: !objfiles
@

<<function Optmain.process_file>>=
let process_file name =
  if Filename.check_suffix name ".ml"
  or Filename.check_suffix name ".mlt" then begin
    Optcompile.implementation name;
    objfiles := (Filename.chop_extension name ^ ".cmx") :: !objfiles
  end
  else if Filename.check_suffix name ".mli" then
    Optcompile.interface name
  else if Filename.check_suffix name ".cmx" 
       or Filename.check_suffix name ".cmxa" then
    objfiles := name :: !objfiles
  else if Filename.check_suffix name ext_obj
       or Filename.check_suffix name ext_lib then
    ccobjs := name :: !ccobjs
  else if Filename.check_suffix name ".c" then begin
    Optcompile.c_file name;
    ccobjs := (Filename.chop_suffix (Filename.basename name) ".c" ^ ext_obj)
    :: !ccobjs
  end
  else
    raise(Arg.Bad("don't know what to do with " ^ name))
@

<<function Optmain.print_version_number>>=
let print_version_number () =
  print_string "The Objective Caml native-code compiler, version ";
  print_string Config.version; print_newline();
  print_string "Standard library directory: ";
  print_string Config.standard_library; print_newline()
@

<<constant Optmain.usage>>=
let usage = "Usage: ocamlopt <options> <files>\nOptions are:"
@

<<function Optmain.main>>=
let main () =
  try
    native_code := true;
    Arg.parse [
       "-a", Arg.Set make_archive, " Build a library";
       "-c", Arg.Set compile_only, " Compile only (do not link)";
       "-cclib", Arg.String(fun s -> ccobjs := s :: !ccobjs),
             "<opt>  Pass option <opt> to the C linker";
       "-ccopt", Arg.String(fun s -> ccopts := s :: !ccopts),
             "<opt>  Pass option <opt> to the C compiler and linker";
       "-compact", Arg.Clear optimize_for_speed,
             " Optimize code size rather than speed";
       "-i", Arg.Set print_types, " Print the types";
       "-I", Arg.String(fun dir -> include_dirs := dir :: !include_dirs),
             "<dir>  Add <dir> to the list of include directories";
       "-impl", Arg.String process_implementation_file,
             "<file>  Compile <file> as a .ml file";
       "-inline", Arg.Int(fun n -> inline_threshold := n * 8),
             "<n>  Set aggressiveness of inlining to <n>";
       "-intf", Arg.String process_interface_file,
             "<file>  Compile <file> as a .mli file";
       "-linkall", Arg.Set link_everything,
             " Link all modules, even unused ones";
       "-noassert", Arg.Set noassert, " Don't compile assertion checks";
       "-o", Arg.String(fun s -> exec_name := s;
                                 archive_name := s;
                                 object_name := s),
             "<file>  Set output file name to <file> (default a.out)";
       "-output-obj", Arg.Unit(fun () -> output_c_object := true),
             "Output a C object file instead of an executable";
       "-pp", Arg.String(fun s -> preprocessor := Some s),
             "<command>  Pipe sources through preprocessor <command>";
       "-S", Arg.Set keep_asm_file, " Keep intermediate assembly file";
       "-thread", Arg.Set thread_safe, " Use thread-safe standard library";
       "-unsafe", Arg.Set fast,
             " No bounds checking on array and string access";
       "-v", Arg.Unit print_version_number, " Print compiler version number";
       "-verbose", Arg.Set verbose, " Print calls to external commands";

       "-nopervasives", Arg.Set nopervasives, " (undocumented)";
       "-drawlambda", Arg.Set dump_rawlambda, " (undocumented)";
       "-dlambda", Arg.Set dump_lambda, " (undocumented)";
       "-dcmm", Arg.Set dump_cmm, " (undocumented)";
       "-dsel", Arg.Set dump_selection, " (undocumented)";
       "-dlive", Arg.Unit(fun () -> dump_live := true;
                                    Printmach.print_live := true),
             " (undocumented)";
       "-dspill", Arg.Set dump_spill, " (undocumented)";
       "-dsplit", Arg.Set dump_split, " (undocumented)";
       "-dinterf", Arg.Set dump_interf, " (undocumented)";
       "-dprefer", Arg.Set dump_prefer, " (undocumented)";
       "-dalloc", Arg.Set dump_regalloc, " (undocumented)";
       "-dreload", Arg.Set dump_reload, " (undocumented)";
       "-dscheduling", Arg.Set dump_scheduling, " (undocumented)";
       "-dlinear", Arg.Set dump_linear, " (undocumented)";
       "-dstartup", Arg.Set keep_startup_file, " (undocumented)";

       "-", Arg.String process_file,
            "<file>  Treat <file> as a file name (even if it starts with `-')"
      ] process_file usage;
    if !make_archive then begin
      Optcompile.init_path();
      Asmlibrarian.create_archive (List.rev !objfiles) !archive_name
    end
    else if not !compile_only & !objfiles <> [] then begin
      Optcompile.init_path();
      Asmlink.link (List.rev !objfiles)
    end;
    exit 0
  with x ->
    Format.set_formatter_out_channel stderr;
    Opterrors.report_error x;
    exit 2
@

<<toplevel Optmain._1>>=
let _ = Printexc.catch main ()
@


%-------------------------------------------------------------

<<./driver/optmain.ml>>=
<<copyright header>>

open Config
open Clflags

<<function Optmain.process_interface_file>>

<<function Optmain.process_implementation_file>>

<<function Optmain.process_file>>

<<function Optmain.print_version_number>>

<<constant Optmain.usage>>

<<function Optmain.main>>

<<toplevel Optmain._1>>
@


\section{[[byterun/]]}

\subsection*{[[byterun/config.h]]}

<<constant _config_>>=
#define _config_
@

<<function bcopy>>=
#define bcopy(src,dst,len) memmove((dst), (src), (len))
@

<<function bcopy (byterun/config.h)>>=
#define bcopy(src,dst,len) memmov((dst), (src), (len))
@

<<constant USING_MEMMOV>>=
#define USING_MEMMOV
@

<<constant THREADED_CODE>>=
#define THREADED_CODE
@

<<constant Page_size>>=
/* Do not change this definition. */
#define Page_size (1 << Page_log)
@

<<constant Page_log>>=
/* The size of a page for memory management (in bytes) is [1 << Page_log].
   It must be a multiple of [sizeof (long)]. */
#define Page_log 12             /* A page is 4 kilobytes. */
@

<<constant Stack_size>>=
/* Initial size of stack (bytes). */
#define Stack_size (4096 * sizeof(value))
@

<<constant Stack_threshold>>=
/* Minimum free size of stack (bytes); below that, it is reallocated. */
#define Stack_threshold (256 * sizeof(value))
@

<<constant Max_stack_def>>=
/* Default maximum size of the stack (words). */
#define Max_stack_def (256 * 1024)
@

<<constant Max_young_wosize>>=
/* Must be > 4 */
#define Max_young_wosize 256
@

<<constant Minor_heap_min>>=
/* Minimum size of the minor zone (words).
   This must be at least [Max_young_wosize + 1]. */
#define Minor_heap_min 4096
@

<<constant Minor_heap_max>>=
/* Maximum size of the minor zone (words).
   Must be greater than or equal to [Minor_heap_min].
*/
#define Minor_heap_max (1 << 28)
@

<<constant Minor_heap_def>>=
/* Default size of the minor zone. (words)  */
#define Minor_heap_def 32768
@

<<constant Heap_chunk_min>>=
/* Minimum size increment when growing the heap (words).
   Must be a multiple of [Page_size / sizeof (value)]. */
#define Heap_chunk_min (2 * Page_size / sizeof (value))
@

<<constant Heap_chunk_max>>=
/* Maximum size of a contiguous piece of the heap (words).
   Must be greater than or equal to [Heap_chunk_min].
   Must be greater than or equal to [Bhsize_wosize (Max_wosize)]. */
#define Heap_chunk_max (Bhsize_wosize (Max_wosize))
@

<<constant Heap_chunk_def>>=
/* Default size increment when growing the heap. (words)
   Must be a multiple of [Page_size / sizeof (value)]. */
#define Heap_chunk_def (62 * 1024)
@

<<constant Init_heap_def>>=
/* Default initial size of the major heap (words);
   same constraints as for Heap_chunk_def. */
#define Init_heap_def (62 * 1024)
@

<<constant Percent_free_def>>=
/* Default speed setting for the major GC.  The heap will grow until
   the dead objects and the free list represent this percentage of the
   heap size.  The rest of the heap is live objects. */
#define Percent_free_def 42
@

<<constant Max_percent_free_def>>=
/* Default setting for the compacter: off */
#define Max_percent_free_def 1000000
@


%-------------------------------------------------------------

<<byterun/config.h>>=
<<copyright header C xavier and damien>>

#ifndef _config_
<<constant _config_>>


#include "../config/m.h"
#include "../config/s.h"

/* Library dependencies */

#ifdef HAS_MEMMOVE
#undef bcopy
<<function bcopy>>
#else
#ifdef HAS_BCOPY
/* Nothing to do */
#else
#undef bcopy
<<function bcopy (byterun/config.h)>>
<<constant USING_MEMMOV>>
#endif
#endif

/* We use threaded code interpretation if the compiler provides labels
   as first-class values (GCC 2.x).
   Macintosh 68k also uses threaded code, with the assembly-language
   bytecode interpreter (THREADED_CODE defined in config/sm-Mac.h).
*/

#if defined(__GNUC__) && __GNUC__ >= 2 && !defined(DEBUG)
<<constant THREADED_CODE>>
#endif

/* Signed char type */

#if defined(__STDC__) || defined(SIGNED_CHAR_WORKS)
typedef signed char schar;
#else
typedef char schar;
#endif

<<constant Page_size>>

/* Memory model parameters */

<<constant Page_log>>

<<constant Stack_size>>

<<constant Stack_threshold>>

<<constant Max_stack_def>>


/* Maximum size of a block allocated in the young generation (words). */
<<constant Max_young_wosize>>


<<constant Minor_heap_min>>

<<constant Minor_heap_max>>

<<constant Minor_heap_def>>


<<constant Heap_chunk_min>>

<<constant Heap_chunk_max>>

<<constant Heap_chunk_def>>

<<constant Init_heap_def>>


<<constant Percent_free_def>>

<<constant Max_percent_free_def>>


#endif /* _config_ */
@


\subsection*{[[byterun/instruct.h]]}

<<enum instructions>>=
/* The instruction set. */

enum instructions {
  ACC0, ACC1, ACC2, ACC3, ACC4, ACC5, ACC6, ACC7,
  ACC, PUSH,
  PUSHACC0, PUSHACC1, PUSHACC2, PUSHACC3,
  PUSHACC4, PUSHACC5, PUSHACC6, PUSHACC7,
  PUSHACC, POP, ASSIGN,
  ENVACC1, ENVACC2, ENVACC3, ENVACC4, ENVACC,
  PUSHENVACC1, PUSHENVACC2, PUSHENVACC3, PUSHENVACC4, PUSHENVACC,
  PUSH_RETADDR, APPLY, APPLY1, APPLY2, APPLY3,
  APPTERM, APPTERM1, APPTERM2, APPTERM3, 
  RETURN, RESTART, GRAB,
  CLOSURE, CLOSUREREC,
  GETGLOBAL, PUSHGETGLOBAL, GETGLOBALFIELD, PUSHGETGLOBALFIELD, SETGLOBAL,
  ATOM0, ATOM, PUSHATOM0, PUSHATOM,
  MAKEBLOCK, MAKEBLOCK1, MAKEBLOCK2, MAKEBLOCK3,
  GETFIELD0, GETFIELD1, GETFIELD2, GETFIELD3, GETFIELD,
  SETFIELD0, SETFIELD1, SETFIELD2, SETFIELD3, SETFIELD,
  DUMMY, UPDATE,
  VECTLENGTH, GETVECTITEM, SETVECTITEM,
  GETSTRINGCHAR, SETSTRINGCHAR, 
  BRANCH, BRANCHIF, BRANCHIFNOT, SWITCH, BOOLNOT,
  PUSHTRAP, POPTRAP, RAISE, CHECK_SIGNALS,
  C_CALL1, C_CALL2, C_CALL3, C_CALL4, C_CALL5, C_CALLN,
  CONST0, CONST1, CONST2, CONST3, CONSTINT,
  PUSHCONST0, PUSHCONST1, PUSHCONST2, PUSHCONST3, PUSHCONSTINT,
  NEGINT, ADDINT, SUBINT, MULINT, DIVINT, MODINT,
  ANDINT, ORINT, XORINT, LSLINT, LSRINT, ASRINT,
  EQ, NEQ, LTINT, LEINT, GTINT, GEINT,
  OFFSETINT, OFFSETREF,
  GETMETHOD,
  STOP, EVENT, BREAK
};
@


%-------------------------------------------------------------

<<byterun/instruct.h>>=
<<copyright header C xavier>>

<<enum instructions>>
@


\subsection*{[[byterun/mlvalues.h]]}

<<constant _mlvalues_>>=
#define _mlvalues_
@

<<function Is_long>>=
/* Longs vs blocks. */
#define Is_long(x)   (((x) & 1) != 0)
@

<<function Is_block>>=
#define Is_block(x)  (((x) & 1) == 0)
@

<<function Val_long>>=
/* Example: Val_long as in "Val from long" or "Val of long". */
#define Val_long(x)     (((long)(x) << 1) + 1)
@

<<function Long_val>>=
#define Long_val(x)     ((x) >> 1)
@

<<constant Max_long>>=
#define Max_long ((1L << (8 * sizeof(value) - 2)) - 1)
@

<<constant Min_long>>=
#define Min_long (-(1L << (8 * sizeof(value) - 2)))
@

<<constant Val_int>>=
#define Val_int Val_long
@

<<function Int_val>>=
#define Int_val(x) ((int) Long_val(x))
@

<<function Tag_hd>>=
/* Structure of the header:

For 16-bit and 32-bit architectures:
     +--------+-------+-----+
     | wosize | color | tag |
     +--------+-------+-----+
bits  31    10 9     8 7   0

For 64-bit architectures:

     +--------+-------+-----+
     | wosize | color | tag |
     +--------+-------+-----+
bits  63    10 9     8 7   0

*/

#define Tag_hd(hd) ((tag_t) ((hd) & 0xFF))
@

<<function Wosize_hd>>=
#define Wosize_hd(hd) ((mlsize_t) ((hd) >> 10))
@

<<function Hd_val>>=
#define Hd_val(val) (((header_t *) (val)) [-1])        /* Also an l-value. */
@

<<function Hd_op>>=
#define Hd_op(op) (Hd_val (op))                        /* Also an l-value. */
@

<<function Hd_bp>>=
#define Hd_bp(bp) (Hd_val (bp))                        /* Also an l-value. */
@

<<function Hd_hp>>=
#define Hd_hp(hp) (* ((header_t *) (hp)))              /* Also an l-value. */
@

<<function Hp_val>>=
#define Hp_val(val) ((char *) (((header_t *) (val)) - 1))
@

<<function Hp_op>>=
#define Hp_op(op) (Hp_val (op))
@

<<function Hp_bp>>=
#define Hp_bp(bp) (Hp_val (bp))
@

<<function Val_op>>=
#define Val_op(op) ((value) (op))
@

<<function Val_hp>>=
#define Val_hp(hp) ((value) (((header_t *) (hp)) + 1))
@

<<function Op_hp>>=
#define Op_hp(hp) ((value *) Val_hp (hp))
@

<<function Bp_hp>>=
#define Bp_hp(hp) ((char *) Val_hp (hp))
@

<<constant Num_tags>>=
#define Num_tags (1 << 8)
@

<<constant Max_wosize>>=
#define Max_wosize ((1L << 54) - 1)
@

<<constant Max_wosize (byterun/mlvalues.h)>>=
#define Max_wosize ((1 << 22) - 1)
@

<<function Wosize_val>>=
#define Wosize_val(val) (Wosize_hd (Hd_val (val)))
@

<<function Wosize_op>>=
#define Wosize_op(op) (Wosize_val (op))
@

<<function Wosize_bp>>=
#define Wosize_bp(bp) (Wosize_val (bp))
@

<<function Wosize_hp>>=
#define Wosize_hp(hp) (Wosize_hd (Hd_hp (hp)))
@

<<function Whsize_wosize>>=
#define Whsize_wosize(sz) ((sz) + 1)
@

<<function Wosize_whsize>>=
#define Wosize_whsize(sz) ((sz) - 1)
@

<<function Wosize_bhsize>>=
#define Wosize_bhsize(sz) ((sz) / sizeof (value) - 1)
@

<<function Bsize_wsize>>=
#define Bsize_wsize(sz) ((sz) * sizeof (value))
@

<<function Wsize_bsize>>=
#define Wsize_bsize(sz) ((sz) / sizeof (value))
@

<<function Bhsize_wosize>>=
#define Bhsize_wosize(sz) (Bsize_wsize (Whsize_wosize (sz)))
@

<<function Bhsize_bosize>>=
#define Bhsize_bosize(sz) ((sz) + sizeof (header_t))
@

<<function Bosize_val>>=
#define Bosize_val(val) (Bsize_wsize (Wosize_val (val)))
@

<<function Bosize_op>>=
#define Bosize_op(op) (Bosize_val (Val_op (op)))
@

<<function Bosize_bp>>=
#define Bosize_bp(bp) (Bosize_val (Val_bp (bp)))
@

<<function Bosize_hd>>=
#define Bosize_hd(hd) (Bsize_wsize (Wosize_hd (hd)))
@

<<function Whsize_hp>>=
#define Whsize_hp(hp) (Whsize_wosize (Wosize_hp (hp)))
@

<<function Whsize_val>>=
#define Whsize_val(val) (Whsize_hp (Hp_val (val)))
@

<<function Whsize_bp>>=
#define Whsize_bp(bp) (Whsize_val (Val_bp (bp)))
@

<<function Whsize_hd>>=
#define Whsize_hd(hd) (Whsize_wosize (Wosize_hd (hd)))
@

<<function Bhsize_hp>>=
#define Bhsize_hp(hp) (Bsize_wsize (Whsize_hp (hp)))
@

<<function Bhsize_hd>>=
#define Bhsize_hd(hd) (Bsize_wsize (Whsize_hd (hd)))
@

<<function Tag_val>>=
#define Tag_val(val) (((unsigned char *) (val)) [-1])
@

<<function Tag_hp>>=
#define Tag_hp(hp) (((unsigned char *) (hp)) [sizeof(value)-1])
@

<<function Tag_val (byterun/mlvalues.h)>>=
#define Tag_val(val) (((unsigned char *) (val)) [-sizeof(value)])
@

<<function Tag_hp (byterun/mlvalues.h)>>=
#define Tag_hp(hp) (((unsigned char *) (hp)) [0])
@

<<constant No_scan_tag>>=
/* The lowest tag for blocks containing no value. */
#define No_scan_tag 251
@

<<function Op_val>>=
/* Pointer to the first field. */
#define Op_val(x) ((value *) (x))
@

<<function Field>>=
/* Fields are numbered from 0. */
#define Field(x, i) (((value *)(x)) [i])           /* Also an l-value. */
@

<<constant Closure_tag>>=
/* Special case of tuples of fields: closures */

#define Closure_tag 250
@

<<function Code_val>>=
#define Code_val(val) (((code_t *) (val)) [0])     /* Also an l-value. */
@

<<constant Infix_tag>>=
/* Infix_tag must be 1 modulo 4 and infix headers can only occur in objects
   with tag Closure_tag (see compact.c). */

#define Infix_tag 249
@

<<function Infix_offset_hd>>=
#define Infix_offset_hd(hd) (Bosize_hd(hd))
@

<<function Infix_offset_val>>=
#define Infix_offset_val(v) Infix_offset_hd(Hd_val(v))
@

<<constant Object_tag>>=
/* Another special case: objects */
#define Object_tag 248
@

<<function Class_val>>=
#define Class_val(val) Field(val, 0)
@

<<function Oid_val>>=
#define Oid_val(val) Long_val(Field(val, 1))
@

<<function Bp_val>>=
/* Pointer to the first byte */
#define Bp_val(v) ((char *) (v))
@

<<function Val_bp>>=
#define Val_bp(p) ((value) (p))
@

<<function Byte>>=
/* Bytes are numbered from 0. */
#define Byte(x, i) (((char *) (x)) [i])            /* Also an l-value. */
@

<<function Byte_u>>=
#define Byte_u(x, i) (((unsigned char *) (x)) [i]) /* Also an l-value. */
@

<<constant Abstract_tag>>=
/* Abstract things.  Their contents is not traced by the GC; therefore they
   must not contain any [value].
*/
#define Abstract_tag 251
@

<<constant String_tag>>=
/* Strings. */
#define String_tag 252
@

<<function String_val>>=
#define String_val(x) ((char *) Bp_val(x))
@

<<constant Double_tag>>=
/* Floating-point numbers. */
#define Double_tag 253
@

<<constant Double_wosize>>=
#define Double_wosize ((sizeof(double) / sizeof(value)))
@

<<macro Double_val>>=
#define Double_val(v) (* (double *)(v))
@

<<macro Store_double_val>>=
#define Store_double_val(v,d) (* (double *)(v) = (d))
@

<<constant Double_array_tag>>=
/* Arrays of floating-point numbers. */
#define Double_array_tag 254
@

<<function Double_field>>=
#define Double_field(v,i) Double_val((value)((double *)(v) + (i)))
@

<<function Store_double_field>>=
#define Store_double_field(v,i,d) \
  Store_double_val((value)((double *)(v) + (i)),d)
@

<<constant Final_tag>>=
/* Finalized things.  Just like abstract things, but the GC will call the
   [Final_fun] before deallocation.
*/
#define Final_tag 255
@

<<function Final_fun>>=
#define Final_fun(val) (((final_fun *) (val)) [0]) /* Also an l-value. */
@

<<function Atom>>=
#define Atom(tag) (Val_hp (&(atom_table [tag])))
@

<<function Is_atom>>=
#define Is_atom(v) ((v) >= Atom(0) && (v) <= Atom(255))
@

<<function Is_atom (byterun/mlvalues.h)>>=
#define Is_atom(v) \
  ((((char *)(v) >= static_data_start && (char *)(v) < static_data_end) || \
   ((v) >= Atom(0) && (v) <= Atom(255))))
@

<<function Val_bool>>=
/* Booleans are integers 0 or 1 */

#define Val_bool(x) Val_int((x) != 0)
@

<<function Bool_val>>=
#define Bool_val(x) Int_val(x)
@

<<constant Val_false>>=
#define Val_false Val_int(0)
@

<<constant Val_true>>=
#define Val_true Val_int(1)
@

<<function Val_not>>=
#define Val_not(x) (4 - (x))
@

<<constant Val_unit>>=
/* The unit value is 0 */

#define Val_unit Val_int(0)
@


%-------------------------------------------------------------

<<byterun/mlvalues.h>>=
<<copyright header C xavier and damien>>

#ifndef _mlvalues_
<<constant _mlvalues_>>


#include "config.h"
#include "misc.h"

/* Definitions

  word: Four bytes on 32 and 16 bit architectures,
        eight bytes on 64 bit architectures.
  long: A C long integer.
  val: The ML representation of something.  A long or a block or a pointer
       outside the heap.  If it is a block, it is the (encoded) address
       of an object.  If it is a long, it is encoded as well.
  object: Something allocated.  It always has a header and some
          fields or some number of bytes (a multiple of the word size).
  field: A word-sized val which is part of an object.
  bp: Pointer to the first byte of an object.  (a char *)
  op: Pointer to the first field of an object.  (a value *)
  hp: Pointer to the header of an object.  (a char *)
  int32: Four bytes on all architectures.

  Remark: An object size is always a multiple of the word size, and at least
          one word plus the header.

  bosize: Size (in bytes) of the "bytes" part.
  wosize: Size (in words) of the "fields" part.
  bhsize: Size (in bytes) of the object with its header.
  whsize: Size (in words) of the object with its header.

  hd: A header.
  tag: The value of the tag field of the header.
  color: The value of the color field of the header.
         This is for use only by the GC.
*/

typedef long value;
typedef unsigned long header_t;
typedef unsigned long mlsize_t;
typedef unsigned int tag_t;             /* Actually, an unsigned char */
typedef unsigned long color_t;
typedef unsigned long mark_t;

typedef int int32;            /* Not portable, but checked by autoconf. */
typedef unsigned int uint32;  /* Seems like a reasonable assumption anyway. */

<<function Is_long>>
<<function Is_block>>

/* Conversion macro names are always of the form  "to_from". */
<<function Val_long>>
<<function Long_val>>
<<constant Max_long>>
<<constant Min_long>>
<<constant Val_int>>
<<function Int_val>>

<<function Tag_hd>>
<<function Wosize_hd>>

<<function Hd_val>>
<<function Hd_op>>
<<function Hd_bp>>
<<function Hd_hp>>
<<function Hp_val>>
<<function Hp_op>>
<<function Hp_bp>>
<<function Val_op>>
<<function Val_hp>>
<<function Op_hp>>
<<function Bp_hp>>

<<constant Num_tags>>
#ifdef ARCH_SIXTYFOUR
<<constant Max_wosize>>
#else
<<constant Max_wosize (byterun/mlvalues.h)>>
#endif

<<function Wosize_val>>
<<function Wosize_op>>
<<function Wosize_bp>>
<<function Wosize_hp>>
<<function Whsize_wosize>>
<<function Wosize_whsize>>
<<function Wosize_bhsize>>
<<function Bsize_wsize>>
<<function Wsize_bsize>>
<<function Bhsize_wosize>>
<<function Bhsize_bosize>>
<<function Bosize_val>>
<<function Bosize_op>>
<<function Bosize_bp>>
<<function Bosize_hd>>
<<function Whsize_hp>>
<<function Whsize_val>>
<<function Whsize_bp>>
<<function Whsize_hd>>
<<function Bhsize_hp>>
<<function Bhsize_hd>>

#ifdef ARCH_BIG_ENDIAN
<<function Tag_val>>
                                                 /* Also an l-value. */
<<function Tag_hp>>
                                                 /* Also an l-value. */
#else
<<function Tag_val (byterun/mlvalues.h)>>
                                                 /* Also an l-value. */
<<function Tag_hp (byterun/mlvalues.h)>>
                                                 /* Also an l-value. */
#endif

<<constant No_scan_tag>>


/* 1- If tag < No_scan_tag : a tuple of fields.  */

<<function Op_val>>
<<function Field>>

typedef int32 opcode_t;
typedef opcode_t * code_t;

<<constant Closure_tag>>
<<function Code_val>>

/* If tag == Infix_tag : an infix header inside a closure */
/* Infix_tag must be odd so that the infix header is scanned as an integer */
<<constant Infix_tag>>
<<function Infix_offset_hd>>
<<function Infix_offset_val>>

<<constant Object_tag>>
<<function Class_val>>
<<function Oid_val>>

/* 2- If tag > No_scan_tag : a sequence of bytes. */

<<function Bp_val>>
<<function Val_bp>>
<<function Byte>>
<<function Byte_u>>

<<constant Abstract_tag>>

<<constant String_tag>>
<<function String_val>>

<<constant Double_tag>>
<<constant Double_wosize>>
#ifndef ARCH_ALIGN_DOUBLE
<<macro Double_val>>
<<macro Store_double_val>>
#else
double Double_val (value);
void Store_double_val (value,double);
#endif

<<constant Double_array_tag>>
<<function Double_field>>
<<function Store_double_field>>

<<constant Final_tag>>
typedef void (*final_fun) (value);
<<function Final_fun>>


/* 3- Atoms are 0-tuples.  They are statically allocated once and for all. */

extern header_t atom_table[];
<<function Atom>>

/* Is_atom tests whether a well-formed block is statically allocated
   outside the heap. For the bytecode system, only zero-sized block (Atoms)
   fall in this class. For the native-code generator, data
   emitted by the code generator (as described in the table
   caml_data_segments) are also atoms. */

#ifndef NATIVE_CODE
<<function Is_atom>>
#else
extern char * static_data_start, * static_data_end;
<<function Is_atom (byterun/mlvalues.h)>>
#endif

<<function Val_bool>>
<<function Bool_val>>
<<constant Val_false>>
<<constant Val_true>>
<<function Val_not>>

<<constant Val_unit>>

/* The table of global identifiers */

extern value global_data;


#endif /* _mlvalues_ */
@


\subsection*{[[byterun/exec.h]]}

<<constant TRAILER_SIZE>>=
/* Structure of the trailer.
   Sizes are 32-bit unsigned integers, big endian */

#define TRAILER_SIZE (5*4+12)
@

<<struct exec_trailer>>=
struct exec_trailer {
  unsigned int code_size;      /* Size of the code block (in bytes) */
  unsigned int prim_size;      /* Size of the primitive table (in bytes) */
  unsigned int data_size;      /* Size of the global data table (bytes) */
  unsigned int symbol_size;    /* Size of the symbol table (bytes) */
  unsigned int debug_size;     /* Size of the debug infos (bytes) */
  char magic[12];              /* A magic string */
};
@

<<constant EXEC_MAGIC>>=
/* Magic number for this release */

#define EXEC_MAGIC "Caml1999X002"
@


%-------------------------------------------------------------

<<byterun/exec.h>>=
<<copyright header C xavier>>

/* exec.h : format of executable bytecode files */

/*  offset 0 --->  initial junk
                   code block
                   names of primitives
                   data block
                   symbol table
                   debug infos
                   trailer
 end of file --->
*/

<<constant TRAILER_SIZE>>

<<struct exec_trailer>>

<<constant EXEC_MAGIC>>

@


\subsection*{[[byterun/prims.h]]}

<<constant _prims_>>=
#define _prims_
@


%-------------------------------------------------------------

<<byterun/prims.h>>=
<<copyright header C xavier>>

/* Interface with C primitives. */

#ifndef _prims_
<<constant _prims_>>

typedef value (*c_primitive)();

extern c_primitive cprim[];
extern char * names_of_cprim[];

#endif /* _prims_ */
@


\subsection*{[[byterun/memory.h]]}

<<constant _memory_>>=
#define _memory_
@

<<constant Garbage_collection_function>>=
#define Garbage_collection_function garbage_collection
@

<<constant Garbage_collection_function (byterun/memory.h)>>=
#define Garbage_collection_function minor_collection
@

<<function Alloc_small>>=
#define Alloc_small(result, wosize, tag) {            Assert (wosize >= 1); \
  young_ptr -= Bhsize_wosize (wosize);                                      \
  if (young_ptr < young_limit){                                             \
    Setup_for_gc;                                                           \
    Garbage_collection_function ();                                         \
    Restore_after_gc;                                                       \
    young_ptr -= Bhsize_wosize (wosize);                                    \
  }                                                                         \
  Hd_hp (young_ptr) = Make_header ((wosize), (tag), Black);                 \
  (result) = Val_hp (young_ptr);                                            \
}
@

<<function Modify>>=
/* [Modify] never calls the GC. */

#define Modify(fp, val) {                                                   \
  value _old_ = *(fp);                                                      \
  *(fp) = (val);                                                            \
  if (Is_in_heap (fp)){                                                     \
    if (gc_phase == Phase_mark) darken (_old_, NULL);                       \
    if (Is_block (val) && Is_young (val)                                    \
        && ! (Is_block (_old_) && Is_young (_old_))){                       \
      *ref_table_ptr++ = (fp);                                              \
      if (ref_table_ptr >= ref_table_limit){                                \
        Assert (ref_table_ptr == ref_table_limit);                          \
        realloc_ref_table ();                                               \
      }                                                                     \
    }                                                                       \
  }                                                                         \
}                                                                           \
@

<<struct caml__roots_block>>=
/*
   [Begin_roots] and [End_roots] are used for C variables that are GC roots.
   It must contain all values in C local variables and function parameters
   at the time the minor GC is called.
   Usage:
   After initialising your local variables to legal Caml values, but before
   calling allocation functions, insert [Begin_roots_n(v1, ... vn)], where
   v1 ... vn are your variables of type [value] that you want to be updated
   across allocations.
   At the end, insert [End_roots()].

   Note that [Begin_roots] opens a new block, and [End_roots] closes it.
   Thus they must occur in matching pairs at the same brace nesting level.

   You can use [Val_unit] as a dummy initial value for your variables.
*/


struct caml__roots_block {
  struct caml__roots_block *next;
  long ntables;
  long nitems;
  value *tables [5];
};
@

<<constant Begin_root>>=
#define Begin_root Begin_roots1
@

<<function Pop_roots>>=
#define Pop_roots() local_roots = caml__roots_block.next;
@


%-------------------------------------------------------------

<<byterun/memory.h>>=
<<copyright header C damien>>

/* Allocation macros and functions */

#ifndef _memory_
<<constant _memory_>>


#include "config.h"
#include "gc.h"
#include "major_gc.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"

value alloc_shr (mlsize_t, tag_t);
void adjust_gc_speed (mlsize_t, mlsize_t);
void modify (value *, value);
void initialize (value *, value);
value check_urgent_gc (value);
void * stat_alloc (asize_t);              /* Size in bytes. */
void stat_free (void *);
void * stat_resize (void *, asize_t);     /* Size in bytes. */

/* void shrink_heap (char *);        Only used in compact.c */

#ifdef NATIVE_CODE
<<constant Garbage_collection_function>>
#else
<<constant Garbage_collection_function (byterun/memory.h)>>
#endif

<<function Alloc_small>>

/* You must use [Modify] to change a field of an existing shared block,
   unless you are sure the value being overwritten is not a shared block and
   the value being written is not a young block. */
<<function Modify>>

<<struct caml__roots_block>>

extern struct caml__roots_block *local_roots;  /* defined in roots.h */

<<constant Begin_root>>

#define Begin_roots1(r0) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 1; \
  caml__roots_block.tables[0] = &(r0);

#define Begin_roots2(r0, r1) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 2; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1);

#define Begin_roots3(r0, r1, r2) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 3; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1); \
  caml__roots_block.tables[2] = &(r2);

#define Begin_roots4(r0, r1, r2, r3) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 4; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1); \
  caml__roots_block.tables[2] = &(r2); \
  caml__roots_block.tables[3] = &(r3);

#define Begin_roots5(r0, r1, r2, r3, r4) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = 1; \
  caml__roots_block.ntables = 5; \
  caml__roots_block.tables[0] = &(r0); \
  caml__roots_block.tables[1] = &(r1); \
  caml__roots_block.tables[2] = &(r2); \
  caml__roots_block.tables[3] = &(r3); \
  caml__roots_block.tables[4] = &(r4);

#define Begin_roots_block(table, size) { \
  struct caml__roots_block caml__roots_block; \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = (size); \
  caml__roots_block.ntables = 1; \
  caml__roots_block.tables[0] = (table);

#define End_roots() local_roots = caml__roots_block.next; }


/*
   [Push_roots] and [Pop_roots] are obsolete.
   Use [Begin_roots] and [End_roots] instead.
*/

/* [Push_roots] and [Pop_roots] are used for C variables that are GC roots.
 * It must contain all values in C local variables at the time the minor GC is
 * called.
 * Usage:
 * At the end of the declarations of your C local variables, add
 * [ Push_roots (variable_name, size); ]
 * The size is the number of declared roots.  They are accessed as
 * [ variable_name [0] ... variable_name [size - 1] ].
 * The [variable_name] and the [size] must not be [ _ ].
 * Just before the function return, add a call to [Pop_roots].
 */

#define Push_roots(name, size) \
  value name [(size)]; \
  struct caml__roots_block caml__roots_block; \
  { long _; for (_ = 0; _ < (size); name [_++] = Val_unit); } \
  caml__roots_block.next = local_roots; \
  local_roots = &caml__roots_block; \
  caml__roots_block.nitems = (size); \
  caml__roots_block.ntables = 1; \
  caml__roots_block.tables[0] = name;
  
<<function Pop_roots>>

/* [register_global_root] registers a global C variable as a memory root
   for the duration of the program, or until [remove_global_root] is
   called. */

void register_global_root (value *);

/* [remove_global_root] removes a memory root registered on a global C
   variable with [register_global_root]. */

void remove_global_root (value *);


#endif /* _memory_ */

@


\subsection*{[[byterun/memory.c]]}

<<function expand_heap>>=
/* Allocate more memory from malloc for the heap.
   Return a block of at least the requested size (in words).
   Return NULL when out of memory.

   Faudrait nettoyer tout ca pour decoupler heap_start de heap_base
   et pour simplifier l'agrandissement de page_table.
*/
static char *expand_heap (mlsize_t request)
{
  char *mem;
  page_table_entry *new_page_table;
  asize_t new_page_table_size;
  asize_t malloc_request;
  asize_t i, more_pages;
  void *block;

  malloc_request = round_heap_chunk_size (Bhsize_wosize (request));
  gc_message ("Growing heap to %luk bytes\n",
              (stat_heap_size + malloc_request) / 1024);
  mem = aligned_malloc (malloc_request + sizeof (heap_chunk_head),
                        sizeof (heap_chunk_head), &block);
  if (mem == NULL){
    gc_message ("No room for growing heap\n", 0);
    return NULL;
  }
  mem += sizeof (heap_chunk_head);
  Chunk_size (mem) = malloc_request;
  Chunk_block (mem) = block;
  Assert (Wosize_bhsize (malloc_request) >= request);
  Hd_hp (mem) = Make_header (Wosize_bhsize (malloc_request), 0, Blue);

  if (mem < heap_start){
    more_pages = -Page (mem);
  }else if (Page (mem + malloc_request) > page_table_size){
    more_pages = Page (mem + malloc_request) - page_table_size;
  }else{
    more_pages = 0;
  }

  if (more_pages != 0){
    new_page_table_size = page_table_size + more_pages;
    new_page_table =
      (page_table_entry *) 
        malloc(new_page_table_size * sizeof(page_table_entry));
    if (new_page_table == NULL){
      gc_message ("No room for growing page table\n", 0);
      free (mem);
      return NULL;
    }
  } else {
    new_page_table = NULL;
    new_page_table_size = 0;
  }

  if (mem < heap_start){
    Assert (more_pages != 0);
    for (i = 0; i < more_pages; i++){
      new_page_table [i] = Not_in_heap;
    }
    bcopy (page_table, new_page_table + more_pages,
           page_table_size * sizeof(page_table_entry));
    Chunk_next (mem) = heap_start;
    heap_start = mem;
  }else{
    char **last;
    char *cur;

    if (mem + malloc_request > heap_end) heap_end = mem + malloc_request;
    if (more_pages != 0){
      for (i = page_table_size; i < new_page_table_size; i++){
        new_page_table [i] = Not_in_heap;
      }
      bcopy (page_table, new_page_table, 
             page_table_size * sizeof(page_table_entry));
    }
    last = &heap_start;
    cur = *last;
    while (cur != NULL && cur < mem){
      last = &(Chunk_next (cur));
      cur = *last;
    }
    Chunk_next (mem) = cur;
    *last = mem;
  }

  if (more_pages != 0){
    free ((char *) page_table);
    page_table = new_page_table;
    page_table_size = new_page_table_size;
  }

  for (i = Page (mem); i < Page (mem + malloc_request); i++){
    page_table [i] = In_heap;
  }
  stat_heap_size += malloc_request;
  return Bp_hp (mem);
}
@

<<function shrink_heap>>=
/* Remove the heap chunk [chunk] from the heap and give the memory back
   to [malloc].
*/
void shrink_heap (char *chunk)
{
  char **cp;
  int i;

  /* Never deallocate the first block, because heap_start is both the
     first block and the base address for page numbers, and we don't
     want to shift the page table, it's too messy (see above).
     It will never happen anyway, because of the way compaction works.
     (see compact.c)
  */
  if (chunk == heap_start) return;

  stat_heap_size -= Chunk_size (chunk);
  gc_message ("Shrinking heap to %luk bytes\n", stat_heap_size / 1024);

#ifdef DEBUG
  {
    mlsize_t i;
    for (i = 0; i < Wsize_bsize (Chunk_size (chunk)); i++){
      ((value *) chunk) [i] = not_random ();
    }
  }
#endif

  /* Remove [chunk] from the list of chunks. */
  cp = &heap_start;
  while (*cp != chunk) cp = &(Chunk_next (*cp));
  *cp = Chunk_next (chunk);

  /* Remove the pages of [chunk] from the page table. */
  for (i = Page (chunk); i < Page (chunk + Chunk_size (chunk)); i++){
    page_table [i] = Not_in_heap;
  }

  /* Free the [malloc]ed block that contains [chunk]. */
  free (Chunk_block (chunk));
}
@

<<function alloc_shr>>=
value alloc_shr (mlsize_t wosize, tag_t tag)
{
  char *hp, *new_block;

  hp = fl_allocate (wosize);
  if (hp == NULL){
    new_block = expand_heap (wosize);
    if (new_block == NULL) {
      if (in_minor_collection)
        fatal_error ("Fatal error: out of memory.\n");
      else
        raise_out_of_memory ();
    }
    fl_add_block (new_block);
    hp = fl_allocate (wosize);
  }

  Assert (Is_in_heap (Val_hp (hp)));

  if (gc_phase == Phase_mark
      || (gc_phase == Phase_sweep && (addr)hp >= (addr)gc_sweep_hp)){
    Hd_hp (hp) = Make_header (wosize, tag, Black);
  }else{
    Assert (gc_phase == Phase_idle
            || (gc_phase == Phase_sweep && (addr)hp < (addr)gc_sweep_hp));
    Hd_hp (hp) = Make_header (wosize, tag, White);
  }
  allocated_words += Whsize_wosize (wosize);
  if (allocated_words > Wsize_bsize (minor_heap_size)) urge_major_slice ();
  return Val_hp (hp);
}
@

<<function adjust_gc_speed>>=
/* Use this function to tell the major GC to speed up when you use
   finalized objects to automatically deallocate extra-heap objects.
   The GC will do at least one cycle every [max] allocated words;
   [mem] is the number of words allocated this time.
   Note that only [mem/max] is relevant.  You can use numbers of bytes
   (or kilobytes, ...) instead of words.  You can change units between
   calls to [adjust_collector_speed].
*/
void adjust_gc_speed (mlsize_t mem, mlsize_t max)
{
  if (max == 0) max = 1;
  if (mem > max) mem = max;
  extra_heap_memory += ((float) mem / max) * stat_heap_size;
  if (extra_heap_memory > stat_heap_size){
    extra_heap_memory = stat_heap_size;
  }
  if (extra_heap_memory > Wsize_bsize (minor_heap_size) / 2) 
    urge_major_slice ();
}
@

<<function initialize>>=
/* [initialize] never calls the GC, so you may call it while an object is
   unfinished (i.e. just after a call to [alloc_shr].) */
void initialize (value *fp, value val)
{
  *fp = val;
  Assert (Is_in_heap (fp));
  if (Is_block (val) && Is_young (val)){
    *ref_table_ptr++ = fp;
    if (ref_table_ptr >= ref_table_limit){
      realloc_ref_table ();
    }
  }
}
@

<<function modify>>=
/* [modify] never calls the GC. */
void modify (value *fp, value val)
{
  Modify (fp, val);
}
@

<<function stat_alloc>>=
void * stat_alloc (asize_t sz)
{
  void * result = malloc (sz);

  if (result == NULL) raise_out_of_memory ();
  return result;
}
@

<<function stat_free>>=
void stat_free (void * blk)
{
  free (blk);
}
@

<<function stat_resize>>=
void * stat_resize (void * blk, asize_t sz)
{
  void * result = realloc (blk, sz);

  if (result == NULL) raise_out_of_memory ();
  return result;
}
@


%-------------------------------------------------------------

<<byterun/memory.c>>=
<<copyright header C damien>>

#include <stdlib.h>
#include <string.h>
#include "fail.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "signals.h"

<<function expand_heap>>

<<function shrink_heap>>

<<function alloc_shr>>

<<function adjust_gc_speed>>

/* You must use [initialize] to store the initial value in a field of
   a shared block, unless you are sure the value is not a young block.
   A block value [v] is a shared block if and only if [Is_in_heap (v)]
   is true.
*/
<<function initialize>>

/* You must use [modify] to change a field of an existing shared block,
   unless you are sure the value being overwritten is not a shared block and
   the value being written is not a young block. */
<<function modify>>

<<function stat_alloc>>

<<function stat_free>>

<<function stat_resize>>

@


\subsection*{[[byterun/freelist.h]]}

<<constant _freelist_>>=
#define _freelist_
@


%-------------------------------------------------------------

<<byterun/freelist.h>>=
<<copyright header C damien>>

/* Free lists of heap blocks. */

#ifndef _freelist_
<<constant _freelist_>>


#include "misc.h"
#include "mlvalues.h"

extern asize_t fl_cur_size;

char *fl_allocate (mlsize_t);
void fl_init_merge (void);
void fl_reset (void);
char *fl_merge_block (char *);
void fl_add_block (char *);


#endif /* _freelist_ */
@


\subsection*{[[byterun/freelist.c]]}

<<global sentinel>>=
/* The sentinel can be located anywhere in memory, but it must not be
   adjacent to any heap object. */
static struct {
  value filler1; /* Make sure the sentinel is never adjacent to any block. */
  header_t h;
  value first_bp;
  value filler2; /* Make sure the sentinel is never adjacent to any block. */
} sentinel = {0, Make_header (0, 0, Blue), 0, 0};
@

<<constant Fl_head>>=
#define Fl_head ((char *) (&(sentinel.first_bp)))
@

<<global fl_prev>>=
static char *fl_prev = Fl_head;  /* Current allocation pointer. */
@

<<global fl_last>>=
static char *fl_last = NULL;     /* Last block in the list.  Only valid
                                    just after fl_allocate returned NULL. */
@

<<global fl_merge>>=
char *fl_merge = Fl_head;        /* Current insertion pointer.  Managed
                                    jointly with [sweep_slice]. */
@

<<global fl_cur_size>>=
asize_t fl_cur_size = 0;         /* How many free words were added since
                                    the latest fl_init_merge. */
@

<<function Next>>=
#define Next(b) (((block *) (b))->next_bp)
@

<<function fl_check>>=
void fl_check (void)
{
  char *cur, *prev;
  int prev_found = 0, merge_found = 0;

  prev = Fl_head;
  cur = Next (prev);
  while (cur != NULL){
    Assert (Is_in_heap (cur));
    if (cur == fl_prev) prev_found = 1;
    if (cur == fl_merge) merge_found = 1;
    prev = cur;
    cur = Next (prev);
  }
  Assert (prev_found || fl_prev == Fl_head);
  Assert (merge_found || fl_merge == Fl_head);
}
@

<<function allocate_block>>=
/* [allocate_block] is called by [fl_allocate].  Given a suitable free
   block and the desired size, it allocates a new block from the free
   block.  There are three cases:
   0. The free block has the desired size.  Detach the block from the
      free-list and return it.
   1. The free block is 1 word longer than the desired size.  Detach
      the block from the free list.  The remaining word cannot be linked:
      turn it into an empty block (header only), and return the rest.
   2. The free block is big enough.  Split it in two and return the right
      block.
   In all cases, the allocated block is right-justified in the free block:
   it is located in the high-address words of the free block.  This way,
   the linking of the free-list does not change in case 2.
*/
static char *allocate_block (mlsize_t wh_sz, char *prev, char *cur)
{
  header_t h = Hd_bp (cur);
                                             Assert (Whsize_hd (h) >= wh_sz);
  if (Wosize_hd (h) < wh_sz + 1){                        /* Cases 0 and 1. */
    Next (prev) = Next (cur);
                    Assert (Is_in_heap (Next (prev)) || Next (prev) == NULL);
    if (fl_merge == cur) fl_merge = prev;
#ifdef DEBUG
    fl_last = NULL;
#endif
      /* In case 1, the following creates the empty block correctly.
         In case 0, it gives an invalid header to the block.  The function
         calling [fl_allocate] will overwrite it. */
    Hd_op (cur) = Make_header (0, 0, White);
  }else{                                                        /* Case 2. */
    Hd_op (cur) = Make_header (Wosize_hd (h) - wh_sz, 0, Blue);
  }
  fl_prev = prev;
  return cur + Bosize_hd (h) - Bsize_wsize (wh_sz);
}  
@

<<function fl_allocate>>=
/* [fl_allocate] does not set the header of the newly allocated block.
   The calling function must do it before any GC function gets called.
   [fl_allocate] returns a head pointer.
*/
char *fl_allocate (mlsize_t wo_sz)
{
  char *cur, *prev;
                                  Assert (sizeof (char *) == sizeof (value));
                                  Assert (fl_prev != NULL);
                                  Assert (wo_sz >= 1);
    /* Search from [fl_prev] to the end of the list. */
  prev = fl_prev;
  cur = Next (prev);
  while (cur != NULL){                             Assert (Is_in_heap (cur));
    if (Wosize_bp (cur) >= wo_sz){
      return allocate_block (Whsize_wosize (wo_sz), prev, cur);
    }
    prev = cur;
    cur = Next (prev);
  }
  fl_last = prev;
    /* Search from the start of the list to [fl_prev]. */
  prev = Fl_head;
  cur = Next (prev);
  while (prev != fl_prev){
    if (Wosize_bp (cur) >= wo_sz){
      return allocate_block (Whsize_wosize (wo_sz), prev, cur);
    }
    prev = cur;
    cur = Next (prev);
  }
    /* No suitable block was found. */
  return NULL;
}
@

<<global last_fragment>>=
static char *last_fragment;
@

<<function fl_init_merge>>=
void fl_init_merge (void)
{
  last_fragment = NULL;
  fl_merge = Fl_head;
  fl_cur_size = 0;
#ifdef DEBUG
  fl_check ();
#endif
}
@

<<function fl_reset>>=
/* This is called by compact_heap. */
void fl_reset (void)
{
  Next (Fl_head) = 0;
  fl_prev = Fl_head;
  fl_init_merge ();
}
@

<<function fl_merge_block>>=
/* [fl_merge_block] returns the head pointer of the next block after [bp],
   because merging blocks may change the size of [bp]. */
char *fl_merge_block (char *bp)
{
  char *prev, *cur, *adj;
  header_t hd = Hd_bp (bp);

  fl_cur_size += Whsize_hd (hd);
  
#ifdef DEBUG
  {
    mlsize_t i;
    for (i = 0; i < Wosize_hd (hd); i++){
      Field (Val_bp (bp), i) = not_random ();
    }
  }
#endif
  prev = fl_merge;
  cur = Next (prev);
  /* The sweep code makes sure that this is the right place to insert
     this block: */
  Assert (prev < bp || prev == Fl_head);
  Assert (cur > bp || cur == NULL);

  /* If [last_fragment] and [bp] are adjacent, merge them. */
  if (last_fragment == Hp_bp (bp)){
    hd = Make_header (Whsize_bp (bp), 0, White);
    bp = last_fragment;
    Hd_bp (bp) = hd;
    fl_cur_size += Whsize_wosize (0);
  }

  /* If [bp] and [cur] are adjacent, remove [cur] from the free-list
     and merge them. */
  adj = bp + Bosize_hd (hd);
  if (adj == Hp_bp (cur)){
    char *next_cur = Next (cur);
    long cur_whsz = Whsize_bp (cur);

    Next (prev) = next_cur;
    if (fl_prev == cur) fl_prev = prev;
    hd = Make_header (Wosize_hd (hd) + cur_whsz, 0, Blue);
    Hd_bp (bp) = hd;
    adj = bp + Bosize_hd (hd);
#ifdef DEBUG
    fl_last = NULL;
    Next (cur) = (char *) not_random ();
    Hd_bp (cur) = not_random ();
#endif
    cur = next_cur;
  }
  /* If [prev] and [bp] are adjacent merge them, else insert [bp] into
     the free-list if it is big enough. */
  if (prev + Bosize_bp (prev) == Hp_bp (bp)){
    Hd_bp (prev) = Make_header (Wosize_bp (prev) + Whsize_hd (hd), 0, Blue);
#ifdef DEBUG
    Hd_bp (bp) = not_random ();
#endif
    Assert (fl_merge == prev);
  }else if (Wosize_hd (hd) != 0){
    Hd_bp (bp) = Bluehd_hd (hd);
    Next (bp) = cur;
    Next (prev) = bp;
    fl_merge = bp;
  }else{
    /* This is a fragment.  Leave it in white but remember it for eventual
       merging with the next block. */
    last_fragment = bp;
  }
  return adj;
}
@

<<function fl_add_block>>=
/* This is a heap extension.  We have to insert it in the right place
   in the free-list.
   [fl_add_block] can only be called just after a call to [fl_allocate]
   that returned NULL.
   Most of the heap extensions are expected to be at the end of the
   free list.  (This depends on the implementation of [malloc].)
*/
void fl_add_block (char *bp)
{
                                                   Assert (fl_last != NULL);
                                            Assert (Next (fl_last) == NULL);
#ifdef DEBUG
  {
    mlsize_t i;
    for (i = 0; i < Wosize_bp (bp); i++){
      Field (Val_bp (bp), i) = not_random ();
    }
  }
#endif
  if (bp > fl_last){
    Next (fl_last) = bp;
    Next (bp) = NULL;
  }else{
    char *cur, *prev;

    prev = Fl_head;
    cur = Next (prev);
    while (cur != NULL && cur < bp){   Assert (prev < bp || prev == Fl_head);
      prev = cur;
      cur = Next (prev);
    }                                  Assert (prev < bp || prev == Fl_head);
                                            Assert (cur > bp || cur == NULL);
    Next (bp) = cur;
    Next (prev) = bp;
    /* When inserting a block between fl_merge and gc_sweep_hp, we must
       advance fl_merge to the new block, so that fl_merge is always the
       last free-list block before gc_sweep_hp. */
    if (prev == fl_merge && bp <= gc_sweep_hp) fl_merge = bp;
  }
}
@


%-------------------------------------------------------------

<<byterun/freelist.c>>=
<<copyright header C damien>>

#include "config.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "misc.h"
#include "mlvalues.h"

/* The free-list is kept sorted by increasing addresses.
   This makes the merging of adjacent free blocks possible.
   (See [fl_merge_block].)
*/

typedef struct {
  char *next_bp;   /* Pointer to the first byte of the next block. */
} block;

<<global sentinel>>

<<constant Fl_head>>
<<global fl_prev>>
<<global fl_last>>
<<global fl_merge>>
<<global fl_cur_size>>

<<function Next>>

#ifdef DEBUG
<<function fl_check>>
#endif

<<function allocate_block>>

<<function fl_allocate>>

<<global last_fragment>>

<<function fl_init_merge>>

<<function fl_reset>>

<<function fl_merge_block>>

<<function fl_add_block>>
@


\subsection*{[[byterun/alloc.h]]}

<<constant _alloc_>>=
#define _alloc_
@


%-------------------------------------------------------------

<<byterun/alloc.h>>=
<<copyright header C xavier and damien>>

#ifndef _alloc_
<<constant _alloc_>>


#include "misc.h"
#include "mlvalues.h"

value alloc (mlsize_t, tag_t);
value alloc_tuple (mlsize_t);
value alloc_string (mlsize_t);
value alloc_final (mlsize_t, final_fun, mlsize_t, mlsize_t);
value copy_string (char *);
value copy_string_array (char **);
value copy_double (double);
value alloc_array (value (*funct) (char *), char ** array);
int convert_flag_list (value, int *);


#endif /* _alloc_ */
@


\subsection*{[[byterun/alloc.c]]}

<<constant Setup_for_gc>>=
#define Setup_for_gc
@

<<constant Restore_after_gc>>=
#define Restore_after_gc
@

<<function alloc>>=
value alloc (mlsize_t wosize, tag_t tag)
{
  value result;
  
  Assert (wosize > 0 && wosize <= Max_young_wosize);
  Alloc_small (result, wosize, tag);
  return result;
}
@

<<function alloc_tuple>>=
value alloc_tuple(mlsize_t n)
{
  return alloc(n, 0);
}
@

<<function alloc_string>>=
value alloc_string (mlsize_t len)
{
  value result;
  mlsize_t offset_index;
  mlsize_t wosize = (len + sizeof (value)) / sizeof (value);

  if (wosize <= Max_young_wosize) {
    Alloc_small (result, wosize, String_tag);
  }else{
    result = alloc_shr (wosize, String_tag);
    result = check_urgent_gc (result);
  }
  Field (result, wosize - 1) = 0;
  offset_index = Bsize_wsize (wosize) - 1;
  Byte (result, offset_index) = offset_index - len;
  return result;
}
@

<<function alloc_final>>=
value alloc_final (mlsize_t len, final_fun fun, mlsize_t mem, mlsize_t max)
{
  value result = alloc_shr (len, Final_tag);

  Field (result, 0) = (value) fun;
  adjust_gc_speed (mem, max);
  result = check_urgent_gc (result);
  return result;
}
@

<<function copy_string>>=
value copy_string(char *s)
{
  int len;
  value res;

  len = strlen(s);
  res = alloc_string(len);
  bcopy(s, String_val(res), len);
  return res;
}
@

<<function alloc_array>>=
value alloc_array(value (*funct)(char *), char ** arr)
{
  mlsize_t nbr, n;
  value v, result;

  nbr = 0;
  while (arr[nbr] != 0) nbr++;
  if (nbr == 0) {
    return Atom(0);
  } else {
    result = nbr < Max_young_wosize ? alloc(nbr, 0) : alloc_shr(nbr, 0);
    for (n = 0; n < nbr; n++) Field(result, n) = Val_int(0);
    Begin_root(result);
      for (n = 0; n < nbr; n++) {
    /* The two statements below must be separate because of evaluation
           order. */
    v = funct(arr[n]);
    modify(&Field(result, n), v);
      }
    End_roots();
    return result;
  }
}
@

<<function copy_string_array>>=
value copy_string_array(char **arr)
{
  return alloc_array(copy_string, arr);
}
@

<<function convert_flag_list>>=
int convert_flag_list(value list, int *flags)
{
  int res;
  res = 0;
  while (list != Val_int(0)) {
    res |= flags[Int_val(Field(list, 0))];
    list = Field(list, 1);
  }
  return res;
}
@


%-------------------------------------------------------------

<<byterun/alloc.c>>=
<<copyright header C xavier and damien>>

/* 1. Allocation functions doing the same work as the macros in the
      case where [Setup_for_gc] and [Restore_after_gc] are no-ops.
   2. Convenience functions related to allocation.
*/

#include <string.h>
#include "alloc.h"
#include "major_gc.h"
#include "memory.h"
#include "mlvalues.h"
#include "stacks.h"

<<constant Setup_for_gc>>
<<constant Restore_after_gc>>

<<function alloc>>

<<function alloc_tuple>>

<<function alloc_string>>

<<function alloc_final>>

<<function copy_string>>

<<function alloc_array>>

<<function copy_string_array>>

<<function convert_flag_list>>
@


\subsection*{[[byterun/interp.h]]}

<<constant _interp_>>=
#define _interp_
@


%-------------------------------------------------------------

<<byterun/interp.h>>=
<<copyright header C xavier>>

/* The bytecode interpreter */

#ifndef _interp_
<<constant _interp_>>


#include "misc.h"
#include "mlvalues.h"

value interprete (code_t prog, asize_t prog_size);


#endif
@


\subsection*{[[byterun/interp.c]]}

<<function Instruct>>=
#  define Instruct(name) lbl_##name
@

<<constant Jumptbl_base>>=
#    define Jumptbl_base ((char *) &&lbl_ACC0)
@

<<constant Jumptbl_base (byterun/interp.c)>>=
#    define Jumptbl_base ((char *) 0)
@

<<constant jumptbl_base>>=
#    define jumptbl_base ((char *) 0)
@

<<constant Setup_for_gc (byterun/interp.c)>>=
/* GC interface */

#define Setup_for_gc { sp -= 2; sp[0] = accu; sp[1] = env; extern_sp = sp; }
@

<<constant Restore_after_gc (byterun/interp.c)>>=
#define Restore_after_gc { accu = sp[0]; env = sp[1]; sp += 2; }
@

<<constant Setup_for_c_call>>=
#define Setup_for_c_call { *--sp = env; extern_sp = sp; }
@

<<constant Restore_after_c_call>>=
#define Restore_after_c_call { sp = extern_sp; env = *sp++; }
@

<<constant Setup_for_debugger>>=
/* Debugger interface */

#define Setup_for_debugger \
   { sp -= 4; \
     sp[0] = accu; sp[1] = (value)(pc - 1); \
     sp[2] = env; sp[3] = Val_long(extra_args); \
     extern_sp = sp; }
@

<<constant Restore_after_debugger>>=
#define Restore_after_debugger { sp += 4; }
@


%-------------------------------------------------------------

<<byterun/interp.c>>=
<<copyright header C xavier>>

/* The bytecode interpreter */

#include "alloc.h"
#include "callback.h"
#include "debugger.h"
#include "fail.h"
#include "fix_code.h"
#include "instrtrace.h"
#include "instruct.h"
#include "interp.h"
#include "major_gc.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"
#include "signals.h"
#include "stacks.h"
#include "str.h"

/* Registers for the abstract machine:
        pc         the code pointer
        sp         the stack pointer (grows downward)
        accu       the accumulator
        env        heap-allocated environment
        trapsp     pointer to the current trap frame
        extra_args number of extra arguments provided by the caller

sp is a local copy of the global variable extern_sp. */

/* Instruction decoding */

#ifdef THREADED_CODE
<<function Instruct>>
#  if defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
<<constant Jumptbl_base>>
#  else
<<constant Jumptbl_base (byterun/interp.c)>>
<<constant jumptbl_base>>
#  endif
#  ifdef DEBUG
#    define Next goto next_instr
#  else
#    define Next goto *(void *)(jumptbl_base + *pc++)
#  endif
#else
#  define Instruct(name) case name
#  define Next break
#endif

<<constant Setup_for_gc (byterun/interp.c)>>
<<constant Restore_after_gc (byterun/interp.c)>>
<<constant Setup_for_c_call>>
<<constant Restore_after_c_call>>

<<constant Setup_for_debugger>>
<<constant Restore_after_debugger>>

#ifdef THREADED_CODE
#define Restart_curr_instr \
  goto *(jumptable[saved_code[pc - 1 - start_code]])
#else
#define Restart_curr_instr \
  curr_instr = saved_code[pc - 1 - start_code]; \
  goto dispatch_instr
#endif

/* Register optimization.
   Some compilers underestimate the use of the local variables representing
   the abstract machine registers, and don't put them in hardware registers,
   which slows down the interpreter considerably.
   For GCC, I have hand-assigned hardware registers for several architectures.
*/

#if defined(__GNUC__) && !defined(DEBUG)
#ifdef __mips__
#define PC_REG asm("$16")
#define SP_REG asm("$17")
#define ACCU_REG asm("$18")
#endif
#ifdef __sparc__
#define PC_REG asm("%l0")
#define SP_REG asm("%l1")
#define ACCU_REG asm("%l2")
#endif
#ifdef __alpha__
#define PC_REG asm("$9")
#define SP_REG asm("$10")
#define ACCU_REG asm("$11")
#define JUMPTBL_BASE_REG asm("$12")
#endif
#ifdef __i386__
#define PC_REG asm("%esi")
#define SP_REG asm("%edi")
#define ACCU_REG asm("%ebx")
#endif
#if defined(PPC) || defined(_POWER) || defined(_IBMR2)
#define PC_REG asm("26")
#define SP_REG asm("27")
#define ACCU_REG asm("28")
#endif
#ifdef __hppa__
#define PC_REG asm("%r18")
#define SP_REG asm("%r17")
#define ACCU_REG asm("%r16")
#endif
#ifdef __mc68000__
#define PC_REG asm("a5")
#define SP_REG asm("a4")
#define ACCU_REG asm("d7")
#endif
#endif

/* The interpreter itself */

value interprete(code_t prog, asize_t prog_size)
{
#ifdef PC_REG
  register code_t pc PC_REG;
  register value * sp SP_REG;
  register value accu ACCU_REG;
#else
  register code_t pc;
  register value * sp;
  register value accu;
#endif
#if defined(THREADED_CODE) && defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
#ifdef JUMPTBL_BASE_REG
  register char * jumptbl_base JUMPTBL_BASE_REG;
#else
  register char * jumptbl_base;
#endif
#endif
  value env;
  long extra_args;
  struct longjmp_buffer * initial_external_raise;
  int initial_sp_offset;
  struct caml__roots_block *initial_local_roots;
  int initial_callback_depth;
  struct longjmp_buffer raise_buf;
  value * modify_dest, modify_newval;
#ifndef THREADED_CODE
  opcode_t curr_instr;
#endif

#ifdef THREADED_CODE
  static void * jumptable[] = {
#    include "jumptbl.h"
  };
#endif

  if (prog == NULL) {           /* Interpreter is initializing */
#ifdef THREADED_CODE
    instr_table = (char **) jumptable; 
    instr_base = Jumptbl_base;
#endif
    return Val_unit;
  }

#if defined(THREADED_CODE) && defined(ARCH_SIXTYFOUR) && !defined(ARCH_CODE32)
  jumptbl_base = Jumptbl_base;
#endif
  initial_local_roots = local_roots;
  initial_sp_offset = (char *) stack_high - (char *) extern_sp;
  initial_external_raise = external_raise;
  initial_callback_depth = callback_depth;

  if (sigsetjmp(raise_buf.buf, 1)) {
    local_roots = initial_local_roots;
    callback_depth = initial_callback_depth;
    accu = exn_bucket;
    goto raise_exception;
  }
  external_raise = &raise_buf;

  sp = extern_sp;
  pc = prog;
  extra_args = 0;
  env = Atom(0);
  accu = Val_int(0);

#ifdef THREADED_CODE
#ifdef DEBUG
 next_instr:
  if (icount-- == 0) stop_here ();
  Assert(sp >= stack_low);
  Assert(sp <= stack_high);
#endif
  goto *(void *)(jumptbl_base + *pc++); /* Jump to the first instruction */
#else
  while(1) {
#ifdef DEBUG
    if (icount-- == 0) stop_here ();
    if (trace_flag) disasm_instr(pc);
    Assert(sp >= stack_low);
    Assert(sp <= stack_high);
#endif
    curr_instr = *pc++;
  dispatch_instr:
    switch(curr_instr) {
#endif

/* Basic stack operations */

    Instruct(ACC0):
      accu = sp[0]; Next;
    Instruct(ACC1):
      accu = sp[1]; Next;
    Instruct(ACC2):
      accu = sp[2]; Next;
    Instruct(ACC3):
      accu = sp[3]; Next;
    Instruct(ACC4):
      accu = sp[4]; Next;
    Instruct(ACC5):
      accu = sp[5]; Next;
    Instruct(ACC6):
      accu = sp[6]; Next;
    Instruct(ACC7):
      accu = sp[7]; Next;

    Instruct(PUSH): Instruct(PUSHACC0):
      *--sp = accu; Next;
    Instruct(PUSHACC1):
      *--sp = accu; accu = sp[1]; Next;
    Instruct(PUSHACC2):
      *--sp = accu; accu = sp[2]; Next;
    Instruct(PUSHACC3):
      *--sp = accu; accu = sp[3]; Next;
    Instruct(PUSHACC4):
      *--sp = accu; accu = sp[4]; Next;
    Instruct(PUSHACC5):
      *--sp = accu; accu = sp[5]; Next;
    Instruct(PUSHACC6):
      *--sp = accu; accu = sp[6]; Next;
    Instruct(PUSHACC7):
      *--sp = accu; accu = sp[7]; Next;

    Instruct(PUSHACC):
      *--sp = accu;
      /* Fallthrough */
    Instruct(ACC):
      accu = sp[*pc++];
      Next;

    Instruct(POP):
      sp += *pc++;
      Next;
    Instruct(ASSIGN):
      sp[*pc++] = accu;
      accu = Val_unit;
      Next;

/* Access in heap-allocated environment */

    Instruct(ENVACC1):
      accu = Field(env, 1); Next;
    Instruct(ENVACC2):
      accu = Field(env, 2); Next;
    Instruct(ENVACC3):
      accu = Field(env, 3); Next;
    Instruct(ENVACC4):
      accu = Field(env, 4); Next;

    Instruct(PUSHENVACC1):
      *--sp = accu; accu = Field(env, 1); Next;
    Instruct(PUSHENVACC2):
      *--sp = accu; accu = Field(env, 2); Next;
    Instruct(PUSHENVACC3):
      *--sp = accu; accu = Field(env, 3); Next;
    Instruct(PUSHENVACC4):
      *--sp = accu; accu = Field(env, 4); Next;

    Instruct(PUSHENVACC):
      *--sp = accu;
      /* Fallthrough */
    Instruct(ENVACC):
      accu = Field(env, *pc++);
      Next;

/* Function application */

    Instruct(PUSH_RETADDR): {
      sp -= 3;
      sp[0] = (value) (pc + *pc);
      sp[1] = env;
      sp[2] = Val_long(extra_args);
      pc++;
      Next;
    }
    Instruct(APPLY): {
      extra_args = *pc - 1;
      pc = Code_val(accu);
      env = accu;
      goto check_stacks;
    }
    Instruct(APPLY1): {
      value arg1 = sp[0];
      sp -= 3;
      sp[0] = arg1;
      sp[1] = (value)pc;
      sp[2] = env;
      sp[3] = Val_long(extra_args);
      pc = Code_val(accu);
      env = accu;
      extra_args = 0;
      goto check_stacks;
    }
    Instruct(APPLY2): {
      value arg1 = sp[0];
      value arg2 = sp[1];
      sp -= 3;
      sp[0] = arg1;
      sp[1] = arg2;
      sp[2] = (value)pc;
      sp[3] = env;
      sp[4] = Val_long(extra_args);
      pc = Code_val(accu);
      env = accu;
      extra_args = 1;
      goto check_stacks;
    }
    Instruct(APPLY3): {
      value arg1 = sp[0];
      value arg2 = sp[1];
      value arg3 = sp[2];
      sp -= 3;
      sp[0] = arg1;
      sp[1] = arg2;
      sp[2] = arg3;
      sp[3] = (value)pc;
      sp[4] = env;
      sp[5] = Val_long(extra_args);
      pc = Code_val(accu);
      env = accu;
      extra_args = 2;
      goto check_stacks;
    }

    Instruct(APPTERM): {
      int nargs = *pc++;
      int slotsize = *pc;
      value * newsp;
      int i;
      /* Slide the nargs bottom words of the current frame to the top
         of the frame, and discard the remainder of the frame */
      newsp = sp + slotsize - nargs;
      for (i = nargs - 1; i >= 0; i--) newsp[i] = sp[i];
      sp = newsp;
      pc = Code_val(accu);
      env = accu;
      extra_args += nargs - 1;
      goto check_stacks;
    }
    Instruct(APPTERM1): {
      value arg1 = sp[0];
      sp = sp + *pc - 1;
      sp[0] = arg1;
      pc = Code_val(accu);
      env = accu;
      goto check_stacks;
    }
    Instruct(APPTERM2): {
      value arg1 = sp[0];
      value arg2 = sp[1];
      sp = sp + *pc - 2;
      sp[0] = arg1;
      sp[1] = arg2;
      pc = Code_val(accu);
      env = accu;
      extra_args += 1;
      goto check_stacks;
    }
    Instruct(APPTERM3): {
      value arg1 = sp[0];
      value arg2 = sp[1];
      value arg3 = sp[2];
      sp = sp + *pc - 3;
      sp[0] = arg1;
      sp[1] = arg2;
      sp[2] = arg3;
      pc = Code_val(accu);
      env = accu;
      extra_args += 2;
      goto check_stacks;
    }

    Instruct(RETURN): {
      sp += *pc++;
      if (extra_args > 0) {
        extra_args--;
        pc = Code_val(accu);
        env = accu;
      } else {
        pc = (code_t)(sp[0]);
        env = sp[1];
        extra_args = Long_val(sp[2]);
        sp += 3;
      }
      Next;
    }

    Instruct(RESTART): {
      int num_args = Wosize_val(env) - 2;
      int i;
      sp -= num_args;
      for (i = 0; i < num_args; i++) sp[i] = Field(env, i + 2);
      env = Field(env, 1);
      extra_args += num_args;
      Next;
    }

    Instruct(GRAB): {
      int required = *pc++;
      if (extra_args >= required) {
        extra_args -= required;
      } else {
        mlsize_t num_args, i;
        num_args = 1 + extra_args; /* arg1 + extra args */
        Alloc_small(accu, num_args + 2, Closure_tag);
        Field(accu, 1) = env;
        for (i = 0; i < num_args; i++) Field(accu, i + 2) = sp[i];
        Code_val(accu) = pc - 3; /* Point to the preceding RESTART instr. */
        sp += num_args;
        pc = (code_t)(sp[0]);
        env = sp[1];
        extra_args = Long_val(sp[2]);
        sp += 3;
      }
      Next;
    }

    Instruct(CLOSURE): {
      int nvars = *pc++;
      int i;
      if (nvars > 0) *--sp = accu;
      Alloc_small(accu, 1 + nvars, Closure_tag);
      Code_val(accu) = pc + *pc;
      for (i = 0; i < nvars; i++) Field(accu, i + 1) = sp[i];
      sp += nvars;
      pc++;
      Next;
    }

    Instruct(CLOSUREREC): {
      int nvars = *pc++;
      int i;
      if (nvars > 0) *--sp = accu;
      Alloc_small(accu, 2 + nvars, Closure_tag);
      Code_val(accu) = pc + *pc;
      Field(accu, 1) = Val_int(0);
      for (i = 0; i < nvars; i++) Field(accu, i + 2) = sp[i];
      sp += nvars;
      modify(&Field(accu, 1), accu);
      pc++;
      Next;
    }

    Instruct(PUSHGETGLOBAL):
      *--sp = accu;
      /* Fallthrough */
    Instruct(GETGLOBAL):
      accu = Field(global_data, *pc);
      pc++;
      Next;

    Instruct(PUSHGETGLOBALFIELD):
      *--sp = accu;
      /* Fallthrough */
    Instruct(GETGLOBALFIELD): {
      accu = Field(global_data, *pc);
      pc++;
      accu = Field(accu, *pc);
      pc++;
      Next;
    }

    Instruct(SETGLOBAL):
      modify(&Field(global_data, *pc), accu);
      accu = Val_unit;
      pc++;
      Next;

/* Allocation of blocks */

    Instruct(PUSHATOM0):
      *--sp = accu;
      /* Fallthrough */
    Instruct(ATOM0):
      accu = Atom(0); Next;

    Instruct(PUSHATOM):
      *--sp = accu;
      /* Fallthrough */
    Instruct(ATOM):
      accu = Atom(*pc++); Next;

    Instruct(MAKEBLOCK): {
      mlsize_t wosize = *pc++;
      tag_t tag = *pc++;
      mlsize_t i;
      value block;
      Alloc_small(block, wosize, tag);
      Field(block, 0) = accu;
      for (i = 1; i < wosize; i++) Field(block, i) = *sp++;
      accu = block;
      Next;
    }
    Instruct(MAKEBLOCK1): {
      tag_t tag = *pc++;
      value block;
      Alloc_small(block, 1, tag);
      Field(block, 0) = accu;
      accu = block;
      Next;
    }
    Instruct(MAKEBLOCK2): {
      tag_t tag = *pc++;
      value block;
      Alloc_small(block, 2, tag);
      Field(block, 0) = accu;
      Field(block, 1) = sp[0];
      sp += 1;
      accu = block;
      Next;
    }
    Instruct(MAKEBLOCK3): {
      tag_t tag = *pc++;
      value block;
      Alloc_small(block, 3, tag);
      Field(block, 0) = accu;
      Field(block, 1) = sp[0];
      Field(block, 2) = sp[1];
      sp += 2;
      accu = block;
      Next;
    }

/* Access to components of blocks */

    Instruct(GETFIELD0):
      accu = Field(accu, 0); Next;
    Instruct(GETFIELD1):
      accu = Field(accu, 1); Next;
    Instruct(GETFIELD2):
      accu = Field(accu, 2); Next;
    Instruct(GETFIELD3):
      accu = Field(accu, 3); Next;
    Instruct(GETFIELD):
      accu = Field(accu, *pc); pc++; Next;

    Instruct(SETFIELD0):
      modify_dest = &Field(accu, 0);
      modify_newval = *sp++;
    modify:
      Modify(modify_dest, modify_newval);
      accu = Val_unit;
      Next;
    Instruct(SETFIELD1):
      modify_dest = &Field(accu, 1);
      modify_newval = *sp++;
      goto modify;
    Instruct(SETFIELD2):
      modify_dest = &Field(accu, 2);
      modify_newval = *sp++;
      goto modify;
    Instruct(SETFIELD3):
      modify_dest = &Field(accu, 3);
      modify_newval = *sp++;
      goto modify;
    Instruct(SETFIELD):
      modify_dest = &Field(accu, *pc);
      pc++;
      modify_newval = *sp++;
      goto modify;

/* For recursive definitions */

    Instruct(DUMMY): {
      int size = *pc++;
      Alloc_small(accu, size, 0);
      while (size--) Field(accu, size) = Val_long(0);
      Next;
    }
    Instruct(UPDATE): {
      value newval = *sp++;
      mlsize_t size, n;
      size = Wosize_val(newval);
      Assert(size == Wosize_val(accu));
      Tag_val(accu) = Tag_val(newval);
      for (n = 0; n < size; n++) {
        modify(&Field(accu, n), Field(newval, n));
      }
      accu = Val_unit;
      Next;
    }

/* Array operations */

    Instruct(VECTLENGTH):
      accu = Val_long(Wosize_val(accu));
      Next;
    Instruct(GETVECTITEM):
      accu = Field(accu, Long_val(sp[0]));
      sp += 1;
      Next;
    Instruct(SETVECTITEM):
      modify_dest = &Field(accu, Long_val(sp[0]));
      modify_newval = sp[1];
      sp += 2;
      goto modify;

/* String operations */

    Instruct(GETSTRINGCHAR):
      accu = Val_int(Byte_u(accu, Long_val(sp[0])));
      sp += 1;
      Next;
    Instruct(SETSTRINGCHAR):
      Byte_u(accu, Long_val(sp[0])) = Int_val(sp[1]);
      sp += 2;
      accu = Val_unit;
      Next;

/* Branches and conditional branches */

    Instruct(BRANCH):
      pc += *pc;
      Next;
    Instruct(BRANCHIF):
      if (accu != Val_false) pc += *pc; else pc++;
      Next;
    Instruct(BRANCHIFNOT):
      if (accu == Val_false) pc += *pc; else pc++;
      Next;
    Instruct(SWITCH): {
      uint32 sizes = *pc++;
      if (Is_block(accu)) {
        long index = Tag_val(accu);
        Assert(index >= 0 && index < (sizes >> 16));
        pc += pc[(sizes & 0xFFFF) + index];
      } else {
        long index = Long_val(accu);
        if ((unsigned long) index < (sizes & 0xFFFF))
          pc += pc[index];
        else
          pc += (sizes & 0xFFFF) + (sizes >> 16);
      }
      Next;
    }
    Instruct(BOOLNOT):
      accu = Val_not(accu);
      Next;

/* Exceptions */

    Instruct(PUSHTRAP):
      sp -= 4;
      Trap_pc(sp) = pc + *pc;
      Trap_link(sp) = trapsp;
      sp[2] = env;
      sp[3] = Val_long(extra_args);
      trapsp = sp;
      pc++;
      Next;

    Instruct(POPTRAP):
      /* We should check here if a signal is pending, to preserve the
         semantics of the program w.r.t. exceptions. Unfortunately,
         process_signal destroys the accumulator, and there is no
         convenient way to preserve it... */
      trapsp = Trap_link(sp);
      sp += 4;
      Next;

    Instruct(RAISE):
    raise_exception:
      if (trapsp >= trap_barrier) debugger(TRAP_BARRIER);
      sp = trapsp;
      if ((char *) sp >= (char *) stack_high - initial_sp_offset) {
        exn_bucket = accu;
        external_raise = initial_external_raise;
        siglongjmp(external_raise->buf, 1);
      }
      pc = Trap_pc(sp);
      trapsp = Trap_link(sp);
      env = sp[2];
      extra_args = Long_val(sp[3]);
      sp += 4;
      Next;

/* Stack checks */

    check_stacks:
      if (sp < stack_threshold) {
        extern_sp = sp;
        realloc_stack();
        sp = extern_sp;
      }
      /* Fall through CHECK_SIGNALS */

/* Signal handling */

    Instruct(CHECK_SIGNALS):    /* accu not preserved */
      if (something_to_do) goto process_signal;
      Next;

    process_signal:
      something_to_do = 0;
      if (force_major_slice){
        Setup_for_gc;
        minor_collection ();
        Restore_after_gc;
      }
      /* If a signal arrives between the following two instructions,
         it will be lost. */
      { int signal_number = pending_signal;
        pending_signal = 0;
        if (signal_number) {
          /* Push a return frame to the current code location */
          sp -= 4;
          sp[0] = Val_int(signal_number);
          sp[1] = (value) pc;
          sp[2] = env;
          sp[3] = Val_long(extra_args);
          /* Branch to the signal handler */
          env = Field(signal_handlers, signal_number);
          pc = Code_val(env);
          extra_args = 0;
        }
      }
      Next;

/* Calling C functions */

    Instruct(C_CALL1):
      Setup_for_c_call;
      accu = cprim[*pc](accu);
      Restore_after_c_call;
      pc++;
      Next;
    Instruct(C_CALL2):
      Setup_for_c_call;
      accu = cprim[*pc](accu, sp[1]);
      Restore_after_c_call;
      sp += 1;
      pc++;
      Next;
    Instruct(C_CALL3):
      Setup_for_c_call;
      accu = cprim[*pc](accu, sp[1], sp[2]);
      Restore_after_c_call;
      sp += 2;
      pc++;
      Next;
    Instruct(C_CALL4):
      Setup_for_c_call;
      accu = cprim[*pc](accu, sp[1], sp[2], sp[3]);
      Restore_after_c_call;
      sp += 3;
      pc++;
      Next;
    Instruct(C_CALL5):
      Setup_for_c_call;
      accu = cprim[*pc](accu, sp[1], sp[2], sp[3], sp[4]);
      Restore_after_c_call;
      sp += 4;
      pc++;
      Next;
    Instruct(C_CALLN): {
      int nargs = *pc++;
      *--sp = accu;
      Setup_for_c_call;
      accu = cprim[*pc](sp + 1, nargs);
      Restore_after_c_call;
      sp += nargs;
      pc++;
      Next;
    }

/* Integer constants */

    Instruct(CONST0):
      accu = Val_int(0); Next;
    Instruct(CONST1):
      accu = Val_int(1); Next;
    Instruct(CONST2):
      accu = Val_int(2); Next;
    Instruct(CONST3):
      accu = Val_int(3); Next;

    Instruct(PUSHCONST0):
      *--sp = accu; accu = Val_int(0); Next;
    Instruct(PUSHCONST1):
      *--sp = accu; accu = Val_int(1); Next;
    Instruct(PUSHCONST2):
      *--sp = accu; accu = Val_int(2); Next;
    Instruct(PUSHCONST3):
      *--sp = accu; accu = Val_int(3); Next;

    Instruct(PUSHCONSTINT):
      *--sp = accu;
      /* Fallthrough */
    Instruct(CONSTINT):
      accu = Val_int(*pc);
      pc++;
      Next;

/* Integer arithmetic */

    Instruct(NEGINT):
      accu = (value)(2 - (long)accu); Next;
    Instruct(ADDINT):
      accu = (value)((long) accu + (long) *sp++ - 1); Next;
    Instruct(SUBINT):
      accu = (value)((long) accu - (long) *sp++ + 1); Next;
    Instruct(MULINT):
      accu = Val_long(Long_val(accu) * Long_val(*sp++)); Next;

    Instruct(DIVINT): {
      long divisor = Long_val(*sp++);
      if (divisor == 0) { Setup_for_c_call; raise_zero_divide(); }
      accu = Val_long(Long_val(accu) / divisor);
      Next;
    }
    Instruct(MODINT): {
      long divisor = Long_val(*sp++);
      if (divisor == 0) { Setup_for_c_call; raise_zero_divide(); }
      accu = Val_long(Long_val(accu) % divisor);
      Next;
    }
    Instruct(ANDINT):
      accu = (value)((long) accu & (long) *sp++); Next;
    Instruct(ORINT):
      accu = (value)((long) accu | (long) *sp++); Next;
    Instruct(XORINT):
      accu = (value)(((long) accu ^ (long) *sp++) | 1); Next;
    Instruct(LSLINT):
      accu = (value)((((long) accu - 1) << Long_val(*sp++)) + 1); Next;
    Instruct(LSRINT):
      accu = (value)((((unsigned long) accu - 1) >> Long_val(*sp++)) | 1);
      Next;
    Instruct(ASRINT):
      accu = (value)((((long) accu - 1) >> Long_val(*sp++)) | 1); Next;

#define Integer_comparison(opname,tst) \
    Instruct(opname): \
      accu = Val_int((long) accu tst (long) *sp++); Next;

    Integer_comparison(EQ, ==)
    Integer_comparison(NEQ, !=)
    Integer_comparison(LTINT, <)
    Integer_comparison(LEINT, <=)
    Integer_comparison(GTINT, >)
    Integer_comparison(GEINT, >=)

    Instruct(OFFSETINT):
      accu += *pc << 1;
      pc++;
      Next;
    Instruct(OFFSETREF):
      Field(accu, 0) += *pc << 1;
      accu = Val_unit;
      pc++;
      Next;

/* Object-oriented operations */

#define Lookup(obj, lab) \
  Field (Field (Field (obj, 0), ((lab) >> 16) / sizeof (value)), \
         ((lab) / sizeof (value)) & 0xFF)

    Instruct(GETMETHOD):
      accu = Lookup(sp[0], accu);
      Next;

/* Debugging and machine control */

    Instruct(STOP):
      external_raise = initial_external_raise;
      extern_sp = sp;
      return accu;

    Instruct(EVENT):
      if (--event_count == 0) {
        Setup_for_debugger;
        debugger(EVENT_COUNT);
        Restore_after_debugger;
      }
      Restart_curr_instr;

    Instruct(BREAK):
      Setup_for_debugger;
      debugger(BREAKPOINT);
      Restore_after_debugger;
      Restart_curr_instr;

#ifndef THREADED_CODE
    default:
      fatal_error_arg("Fatal error: bad opcode (%lx)\n",
                      (char *)(long)(*(pc-1)));
    }
  }
#endif
}
@


\subsection*{[[byterun/gc.h]]}

<<constant _gc_>>=
#define _gc_
@

<<constant White>>=
#define White (0 << 8)
@

<<constant Gray>>=
#define Gray  (1 << 8)
@

<<constant Blue>>=
#define Blue  (2 << 8)
@

<<constant Black>>=
#define Black (3 << 8)
@

<<function Color_hd>>=
#define Color_hd(hd) ((color_t) ((hd) & Black))
@

<<function Color_hp>>=
#define Color_hp(hp) Color_hd (Hd_hp (hp))
@

<<function Is_white_hd>>=
#define Is_white_hd(hd) (Color_hd (hd) == White)
@

<<function Is_gray_hd>>=
#define Is_gray_hd(hd) (Color_hd (hd) == Gray)
@

<<function Is_blue_hd>>=
#define Is_blue_hd(hd) (Color_hd (hd) == Blue)
@

<<function Is_black_hd>>=
#define Is_black_hd(hd) (Color_hd (hd) == Black)
@

<<function Whitehd_hd>>=
#define Whitehd_hd(hd) (((hd)  & ~Black)/*| White*/)
@

<<function Grayhd_hd>>=
#define Grayhd_hd(hd)  (((hd)  & ~Black)  | Gray)
@

<<function Blackhd_hd>>=
#define Blackhd_hd(hd) (((hd)/*& ~Black*/)| Black)
@

<<function Bluehd_hd>>=
#define Bluehd_hd(hd)  (((hd)  & ~Black)  | Blue)
@

<<function Make_header>>=
/* This depends on the layout of the header.  See [mlvalues.h]. */
#define Make_header(wosize, tag, color)                                       \
       ((header_t) (((header_t) (wosize) << 10)                               \
                    + (color)                                                 \
                    + (tag_t) (tag)))
@

<<function Color_val>>=
#define Color_val(val) (Color_hd (Hd_val (val)))
@

<<function Is_white_val>>=
#define Is_white_val(val) (Color_val(val) == White)
@

<<function Is_gray_val>>=
#define Is_gray_val(val) (Color_val(val) == Gray)
@

<<function Is_blue_val>>=
#define Is_blue_val(val) (Color_val(val) == Blue)
@

<<function Is_black_val>>=
#define Is_black_val(val) (Color_val(val) == Black)
@


%-------------------------------------------------------------

<<byterun/gc.h>>=
<<copyright header C damien>>

#ifndef _gc_
<<constant _gc_>>


#include "mlvalues.h"

<<constant White>>
<<constant Gray>>
<<constant Blue>>
<<constant Black>>

<<function Color_hd>>
<<function Color_hp>>

<<function Is_white_hd>>
<<function Is_gray_hd>>
<<function Is_blue_hd>>
<<function Is_black_hd>>

<<function Whitehd_hd>>
<<function Grayhd_hd>>
<<function Blackhd_hd>>
<<function Bluehd_hd>>

<<function Make_header>>

<<function Color_val>>

<<function Is_white_val>>
<<function Is_gray_val>>
<<function Is_blue_val>>
<<function Is_black_val>>


#endif /* _gc_ */
@


\subsection*{[[byterun/gc_ctrl.h]]}

<<constant _gc_ctrl_>>=
#define _gc_ctrl_
@


%-------------------------------------------------------------

<<byterun/gc_ctrl.h>>=
<<copyright header C damien>>

#ifndef _gc_ctrl_
<<constant _gc_ctrl_>>

#include "misc.h"

extern long
     stat_minor_words,
     stat_promoted_words,
     stat_major_words,
     stat_minor_collections,
     stat_major_collections,
     stat_heap_size,
     stat_compactions;

void init_gc (unsigned long, unsigned long, unsigned long,
              unsigned long, unsigned long, unsigned long);


#endif /* _gc_ctrl_ */
@


\subsection*{[[byterun/gc_ctrl.c]]}

<<function Next (byterun/gc_ctrl.c)>>=
#define Next(hp) ((hp) + Bhsize_hp (hp))
@

<<function gc_stat>>=
/* This will also thoroughly verify the heap if compiled in DEBUG mode. */

value gc_stat(value v) /* ML */
{
  value res;
  long live_words = 0, live_blocks = 0,
       free_words = 0, free_blocks = 0, largest_free = 0,
       fragments = 0, heap_chunks = 0;
  char *chunk = heap_start, *chunk_end;
  char *cur_hp, *prev_hp;
  header_t cur_hd;

  Assert (v == Val_unit);

  while (chunk != NULL){
    ++ heap_chunks;
    chunk_end = chunk + Chunk_size (chunk);
    prev_hp = NULL;
    cur_hp = chunk;
    while (cur_hp < chunk_end){
      cur_hd = Hd_hp (cur_hp);
      switch (Color_hd (cur_hd)){
      case White:
        if (Wosize_hd (cur_hd) == 0){
          ++fragments;
          Assert (prev_hp == NULL
                  || (Color_hp (prev_hp) != Blue
                      && Wosize_hp (prev_hp) > 0)
          || cur_hp == gc_sweep_hp);
          Assert (Next (cur_hp) == chunk_end
                  || (Color_hp (Next (cur_hp)) != Blue
                      && Wosize_hp (Next (cur_hp)) > 0)
          || Next (cur_hp) == gc_sweep_hp);
          break;
        }
        /* FALLTHROUGH */
      case Gray: case Black:
        Assert (Wosize_hd (cur_hd) > 0);
        ++ live_blocks;
        live_words += Whsize_hd (cur_hd);
        break;
      case Blue:
        Assert (Wosize_hd (cur_hd) > 0);
        ++ free_blocks;
        free_words += Whsize_hd (cur_hd);
        if (Whsize_hd (cur_hd) > largest_free){
          largest_free = Whsize_hd (cur_hd);
        }
        Assert (prev_hp == NULL
                || (Color_hp (prev_hp) != Blue
                    && Wosize_hp (prev_hp) > 0)
        || cur_hp == gc_sweep_hp);
        Assert (Next (cur_hp) == chunk_end
                || (Color_hp (Next (cur_hp)) != Blue
                    && Wosize_hp (Next (cur_hp)) > 0)
        || Next (cur_hp) == gc_sweep_hp);
        break;
      }
      prev_hp = cur_hp;
      cur_hp = Next (cur_hp);
    }                                          Assert (cur_hp == chunk_end);
    chunk = Chunk_next (chunk);
  }
  
  Assert (live_words + free_words + fragments == Wsize_bsize (stat_heap_size));

  res = alloc (14, 0);
  Field (res, 0) = Val_long (stat_minor_words
                             + Wsize_bsize (young_end - young_ptr));
  Field (res, 1) = Val_long (stat_promoted_words);
  Field (res, 2) = Val_long (stat_major_words + allocated_words);
  Field (res, 3) = Val_long (stat_minor_collections);
  Field (res, 4) = Val_long (stat_major_collections);
  Field (res, 5) = Val_long (Wsize_bsize (stat_heap_size));
  Field (res, 6) = Val_long (heap_chunks);
  Field (res, 7) = Val_long (live_words);
  Field (res, 8) = Val_long (live_blocks);
  Field (res, 9) = Val_long (free_words);
  Field (res, 10) = Val_long (free_blocks);
  Field (res, 11) = Val_long (largest_free);
  Field (res, 12) = Val_long (fragments);
  Field (res, 13) = Val_long (stat_compactions);
  return res;
}
@

<<function gc_get>>=
value gc_get(value v) /* ML */
{
  value res;

  Assert (v == Val_unit);
  res = alloc (6, 0);
  Field (res, 0) = Wsize_bsize (Val_long (minor_heap_size));
  Field (res, 1) = Wsize_bsize (Val_long (major_heap_increment));
  Field (res, 2) = Val_long (percent_free);
  Field (res, 3) = Val_bool (verb_gc);
  Field (res, 4) = Val_long (percent_max);
#ifndef NATIVE_CODE
  Field (res, 5) = Val_long (max_stack_size);
#else
  Field (res, 5) = 0;
#endif
  return res;
}
@

<<function Max>>=
#define Max(x,y) ((x) < (y) ? (y) : (x))
@

<<function norm_pfree>>=
static unsigned long norm_pfree (long unsigned int p)
{
  return Max (p, 1);
}
@

<<function norm_pmax>>=
static unsigned long norm_pmax (long unsigned int p)
{
  return p;
}
@

<<function norm_heapincr>>=
static long norm_heapincr (long unsigned int i)
{
#define Psv (Wsize_bsize (Page_size))
  i = ((i + Psv - 1) / Psv) * Psv;
  if (i < Heap_chunk_min) i = Heap_chunk_min;
  if (i > Heap_chunk_max) i = Heap_chunk_max;
  return i;
}
@

<<function norm_minsize>>=
static long norm_minsize (long int s)
{
  if (s < Minor_heap_min) s = Minor_heap_min;
  if (s > Minor_heap_max) s = Minor_heap_max;
  return s;
}
@

<<function gc_set>>=
value gc_set(value v) /* ML */
{
  unsigned long newpf, newpm;
  asize_t newheapincr;
  asize_t newminsize;

  verb_gc = Bool_val (Field (v, 3));

#ifndef NATIVE_CODE
  change_max_stack_size (Long_val (Field (v, 5)));
#endif

  newpf = norm_pfree (Long_val (Field (v, 2)));
  if (newpf != percent_free){
    percent_free = newpf;
    gc_message ("New space overhead: %d%%\n", percent_free);
  }

  newpm = norm_pmax (Long_val (Field (v, 4)));
  if (newpm != percent_max){
    percent_max = newpm;
    gc_message ("New max overhead: %d%%\n", percent_max);
  }

  newheapincr = norm_heapincr (Bsize_wsize (Long_val (Field (v, 1))));
  if (newheapincr != major_heap_increment){
    major_heap_increment = newheapincr;
    gc_message ("New heap increment size: %luk bytes\n",
                major_heap_increment/1024);
  }

    /* Minor heap size comes last because it will trigger a minor collection
       (thus invalidating [v]) and it can raise [Out_of_memory]. */
  newminsize = norm_minsize (Bsize_wsize (Long_val (Field (v, 0))));
  if (newminsize != minor_heap_size){
    gc_message ("New minor heap size: %luk bytes\n", newminsize/1024);
    set_minor_heap_size (newminsize);
  }
  return Val_unit;
}
@

<<function gc_minor>>=
value gc_minor(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  return Val_unit;
}
@

<<function gc_major>>=
value gc_major(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  finish_major_cycle ();
  return Val_unit;
}
@

<<function gc_full_major>>=
value gc_full_major(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  finish_major_cycle ();
  finish_major_cycle ();
  return Val_unit;
}
@

<<function gc_compaction>>=
value gc_compaction(value v) /* ML */
{                                                    Assert (v == Val_unit);
  minor_collection ();
  finish_major_cycle ();
  finish_major_cycle ();
  compact_heap ();
  return Val_unit;
}
@

<<function init_gc>>=
void init_gc (long unsigned int minor_size, long unsigned int major_size, long unsigned int major_incr, long unsigned int percent_fr, long unsigned int percent_m, long unsigned int verb)
{
  unsigned long major_heap_size = Bsize_wsize (norm_heapincr (major_size));
#ifdef DEBUG
  verb_gc = 1;
  gc_message ("*** O'Caml runtime: debug mode ***\n", 0);
#endif
  verb_gc = verb;
  set_minor_heap_size (Bsize_wsize (norm_minsize (minor_size)));
  major_heap_increment = Bsize_wsize (norm_heapincr (major_incr));
  percent_free = norm_pfree (percent_fr);
  percent_max = norm_pmax (percent_m);
  init_major_heap (major_heap_size);
  gc_message ("Initial minor heap size: %luk bytes\n", minor_heap_size / 1024);
  gc_message ("Initial major heap size: %luk bytes\n", major_heap_size / 1024);
  gc_message ("Initial space overhead: %lu%%\n", percent_free);
  gc_message ("Initial max overhead: %lu%%\n", percent_max);
  gc_message ("Initial heap increment: %luk bytes\n",
              major_heap_increment / 1024);
}
@


%-------------------------------------------------------------

<<byterun/gc_ctrl.c>>=
<<copyright header C damien>>

#include "alloc.h"
#include "compact.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "stacks.h"

#ifndef NATIVE_CODE
extern unsigned long max_stack_size;    /* defined in stacks.c */
#endif

long stat_minor_words = 0,
     stat_promoted_words = 0,
     stat_major_words = 0,
     stat_minor_collections = 0,
     stat_major_collections = 0,
     stat_heap_size = 0,           /* bytes */
     stat_compactions = 0;

extern asize_t major_heap_increment;  /* bytes; cf. major_gc.c */
extern unsigned long percent_free;    /*        cf. major_gc.c */
extern unsigned long percent_max;     /*        cf. compact.c */

<<function Next (byterun/gc_ctrl.c)>>

<<function gc_stat>>

<<function gc_get>>

<<function Max>>

<<function norm_pfree>>

<<function norm_pmax>>

<<function norm_heapincr>>

<<function norm_minsize>>

<<function gc_set>>

<<function gc_minor>>

<<function gc_major>>

<<function gc_full_major>>

<<function gc_compaction>>

<<function init_gc>>
@


\subsection*{[[byterun/roots.h]]}

<<constant _roots_>>=
#define _roots_
@


%-------------------------------------------------------------

<<byterun/roots.h>>=
<<copyright header C xavier and damien>>

#ifndef _roots_
<<constant _roots_>>

#include "misc.h"
#include "memory.h"

typedef void (*scanning_action) (value, value *);

void oldify_local_roots (void);
void darken_all_roots (void);
void do_roots (scanning_action);
#ifndef NATIVE_CODE
void do_local_roots (scanning_action, value *, value *,
                     struct caml__roots_block *);
#else
void do_local_roots(scanning_action f, char * bottom_of_stack,
                    unsigned long last_retaddr, value * gc_regs,
                    struct caml__roots_block * local_roots);
#endif

extern void (*scan_roots_hook) (scanning_action);

#endif /* _roots_ */
@


\subsection*{[[byterun/roots.c]]}

<<global local_roots>>=
struct caml__roots_block *local_roots = NULL;
@

<<struct global_root>>=
struct global_root {
  value * root;
  struct global_root * next;
};
@

<<global global_roots>>=
static struct global_root * global_roots = NULL;
@

<<global scan_roots_hook>>=
void (*scan_roots_hook) (scanning_action f) = NULL;
@

<<function register_global_root>>=
/* Register a global C root */

void register_global_root(value *r)
{
  struct global_root * gr;
  gr = (struct global_root *) stat_alloc(sizeof(struct global_root));
  gr->root = r;
  gr->next = global_roots;
  global_roots = gr;
}
@

<<function remove_global_root>>=
/* Un-register a global C root */

void remove_global_root(value *r)
{
  struct global_root ** gp, * gr;
  for (gp = &global_roots; *gp != NULL; gp = &(*gp)->next) {
    gr = *gp;
    if (gr->root == r) {
      *gp = gr->next;
      stat_free(gr);
      return;
    }
  }
}
@

<<function oldify_local_roots>>=
/* Call [oldify] on all roots except [global_data] */

void oldify_local_roots (void)
{
  register value * sp;
  struct global_root * gr;
  struct caml__roots_block *lr;
  long i, j;

  /* The stack */
  for (sp = extern_sp; sp < stack_high; sp++) {
    oldify (*sp, sp);
  }
  /* Local C roots */
  for (lr = local_roots; lr != NULL; lr = lr->next) {
    for (i = 0; i < lr->ntables; i++){
      for (j = 0; j < lr->nitems; j++){
        sp = &(lr->tables[i][j]);
        oldify (*sp, sp);
      }
    }
  }
  /* Global C roots */
  for (gr = global_roots; gr != NULL; gr = gr->next) {
    oldify(*(gr->root), gr->root);
  }
  /* Hook */
  if (scan_roots_hook != NULL) (*scan_roots_hook)(oldify);
}
@

<<function darken_all_roots>>=
/* Call [darken] on all roots */

void darken_all_roots (void)
{
  do_roots (darken);
}
@

<<function do_roots>>=
void do_roots (scanning_action f)
{
  struct global_root * gr;

  /* Global variables */
  f(global_data, &global_data);

  /* The stack and the local C roots */
  do_local_roots(f, extern_sp, stack_high, local_roots);

  /* Global C roots */
  for (gr = global_roots; gr != NULL; gr = gr->next) {
    f (*(gr->root), gr->root);
  }
  /* Hook */
  if (scan_roots_hook != NULL) (*scan_roots_hook)(f);
}
@

<<function do_local_roots>>=
void do_local_roots (scanning_action f, value *stack_low, value *stack_high, struct caml__roots_block *local_roots)
{
  register value * sp;
  struct caml__roots_block *lr;
  int i, j;

  for (sp = stack_low; sp < stack_high; sp++) {
    f (*sp, sp);
  }
  for (lr = local_roots; lr != NULL; lr = lr->next) {
    for (i = 0; i < lr->ntables; i++){
      for (j = 0; j < lr->nitems; j++){
        sp = &(lr->tables[i][j]);
        f (*sp, sp);
      }
    }
  }
}
@


%-------------------------------------------------------------

<<byterun/roots.c>>=
<<copyright header C xavier and damien>>

/* To walk the memory roots for garbage collection */

#include "memory.h"
#include "major_gc.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "stacks.h"

<<global local_roots>>

<<struct global_root>>

<<global global_roots>>

<<global scan_roots_hook>>

<<function register_global_root>>

<<function remove_global_root>>

<<function oldify_local_roots>>

<<function darken_all_roots>>

<<function do_roots>>

<<function do_local_roots>>

@


\subsection*{[[byterun/major_gc.h]]}

<<constant _major_gc_>>=
#define _major_gc_
@

<<function Chunk_size>>=
#define Chunk_size(c) (((heap_chunk_head *) (c)) [-1]).size
@

<<function Chunk_alloc>>=
#define Chunk_alloc(c) (((heap_chunk_head *) (c)) [-1]).alloc
@

<<function Chunk_next>>=
#define Chunk_next(c) (((heap_chunk_head *) (c)) [-1]).next
@

<<function Chunk_block>>=
#define Chunk_block(c) (((heap_chunk_head *) (c)) [-1]).block
@

<<constant Phase_mark>>=
#define Phase_mark 0
@

<<constant Phase_sweep>>=
#define Phase_sweep 1
@

<<constant Phase_idle>>=
#define Phase_idle 2
@

<<constant In_heap>>=
#define In_heap 1
@

<<constant Not_in_heap>>=
#define Not_in_heap 0
@

<<function Page>>=
#define Page(p) (((addr) (p) - (addr) heap_start) >> Page_log)
@

<<function Is_in_heap>>=
#define Is_in_heap(p) \
  ((addr)(p) >= (addr)heap_start && (addr)(p) < (addr)heap_end \
   && page_table [Page (p)])
@


%-------------------------------------------------------------

<<byterun/major_gc.h>>=
<<copyright header C damien>>

#ifndef _major_gc_
<<constant _major_gc_>>


#include "freelist.h"
#include "misc.h"

typedef struct {
  void *block;           /* address of the malloced block this chunk live in */
  asize_t alloc;         /* in bytes, used for compaction */
  asize_t size;          /* in bytes */
  char *next;
} heap_chunk_head;

<<function Chunk_size>>
<<function Chunk_alloc>>
<<function Chunk_next>>
<<function Chunk_block>>

extern int gc_phase;
extern unsigned long allocated_words;
extern unsigned long extra_heap_memory;

<<constant Phase_mark>>
<<constant Phase_sweep>>
<<constant Phase_idle>>

#ifdef __alpha
typedef int page_table_entry;
#else
typedef char page_table_entry;
#endif

extern char *heap_start;
extern char *heap_end;
extern unsigned long total_heap_size;
extern page_table_entry *page_table;
extern asize_t page_table_size;
extern char *gc_sweep_hp;

<<constant In_heap>>
<<constant Not_in_heap>>
<<function Page>>
<<function Is_in_heap>>

void init_major_heap (asize_t);
asize_t round_heap_chunk_size (asize_t);
void darken (value, value *);
void major_collection_slice (void);
void major_collection (void);
void finish_major_cycle (void);


#endif /* _major_gc_ */
@


\subsection*{[[byterun/major_gc.c]]}

<<constant LONG_MAX>>=
#define LONG_MAX 0x7FFFFFFFFFFFFFFF
@

<<constant LONG_MAX (byterun/major_gc.c)>>=
#define LONG_MAX 0x7FFFFFFF
@

<<global percent_free>>=
unsigned long percent_free;
@

<<global major_heap_increment>>=
long major_heap_increment;
@

<<global page_table>>=
page_table_entry *page_table;
@

<<global page_table_size>>=
asize_t page_table_size;
@

<<global gc_sweep_hp>>=
char *gc_sweep_hp;
@

<<global gc_phase>>=
int gc_phase;
@

<<global gray_vals>>=
static value *gray_vals;
@

<<global gray_vals_size>>=
static asize_t gray_vals_size;
@

<<global heap_is_pure>>=
static int heap_is_pure;   /* The heap is pure if the only gray objects
                              below [markhp] are also in [gray_vals]. */
@

<<global allocated_words>>=
unsigned long allocated_words;
@

<<global extra_heap_memory>>=
unsigned long extra_heap_memory;
@

<<function realloc_gray_vals>>=
static void realloc_gray_vals (void)
{
  value *new;

  Assert (gray_vals_cur == gray_vals_end);
  if (gray_vals_size < stat_heap_size / 128){
    gc_message ("Growing gray_vals to %luk bytes\n",
                (long) gray_vals_size * sizeof (value) / 512);
    new = (value *) realloc ((char *) gray_vals,
                             2 * gray_vals_size * sizeof (value));
    if (new == NULL){
      gc_message ("No room for growing gray_vals\n", 0);
      gray_vals_cur = gray_vals;
      heap_is_pure = 0;
    }else{
      gray_vals = new;
      gray_vals_cur = gray_vals + gray_vals_size;
      gray_vals_size *= 2;
      gray_vals_end = gray_vals + gray_vals_size;
    }
  }else{
    gray_vals_cur = gray_vals + gray_vals_size / 2;
    heap_is_pure = 0;
  }
}
@

<<function darken>>=
void darken (value v, value *p)
             
                /* not used */
{
  if (Is_block (v) && Is_in_heap (v)) {
    if (Tag_val(v) == Infix_tag) v -= Infix_offset_val(v);
    if (Is_white_val (v)){
      Hd_val (v) = Grayhd_hd (Hd_val (v));
      *gray_vals_cur++ = v;
      if (gray_vals_cur >= gray_vals_end) realloc_gray_vals ();
    }
  }
}
@

<<function start_cycle>>=
static void start_cycle (void)
{
  Assert (gc_phase == Phase_idle);
  Assert (gray_vals_cur == gray_vals);
  darken_all_roots();
  gc_phase = Phase_mark;
  markhp = NULL;
}
@

<<function mark_slice>>=
static void mark_slice (long int work)
{
  value *gray_vals_ptr;  /* Local copy of gray_vals_cur */
  value v, child;
  header_t hd;
  mlsize_t size, i;

  gray_vals_ptr = gray_vals_cur;
  while (work > 0){
    if (gray_vals_ptr > gray_vals){
      v = *--gray_vals_ptr;
      hd = Hd_val(v);
      Assert (Is_gray_hd (hd));
      Hd_val (v) = Blackhd_hd (hd);
      size = Wosize_hd(hd);
      if (Tag_hd (hd) < No_scan_tag){
        for (i = 0; i < size; i++){
          child = Field (v, i);
          if (Is_block (child) && Is_in_heap (child)) {
            hd = Hd_val(child);
            if (Tag_hd(hd) == Infix_tag) {
              child -= Infix_offset_val(child);
              hd = Hd_val(child);
            }
            if (Is_white_hd (hd)){
              Hd_val (child) = Grayhd_hd (hd);
              *gray_vals_ptr++ = child;
              if (gray_vals_ptr >= gray_vals_end) {
                gray_vals_cur = gray_vals_ptr;
                realloc_gray_vals ();
                gray_vals_ptr = gray_vals_cur;
              }
            }
          }
        }
      }
      work -= Whsize_wosize(size);
    }else if (markhp != NULL){
      if (markhp == limit){
        chunk = Chunk_next (chunk);
        if (chunk == NULL){
          markhp = NULL;
        }else{
          markhp = chunk;
          limit = chunk + Chunk_size (chunk);
        }
      }else{
        if (Is_gray_val (Val_hp (markhp))){
          Assert (gray_vals_ptr == gray_vals);
          *gray_vals_ptr++ = Val_hp (markhp);
        }
        markhp += Bhsize_hp (markhp);
      }
    }else if (!heap_is_pure){
      heap_is_pure = 1;
      chunk = heap_start;
      markhp = chunk;
      limit = chunk + Chunk_size (chunk);
    }else{
      /* Marking is done. */

      update_weak_pointers ();
      
      /* Initialise the sweep phase. */
      gray_vals_cur = gray_vals_ptr;
      gc_sweep_hp = heap_start;
      fl_init_merge ();
      gc_phase = Phase_sweep;
      chunk = heap_start;
      gc_sweep_hp = chunk;
      limit = chunk + Chunk_size (chunk);
      work = 0;
    }
  }
  gray_vals_cur = gray_vals_ptr;
}
@

<<function update_weak_pointers>>=
/* Walk through the linked list of weak arrays.
   Arrays that are white are removed from this list.
   For the other arrays, pointers to white objects are erased.
*/
static void update_weak_pointers (void)
{
  value *prev = &weak_list_head;
  value *cur = (value *) *prev;
  mlsize_t sz, i;

  while (cur != NULL){
    if (Color_val (cur) == White){
      *prev = Field (cur, 0);
      cur = (value *) *prev;
    }else{
      value curfield;

      sz = Wosize_val (cur);
      for (i = 1; i < sz; i++){
        curfield = Field (cur, i);
        if (curfield != 0 && Is_block (curfield) && Is_white_val (curfield)){
          Field (cur, i) = 0;
        }
      }
      prev = &Field (cur, 0);
      cur = (value *) *prev;
    }
  }
}
@

<<function sweep_slice>>=
static void sweep_slice (long int work)
{
  char *hp;
  header_t hd;

  while (work > 0){
    if (gc_sweep_hp < limit){
      hp = gc_sweep_hp;
      hd = Hd_hp (hp);
      work -= Whsize_hd (hd);
      gc_sweep_hp += Bhsize_hd (hd);
      switch (Color_hd (hd)){
      case White:
        if (Tag_hd (hd) == Final_tag){
          Final_fun (Val_hp (hp)) (Val_hp (hp));
        }
        gc_sweep_hp = fl_merge_block (Bp_hp (hp));
        break;
      case Blue:
        /* Only the blocks of the free-list are blue.  See [freelist.c]. */
        fl_merge = Bp_hp (hp);
        break;
      default:          /* Gray or Black */
        Assert(Color_hd(hd) == Black);
        Hd_hp (hp) = Whitehd_hd (hd);
        break;
      }
      Assert (gc_sweep_hp <= limit);
    }else{
      chunk = Chunk_next (chunk);
      if (chunk == NULL){
        /* Sweeping is done. */
        ++ stat_major_collections;
        work = 0;
        gc_phase = Phase_idle;
      }else{
        gc_sweep_hp = chunk;
        limit = chunk + Chunk_size (chunk);
      }
    }
  }
}
@

<<function major_collection_slice>>=
/* The main entry point for the GC.  Called at each minor GC. */
void major_collection_slice (void)
{
  /* 
     Free memory at the start of the GC cycle (garbage + free list) (assumed):
                 FM = stat_heap_size * percent_free / (100 + percent_free)
     Garbage at the start of the GC cycle:
                 G = FM * 2/3
     Proportion of free memory consumed since the previous slice:
                 PH = allocated_words / G
     Proportion of extra-heap memory consumed since the previous slice:
                 PE = extra_heap_memory / stat_heap_size
     Proportion of total work to do in this slice:
                 P  = PH + PE
     Amount of marking work for the GC cycle:
                 MW = stat_heap_size * 100 / (100 + percent_free)
     Amount of sweeping work for the GC cycle:
                 SW = stat_heap_size
     Amount of marking work for this slice:
                 MS = MW * P
                 MS = 3/2 * 100 * allocated_words / percent_free
                      + extra_heap_memory * 100 / (100 + percent_free)
     Amount of sweeping work for this slice:
                 SS = SW * P
                 SS = 3/2 * (100 + percent_free)/percent_free * allocated_words
                      + extra_heap_memory
     This slice will either mark 2*MS words or sweep 2*SS words.
  */

#define Margin 100  /* Make it a little faster to be on the safe side. */

  if (gc_phase == Phase_idle) start_cycle ();

  if (gc_phase == Phase_mark){
    mark_slice (300 * (allocated_words / percent_free + 1)
                + 200 * (extra_heap_memory / (100 + percent_free) + 1)
        + Margin);
    gc_message ("!", 0);
  }else{
    Assert (gc_phase == Phase_sweep);
    sweep_slice (3 * (100 + percent_free) * (allocated_words / percent_free + 1)
                 + 2 * extra_heap_memory
                 + Margin);
    gc_message ("$", 0);
  }

  if (gc_phase == Phase_idle) compact_heap_maybe ();

  stat_major_words += allocated_words;
  allocated_words = 0;
  extra_heap_memory = 0;
}
@
%$

<<function finish_major_cycle>>=
/* This does not call compact_heap_maybe because the estimations of
   free and live memory are only valid for a cycle done incrementally.
   Besides, this function is called by compact_heap_maybe.
*/
void finish_major_cycle (void)
{
  if (gc_phase == Phase_idle) start_cycle ();
  if (gc_phase == Phase_mark) mark_slice (LONG_MAX);
  Assert (gc_phase == Phase_sweep);
  sweep_slice (LONG_MAX);
  Assert (gc_phase == Phase_idle);
  stat_major_words += allocated_words;
  allocated_words = 0;
}
@

<<function round_heap_chunk_size>>=
asize_t round_heap_chunk_size (asize_t request)
{                            Assert (major_heap_increment >= Heap_chunk_min);
  if (request < major_heap_increment){
                              Assert (major_heap_increment % Page_size == 0);
    return major_heap_increment;
  }else if (request <= Heap_chunk_max){
    return ((request + Page_size - 1) >> Page_log) << Page_log;
  }else{
    raise_out_of_memory ();
    /* not reached */ return 0;
  }
}
@

<<function init_major_heap>>=
void init_major_heap (asize_t heap_size)
{
  asize_t i;
  void *block;

  stat_heap_size = round_heap_chunk_size (heap_size);
  Assert (stat_heap_size % Page_size == 0);
  heap_start = aligned_malloc (stat_heap_size + sizeof (heap_chunk_head),
                               sizeof (heap_chunk_head), &block);
  if (heap_start == NULL)
    fatal_error ("Fatal error: not enough memory for the initial heap.\n");
  heap_start += sizeof (heap_chunk_head);
  Assert ((unsigned long) heap_start % Page_size == 0);
  Chunk_size (heap_start) = stat_heap_size;
  Chunk_next (heap_start) = NULL;
  Chunk_block (heap_start) = block;
  heap_end = heap_start + stat_heap_size;
  Assert ((unsigned long) heap_end % Page_size == 0);
  page_table_size = 4 * stat_heap_size / Page_size;
  page_table = 
    (page_table_entry *) malloc (page_table_size * sizeof(page_table_entry));
  if (page_table == NULL)
    fatal_error ("Fatal error: not enough memory for the initial heap.\n");
  for (i = 0; i < page_table_size; i++){
    page_table [i] = Not_in_heap;
  }
  for (i = Page (heap_start); i < Page (heap_end); i++){
    page_table [i] = In_heap;
  }
  Hd_hp (heap_start) = Make_header (Wosize_bhsize (stat_heap_size), 0, Blue);
  fl_init_merge ();
  fl_merge_block (Bp_hp (heap_start));
  gc_phase = Phase_idle;
  gray_vals_size = 2048;
  gray_vals = (value *) malloc (gray_vals_size * sizeof (value));
  if (gray_vals == NULL)
    fatal_error ("Fatal error: not enough memory for the initial heap.\n");
  gray_vals_cur = gray_vals;
  gray_vals_end = gray_vals + gray_vals_size;
  heap_is_pure = 1;
  allocated_words = 0;
  extra_heap_memory = 0;
}
@


%-------------------------------------------------------------

<<byterun/major_gc.c>>=
<<copyright header C damien>>

#include "compact.h"
#include "config.h"
#include "fail.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "weak.h"

#ifdef __STDC__
#include <limits.h>
#else
#ifdef ARCH_SIXTYFOUR
<<constant LONG_MAX>>
#else
<<constant LONG_MAX (byterun/major_gc.c)>>
#endif
#endif

<<global percent_free>>
<<global major_heap_increment>>
char *heap_start, *heap_end;
<<global page_table>>
<<global page_table_size>>
<<global gc_sweep_hp>>
<<global gc_phase>>
<<global gray_vals>>
value *gray_vals_cur, *gray_vals_end;
<<global gray_vals_size>>
<<global heap_is_pure>>
<<global allocated_words>>
<<global extra_heap_memory>>
extern char *fl_merge;  /* Defined in freelist.c. */

static char *markhp, *chunk, *limit;

static void update_weak_pointers (void);

<<function realloc_gray_vals>>

<<function darken>>

<<function start_cycle>>

<<function mark_slice>>

<<function update_weak_pointers>>

<<function sweep_slice>>

<<function major_collection_slice>>

/* The minor heap must be empty when this function is called. */
<<function finish_major_cycle>>

<<function round_heap_chunk_size>>

<<function init_major_heap>>
@


\subsection*{[[byterun/minor_gc.h]]}

<<constant _minor_gc_>>=
#define _minor_gc_
@

<<function Is_young>>=
#define Is_young(val) \
  ((addr)(val) > (addr)young_start && (addr)(val) < (addr)young_end)
@


%-------------------------------------------------------------

<<byterun/minor_gc.h>>=
<<copyright header C damien>>

#ifndef _minor_gc_
<<constant _minor_gc_>>


#include "misc.h"

extern char *young_start, *young_ptr, *young_end, *young_limit;
extern value **ref_table_ptr, **ref_table_limit;
extern asize_t minor_heap_size;
extern int in_minor_collection;

<<function Is_young>>

extern void set_minor_heap_size (asize_t);
extern void minor_collection (void);
extern void garbage_collection (void); /* for the native-code system */
extern void realloc_ref_table (void);
extern void oldify (value, value *);

#endif /* _minor_gc_ */
@


\subsection*{[[byterun/minor_gc.c]]}

<<global minor_heap_size>>=
asize_t minor_heap_size;
@

<<global in_minor_collection>>=
int in_minor_collection = 0;
@

<<function set_minor_heap_size>>=
void set_minor_heap_size (asize_t size)
{
  char *new_heap;
  value **new_table;

  Assert (size >= Minor_heap_min);
  Assert (size <= Minor_heap_max);
  Assert (size % sizeof (value) == 0);
  if (young_ptr != young_end) minor_collection ();
                                           Assert (young_ptr == young_end);
  new_heap = (char *) stat_alloc (size);
  if (young_start != NULL){
    stat_free (young_start);
  }
  young_start = new_heap;
  young_end = new_heap + size;
  young_limit = young_start;
  young_ptr = young_end;
  minor_heap_size = size;

  ref_table_size = minor_heap_size / sizeof (value) / 8;
  ref_table_reserve = 256;
  new_table = (value **) stat_alloc ((ref_table_size + ref_table_reserve)
                                     * sizeof (value *));
  if (ref_table != NULL) stat_free (ref_table);
  ref_table = new_table;
  ref_table_ptr = ref_table;
  ref_table_threshold = ref_table + ref_table_size;
  ref_table_limit = ref_table_threshold;
  ref_table_end = ref_table + ref_table_size + ref_table_reserve;
}
@

<<function oldify>>=
void oldify (value v, value *p)
{
  value result, field0;
  header_t hd;
  mlsize_t sz, i;
  int tag;

 tail_call:
  if (Is_block (v) && Is_young (v)){
    Assert (Hp_val (v) >= young_ptr);
    hd = Hd_val (v);
    tag = Tag_hd (hd);
    if (Is_blue_hd (hd)){    /* Already forwarded ? */
      *p = Field (v, 0);     /* Then the forward pointer is the first field. */
    }else if (tag == Infix_tag) {
      mlsize_t offset = Infix_offset_hd (hd);
      oldify(v - offset, p);
      *p += offset;
    }else if (tag >= No_scan_tag){
      sz = Wosize_hd (hd);
      result = alloc_shr (sz, tag);
      for (i = 0; i < sz; i++) Field(result, i) = Field(v, i);
      Hd_val (v) = Bluehd_hd (hd);            /* Put the forward flag. */
      Field (v, 0) = result;                  /* And the forward pointer. */
      *p = result;
    }else{
      /* We can do recursive calls before all the fields are filled, because
         we will not be calling the major GC. */
      sz = Wosize_hd (hd);
      result = alloc_shr (sz, tag);
      *p = result;
      field0 = Field (v, 0);
      Hd_val (v) = Bluehd_hd (hd);            /* Put the forward flag. */
      Field (v, 0) = result;                  /* And the forward pointer. */
      if (sz == 1) {
        p = &Field (result, 0);
        v = field0;
        goto tail_call;
      } else {
        oldify (field0, &Field (result, 0));
        for (i = 1; i < sz - 1; i++){
          oldify (Field(v, i), &Field (result, i));
        }
        p = &Field (result, i);
        v = Field (v, i);
        goto tail_call;
      }
    }
  }else{
    *p = v;
  }
}
@

<<function minor_collection>>=
void minor_collection (void)
{
  value **r;
  long prev_alloc_words = allocated_words;

  in_minor_collection = 1;
  gc_message ("<", 0);
  oldify_local_roots();
  for (r = ref_table; r < ref_table_ptr; r++) oldify (**r, *r);
  stat_minor_words += Wsize_bsize (young_end - young_ptr);
  young_ptr = young_end;
  ref_table_ptr = ref_table;
  ref_table_limit = ref_table_threshold;
  gc_message (">", 0);
  in_minor_collection = 0;

  stat_promoted_words += allocated_words - prev_alloc_words;
  ++ stat_minor_collections;
  major_collection_slice ();
  force_major_slice = 0;
}
@

<<function check_urgent_gc>>=
value check_urgent_gc (value extra_root)
{
  if (force_major_slice) {
    Begin_root(extra_root);
      minor_collection();
    End_roots();
  }
  return extra_root;
}
@

<<function realloc_ref_table>>=
void realloc_ref_table (void)
{                                 Assert (ref_table_ptr == ref_table_limit);
                                  Assert (ref_table_limit <= ref_table_end);
                            Assert (ref_table_limit >= ref_table_threshold);

  if (ref_table_limit == ref_table_threshold){
    gc_message ("ref_table threshold crossed\n", 0);
    ref_table_limit = ref_table_end;
    urge_major_slice ();
  }else{ /* This will almost never happen with the bytecode interpreter. */
    asize_t sz;
    asize_t cur_ptr = ref_table_ptr - ref_table;
                                                  Assert (force_major_slice);

    ref_table_size *= 2;
    sz = (ref_table_size + ref_table_reserve) * sizeof (value *);
    gc_message ("Growing ref_table to %ldk bytes\n", (long) sz / 1024);
    ref_table = (value **) realloc ((char *) ref_table, sz);
    if (ref_table == NULL) fatal_error ("Fatal error: ref_table overflow\n");
    ref_table_end = ref_table + ref_table_size + ref_table_reserve;
    ref_table_threshold = ref_table + ref_table_size;
    ref_table_ptr = ref_table + cur_ptr;
    ref_table_limit = ref_table_end;
  }
}
@


%-------------------------------------------------------------

<<byterun/minor_gc.c>>=
<<copyright header C damien>>

#include <string.h>
#include "config.h"
#include "fail.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "signals.h"

<<global minor_heap_size>>
char *young_start = NULL, *young_end = NULL;
char *young_ptr = NULL, *young_limit = NULL;
static value **ref_table = NULL, **ref_table_end, **ref_table_threshold;
value **ref_table_ptr = NULL, **ref_table_limit;
static asize_t ref_table_size, ref_table_reserve;
<<global in_minor_collection>>

<<function set_minor_heap_size>>

<<function oldify>>

<<function minor_collection>>

<<function check_urgent_gc>>

<<function realloc_ref_table>>
@


\subsection*{[[byterun/compact.h]]}

<<constant _compact_>>=
#define _compact_
@


%-------------------------------------------------------------

<<byterun/compact.h>>=
<<copyright header C damien>>

#ifndef _compact_
<<constant _compact_>>


#include "config.h"
#include "misc.h"

void compact_heap (void);
void compact_heap_maybe (void);


#endif /* _compact_ */
@


\subsection*{[[byterun/compact.c]]}

<<function Make_ehd>>=
/* Encoded headers: the color is stored in the 2 least significant bits.
   (For pointer inversion, we need to distinguish headers from pointers.)
   s is a Wosize, t is a tag, and c is a color (a two-bit number)

   For the purpose of compaction, "colors" are:
   0: pointers (direct or inverted)
   1: integer or (unencoded) infix header
   2: inverted pointer for infix header
   3: integer or encoded (noninfix) header
*/
#define Make_ehd(s,t,c) (((s) << 10) | (t) << 2 | (c))
@

<<function Whsize_ehd>>=
#define Whsize_ehd(h) Whsize_hd (h)
@

<<function Wosize_ehd>>=
#define Wosize_ehd(h) Wosize_hd (h)
@

<<function Tag_ehd>>=
#define Tag_ehd(h) (((h) >> 2) & 0xFF)
@

<<function Ecolor>>=
#define Ecolor(w) ((w) & 3)
@

<<function invert_root>>=
static void invert_root (value v, value *p)
{
  invert_pointer_at ((word *) p);
}
@

<<global compact_fl>>=
static char *compact_fl;
@

<<function init_compact_allocate>>=
static void init_compact_allocate (void)
{
  char *ch = heap_start;
  while (ch != NULL){
    Chunk_alloc (ch) = 0;
    ch = Chunk_next (ch);
  }
  compact_fl = heap_start;
}
@

<<function compact_allocate>>=
static char *compact_allocate (mlsize_t size)
                                      /* in bytes, including header */
{
  char *chunk, *adr;

  while (Chunk_size (compact_fl) - Chunk_alloc (compact_fl) <= Bhsize_wosize (3)
         && Chunk_size (Chunk_next (compact_fl))
            - Chunk_alloc (Chunk_next (compact_fl))
            <= Bhsize_wosize (3)){
    compact_fl = Chunk_next (compact_fl);
  }
  chunk = compact_fl;
  while (Chunk_size (chunk) - Chunk_alloc (chunk) < size){
    chunk = Chunk_next (chunk);                         Assert (chunk != NULL);
  }
  adr = chunk + Chunk_alloc (chunk);
  Chunk_alloc (chunk) += size;
  return adr;
}
@

<<function compact_heap>>=
void compact_heap (void)
{
  char *ch, *chend;
                                               Assert (gc_phase == Phase_idle);
  gc_message ("Compacting heap...\n", 0);
  /* First pass: encode all noninfix headers. */
  {
    ch = heap_start;
    while (ch != NULL){
      header_t *p = (header_t *) ch;

      chend = ch + Chunk_size (ch);
      while ((char *) p < chend){
        header_t hd = Hd_hp (p);
        mlsize_t sz = Wosize_hd (hd);

        if (Is_blue_hd (hd)){
          /* Free object.  Give it a string tag. */
          Hd_hp (p) = Make_ehd (sz, String_tag, 3);
        }else{                                      Assert (Is_white_hd (hd));
          /* Live object.  Keep its tag. */
          Hd_hp (p) = Make_ehd (sz, Tag_hd (hd), 3);
        }
        p += Whsize_wosize (sz);
      }
      ch = Chunk_next (ch);
    }
  }


  /* Second pass: invert pointers.
     Link infix headers in each block in an inverted list of inverted lists.
     Don't forget roots and weak pointers. */
  {
    ch = heap_start;
    while (ch != NULL){
      word *p = (word *) ch;
      chend = ch + Chunk_size (ch);

      while ((char *) p < chend){
        word q = *p;
        size_t sz, i;
        tag_t t;
        word *infixes;

        while (Ecolor (q) == 0) q = * (word *) q;
        sz = Whsize_ehd (q);
        t = Tag_ehd (q);
        
        if (t == Infix_tag){
          /* Get the original header of this block. */
          infixes = p + sz;
          q = *infixes;
          while (Ecolor (q) != 3) q = * (word *) (q & ~(unsigned long)3);
          sz = Whsize_ehd (q);
          t = Tag_ehd (q);
        }

        if (t < No_scan_tag){
          for (i = 1; i < sz; i++) invert_pointer_at (&(p[i]));
        }
        p += sz;
      }
      ch = Chunk_next (ch);
    }
    /* Invert weak pointers. */
    {
      value *pp = &weak_list_head;
      value p;
      word q;
      size_t sz, i;

      while (1){
        p = *pp;
        if (p == (value) NULL) break;
        q = Hd_val (p);
        while (Ecolor (q) == 0) q = * (word *) q;
        sz = Wosize_ehd (q);
        for (i = 1; i < sz; i++){
          if (Field (p,i) != 0) invert_pointer_at ((word *) &(Field (p,i)));
        }
        invert_pointer_at ((word *) pp);
        pp = &Field (p, 0);
      }
    }
    /* Invert roots */
    do_roots (invert_root);
  }


  /* Third pass: reallocate virtually; revert pointers; decode headers.
     Rebuild infix headers. */
  {
    init_compact_allocate ();
    ch = heap_start;
    while (ch != NULL){
      word *p = (word *) ch;
      
      chend = ch + Chunk_size (ch);
      while ((char *) p < chend){
        word q = *p;
        
        if (Ecolor (q) == 0 || Tag_ehd (q) == Infix_tag){
          /* There were (normal or infix) pointers to this block. */
          size_t sz;
          tag_t t;
          char *newadr;
          word *infixes = NULL;
          
          while (Ecolor (q) == 0) q = * (word *) q;
          sz = Whsize_ehd (q);
          t = Tag_ehd (q);

          if (t == Infix_tag){
            /* Get the original header of this block. */
            infixes = p + sz;
            q = *infixes;                             Assert (Ecolor (q) == 2);
            while (Ecolor (q) != 3) q = * (word *) (q & ~(unsigned long)3);
            sz = Whsize_ehd (q);
            t = Tag_ehd (q);
          }

          newadr = compact_allocate (Bsize_wsize (sz));
          q = *p;
          while (Ecolor (q) == 0){
            word next = * (word *) q;
            * (word *) q = (word) Val_hp (newadr);
            q = next;
          }
          *p = Make_header (Wosize_whsize (sz), t, White);

          if (infixes != NULL){
            /* Rebuild the infix headers and revert the infix pointers. */
            while (Ecolor ((word) infixes) != 3){
              infixes = (word *) ((word) infixes & ~(unsigned long) 3);
              q = *infixes;
              while (Ecolor (q) == 2){
                word next;
                q = (word) q & ~(unsigned long) 3;
                next = * (word *) q;
                * (word *) q = (word) Val_hp ((word *) newadr + (infixes - p));
                q = next;
              }                    Assert (Ecolor (q) == 1 || Ecolor (q) == 3);
              *infixes = Make_header (infixes - p, Infix_tag, White);
              infixes = (word *) q;
            }
          }
          p += sz;
        }else{                                        Assert (Ecolor (q) == 3);
          /* This is guaranteed only if compact_heap was called after a
             nonincremental major GC:       Assert (Tag_ehd (q) == String_tag);
          */
          /* No pointers to the header and no infix header:
             the object was free. */
          *p = Make_header (Wosize_ehd (q), Tag_ehd (q), Blue);
          p += Whsize_ehd (q);
        }
      }
      ch = Chunk_next (ch);
    }
  }


  /* Fourth pass: reallocate and move objects.
     Use the exact same allocation algorithm as pass 3. */
  {
    init_compact_allocate ();
    ch = heap_start;
    while (ch != NULL){
      word *p = (word *) ch;

      chend = ch + Chunk_size (ch);
      while ((char *) p < chend){
        word q = *p;
        if (Color_hd (q) == White){
          size_t sz = Bhsize_hd (q);
          char *newadr = compact_allocate (sz);  Assert (newadr <= (char *)p);
          /* bcopy (source, destination, length) */
          bcopy (p, newadr, sz);
          p += Wsize_bsize (sz);
        }else{
          Assert (Color_hd (q) == Blue);
          p += Whsize_hd (q);
        }
      }
      ch = Chunk_next (ch);
    }
  }

  /* Shrink the heap if needed. */
  {
    /* Find the amount of live data and the unshrinkable free space. */
    asize_t live = 0;
    asize_t free = 0;
    asize_t wanted;

    ch = heap_start;
    while (ch != NULL){
      if (Chunk_alloc (ch) != 0){
        live += Wsize_bsize (Chunk_alloc (ch));
        free += Wsize_bsize (Chunk_size (ch) - Chunk_alloc (ch));
      }
      ch = Chunk_next (ch);
    }

    /* Add up the empty chunks until there are enough, then remove the
       other empty chunks. */
    wanted = percent_free * (live / 100 + 1);
    ch = heap_start;
    while (ch != NULL){
      char *next_chunk = Chunk_next (ch);  /* Chunk_next (ch) will be erased */

      if (Chunk_alloc (ch) == 0){
        if (free < wanted){
          free += Wsize_bsize (Chunk_size (ch));
        }else{
          shrink_heap (ch);
        }
      }
      ch = next_chunk;
    }
  }

  /* Rebuild the free list. */
  {
    ch = heap_start;
    fl_reset ();
    while (ch != NULL){
      if (Chunk_size (ch) > Chunk_alloc (ch)){
        header_t *p = (header_t *) (ch + Chunk_alloc (ch));
        *p = Make_header (Wosize_bhsize (Chunk_size (ch) - Chunk_alloc (ch)),
                          0, White);
        fl_merge_block (Bp_hp (p));
      }
      ch = Chunk_next (ch);
    }
  }
  ++ stat_compactions;
  gc_message ("done.\n", 0);
}
@

<<global percent_max>>=
unsigned long percent_max;
@

<<function compact_heap_maybe>>=
void compact_heap_maybe (void)
{
  /* Estimated free words in the heap: FW = 1.5 * fl_cur_size
     Estimated live words: LW = stat_heap_size - FW
     We compact the heap if FW > percent_max / 100 * LW
  */
  float fw;
                                               Assert (gc_phase == Phase_idle);
  if (percent_max >= 1000000) return;
  switch (percent_max){
  case 0:
    finish_major_cycle ();
    compact_heap ();
    break;
  default:
    fw = 1.5 * fl_cur_size;
    if (fw > 0.01 * percent_max * (Wsize_bsize (stat_heap_size) - fw)){
      finish_major_cycle ();
      compact_heap ();
    }
    break;
  }
}
@


%-------------------------------------------------------------

<<byterun/compact.c>>=
<<copyright header C damien>>

#include <string.h>

#include "config.h"
#include "freelist.h"
#include "gc.h"
#include "gc_ctrl.h"
#include "major_gc.h"
#include "memory.h"
#include "mlvalues.h"
#include "roots.h"
#include "weak.h"

extern unsigned long percent_free;             /* major_gc.c */
extern void shrink_heap (char *);              /* memory.c */

<<function Make_ehd>>
<<function Whsize_ehd>>
<<function Wosize_ehd>>
<<function Tag_ehd>>
<<function Ecolor>>

typedef unsigned long word;

static void invert_pointer_at (word *p)
{
  word q = *p;

  /* Use Ecolor (q) == 0 instead of Is_block (q) because q could be an
     inverted pointer for an infix header (with Ecolor == 2). */
  if (Ecolor (q) == 0 && Is_in_heap (q)){
    switch (Ecolor (Hd_val (q))){
    case 0:
    case 3: /* Pointer or header: insert in inverted list. */
      *p = Hd_val (q);
      Hd_val (q) = (header_t) p;
      break;
    case 1: /* Infix header: make inverted infix list. */
      /* Double inversion: the last of the inverted infix list points to
         the next infix header in this block.  The last of the last list
         contains the original block header. */
      {
        /* This block as a value. */
        value val = (value) q - Infix_offset_val (q);
        /* Get the block header. */
        word *hp = (word *) Hp_val (val);
        while (Ecolor (*hp) == 0) hp = (word *) *hp;
                                                   Assert (Ecolor (*hp) == 3);
        if (Tag_ehd (*hp) == Closure_tag){
          /* This is the first infix found in this block. */
          /* Save original header. */
          *p = *hp;
          /* Link inverted infix list. */
          Hd_val (q) = (header_t) ((word) p | 2);
          /* Change block header's tag to Infix_tag, and change its size
             to point to the infix list. */
          *hp = Make_ehd (Wosize_bhsize (q - val), Infix_tag, 3);
        }else{                            Assert (Tag_ehd (*hp) == Infix_tag);
          /* Point the last of this infix list to the current first infix
             list of the block. */
          *p = (word) &Field (val, Wosize_ehd (*hp)) | 1;
          /* Point the head of this infix list to the above. */
          Hd_val (q) = (header_t) ((word) p | 2);
          /* Change block header's size to point to this infix list. */
          *hp = Make_ehd (Wosize_bhsize (q - val), Infix_tag, 3);
        }
      }
      break;
    case 2: /* Inverted infix list: insert. */
      *p = Hd_val (q);
      Hd_val (q) = (header_t) ((word) p | 2);
      break;
    }
  }
}

<<function invert_root>>

<<global compact_fl>>

<<function init_compact_allocate>>

<<function compact_allocate>>

<<function compact_heap>>

<<global percent_max>>

<<function compact_heap_maybe>>
@


\subsection*{[[byterun/hash.c]]}

<<global hash_accu>>=
static unsigned long hash_accu;
@

<<function hash_univ_param>>=
value hash_univ_param(value count, value limit, value obj) /* ML */
{
  hash_univ_limit = Long_val(limit);
  hash_univ_count = Long_val(count);
  hash_accu = 0;
  hash_aux(obj);
  return Val_long(hash_accu & 0x3FFFFFFF);
  /* The & has two purposes: ensure that the return value is positive
     and give the same result on 32 bit and 64 bit architectures. */
}
@

<<constant Alpha>>=
#define Alpha 65599
@

<<constant Beta>>=
#define Beta 19
@

<<function Combine>>=
#define Combine(new)  (hash_accu = hash_accu * Alpha + (new))
@

<<function Combine_small>>=
#define Combine_small(new) (hash_accu = hash_accu * Beta + (new))
@


%-------------------------------------------------------------

<<byterun/hash.c>>=
<<copyright header C xavier>>

/* The generic hashing primitive */

#include "mlvalues.h"
#include "memory.h"
#include "str.h"

<<global hash_accu>>
static long hash_univ_limit, hash_univ_count;

static void hash_aux(value obj);

<<function hash_univ_param>>

<<constant Alpha>>
<<constant Beta>>
<<function Combine>>
<<function Combine_small>>

static void hash_aux(value obj)
{
  unsigned char * p;
  mlsize_t i, j;
  tag_t tag;

  hash_univ_limit--;
  if (hash_univ_count < 0 || hash_univ_limit < 0) return;

  if (Is_long(obj)) {
    hash_univ_count--;
    Combine(Long_val(obj));
    return;
  }

  /* Pointers into the heap are well-structured blocks. So are atoms.
     We can inspect the block contents. */
  
  if (Is_atom(obj) || Is_young(obj) || Is_in_heap(obj)) {
    tag = Tag_val(obj);
    switch (tag) {
    case String_tag:
      hash_univ_count--;
      i = string_length(obj);
      for (p = &Byte_u(obj, 0); i > 0; i--, p++)
        Combine_small(*p);
      break;
    case Double_tag:
      /* For doubles, we inspect their binary representation, LSB first.
         The results are consistent among all platforms with IEEE floats. */
      hash_univ_count--;
#ifdef ARCH_BIG_ENDIAN
      for (p = &Byte_u(obj, sizeof(double) - 1), i = sizeof(double);
           i > 0;
           p--, i--)
#else
      for (p = &Byte_u(obj, 0), i = sizeof(double);
           i > 0;
           p++, i--)
#endif
        Combine_small(*p);
      break;
    case Double_array_tag:
      hash_univ_count--;
      for (j = 0; j < Bosize_val(obj); j += sizeof(double)) {
#ifdef ARCH_BIG_ENDIAN
      for (p = &Byte_u(obj, j + sizeof(double) - 1), i = sizeof(double);
           i > 0;
           p--, i--)
#else
      for (p = &Byte_u(obj, j), i = sizeof(double);
           i > 0;
           p++, i--)
#endif
        Combine_small(*p);
      }
      break;
    case Abstract_tag:
    case Final_tag:
      /* We don't know anything about the contents of the block.
         Better do nothing. */
      break;
    case Infix_tag:
      hash_aux(obj - Infix_offset_val(obj));
      break;
    case Object_tag:
      hash_univ_count--;
      Combine(Oid_val(obj));
      break;
    default:
      hash_univ_count--;
      Combine_small(tag);
      i = Wosize_val(obj);
      while (i != 0) {
        i--;
        hash_aux(Field(obj, i));
      }
      break;
    }
    return;
  }

  /* Otherwise, obj is a pointer outside the heap, to an object with
     a priori unknown structure. Use its physical address as hash key. */
  Combine((long) obj);
}
@


\subsection*{[[byterun/array.c]]}

<<function array_get>>=
value array_get(value array, value index)   /* ML */
{
  long idx = Long_val(index);
  if (idx < 0 || idx >= Wosize_val(array)) invalid_argument("Array.get");
  return Field(array, idx);
}
@

<<function array_set>>=
value array_set(value array, value index, value newval)   /* ML */
{
  long idx = Long_val(index);
  if (idx < 0 || idx >= Wosize_val(array)) invalid_argument("Array.set");
  Modify(&Field(array, idx), newval);
  return Val_unit;
}
@

<<function make_vect>>=
value make_vect(value len, value init)      /* ML */
{
  value res;
  mlsize_t size, i;

  size = Long_val(len);
  if (size > Max_wosize) invalid_argument("Array.make");

  Begin_root(init);
    if (size == 0) {
      res = Atom(0);
    }
    else if (size < Max_young_wosize) {
      res = alloc(size, 0);
      for (i = 0; i < size; i++) Field(res, i) = init;
    }
    else if (Is_block(init) && Is_young(init)) {
      minor_collection();
      res = alloc_shr(size, 0);
      for (i = 0; i < size; i++) Field(res, i) = init;
      res = check_urgent_gc (res);
    }
    else {
      res = alloc_shr(size, 0);
      for (i = 0; i < size; i++) initialize(&Field(res, i), init);
      res = check_urgent_gc (res);
    }
  End_roots();
  return res;
}
@


%-------------------------------------------------------------

<<byterun/array.c>>=
<<copyright header C xavier>>

/* Operations on arrays */

#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"

<<function array_get>>

<<function array_set>>

<<function make_vect>>
@


\subsection*{[[byterun/stacks.h]]}

<<constant _stacks_>>=
#define _stacks_
@

<<function Trap_pc>>=
#define Trap_pc(tp) (((code_t *)(tp))[0])
@

<<function Trap_link>>=
#define Trap_link(tp) (((value **)(tp))[1])
@


%-------------------------------------------------------------

<<byterun/stacks.h>>=
<<copyright header C xavier>>

/* structure of the stacks */

#ifndef _stacks_
<<constant _stacks_>>


#include "misc.h"
#include "mlvalues.h"
#include "memory.h"

extern value * stack_low;
extern value * stack_high;
extern value * stack_threshold;
extern value * extern_sp;
extern value * trapsp;
extern value * trap_barrier;

<<function Trap_pc>>
<<function Trap_link>>

void reset_roots (void);
void init_stack (unsigned long init_max_size);
void realloc_stack (void);
void change_max_stack_size (unsigned long new_max_size);


#endif /* _stacks_ */

@


\subsection*{[[byterun/stacks.c]]}

<<global stack_low>>=
value * stack_low;
@

<<global stack_high>>=
value * stack_high;
@

<<global stack_threshold>>=
value * stack_threshold;
@

<<global extern_sp>>=
value * extern_sp;
@

<<global trapsp>>=
value * trapsp;
@

<<global trap_barrier>>=
value * trap_barrier;
@

<<global global_data>>=
value global_data;
@

<<global max_stack_size>>=
unsigned long max_stack_size;            /* also used in gc_ctrl.c */
@

<<function init_stack>>=
void init_stack (long unsigned int initial_max_size)
{
  stack_low = (value *) stat_alloc(Stack_size);
  stack_high = stack_low + Stack_size / sizeof (value);
  stack_threshold = stack_low + Stack_threshold / sizeof (value);
  extern_sp = stack_high;
  trapsp = stack_high;
  trap_barrier = stack_high + 1;
  max_stack_size = initial_max_size;
  gc_message ("Initial stack limit: %luk bytes\n",
          max_stack_size / 1024 * sizeof (value));
}
@

<<function realloc_stack>>=
void realloc_stack(void)
{        
  asize_t size;
  value * new_low, * new_high, * new_sp;
  value * p;

  Assert(extern_sp >= stack_low);
  size = stack_high - stack_low;
  if (size >= max_stack_size) raise_stack_overflow();
  size *= 2;
  gc_message ("Growing stack to %luk bytes\n",
              (unsigned long) size * sizeof(value) / 1024);
  new_low = (value *) stat_alloc(size * sizeof(value));
  new_high = new_low + size;

#define shift(ptr) \
    ((char *) new_high - ((char *) stack_high - (char *) (ptr)))

  new_sp = (value *) shift(extern_sp);
  bcopy((char *) extern_sp,
        (char *) new_sp,
        (stack_high - extern_sp) * sizeof(value));
  stat_free(stack_low);
  trapsp = (value *) shift(trapsp);
  trap_barrier = (value *) shift(trap_barrier);
  for (p = trapsp; p < new_high; p = Trap_link(p))
    Trap_link(p) = (value *) shift(Trap_link(p));
  stack_low = new_low;
  stack_high = new_high;
  stack_threshold = stack_low + Stack_threshold / sizeof (value);
  extern_sp = new_sp;

#undef shift
}
@

<<function change_max_stack_size>>=
void change_max_stack_size (long unsigned int new_max_size)
{
  asize_t size = stack_high - extern_sp + Stack_threshold / sizeof (value);

  if (new_max_size < size) new_max_size = size;
  if (new_max_size != max_stack_size){
    gc_message ("Changing stack limit to %luk bytes\n",
                new_max_size * sizeof (value) / 1024);
  }
  max_stack_size = new_max_size;
}
@


%-------------------------------------------------------------

<<byterun/stacks.c>>=
<<copyright header C xavier>>

/* To initialize and resize the stacks */

#include <string.h>
#include "config.h"
#include "fail.h"
#include "misc.h"
#include "mlvalues.h"
#include "stacks.h"

<<global stack_low>>
<<global stack_high>>
<<global stack_threshold>>
<<global extern_sp>>
<<global trapsp>>
<<global trap_barrier>>
<<global global_data>>

<<global max_stack_size>>

<<function init_stack>>

<<function realloc_stack>>

<<function change_max_stack_size>>
@


\subsection*{[[byterun/callback.h]]}

<<constant _callback_>>=
#define _callback_
@


%-------------------------------------------------------------

<<byterun/callback.h>>=
<<copyright header C xavier>>

/* Callbacks from C to Caml */

#ifndef _callback_
<<constant _callback_>>

#include "mlvalues.h"

value callback (value closure, value arg);
value callback2 (value closure, value arg1, value arg2);
value callback3 (value closure, value arg1, value arg2, value arg3);
extern int callback_depth;

value * caml_named_value (char * name);

void caml_main (char ** argv);
void caml_startup (char ** argv);

#endif
@


\subsection*{[[byterun/callback.c]]}

<<global callback_depth>>=
int callback_depth = 0;
@

<<global callback1_code>>=
static opcode_t callback1_code[] = { ACC1, APPLY1, POP, 1, STOP };
@

<<global callback2_code>>=
static opcode_t callback2_code[] = { ACC2, APPLY2, POP, 1, STOP };
@

<<global callback3_code>>=
static opcode_t callback3_code[] = { ACC3, APPLY3, POP, 1, STOP };
@

<<global callback_code_threaded>>=
static int callback_code_threaded = 0;
@

<<function thread_callback>>=
static void thread_callback(void)
{
  thread_code(callback1_code, sizeof(callback1_code));
  thread_code(callback2_code, sizeof(callback2_code));
  thread_code(callback3_code, sizeof(callback3_code));
  callback_code_threaded = 1;
}
@

<<function Init_callback>>=
#define Init_callback()
@

<<function callback>>=
value callback(value closure, value arg)
{
  value res;
  Init_callback();
  extern_sp -= 2;
  extern_sp[0] = arg;
  extern_sp[1] = closure;
  callback_depth++;
  res = interprete(callback1_code, sizeof(callback1_code));
  callback_depth--;
  return res;
}
@

<<function callback2>>=
value callback2(value closure, value arg1, value arg2)
{
  value res;
  Init_callback();
  extern_sp -= 3;
  extern_sp[0] = arg1;
  extern_sp[1] = arg2;
  extern_sp[2] = closure;
  callback_depth++;
  res = interprete(callback2_code, sizeof(callback2_code));
  callback_depth--;
  return res;
}
@

<<function callback3>>=
value callback3(value closure, value arg1, value arg2, value arg3)
{
  value res;
  Init_callback();
  extern_sp -= 4;
  extern_sp[0] = arg1;
  extern_sp[1] = arg2;
  extern_sp[2] = arg3;
  extern_sp[3] = closure;
  callback_depth++;
  res = interprete(callback3_code, sizeof(callback3_code));
  callback_depth--;
  return res;
}
@

<<struct named_value>>=
/* Naming of Caml values */

struct named_value {
  value val;
  struct named_value * next;
  char name[1];
};
@

<<constant Named_value_size>>=
#define Named_value_size 13
@

<<global named_value_table>>=
static struct named_value * named_value_table[Named_value_size] = { NULL, };
@

<<function hash_value_name>>=
static unsigned int hash_value_name(char *name)
{
  unsigned int h;
  for (h = 0; *name != 0; name++) h = h * 19 + *name;
  return h % Named_value_size;
}
@

<<function register_named_value>>=
value register_named_value(value vname, value val) /* ML */
{
  struct named_value * nv;
  char * name = String_val(vname);
  unsigned int h = hash_value_name(name);

  nv = (struct named_value *)
         stat_alloc(sizeof(struct named_value) + strlen(name));
  strcpy(nv->name, name);
  nv->val = val;
  nv->next = named_value_table[h];
  named_value_table[h] = nv;
  register_global_root(&nv->val);
  return Val_unit;
}
@

<<function caml_named_value>>=
value * caml_named_value(char *name)
{
  struct named_value * nv;
  for (nv = named_value_table[hash_value_name(name)];
       nv != NULL;
       nv = nv->next) {
    if (strcmp(name, nv->name) == 0) return &nv->val;
  }
  return NULL;
}
@


%-------------------------------------------------------------

<<byterun/callback.c>>=
<<copyright header C xavier>>

/* Callbacks from C to Caml */

#include <string.h>
#include "callback.h"
#include "memory.h"
#include "mlvalues.h"

/* Bytecode callbacks (implemented in asm for the native code compiler) */

#ifndef NATIVE_CODE

#include "interp.h"
#include "instruct.h"
#include "fix_code.h"
#include "stacks.h"

<<global callback_depth>>

<<global callback1_code>>
<<global callback2_code>>
<<global callback3_code>>

#ifdef THREADED_CODE

<<global callback_code_threaded>>

<<function thread_callback>>

#define Init_callback() if (!callback_code_threaded) thread_callback()

#else

<<function Init_callback>>

#endif

<<function callback>>

<<function callback2>>

<<function callback3>>

#endif

<<struct named_value>>

<<constant Named_value_size>>

<<global named_value_table>>

<<function hash_value_name>>

<<function register_named_value>>

<<function caml_named_value>>
@


\subsection*{[[byterun/compare.c]]}

<<function compare_val>>=
/* Structural comparison on trees.
   May loop on cyclic structures. */

static long compare_val(value v1, value v2)
{
  tag_t t1, t2;

 tailcall:
  if (v1 == v2) return 0;
  if (Is_long(v1)) {
    if (Is_long(v2))
      return Long_val(v1) - Long_val(v2);
    else
      return -1;
  }
  if (Is_long(v2)) return 1;
  /* If one of the objects is outside the heap (but is not an atom),
     use address comparison. Since both addresses are 2-aligned,
     shift lsb off to avoid overflow in subtraction. */
  if ((!Is_atom(v1) && !Is_young(v1) && !Is_in_heap(v1)) ||
      (!Is_atom(v2) && !Is_young(v2) && !Is_in_heap(v2)))
      return (v1 >> 1) - (v2 >> 1);
  t1 = Tag_val(v1);
  t2 = Tag_val(v2);
  if (t1 != t2) return (long)t1 - (long)t2;
  switch(t1) {
  case String_tag: {
    mlsize_t len1, len2, len;
    unsigned char * p1, * p2;
    len1 = string_length(v1);
    len2 = string_length(v2);
    for (len = (len1 <= len2 ? len1 : len2),
         p1 = (unsigned char *) String_val(v1),
         p2 = (unsigned char *) String_val(v2);
         len > 0;
         len--, p1++, p2++)
      if (*p1 != *p2) return (long)*p1 - (long)*p2;
    return len1 - len2;
  }
  case Double_tag: {
    double d1 = Double_val(v1);
    double d2 = Double_val(v2);
    if (d1 < d2) return -1; else if (d1 > d2) return 1; else return 0;
  }
  case Double_array_tag: {
    mlsize_t sz1 = Wosize_val(v1) / Double_wosize;
    mlsize_t sz2 = Wosize_val(v2) / Double_wosize;
    mlsize_t i;
    if (sz1 != sz2) return sz1 - sz2;
    for (i = 0; i < sz1; i++) {
      double d1 = Double_field(v1, i);
      double d2 = Double_field(v2, i);
      if (d1 < d2) return -1; else if (d1 > d2) return 1;
    }
    return 0;
  }
  case Abstract_tag:
  case Final_tag:
    invalid_argument("equal: abstract value");
  case Closure_tag:
  case Infix_tag:
    invalid_argument("equal: functional value");
  case Object_tag:
    return (Oid_val(v1) - Oid_val(v2));
  default: {
    mlsize_t sz1 = Wosize_val(v1);
    mlsize_t sz2 = Wosize_val(v2);
    value * p1, * p2;
    long res;
    if (sz1 != sz2) return sz1 - sz2;
    if (sz1 == 0) return 0;
    for(p1 = Op_val(v1), p2 = Op_val(v2);
        sz1 > 1;
        sz1--, p1++, p2++) {
      res = compare_val(*p1, *p2);
      if (res != 0) return res;
    }
    v1 = *p1;
    v2 = *p2;
    goto tailcall;
  }
  }
}
@

<<function compare>>=
value compare(value v1, value v2)           /* ML */
{
  long res = compare_val(v1, v2);
  if (res < 0) 
    return Val_int(-1);
  else if (res > 0)
    return Val_int(1);
  else
    return Val_int(0);
}
@

<<function equal>>=
value equal(value v1, value v2)            /* ML */
{
  return Val_int(compare_val(v1, v2) == 0);
}
@

<<function notequal>>=
value notequal(value v1, value v2)            /* ML */
{
  return Val_int(compare_val(v1, v2) != 0);
}
@

<<function lessthan>>=
value lessthan(value v1, value v2)            /* ML */
{
  return Val_int(compare_val(v1, v2) < 0);
}
@

<<function lessequal>>=
value lessequal(value v1, value v2)          /* ML */
{
  return Val_int(compare_val(v1, v2) <= 0);
}
@

<<function greaterthan>>=
value greaterthan(value v1, value v2)        /* ML */
{
  return Val_int(compare_val(v1, v2) > 0);
}
@

<<function greaterequal>>=
value greaterequal(value v1, value v2)       /* ML */
{
  return Val_int(compare_val(v1, v2) >= 0);
}
@


%-------------------------------------------------------------

<<byterun/compare.c>>=
<<copyright header C xavier>>

#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "str.h"

<<function compare_val>>

<<function compare>>

<<function equal>>

<<function notequal>>

<<function lessthan>>

<<function lessequal>>

<<function greaterthan>>

<<function greaterequal>>
@


\subsection*{[[byterun/debugger.h]]}

<<constant _debugger_>>=
#define _debugger_
@

<<enum event_kind>>=
enum event_kind {
  EVENT_COUNT, BREAKPOINT, PROGRAM_START, PROGRAM_EXIT,
  TRAP_BARRIER, UNCAUGHT_EXC
};
@

<<enum debugger_request>>=
/* Requests from the debugger to the runtime system */

enum debugger_request {
  REQ_SET_EVENT = 'e',          /* uint32 pos */
  /* Set an event on the instruction at position pos */
  REQ_SET_BREAKPOINT = 'B',     /* uint32 pos */
  /* Set a breakpoint at position pos */
  REQ_RESET_INSTR = 'i',        /* uint32 pos */
  /* Clear an event or breapoint at position pos, restores initial instr. */
  REQ_CHECKPOINT = 'c',         /* no args */
  /* Checkpoint the runtime system by forking a child process. 
     Reply is pid of child process or -1 if checkpoint failed. */
  REQ_GO = 'g',                 /* uint32 n */
  /* Run the program for n events.
     Reply is one of debugger_reply described below. */
  REQ_STOP = 's',               /* no args */
  /* Terminate the runtime system */
  REQ_WAIT = 'w',               /* no args */
  /* Reap one dead child (a discarded checkpoint). */
  REQ_INITIAL_FRAME = '0',      /* no args */
  /* Set current frame to bottom frame (the one currently executing).
     Reply is stack offset and current pc. */
  REQ_GET_FRAME = 'f',          /* no args */
  /* Return current frame location (stack offset + current pc). */
  REQ_SET_FRAME = 'S',          /* uint32 stack_offset */
  /* Set current frame to given stack offset. No reply. */
  REQ_UP_FRAME = 'U',           /* uint32 n */
  /* Move one frame up. Argument n is size of current frame (in words).
     Reply is stack offset and current pc, or -1 if top of stack reached. */
  REQ_SET_TRAP_BARRIER = 'b',   /* uint32 offset */
  /* Set the trap barrier at the given offset. */
  REQ_GET_LOCAL = 'L',          /* uint32 slot_number */
  /* Return the local variable at the given slot in the current frame.
     Reply is one value. */
  REQ_GET_ENVIRONMENT = 'E',    /* uint32 slot_number */
  /* Return the local variable at the given slot in the heap environment
     of the current frame. Reply is one value. */
  REQ_GET_GLOBAL = 'G',         /* uint32 global_number */
  /* Return the specified global variable. Reply is one value. */
  REQ_GET_ACCU = 'A',           /* no args */
  /* Return the current contents of the accumulator. Reply is one value. */
  REQ_GET_HEADER = 'H',         /* mlvalue v */
  /* As REQ_GET_OBJ, but sends only the header. */
  REQ_GET_FIELD = 'F',          /* mlvalue v, uint32 fieldnum */
  /* As REQ_GET_OBJ, but sends only one field. */
  REQ_MARSHAL_OBJ = 'M',        /* mlvalue v */
  /* Send a copy of the data structure rooted at v, using the same
     format as output_value. */
  REQ_GET_CLOSURE_CODE = 'C'    /* mlvalue v */
  /* Send the code address of the given closure.
     Reply is one uint32. */
};
@

<<enum debugger_reply>>=
/* Replies to a REQ_GO request. All replies are followed by three uint32:
   - the value of the event counter
   - the position of the stack
   - the current pc. */

enum debugger_reply {
  REP_EVENT = 'e',
  /* Event counter reached 0. */
  REP_BREAKPOINT = 'b',
  /* Breakpoint hit. */
  REP_EXITED = 'x',
  /* Program exited by calling exit or reaching the end of the source. */
  REP_TRAP = 's',
  /* Trap barrier crossed. */
  REP_UNCAUGHT_EXC = 'u'
  /* Program exited due to a stray exception. */
};
@


%-------------------------------------------------------------

<<byterun/debugger.h>>=
<<copyright header C xavier>>

/* Interface with the debugger */

#ifndef _debugger_
<<constant _debugger_>>

#include "misc.h"
#include "mlvalues.h"

extern int debugger_in_use;
extern unsigned long event_count;

<<enum event_kind>>

void debugger_init (void);
void debugger (enum event_kind event);

/* Communication protocol */

<<enum debugger_request>>

<<enum debugger_reply>>

#endif


@


\subsection*{[[byterun/debugger.c]]}

<<global debugger_in_use>>=
int debugger_in_use = 0;
@

<<global event_count>>=
unsigned long event_count;
@

<<function debugger_init>>=
void debugger_init(void)
{
}
@

<<function debugger>>=
void debugger(enum event_kind event)
{
}
@

<<global sock_domain>>=
static int sock_domain;         /* Socket domain for the debugger */
@

<<global sock_addr>>=
static union {                  /* Socket address for the debugger */
  struct sockaddr s_gen;
  struct sockaddr_un s_unix;
  struct sockaddr_in s_inet;
} sock_addr;
@

<<global sock_addr_len>>=
static int sock_addr_len;       /* Length of sock_addr */
@

<<global dbg_socket>>=
static int dbg_socket = -1;     /* The socket connected to the debugger */
@

<<global dbg_in>>=
static struct channel * dbg_in; /* Input channel on the socket */
@

<<global dbg_out>>=
static struct channel * dbg_out;/* Output channel on the socket */
@

<<function open_connection>>=
static void open_connection(void)
{
  dbg_socket = socket(sock_domain, SOCK_STREAM, 0);
  if (dbg_socket == -1 ||
      connect(dbg_socket, &sock_addr.s_gen, sock_addr_len) == -1)
    fatal_error("cannot connect to debugger");
  dbg_in = open_descriptor(dbg_socket);
  dbg_out = open_descriptor(dbg_socket);
  if (!debugger_in_use) putword(dbg_out, -1); /* first connection */
  putword(dbg_out, getpid());
  flush(dbg_out);
}
@

<<function close_connection>>=
static void close_connection(void)
{
  close_channel(dbg_in);
  close_channel(dbg_out);
  dbg_socket = -1;              /* was closed by close_channel */
}
@

<<function debugger_init (byterun/debugger.c)>>=
void debugger_init(void)
{
  char * address;
  char * port, * p;
  struct hostent * host;
  int n;

  address = getenv("CAML_DEBUG_SOCKET");
  if (address == NULL) return;

  /* Parse the address */
  port = NULL;
  for (p = address; *p != 0; p++) {
    if (*p == ':') { *p = 0; port = p+1; break; }
  }
  if (port == NULL) {
    /* Unix domain */
    sock_domain = PF_UNIX;
    sock_addr.s_unix.sun_family = AF_UNIX;
    strncpy(sock_addr.s_unix.sun_path, address,
            sizeof(sock_addr.s_unix.sun_path));
    sock_addr_len = 
      ((char *)&(sock_addr.s_unix.sun_path) - (char *)&(sock_addr.s_unix))
        + strlen(address);
  } else {
    /* Internet domain */
    sock_domain = PF_INET;
    for (p = (char *) &sock_addr.s_inet, n = sizeof(sock_addr.s_inet);
         n > 0; n--) *p++ = 0;
    sock_addr.s_inet.sin_family = AF_INET;
    sock_addr.s_inet.sin_addr.s_addr = inet_addr(address);
    if (sock_addr.s_inet.sin_addr.s_addr == -1) {
      host = gethostbyname(address);
      if (host == NULL)
        fatal_error_arg("Unknown debugging host %s\n", address);
      bcopy(host->h_addr, &sock_addr.s_inet.sin_addr, host->h_length);
    }
    sock_addr.s_inet.sin_port = htons(atoi(port));
    sock_addr_len = sizeof(sock_addr.s_inet);
  }
  open_connection();
  debugger_in_use = 1;
  trap_barrier = stack_high;
}
@

<<function getval>>=
static value getval(struct channel *chan)
{
  value res;
  if (really_getblock(chan, (char *) &res, sizeof(res)) == 0)
    raise_end_of_file(); /* Bad, but consistent with getword */
  return res;
}
@

<<function putval>>=
static void putval(struct channel *chan, value val)
{
  really_putblock(chan, (char *) &val, sizeof(val));
}
@

<<function safe_output_value>>=
static void safe_output_value(struct channel *chan, value val)
{
  struct longjmp_buffer raise_buf, * saved_external_raise;

  /* Catch exceptions raised by output_val */
  saved_external_raise = external_raise;
  if (sigsetjmp(raise_buf.buf, 1) == 0) {
    external_raise = &raise_buf;
    output_val(chan, val, Val_unit);
  } else {
    /* Send wrong magic number, will cause input_value to fail */
    really_putblock(chan, "\000\000\000\000", 4);
  }
  external_raise = saved_external_raise;
}
@

<<function Pc>>=
#define Pc(sp) ((code_t)(sp[0]))
@

<<function Env>>=
#define Env(sp) (sp[1])
@

<<function Extra_args>>=
#define Extra_args(sp) (Long_val((sp[2])))
@

<<function Locals>>=
#define Locals(sp) (sp + 3)
@

<<function debugger (byterun/debugger.c)>>=
void debugger(enum event_kind event)
{
  int frame_number;
  value * frame;
  long i, pos;
  value val;

  if (dbg_socket == -1) return;  /* Not connected to a debugger. */

  /* Reset current frame */
  frame_number = 0;
  frame = extern_sp + 1;

  /* Report the event to the debugger */
  switch(event) {
  case PROGRAM_START:           /* Nothing to report */
    goto command_loop;
  case EVENT_COUNT:
    putch(dbg_out, REP_EVENT);
    break;
  case BREAKPOINT:
    putch(dbg_out, REP_BREAKPOINT);
    break;
  case PROGRAM_EXIT:
    putch(dbg_out, REP_EXITED);
    break;
  case TRAP_BARRIER:
    putch(dbg_out, REP_TRAP);
    break;
  case UNCAUGHT_EXC:
    putch(dbg_out, REP_UNCAUGHT_EXC);
    break;
  }
  putword(dbg_out, event_count);
  if (event == EVENT_COUNT || event == BREAKPOINT) {
    putword(dbg_out, stack_high - frame);
    putword(dbg_out, (Pc(frame) - start_code) * sizeof(opcode_t));
  } else {
    /* No PC and no stack frame associated with other events */
    putword(dbg_out, 0);
    putword(dbg_out, 0);
  }
  flush(dbg_out);

 command_loop:
  
  /* Read and execute the commands sent by the debugger */
  while(1) {
    switch(getch(dbg_in)) {
    case REQ_SET_EVENT:
      pos = getword(dbg_in);
      Assert(pos >= 0 && pos < code_size);
      set_instruction(start_code + pos / sizeof(opcode_t), EVENT);
      break;
    case REQ_SET_BREAKPOINT:
      pos = getword(dbg_in);
      Assert(pos >= 0 && pos < code_size);
      set_instruction(start_code + pos / sizeof(opcode_t), BREAK);
      break;
    case REQ_RESET_INSTR:
      pos = getword(dbg_in);
      Assert(pos >= 0 && pos < code_size);
      pos = pos / sizeof(opcode_t);
      set_instruction(start_code + pos, saved_code[pos]);
      break;
    case REQ_CHECKPOINT:
      i = fork();
      if (i == 0) {
        close_connection();     /* Close parent connection. */
        open_connection();      /* Open new connection with debugger */
      } else {
        putword(dbg_out, i);
        flush(dbg_out);
      }
      break;
    case REQ_GO:
      event_count = getword(dbg_in);
      return;
    case REQ_STOP:
      exit(0);
      break;
    case REQ_WAIT:
      wait(NULL);
      break;
    case REQ_INITIAL_FRAME:
      frame = extern_sp + 1;
      /* Fall through */
    case REQ_GET_FRAME:
      putword(dbg_out, stack_high - frame);
      putword(dbg_out, (Pc(frame) - start_code) * sizeof(opcode_t));
      flush(dbg_out);
      break;
    case REQ_SET_FRAME:
      i = getword(dbg_in);
      frame = stack_high - i;
      break;
    case REQ_UP_FRAME:
      i = getword(dbg_in);
      if (frame + Extra_args(frame) + i + 3 >= stack_high) {
        putword(dbg_out, -1);
      } else {
        frame += Extra_args(frame) + i + 3;
        putword(dbg_out, stack_high - frame);
        putword(dbg_out, (Pc(frame) - start_code) * sizeof(opcode_t));
      }
      flush(dbg_out);
      break;
    case REQ_SET_TRAP_BARRIER:
      i = getword(dbg_in);
      trap_barrier = stack_high - i;
      break;
    case REQ_GET_LOCAL:
      i = getword(dbg_in);
      putval(dbg_out, Locals(frame)[i]);
      flush(dbg_out);
      break;
    case REQ_GET_ENVIRONMENT:
      i = getword(dbg_in);
      putval(dbg_out, Field(Env(frame), i));
      flush(dbg_out);
      break;
    case REQ_GET_GLOBAL:
      i = getword(dbg_in);
      putval(dbg_out, Field(global_data, i));
      flush(dbg_out);
      break;
    case REQ_GET_ACCU:
      putval(dbg_out, *extern_sp);
      flush(dbg_out);
      break;
    case REQ_GET_HEADER:
      val = getval(dbg_in);
      putword(dbg_out, Hd_val(val));
      flush(dbg_out);
      break;
    case REQ_GET_FIELD:
      val = getval(dbg_in);
      i = getword(dbg_in);
      putval(dbg_out, Field(val, i));
      flush(dbg_out);
      break;
    case REQ_MARSHAL_OBJ:
      val = getval(dbg_in);
      safe_output_value(dbg_out, val);
      flush(dbg_out);
      break;
    case REQ_GET_CLOSURE_CODE:
      val = getval(dbg_in);
      putword(dbg_out, (Code_val(val) - start_code) * sizeof(opcode_t));
      flush(dbg_out);
      break;
    }
  }
}
@


%-------------------------------------------------------------

<<byterun/debugger.c>>=
<<copyright header C xavier>>

/* Interface with the debugger */

#include <string.h>

#include "config.h"
#include "debugger.h"
#include "fail.h"
#include "fix_code.h"
#include "instruct.h"
#include "intext.h"
#include "io.h"
#include "misc.h"
#include "mlvalues.h"
#include "stacks.h"
#include "sys.h"

<<global debugger_in_use>>
<<global event_count>>

#if !defined(HAS_SOCKETS)

<<function debugger_init>>

<<function debugger>>

#else

#ifdef HAS_UNISTD
#include <unistd.h>
#endif
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

<<global sock_domain>>
<<global sock_addr>>
<<global sock_addr_len>>

<<global dbg_socket>>
<<global dbg_in>>
<<global dbg_out>>

<<function open_connection>>

<<function close_connection>>

<<function debugger_init (byterun/debugger.c)>>

<<function getval>>

<<function putval>>

<<function safe_output_value>>

<<function Pc>>
<<function Env>>
<<function Extra_args>>
<<function Locals>>

<<function debugger (byterun/debugger.c)>>

#endif
@


\subsection*{[[byterun/instrtrace.h]]}

<<constant _instrtrace_>>=
#define _instrtrace_
@


%-------------------------------------------------------------

<<byterun/instrtrace.h>>=
<<copyright header C xavier>>

/* Trace the instructions executed */

#ifndef _instrtrace_
<<constant _instrtrace_>>


#include "mlvalues.h"
#include "misc.h"

extern int trace_flag;
extern long icount;
void stop_here (void);
void disasm_instr (code_t pc);


#endif
@


\subsection*{[[byterun/instrtrace.c]]}

<<global icount>>=
long icount = 0;
@

<<function stop_here>>=
void stop_here () {}
@

<<global trace_flag>>=
int trace_flag = 0;
@


%-------------------------------------------------------------

<<byterun/instrtrace.c>>=
<<copyright header C xavier>>

/* Trace the instructions executed */

#ifdef DEBUG

#include <stdio.h>
#include "instruct.h"
#include "misc.h"
#include "mlvalues.h"
#include "opnames.h"

extern code_t start_code;
extern char * names_of_cprim[];

<<global icount>>

<<function stop_here>>

<<global trace_flag>>

void disasm_instr(pc)
     code_t pc;
{
  int instr = *pc;
  printf("%6ld  %s", (long) (pc - start_code),
         instr < 0 || instr > STOP ? "???" : names_of_instructions[instr]);
  pc++;
  switch(instr) {
      /* Instructions with one integer operand */
    case PUSHACC: case ACC: case POP: case ASSIGN:
    case PUSHENVACC: case ENVACC: case PUSH_RETADDR: case APPLY:
    case APPTERM1: case APPTERM2: case APPTERM3: case RETURN:
    case GRAB: case PUSHGETGLOBAL: case GETGLOBAL: case SETGLOBAL:
    case PUSHATOM: case ATOM: case MAKEBLOCK1: case MAKEBLOCK2:
    case MAKEBLOCK3: case GETFIELD: case SETFIELD: case DUMMY:
    case BRANCH: case BRANCHIF: case BRANCHIFNOT: case PUSHTRAP:
    case CONSTINT: case PUSHCONSTINT: case OFFSETINT: case OFFSETREF:
      printf(" %d\n", pc[0]); break;
      /* Instructions with two operands */
    case APPTERM: case CLOSURE: case CLOSUREREC: case PUSHGETGLOBALFIELD:
    case GETGLOBALFIELD: case MAKEBLOCK:
      printf(" %d, %d\n", pc[0], pc[1]); break;
      /* Instructions with a C primitive as operand */
    case C_CALL1: case C_CALL2: case C_CALL3: case C_CALL4: case C_CALL5:
      printf(" %s\n", names_of_cprim[pc[0]]); break;
    case C_CALLN:
      printf(" %d, %s\n", pc[0], names_of_cprim[pc[1]]); break;
    default:
      printf("\n");
    }
}

#endif
@


\subsection*{[[byterun/extern.c]]}

<<struct extern_obj>>=
struct extern_obj {
  byteoffset_t ofs;
  value obj;
};
@

<<global initial_ofs>>=
static byteoffset_t initial_ofs = 1; /* Initial value of object offsets */
@

<<global extern_table>>=
static struct extern_obj * extern_table = NULL;
@

<<global extern_table_size>>=
static unsigned long extern_table_size;
@

<<global obj_counter>>=
static byteoffset_t obj_counter;    /* Number of objects emitted so far */
@

<<function Hash>>=
#define Hash(v) (((unsigned long) ((v) >> 3)) % extern_table_size)
@

<<function Hash (byterun/extern.c)>>=
#define Hash(v) (((unsigned long) ((v) >> 2)) % extern_table_size)
@

<<function alloc_extern_table>>=
/* Allocate a new extern table */
static void alloc_extern_table(void)
{
  asize_t i;
  extern_table = (struct extern_obj *)
                 stat_alloc(extern_table_size * sizeof(struct extern_obj));
  for (i = 0; i < extern_table_size; i++) extern_table[i].ofs = 0;
}
@

<<function resize_extern_table>>=
/* Grow the extern table */
static void resize_extern_table(void)
{
  asize_t oldsize;
  struct extern_obj * oldtable;
  value obj;
  byteoffset_t ofs;
  asize_t i, h;

  oldsize = extern_table_size;
  oldtable = extern_table;
  extern_table_size = 2 * extern_table_size;
  alloc_extern_table();
  for (i = 0; i < oldsize; i++) {
    ofs = oldtable[i].ofs;
    if (ofs >= initial_ofs) {
      obj = oldtable[i].obj;
      h = Hash(obj);
      while (extern_table[h].ofs >= initial_ofs) {
        h++;
        if (h >= extern_table_size) h = 0;
      }
      extern_table[h].ofs = ofs;
      extern_table[h].obj = obj;
    }
  }
  stat_free(oldtable);
}
@

<<function free_extern_table>>=
/* Free the extern table. We keep it around for next call if
   it's still small (we did not grow it) and the initial offset
   does not risk running over next time. */
static void free_extern_table(void)
{
  if (extern_table_size > INITIAL_EXTERN_TABLE_SIZE ||
      initial_ofs >= INITIAL_OFFSET_MAX) {
    stat_free(extern_table);
    extern_table = NULL;
  }
}
@

<<global extern_block_malloced>>=
static int extern_block_malloced;
@

<<function alloc_extern_block>>=
static void alloc_extern_block(void)
{
  extern_block = stat_alloc(INITIAL_EXTERN_BLOCK_SIZE);
  extern_limit = extern_block + INITIAL_EXTERN_BLOCK_SIZE;
  extern_ptr = extern_block;
  extern_block_malloced = 1;
}
@

<<function resize_extern_block>>=
static void resize_extern_block(int required)
{
  long curr_pos, size, reqd_size;

  if (! extern_block_malloced) {
    initial_ofs += obj_counter;
    free_extern_table();
    failwith("Marshal.to_buffer: buffer overflow");
  }
  curr_pos = extern_ptr - extern_block;
  size = extern_limit - extern_block;
  reqd_size = curr_pos + required;
  while (size <= reqd_size) size *= 2;
  extern_block = stat_resize(extern_block, size);
  extern_limit = extern_block + size;
  extern_ptr = extern_block + curr_pos;
}
@

<<function writeblock>>=
static void writeblock(char *data, long int len)
{
  if (extern_ptr + len > extern_limit) resize_extern_block(len);
  bcopy(data, extern_ptr, len);
  extern_ptr += len;
}
@

<<function writecode8>>=
static void writecode8(int code, long int val)
{
  if (extern_ptr + 2 > extern_limit) resize_extern_block(2);
  extern_ptr[0] = code;
  extern_ptr[1] = val;
  extern_ptr += 2;
}
@

<<function writecode16>>=
static void writecode16(int code, long int val)
{
  if (extern_ptr + 3 > extern_limit) resize_extern_block(3);
  extern_ptr[0] = code;
  extern_ptr[1] = val >> 8;
  extern_ptr[2] = val;
  extern_ptr += 3;
}
@

<<function write32>>=
static void write32(long int val)
{
  if (extern_ptr + 4 > extern_limit) resize_extern_block(4);
  extern_ptr[0] = val >> 24;
  extern_ptr[1] = val >> 16;
  extern_ptr[2] = val >> 8;
  extern_ptr[3] = val;
  extern_ptr += 4;
}
@

<<function writecode32>>=
static void writecode32(int code, long int val)
{
  if (extern_ptr + 5 > extern_limit) resize_extern_block(5);
  extern_ptr[0] = code;
  extern_ptr[1] = val >> 24;
  extern_ptr[2] = val >> 16;
  extern_ptr[3] = val >> 8;
  extern_ptr[4] = val;
  extern_ptr += 5;
}
@

<<function writecode64>>=
static void writecode64(int code, long val)
{
  int i;
  if (extern_ptr + 9 > extern_limit) resize_extern_block(9);
  *extern_ptr ++ = code;
  for (i = 64 - 8; i >= 0; i -= 8) *extern_ptr++ = val >> i;
}
@

<<global size_32>>=
/* Marshal the given value in the output buffer */

static unsigned long size_32;  /* Size in words of 32-bit block for struct. */
@

<<global size_64>>=
static unsigned long size_64;  /* Size in words of 64-bit block for struct. */
@

<<global extern_ignore_sharing>>=
static int extern_ignore_sharing; /* Flag to ignore sharing */
@

<<global extern_closures>>=
static int extern_closures;     /* Flag to allow externing code pointers */
@

<<function extern_invalid_argument>>=
static void extern_invalid_argument(char *msg)
{
  if (extern_block_malloced) stat_free(extern_block);
  initial_ofs += obj_counter;
  free_extern_table();
  invalid_argument(msg);
}
@

<<function extern_rec>>=
static void extern_rec(value v)
{
 tailcall:
  if (Is_long(v)) {
    long n = Long_val(v);
    if (n >= 0 && n < 0x40) {
      Write(PREFIX_SMALL_INT + n);
    } else if (n >= -(1 << 7) && n < (1 << 7)) {
      writecode8(CODE_INT8, n);
    } else if (n >= -(1 << 15) && n < (1 << 15)) {
      writecode16(CODE_INT16, n);
#ifdef ARCH_SIXTYFOUR
    } else if (n < -(1L << 31) || n >= (1L << 31)) {
      writecode64(CODE_INT64, n);
#endif
    } else
      writecode32(CODE_INT32, n);
    return;
  }
  if (Is_young(v) || Is_in_heap(v) || Is_atom(v)) {
    header_t hd = Hd_val(v);
    tag_t tag = Tag_hd(hd);
    mlsize_t sz = Wosize_hd(hd);
    asize_t h;
    /* Atoms are treated specially for two reasons: they are not allocated
       in the externed block, and they are automatically shared. */
    if (sz == 0) {
      if (tag < 16) {
        Write(PREFIX_SMALL_BLOCK + tag);
      } else {
        writecode32(CODE_BLOCK32, hd);
      }
      return;
    }
    /* Check if already seen */
    if (! extern_ignore_sharing) {
      if (2 * obj_counter >= extern_table_size) resize_extern_table();
      h = Hash(v);
      while (extern_table[h].ofs >= initial_ofs) {
        if (extern_table[h].obj == v) {
          byteoffset_t d = obj_counter - (extern_table[h].ofs - initial_ofs);
          if (d < 0x100) {
            writecode8(CODE_SHARED8, d);
          } else if (d < 0x10000) {
            writecode16(CODE_SHARED16, d);
          } else {
            writecode32(CODE_SHARED32, d);
          }
          return;
        }
        h++;
        if (h >= extern_table_size) h = 0;
      }
      /* Not seen yet. Record the object */
      extern_table[h].ofs = initial_ofs + obj_counter;
      extern_table[h].obj = v;
      obj_counter++;
    }
    /* Output the contents of the object */
    switch(tag) {
    case String_tag: {
      mlsize_t len = string_length(v);
      if (len < 0x20) {
        Write(PREFIX_SMALL_STRING + len);
      } else if (len < 0x100) {
        writecode8(CODE_STRING8, len);
      } else {
        writecode32(CODE_STRING32, len);
      }
      writeblock(String_val(v), len);
      size_32 += 1 + (len + 4) / 4;
      size_64 += 1 + (len + 8) / 8;
      break;
    }
    case Double_tag: {
      if (sizeof(double) != 8)
        extern_invalid_argument("output_value: non-standard floats");
      Write(CODE_DOUBLE_NATIVE);
      writeblock((char *) v, 8);
      size_32 += 1 + 2;
      size_64 += 1 + 1;
      break;
    }
    case Double_array_tag: {
      mlsize_t nfloats;
      if (sizeof(double) != 8)
        extern_invalid_argument("output_value: non-standard floats");
      nfloats = Wosize_val(v) / Double_wosize;
      if (nfloats < 0x100) {
        writecode8(CODE_DOUBLE_ARRAY8_NATIVE, nfloats);
      } else {
        writecode32(CODE_DOUBLE_ARRAY32_NATIVE, nfloats);
      }
      writeblock((char *) v, Bosize_val(v));
      size_32 += 1 + nfloats * 2;
      size_64 += 1 + nfloats;
      break;
    }
    case Abstract_tag:
    case Final_tag:
      extern_invalid_argument("output_value: abstract value");
      break;
    case Infix_tag:
      writecode32(CODE_INFIXPOINTER, Infix_offset_hd(hd));
      extern_rec(v - Infix_offset_hd(hd));
      break;
    case Object_tag:
      extern_invalid_argument("output_value: object value");
      break;
    default: {
      mlsize_t i;
      if (tag < 16 && sz < 8) {
        Write(PREFIX_SMALL_BLOCK + tag + (sz << 4));
      } else {
        writecode32(CODE_BLOCK32, hd & ~Black);
      }
      size_32 += 1 + sz;
      size_64 += 1 + sz;
      for (i = 0; i < sz - 1; i++) extern_rec(Field(v, i));
      v = Field(v, i);
      goto tailcall;
      }
    }
    return;
  }
  if ((char *) v >= code_area_start && (char *) v < code_area_end) {
    if (!extern_closures)
      extern_invalid_argument("output_value: functional value");
    writecode32(CODE_CODEPOINTER, (char *) v - code_area_start);
    writeblock((char *) code_checksum(), 16);
    return;
  }
  extern_invalid_argument("output_value: abstract value");
}
@

<<enum _anon_>>=
enum { NO_SHARING = 1, CLOSURES = 2 };
@

<<global extern_flags>>=
static int extern_flags[] = { NO_SHARING, CLOSURES };
@

<<function extern_value>>=
static long extern_value(value v, value flags)
{
  long res_len;
  int fl;
  /* Parse flag list */
  fl = convert_flag_list(flags, extern_flags);
  extern_ignore_sharing = fl & NO_SHARING;
  extern_closures = fl & CLOSURES;
  /* Allocate hashtable of objects already seen, if needed */
  extern_table_size = INITIAL_EXTERN_TABLE_SIZE;
  if (extern_table == NULL) {
    alloc_extern_table();
    initial_ofs = 1;
  }
  obj_counter = 0;
  size_32 = 0;
  size_64 = 0;
  /* Write magic number */
  write32(Intext_magic_number);
  /* Set aside space for the sizes */
  extern_ptr += 4*4;
  /* Marshal the object */
  extern_rec(v);
  /* Update initial offset for next call to extern_value(),
     if we decide to keep the table of shared objects. */
  initial_ofs += obj_counter;
  /* Free the table of shared objects (if needed) */
  free_extern_table();
  /* Write the sizes */
#ifdef ARCH_SIXTYFOUR
  if (size_32 >= (1L << 32) || size_64 >= (1L << 32)) {
    /* The object is so big its size cannot be written in the header.
       Besides, some of the block sizes or string lengths or shared offsets
       it contains may have overflowed the 32 bits used to write them. */
    failwith("output_value: object too big");
  }
#endif
  res_len = extern_ptr - extern_block;
  extern_ptr = extern_block + 4;
  write32(res_len - 5*4);
  write32(obj_counter);
  write32(size_32);
  write32(size_64);
  /* Result is res_len bytes starting at extern_block */
  return res_len;
}
@

<<function output_val>>=
void output_val(struct channel *chan, value v, value flags)
{
  long len;
  alloc_extern_block();
  len = extern_value(v, flags);
  really_putblock(chan, extern_block, len);
  stat_free(extern_block);
}
@

<<function output_value_to_string>>=
value output_value_to_string(value v, value flags) /* ML */
{
  long len;
  value res;
  alloc_extern_block();
  len = extern_value(v, flags);
  res = alloc_string(len);
  bcopy(extern_block, String_val(res), len);
  stat_free(extern_block);
  return res;
}
@

<<function output_value_to_buffer>>=
value output_value_to_buffer(value buf, value ofs, value len, value v, value flags) /* ML */
{
  long len_res;
  extern_block = &Byte(buf, Long_val(ofs));
  extern_limit = extern_block + Long_val(len);
  extern_ptr = extern_block;
  extern_block_malloced = 0;
  len_res = extern_value(v, flags);
  return Val_long(len_res);
}
@


%-------------------------------------------------------------

<<byterun/extern.c>>=
<<copyright header C xavier>>

/* Structured output */

#include <string.h>
#include "alloc.h"
#include "fail.h"
#include "gc.h"
#include "intext.h"
#include "io.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "reverse.h"
#include "str.h"

/* To keep track of sharing in externed objects */

typedef unsigned long byteoffset_t;

<<struct extern_obj>>

<<global initial_ofs>>
<<global extern_table>>
<<global extern_table_size>>
<<global obj_counter>>

#ifdef ARCH_SIXTYFOUR
<<function Hash>>
#else
<<function Hash (byterun/extern.c)>>
#endif

<<function alloc_extern_table>>

<<function resize_extern_table>>

<<function free_extern_table>>

/* To buffer the output */

static char * extern_block, * extern_ptr, * extern_limit;
<<global extern_block_malloced>>

<<function alloc_extern_block>>

<<function resize_extern_block>>

/* Write characters, integers, and blocks in the output buffer */

#define Write(c) \
  if (extern_ptr >= extern_limit) resize_extern_block(1); \
  *extern_ptr++ = (c)

<<function writeblock>>

<<function writecode8>>

<<function writecode16>>

<<function write32>>

<<function writecode32>>

#ifdef ARCH_SIXTYFOUR
<<function writecode64>>
#endif

<<global size_32>>
<<global size_64>>

<<global extern_ignore_sharing>>
<<global extern_closures>>

<<function extern_invalid_argument>>

<<function extern_rec>>

<<enum _anon_>>
<<global extern_flags>>

<<function extern_value>>

<<function output_val>>

value output_value(value vchan, value v, value flags) /* ML */
{
  struct channel * channel = Channel(vchan);
  Begin_root(v)
    Lock(channel);
    output_val(channel, v, flags);
    Unlock(channel);
  End_roots();
  return Val_unit;
}

<<function output_value_to_string>>

<<function output_value_to_buffer>>

@


\subsection*{[[byterun/fail.h]]}

<<constant _fail_>>=
#define _fail_
@

<<constant OUT_OF_MEMORY_EXN>>=
#define OUT_OF_MEMORY_EXN 0     /* "Out_of_memory" */
@

<<constant SYS_ERROR_EXN>>=
#define SYS_ERROR_EXN 1         /* "Sys_error" */
@

<<constant FAILURE_EXN>>=
#define FAILURE_EXN 2           /* "Failure" */
@

<<constant INVALID_EXN>>=
#define INVALID_EXN 3           /* "Invalid_argument" */
@

<<constant END_OF_FILE_EXN>>=
#define END_OF_FILE_EXN 4       /* "End_of_file" */
@

<<constant ZERO_DIVIDE_EXN>>=
#define ZERO_DIVIDE_EXN 5       /* "Division_by_zero" */
@

<<constant NOT_FOUND_EXN>>=
#define NOT_FOUND_EXN 6         /* "Not_found" */
@

<<constant MATCH_FAILURE_EXN>>=
#define MATCH_FAILURE_EXN 7     /* "Match_failure" */
@

<<constant STACK_OVERFLOW_EXN>>=
#define STACK_OVERFLOW_EXN 8    /* "Stack_overflow" */
@

<<struct longjmp_buffer>>=
#ifdef POSIX_SIGNALS
struct longjmp_buffer {
  sigjmp_buf buf;
};
@


%-------------------------------------------------------------

<<byterun/fail.h>>=
<<copyright header C xavier>>

#ifndef _fail_
<<constant _fail_>>


#include <setjmp.h>
#include "misc.h"
#include "mlvalues.h"

<<constant OUT_OF_MEMORY_EXN>>
<<constant SYS_ERROR_EXN>>
<<constant FAILURE_EXN>>
<<constant INVALID_EXN>>
<<constant END_OF_FILE_EXN>>
<<constant ZERO_DIVIDE_EXN>>
<<constant NOT_FOUND_EXN>>
<<constant MATCH_FAILURE_EXN>>
<<constant STACK_OVERFLOW_EXN>>

<<struct longjmp_buffer>>
#else
struct longjmp_buffer {
  jmp_buf buf;
};
#define sigsetjmp(buf,save) setjmp(buf)
#define siglongjmp(buf,val) longjmp(buf,val)
#endif

extern struct longjmp_buffer * external_raise;
extern value exn_bucket;

void mlraise (value bucket) Noreturn;
void raise_constant (value tag) Noreturn;
void raise_with_arg (value tag, value arg) Noreturn;
void raise_with_string (value tag, char * msg) Noreturn;
void failwith (char *) Noreturn;
void invalid_argument (char *) Noreturn;
void raise_out_of_memory (void) Noreturn;
void raise_stack_overflow (void) Noreturn;
void raise_sys_error (value) Noreturn;
void raise_end_of_file (void) Noreturn;
void raise_zero_divide (void) Noreturn;
void raise_not_found (void) Noreturn;
void fatal_uncaught_exception (value) Noreturn;

#endif /* _fail_ */
@


\subsection*{[[byterun/fail.c]]}

<<global external_raise>>=
struct longjmp_buffer * external_raise;
@

<<global exn_bucket>>=
value exn_bucket;
@

<<function mlraise>>=
void mlraise(value v)
{
  Assert(! async_signal_mode);
  Unlock_exn();
  exn_bucket = v;
  siglongjmp(external_raise->buf, 1);
}
@

<<function raise_constant>>=
void raise_constant(value tag)
{
  value bucket;
  Begin_root (tag);
    bucket = alloc (1, 0);
    Field(bucket, 0) = tag;
  End_roots ();
  mlraise(bucket);
}
@

<<function raise_with_arg>>=
void raise_with_arg(value tag, value arg)
{
  value bucket;
  Begin_roots2 (tag, arg);
    bucket = alloc (2, 0);
    Field(bucket, 0) = tag;
    Field(bucket, 1) = arg;
  End_roots ();
  mlraise(bucket);
}
@

<<function raise_with_string>>=
void raise_with_string(value tag, char *msg)
{
  value vmsg;
  Begin_root(tag);
    vmsg = copy_string(msg);
  End_roots();
  raise_with_arg(tag, vmsg);
}
@

<<function failwith>>=
void failwith (char *msg)
{
  raise_with_string(Field(global_data, FAILURE_EXN), msg);
}
@

<<function invalid_argument>>=
void invalid_argument (char *msg)
{
  raise_with_string(Field(global_data, INVALID_EXN), msg);
}
@

<<global out_of_memory_bucket>>=
/* Problem: we can't use raise_constant, because it allocates and
   we're out of memory... The following is a terrible hack that works
   because global_data[OUT_OF_MEMORY_EXN] is in the old generation
   (because global_data was read with intern_val), hence stays at
   a fixed address */

static struct {
  header_t hdr;
  value exn;
} out_of_memory_bucket;
@

<<function raise_out_of_memory>>=
void raise_out_of_memory(void)
{
  out_of_memory_bucket.hdr = Make_header(1, 0, White);
  out_of_memory_bucket.exn = Field(global_data, OUT_OF_MEMORY_EXN);
  mlraise((value) &(out_of_memory_bucket.exn));
}
@

<<function raise_stack_overflow>>=
void raise_stack_overflow(void)
{
  raise_constant(Field(global_data, STACK_OVERFLOW_EXN));
}
@

<<function raise_sys_error>>=
void raise_sys_error(value msg)
{
  raise_with_arg(Field(global_data, SYS_ERROR_EXN), msg);
}
@

<<function raise_end_of_file>>=
void raise_end_of_file(void)
{
  raise_constant(Field(global_data, END_OF_FILE_EXN));
}
@

<<function raise_zero_divide>>=
void raise_zero_divide(void)
{
  raise_constant(Field(global_data, ZERO_DIVIDE_EXN));
}
@

<<function raise_not_found>>=
void raise_not_found(void)
{
  raise_constant(Field(global_data, NOT_FOUND_EXN));
}
@


%-------------------------------------------------------------

<<byterun/fail.c>>=
<<copyright header C xavier>>

/* Raising exceptions from C. */

#include "alloc.h"
#include "fail.h"
#include "io.h"
#include "gc.h"
#include "memory.h"
#include "mlvalues.h"
#include "signals.h"
#include "stacks.h"

<<global external_raise>>
<<global exn_bucket>>

<<function mlraise>>

<<function raise_constant>>

<<function raise_with_arg>>

<<function raise_with_string>>

<<function failwith>>

<<function invalid_argument>>

<<global out_of_memory_bucket>>

<<function raise_out_of_memory>>

<<function raise_stack_overflow>>

<<function raise_sys_error>>

<<function raise_end_of_file>>

<<function raise_zero_divide>>

<<function raise_not_found>>

@


\subsection*{[[byterun/fix_code.h]]}

<<constant _fix_code_>>=
#define _fix_code_
@


%-------------------------------------------------------------

<<byterun/fix_code.h>>=
<<copyright header C xavier>>

/* Handling of blocks of bytecode (endianness switch, threading). */

#ifndef _fix_code_
<<constant _fix_code_>>


#include "config.h"
#include "misc.h"
#include "mlvalues.h"

extern code_t start_code;
extern asize_t code_size;
extern unsigned char * saved_code;
extern unsigned char code_md5[16];

void load_code (int fd, asize_t len);
void fixup_endianness (code_t code, asize_t len);
void set_instruction (code_t pos, opcode_t instr);

#ifdef THREADED_CODE
extern char ** instr_table;
extern char * instr_base;
void thread_code (code_t code, asize_t len);
#endif

#endif
@


\subsection*{[[byterun/fix_code.c]]}

<<global start_code>>=
code_t start_code;
@

<<global code_size>>=
asize_t code_size;
@

<<global saved_code>>=
unsigned char * saved_code;
@

<<global code_md5>>=
unsigned char code_md5[16];
@

<<function load_code>>=
/* Read the main bytecode block from a file */

void load_code(int fd, asize_t len)
{
  int i;
  struct MD5Context ctx;

  code_size = len;
  start_code = (code_t) stat_alloc(code_size);
  if (read(fd, (char *) start_code, code_size) != code_size)
    fatal_error("Fatal error: truncated bytecode file.\n");
  MD5Init(&ctx);
  MD5Update(&ctx, (unsigned char *) start_code, code_size);
  MD5Final(code_md5, &ctx);
#ifdef ARCH_BIG_ENDIAN
  fixup_endianness(start_code, code_size);
#endif
  if (debugger_in_use) {
    len /= sizeof(opcode_t);
    saved_code = (unsigned char *) stat_alloc(len);
    for (i = 0; i < len; i++) saved_code[i] = start_code[i];
  }
#ifdef THREADED_CODE
  /* Better to thread now than at the beginning of interprete(),
     since the debugger interface needs to perform SET_EVENT requests
     on the code. */
  thread_code(start_code, code_size);
#endif
}
@

<<function fixup_endianness>>=
void fixup_endianness(code_t code, asize_t len)
{
  code_t p;
  len /= sizeof(opcode_t);
  for (p = code; p < code + len; p++) {
    Reverse_int32(p);
  }
}
@

<<global instr_table>>=
char ** instr_table;
@

<<global instr_base>>=
char * instr_base;
@

<<function thread_code>>=
void thread_code (code_t code, asize_t len)
{
  code_t p;
  int l [STOP + 1];
  int i;
  
  for (i = 0; i <= STOP; i++) {
    l [i] = 0;
  }
  /* Instructions with one operand */
  l[PUSHACC] = l[ACC] = l[POP] = l[ASSIGN] =
  l[PUSHENVACC] = l[ENVACC] = l[PUSH_RETADDR] = l[APPLY] =
  l[APPTERM1] = l[APPTERM2] = l[APPTERM3] = l[RETURN] =
  l[GRAB] = l[PUSHGETGLOBAL] = l[GETGLOBAL] = l[SETGLOBAL] =
  l[PUSHATOM] = l[ATOM] = l[MAKEBLOCK1] = l[MAKEBLOCK2] =
  l[MAKEBLOCK3] = l[GETFIELD] = l[SETFIELD] = l[DUMMY] =
  l[BRANCH] = l[BRANCHIF] = l[BRANCHIFNOT] = l[PUSHTRAP] =
  l[C_CALL1] = l[C_CALL2] = l[C_CALL3] = l[C_CALL4] = l[C_CALL5] =
  l[CONSTINT] = l[PUSHCONSTINT] = l[OFFSETINT] = l[OFFSETREF] = 1;

  /* Instructions with two operands */
  l[APPTERM] = l[CLOSURE] = l[CLOSUREREC] = l[PUSHGETGLOBALFIELD] =
  l[GETGLOBALFIELD] = l[MAKEBLOCK] = l[C_CALLN] = 2;

  len /= sizeof(opcode_t);
  for (p = code; p < code + len; /*nothing*/) {
    opcode_t instr = *p;
    if (instr < 0 || instr > STOP){
      fatal_error_arg ("Fatal error in fix_code: bad opcode (%lx)\n",
                       (char *)(long)instr);
    }
    *p++ = (opcode_t)(instr_table[instr] - instr_base);
    if (instr == SWITCH) {
      uint32 sizes = *p++;
      uint32 const_size = sizes & 0xFFFF;
      uint32 block_size = sizes >> 16;
      p += const_size + block_size;
    } else {
      p += l[instr];
    }
  }
  Assert(p == code + len);
}
@

<<function set_instruction>>=
void set_instruction(code_t pos, opcode_t instr)
{
#ifdef THREADED_CODE
  *pos = (opcode_t)(instr_table[instr] - instr_base);
#else
  *pos = instr;
#endif
}
@


%-------------------------------------------------------------

<<byterun/fix_code.c>>=
<<copyright header C xavier>>

/* Handling of blocks of bytecode (endianness switch, threading). */

#include "config.h"
#include "debugger.h"
#include "fix_code.h"
#include "instruct.h"
#include "md5.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "reverse.h"
#ifdef HAS_UNISTD
#include <unistd.h>
#endif

<<global start_code>>
<<global code_size>>
<<global saved_code>>
<<global code_md5>>

<<function load_code>>

/* This code is needed only if the processor is big endian */

#ifdef ARCH_BIG_ENDIAN

<<function fixup_endianness>>

#endif

/* This code is needed only if we're using threaded code */

#ifdef THREADED_CODE

<<global instr_table>>
<<global instr_base>>

<<function thread_code>>

#endif /* THREADED_CODE */

<<function set_instruction>>

@


\subsection*{[[byterun/intext.h]]}

<<constant __intext__>>=
#define __intext__
@

<<constant Intext_magic_number>>=
/* Magic number */

#define Intext_magic_number 0x8495A6BE
@

<<constant PREFIX_SMALL_BLOCK>>=
/* Codes for the compact format */

#define PREFIX_SMALL_BLOCK 0x80
@

<<constant PREFIX_SMALL_INT>>=
#define PREFIX_SMALL_INT 0x40
@

<<constant PREFIX_SMALL_STRING>>=
#define PREFIX_SMALL_STRING 0x20
@

<<constant CODE_INT8>>=
#define CODE_INT8 0x0
@

<<constant CODE_INT16>>=
#define CODE_INT16 0x1
@

<<constant CODE_INT32>>=
#define CODE_INT32 0x2
@

<<constant CODE_INT64>>=
#define CODE_INT64 0x3
@

<<constant CODE_SHARED8>>=
#define CODE_SHARED8 0x4
@

<<constant CODE_SHARED16>>=
#define CODE_SHARED16 0x5
@

<<constant CODE_SHARED32>>=
#define CODE_SHARED32 0x6
@

<<constant CODE_BLOCK32>>=
#define CODE_BLOCK32 0x8
@

<<constant CODE_STRING8>>=
#define CODE_STRING8 0x9
@

<<constant CODE_STRING32>>=
#define CODE_STRING32 0xA
@

<<constant CODE_DOUBLE_BIG>>=
#define CODE_DOUBLE_BIG 0xB
@

<<constant CODE_DOUBLE_LITTLE>>=
#define CODE_DOUBLE_LITTLE 0xC
@

<<constant CODE_DOUBLE_ARRAY8_BIG>>=
#define CODE_DOUBLE_ARRAY8_BIG 0xD
@

<<constant CODE_DOUBLE_ARRAY8_LITTLE>>=
#define CODE_DOUBLE_ARRAY8_LITTLE 0xE
@

<<constant CODE_DOUBLE_ARRAY32_BIG>>=
#define CODE_DOUBLE_ARRAY32_BIG 0xF
@

<<constant CODE_DOUBLE_ARRAY32_LITTLE>>=
#define CODE_DOUBLE_ARRAY32_LITTLE 0x7
@

<<constant CODE_CODEPOINTER>>=
#define CODE_CODEPOINTER 0x10
@

<<constant CODE_INFIXPOINTER>>=
#define CODE_INFIXPOINTER 0x11
@

<<constant CODE_DOUBLE_NATIVE>>=
#define CODE_DOUBLE_NATIVE CODE_DOUBLE_BIG
@

<<constant CODE_DOUBLE_ARRAY8_NATIVE>>=
#define CODE_DOUBLE_ARRAY8_NATIVE CODE_DOUBLE_ARRAY8_BIG
@

<<constant CODE_DOUBLE_ARRAY32_NATIVE>>=
#define CODE_DOUBLE_ARRAY32_NATIVE CODE_DOUBLE_ARRAY32_BIG
@

<<constant CODE_DOUBLE_NATIVE (byterun/intext.h)>>=
#define CODE_DOUBLE_NATIVE CODE_DOUBLE_LITTLE
@

<<constant CODE_DOUBLE_ARRAY8_NATIVE (byterun/intext.h)>>=
#define CODE_DOUBLE_ARRAY8_NATIVE CODE_DOUBLE_ARRAY8_LITTLE
@

<<constant CODE_DOUBLE_ARRAY32_NATIVE (byterun/intext.h)>>=
#define CODE_DOUBLE_ARRAY32_NATIVE CODE_DOUBLE_ARRAY32_LITTLE
@

<<constant INITIAL_EXTERN_BLOCK_SIZE>>=
#define INITIAL_EXTERN_BLOCK_SIZE 8192
@

<<constant INITIAL_EXTERN_TABLE_SIZE>>=
#define INITIAL_EXTERN_TABLE_SIZE 2039
@

<<constant INITIAL_OFFSET_MAX>>=
/* Maximal value of initial_ofs above which we should start again with
   initial_ofs = 1. Should be low enough to prevent rollover of initial_ofs
   next time we extern a structure. Since a structure contains at most 
   2^N / (2 * sizeof(value)) heap objects (N = 32 or 64 depending on target),
   any value below 2^N - (2^N / (2 * sizeof(value))) suffices.
   We just take 2^(N-1) for simplicity. */

#define INITIAL_OFFSET_MAX ((unsigned long)1 << (8 * sizeof(value) - 1))
@

<<constant code_area_start>>=
#define code_area_start ((char *) start_code)
@

<<constant code_area_end>>=
#define code_area_end ((char *) start_code + code_size)
@


%-------------------------------------------------------------

<<byterun/intext.h>>=
<<copyright header C xavier>>

/* Structured input/output */

#ifndef __intext__
<<constant __intext__>>

#include "misc.h"
#include "mlvalues.h"
#include "io.h"

<<constant Intext_magic_number>>

<<constant PREFIX_SMALL_BLOCK>>
<<constant PREFIX_SMALL_INT>>
<<constant PREFIX_SMALL_STRING>>
<<constant CODE_INT8>>
<<constant CODE_INT16>>
<<constant CODE_INT32>>
<<constant CODE_INT64>>
<<constant CODE_SHARED8>>
<<constant CODE_SHARED16>>
<<constant CODE_SHARED32>>
<<constant CODE_BLOCK32>>
<<constant CODE_STRING8>>
<<constant CODE_STRING32>>
<<constant CODE_DOUBLE_BIG>>
<<constant CODE_DOUBLE_LITTLE>>
<<constant CODE_DOUBLE_ARRAY8_BIG>>
<<constant CODE_DOUBLE_ARRAY8_LITTLE>>
<<constant CODE_DOUBLE_ARRAY32_BIG>>
<<constant CODE_DOUBLE_ARRAY32_LITTLE>>
<<constant CODE_CODEPOINTER>>
<<constant CODE_INFIXPOINTER>>

#ifdef ARCH_BIG_ENDIAN
<<constant CODE_DOUBLE_NATIVE>>
<<constant CODE_DOUBLE_ARRAY8_NATIVE>>
<<constant CODE_DOUBLE_ARRAY32_NATIVE>>
#else
<<constant CODE_DOUBLE_NATIVE (byterun/intext.h)>>
<<constant CODE_DOUBLE_ARRAY8_NATIVE (byterun/intext.h)>>
<<constant CODE_DOUBLE_ARRAY32_NATIVE (byterun/intext.h)>>
#endif

/* Initial sizes of data structures for extern */

#ifndef INITIAL_EXTERN_BLOCK_SIZE
<<constant INITIAL_EXTERN_BLOCK_SIZE>>
#endif

#ifndef INITIAL_EXTERN_TABLE_SIZE
<<constant INITIAL_EXTERN_TABLE_SIZE>>
#endif

<<constant INITIAL_OFFSET_MAX>>

/* The entry points */

void output_val (struct channel * chan, value v, value flags);
value input_val (struct channel * chan);
value input_val_from_string (value str, long ofs);

/* Auxiliary stuff for sending code pointers */
unsigned char * code_checksum (void);

#ifndef NATIVE_CODE
#include "fix_code.h"
<<constant code_area_start>>
<<constant code_area_end>>
#else
extern char * code_area_start, * code_area_end;
#endif


#endif

@


\subsection*{[[byterun/intern.c]]}

<<global intern_input_malloced>>=
static int intern_input_malloced;
@

<<global intern_dest>>=
static header_t * intern_dest;
@

<<global obj_counter (byterun/intern.c)>>=
static asize_t obj_counter;
@

<<global intern_obj_table>>=
static value * intern_obj_table;
@

<<global intern_color>>=
static unsigned int intern_color;
@

<<global intern_header>>=
static header_t intern_header;
@

<<global intern_block>>=
static value intern_block;
@

<<constant Sign_extend_shift>>=
#define Sign_extend_shift ((sizeof(long) - 1) * 8)
@

<<function Sign_extend>>=
#define Sign_extend(x) (((long)(x) << Sign_extend_shift) >> Sign_extend_shift)
@

<<function read8u>>=
#define read8u() (*intern_src++)
@

<<function read8s>>=
#define read8s() Sign_extend(*intern_src++)
@

<<function read16u>>=
#define read16u() \
  (intern_src += 2, \
   (intern_src[-2] << 8) + intern_src[-1])
@

<<function read16s>>=
#define read16s() \
  (intern_src += 2, \
   (Sign_extend(intern_src[-2]) << 8) + intern_src[-1])
@

<<function read32u>>=
#define read32u() \
  (intern_src += 4, \
   (intern_src[-4] << 24) + (intern_src[-3] << 16) + \
   (intern_src[-2] << 8) + intern_src[-1])
@

<<function read32s>>=
#define read32s() \
  (intern_src += 4, \
   (Sign_extend(intern_src[-4]) << 24) + (intern_src[-3] << 16) + \
   (intern_src[-2] << 8) + intern_src[-1])
@

<<function read64s>>=
static long read64s(void)
{
  long res;
  int i;
  res = 0;
  for (i = 0; i < 8; i++) res = (res << 8) + intern_src[i];
  intern_src += 8;
  return res;
}
@

<<function readblock>>=
#define readblock(dest,len) \
  (bcopy(intern_src, dest, len), intern_src += len)
@

<<function intern_cleanup>>=
static void intern_cleanup(void)
{
  if (intern_input_malloced) stat_free(intern_input);
  if (intern_obj_table != NULL) stat_free(intern_obj_table);
  Hd_val(intern_block) = intern_header; /* Don't confuse the GC */
}
@

<<function intern_alloc>>=
static void intern_alloc(mlsize_t whsize, mlsize_t num_objects)
{
  mlsize_t wosize;

  if (whsize == 0) {
    intern_obj_table = NULL;
  } else {
    wosize = Wosize_whsize(whsize);
    if (wosize > Max_wosize) failwith("intern: structure too big");
    if (wosize < Max_young_wosize) {
      intern_block = alloc(wosize, String_tag);
    } else {
      intern_block = alloc_shr(wosize, String_tag);
    }
    intern_header = Hd_val(intern_block);
    intern_color = Color_hd(intern_header);
    Assert (intern_color == White || intern_color == Black);
    intern_dest = (header_t *) Hp_val(intern_block);
    obj_counter = 0;
    if (num_objects > 0)
      intern_obj_table = (value *) stat_alloc(num_objects * sizeof(value));
    else
      intern_obj_table = NULL;
  }
}
@

<<function input_val>>=
value input_val(struct channel *chan)
{
  uint32 magic;
  mlsize_t block_len, num_objects, size_32, size_64, whsize;
  value res;

  magic = getword(chan);
  if (magic != Intext_magic_number) failwith("input_value: bad object");
  block_len = getword(chan);
  num_objects = getword(chan);
  size_32 = getword(chan);
  size_64 = getword(chan);
  /* Read block from channel */
  intern_input = (unsigned char *) stat_alloc(block_len);
  intern_input_malloced = 1;
  if (really_getblock(chan, (char *)intern_input, block_len) == 0) {
    stat_free(intern_input);
    failwith("input_value: truncated object");
  }
  intern_src = intern_input;
  /* Allocate result */
#ifdef ARCH_SIXTYFOUR
  whsize = size_64;
#else
  whsize = size_32;
#endif
  intern_alloc(whsize, num_objects);
  /* Fill it in */
  intern_rec(&res);
  /* Free everything */
  stat_free(intern_input);
  if (intern_obj_table != NULL) stat_free(intern_obj_table);
  return res;
}
@

<<function input_val_from_string>>=
value input_val_from_string(value str, long int ofs)
{
  mlsize_t num_objects, size_32, size_64, whsize;
  value obj;

  intern_src = &Byte_u(str, ofs + 2*4);
  intern_input_malloced = 0;
  num_objects = read32u();
  size_32 = read32u();
  size_64 = read32u();
  /* Allocate result */
#ifdef ARCH_SIXTYFOUR
  whsize = size_64;
#else
  whsize = size_32;
#endif
  Begin_root(str);
    intern_alloc(whsize, num_objects);
  End_roots();
  intern_src = &Byte_u(str, ofs + 5*4); /* If a GC occurred */
  /* Fill it in */
  intern_rec(&obj);
  /* Free everything */
  if (intern_obj_table != NULL) stat_free(intern_obj_table);
  return obj;
}
@

<<function input_value_from_string>>=
value input_value_from_string(value str, value ofs) /* ML */
{
  return input_val_from_string(str, Long_val(ofs));
}
@

<<function marshal_data_size>>=
value marshal_data_size(value buff, value ofs) /* ML */
{
  uint32 magic;
  mlsize_t block_len;

  intern_src = &Byte_u(buff, Long_val(ofs));
  intern_input_malloced = 0;
  magic = read32u();
  if (magic != Intext_magic_number) failwith("Marshal.data_size: bad object");
  block_len = read32u();
  return Val_long(block_len);
}
@

<<function code_checksum>>=
unsigned char * code_checksum()
{
  static unsigned char checksum[16];
  static int checksum_computed = 0;

  if (! checksum_computed) {
    struct MD5Context ctx;
    MD5Init(&ctx);
    MD5Update(&ctx,
              (unsigned char *) code_area_start,
              code_area_end - code_area_start);
    MD5Final(checksum, &ctx);
    checksum_computed = 1;
  }
  return checksum;
}
@

<<function code_checksum (byterun/intern.c)>>=
unsigned char * code_checksum(void)
{
  return code_md5;
}
@


%-------------------------------------------------------------

<<byterun/intern.c>>=
<<copyright header C xavier>>

/* Structured input, compact format */

#include <string.h>
#include "alloc.h"
#include "fail.h"
#include "gc.h"
#include "intext.h"
#include "io.h"
#include "memory.h"
#include "mlvalues.h"
#include "misc.h"
#include "reverse.h"

static unsigned char * intern_input, * intern_src;
<<global intern_input_malloced>>
<<global intern_dest>>
<<global obj_counter (byterun/intern.c)>>
<<global intern_obj_table>>
<<global intern_color>>
<<global intern_header>>
<<global intern_block>>

<<constant Sign_extend_shift>>
<<function Sign_extend>>

<<function read8u>>
<<function read8s>>
<<function read16u>>
<<function read16s>>
<<function read32u>>
<<function read32s>>

#ifdef ARCH_SIXTYFOUR
<<function read64s>>
#endif

<<function readblock>>

<<function intern_cleanup>>

static void intern_rec(value *dest)
{
  unsigned int code;
  tag_t tag;
  mlsize_t size, len, ofs_ind;
  value v, clos;
  asize_t ofs;
  header_t header;
  char cksum[16];

 tailcall:
  code = read8u();
  if (code >= PREFIX_SMALL_INT) {
    if (code >= PREFIX_SMALL_BLOCK) {
      /* Small block */
      tag = code & 0xF;
      size = (code >> 4) & 0x7;
    read_block:
      if (size == 0) {
        v = Atom(tag);
      } else {
        v = Val_hp(intern_dest);
        *dest = v;
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        dest = (value *) (intern_dest + 1);
        *intern_dest = Make_header(size, tag, intern_color);
        intern_dest += 1 + size;
        for(/*nothing*/; size > 1; size--, dest++)
          intern_rec(dest);
        goto tailcall;
      }
    } else {
      /* Small integer */
      v = Val_int(code & 0x3F);
    }
  } else {
    if (code >= PREFIX_SMALL_STRING) {
      /* Small string */
      len = (code & 0x1F);
    read_string:
      size = (len + sizeof(value)) / sizeof(value);
      v = Val_hp(intern_dest);
      if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
      *intern_dest = Make_header(size, String_tag, intern_color);
      intern_dest += 1 + size;
      Field(v, size - 1) = 0;
      ofs_ind = Bsize_wsize(size) - 1;
      Byte(v, ofs_ind) = ofs_ind - len;
      readblock(String_val(v), len);
    } else {
      switch(code) {
      case CODE_INT8:
        v = Val_long(read8s());
        break;
      case CODE_INT16:
        v = Val_long(read16s());
        break;
      case CODE_INT32:
        v = Val_long(read32s());
        break;
      case CODE_INT64:
#ifdef ARCH_SIXTYFOUR
        v = Val_long(read64s());
        break;
#else
        intern_cleanup();
        failwith("input_value: integer too large");
        break;
#endif
      case CODE_SHARED8:
        ofs = read8u();
      read_shared:
        Assert(ofs > 0 && ofs <= obj_counter && intern_obj_table != NULL); 
        v = intern_obj_table[obj_counter - ofs];
        break;
      case CODE_SHARED16:
        ofs = read16u();
        goto read_shared;
      case CODE_SHARED32:
        ofs = read32u();
        goto read_shared;
      case CODE_BLOCK32:
        header = (header_t) read32u();
        tag = Tag_hd(header);
        size = Wosize_hd(header);
        goto read_block;
      case CODE_STRING8:
        len = read8u();
        goto read_string;
      case CODE_STRING32:
        len = read32u();
        goto read_string;
      case CODE_DOUBLE_LITTLE:
      case CODE_DOUBLE_BIG:
        if (sizeof(double) != 8) {
          intern_cleanup();
          invalid_argument("input_value: non-standard floats");
        }
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(Double_wosize, Double_tag, intern_color);
        intern_dest += 1 + Double_wosize;
        readblock((char *) v, 8);
        if (code != CODE_DOUBLE_NATIVE) Reverse_double(v);
        break;
      case CODE_DOUBLE_ARRAY8_LITTLE:
      case CODE_DOUBLE_ARRAY8_BIG:
        len = read8u();
      read_double_array:
#ifdef NATIVE_CODE
        if (sizeof(double) != 8) {
          intern_cleanup();
          invalid_argument("input_value: non-standard floats");
        }
        size = len * Double_wosize;
        v = Val_hp(intern_dest);
        if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v;
        *intern_dest = Make_header(size, Double_array_tag, intern_color);
        intern_dest += 1 + size;
        readblock((char *) v, len * 8);
        if (code != CODE_DOUBLE_ARRAY8_NATIVE && 
            code != CODE_DOUBLE_ARRAY32_NATIVE) {
          mlsize_t i;
          for (i = 0; i < len; i++) Reverse_double((value)((double *)v + i));
        }
#else
        intern_cleanup();
        failwith("input_value: cannot read float array");
#endif
        break;
      case CODE_DOUBLE_ARRAY32_LITTLE:
      case CODE_DOUBLE_ARRAY32_BIG:
        len = read32u();
        goto read_double_array;
      case CODE_CODEPOINTER:
        ofs = read32u();
        readblock(cksum, 16);
        if (memcmp(cksum, code_checksum(), 16) != 0) {
          intern_cleanup();
          failwith("input_value: code mismatch");
        }
        v = (value) (code_area_start + ofs);
        break;
      case CODE_INFIXPOINTER:
        ofs = read32u();
        intern_rec(&clos);
        v = clos + ofs;
        break;
      default:
        intern_cleanup();
        failwith("input_value: ill-formed message");
      }
    }
  }
  *dest = v;
}

<<function intern_alloc>>

<<function input_val>>

value input_value(value vchan)        /* ML */
{
  struct channel * chan = Channel(vchan);
  value res = Val_unit;

  Begin_root(res)
    Lock(chan);
    res = input_val(chan);
    Unlock(chan);
  End_roots();
  return res;
}

<<function input_val_from_string>>

<<function input_value_from_string>>

<<function marshal_data_size>>

/* Return an MD5 checksum of the code area */

#ifdef NATIVE_CODE

#include "md5.h"

<<function code_checksum>>

#else

#include "fix_code.h"

<<function code_checksum (byterun/intern.c)>>

#endif
@


\subsection*{[[byterun/ints.c]]}

<<function int_of_string>>=
value int_of_string(value s)          /* ML */
{
  long res;
  int sign;
  int base;
  char * p;
  int c, d;

  p = String_val(s);
  if (*p == 0) failwith("int_of_string");
  sign = 1;
  if (*p == '-') {
    sign = -1;
    p++;
  }
  base = 10;
  if (*p == '0') {
    switch (p[1]) {
    case 'x': case 'X':
      base = 16; p += 2; break;
    case 'o': case 'O':
      base = 8; p += 2; break;
    case 'b': case 'B':
      base = 2; p += 2; break;
    }
  }
  res = 0;
  while (1) {
    c = *p;
    if (c >= '0' && c <= '9')
      d = c - '0';
    else if (c >= 'A' && c <= 'F')
      d = c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
      d = c - 'a' + 10;
    else
      break;
    if (d >= base) break;
    res = base * res + d;
    p++;
  }
  if (*p != 0)
    failwith("int_of_string");
  return Val_long(sign < 0 ? -res : res);
}
@

<<function format_int>>=
value format_int(value fmt, value arg)      /* ML */
{
  char format_string[32], format_buffer[32];
  int prec;
  char * p;
  char * dest;
  mlsize_t len;
  value res;

  prec = 32;
  for (p = String_val(fmt); *p != 0; p++) {
    if (*p >= '0' && *p <= '9') {
      prec = atoi(p) + 5;
      break;
    }
  }
  if (prec <= sizeof(format_buffer)) {
    dest = format_buffer;
  } else {
    dest = stat_alloc(prec);
  }
  len = string_length(fmt);
  if (len >= sizeof(format_string) - 1)
    invalid_argument("format_int: format too long");
  bcopy(String_val(fmt), format_string, len);
  format_string[len + 1] = 0;
  format_string[len] = format_string[len - 1];
  format_string[len - 1] = 'l';
  sprintf(dest, format_string, Long_val(arg));
  res = copy_string(dest);
  if (dest != format_buffer) {
    stat_free(dest);
  }
  return res;
}
@


%-------------------------------------------------------------

<<byterun/ints.c>>=
<<copyright header C xavier>>

#include <stdio.h>
#include <string.h>
#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "str.h"

<<function int_of_string>>

<<function format_int>>
@


\subsection*{[[byterun/floats.c]]}

<<function Double_val>>=
double Double_val(value val)
{
  union { value v[2]; double d; } buffer;

  Assert(sizeof(double) == 2 * sizeof(value));
  buffer.v[0] = Field(val, 0);
  buffer.v[1] = Field(val, 1);
  return buffer.d;
}
@

<<function Store_double_val>>=
void Store_double_val(value val, double dbl)
{
  union { value v[2]; double d; } buffer;

  Assert(sizeof(double) == 2 * sizeof(value));
  buffer.d = dbl;
  Field(val, 0) = buffer.v[0];
  Field(val, 1) = buffer.v[1];
}
@

<<function copy_double>>=
value copy_double(double d)
{
  value res;

#define Setup_for_gc
#define Restore_after_gc
  Alloc_small(res, Double_wosize, Double_tag);
#undef Setup_for_gc
#undef Restore_after_gc
  Store_double_val(res, d);
  return res;
}
@

<<function format_float>>=
value format_float(value fmt, value arg)    /* ML */
{
#define MAX_DIGITS 350
/* Max number of decimal digits in a "natural" (not artificially padded)
   representation of a float. Can be quite big for %f format.
   Max exponent for IEEE format is 308 decimal digits.
   Rounded up for good measure. */
  char format_buffer[MAX_DIGITS + 20];
  int prec, i;
  char * p;
  char * dest;
  value res;

  prec = MAX_DIGITS;
  for (p = String_val(fmt); *p != 0; p++) {
    if (*p >= '0' && *p <= '9') {
      i = atoi(p) + MAX_DIGITS;
      if (i > prec) prec = i;
      break;
    }
  }
  for( ; *p != 0; p++) {
    if (*p == '.') {
      i = atoi(p+1) + MAX_DIGITS;
      if (i > prec) prec = i;
      break;
    }
  }
  if (prec <= sizeof(format_buffer)) {
    dest = format_buffer;
  } else {
    dest = stat_alloc(prec);
  }
  sprintf(dest, String_val(fmt), Double_val(arg));
  res = copy_string(dest);
  if (dest != format_buffer) {
    stat_free(dest);
  }
  return res;
}
@

<<function float_of_string>>=
value float_of_string(value s)        /* ML */
{
  return copy_double(atof(String_val(s)));
}
@

<<function int_of_float>>=
value int_of_float(value f)           /* ML */
{
  return Val_long((long) Double_val(f));
}
@

<<function float_of_int>>=
value float_of_int(value n)           /* ML */
{
  return copy_double((double) Long_val(n));
}
@

<<function neg_float>>=
value neg_float(value f)              /* ML */
{
  return copy_double(- Double_val(f));
}
@

<<function abs_float>>=
value abs_float(value f)              /* ML */
{
  return copy_double(fabs(Double_val(f)));
}
@

<<function add_float>>=
value add_float(value f, value g)         /* ML */
{
  return copy_double(Double_val(f) + Double_val(g));
}
@

<<function sub_float>>=
value sub_float(value f, value g)         /* ML */
{
  return copy_double(Double_val(f) - Double_val(g));
}
@

<<function mul_float>>=
value mul_float(value f, value g)         /* ML */
{
  return copy_double(Double_val(f) * Double_val(g));
}
@

<<function div_float>>=
value div_float(value f, value g)         /* ML */
{
  double dg = Double_val(g);
  return copy_double(Double_val(f) / dg);
}
@

<<function exp_float>>=
value exp_float(value f)              /* ML */
{
  return copy_double(exp(Double_val(f)));
}
@

<<function floor_float>>=
value floor_float(value f)              /* ML */
{
  return copy_double(floor(Double_val(f)));
}
@

<<function fmod_float>>=
value fmod_float(value f1, value f2)              /* ML */
{
  return copy_double(fmod(Double_val(f1), Double_val(f2)));
}
@

<<function frexp_float>>=
value frexp_float(value f)              /* ML */
{
  int exponent;
  value res;
  value mantissa = copy_double(frexp (Double_val(f), &exponent));

  Begin_root(mantissa);
    res = alloc_tuple(2);
    Field(res, 0) = mantissa;
    Field(res, 1) = Val_int(exponent);
  End_roots();
  return res;
}
@

<<function ldexp_float>>=
value ldexp_float(value f, value i)              /* ML */
{
  return copy_double(ldexp(Double_val(f), Int_val(i)));
}
@

<<function log_float>>=
value log_float(value f)              /* ML */
{
  return copy_double(log(Double_val(f)));
}
@

<<function log10_float>>=
value log10_float(value f)              /* ML */
{
  return copy_double(log10(Double_val(f)));
}
@

<<function modf_float>>=
value modf_float(value f)              /* ML */
{
  double frem;
  value res;
  value quo = Val_unit, rem = Val_unit;

  Begin_roots2(quo,rem);
    quo = copy_double(modf (Double_val(f), &frem));
    rem = copy_double(frem);
    res = alloc_tuple(2);
    Field(res, 0) = quo;
    Field(res, 1) = rem;
  End_roots();
  return res;
}
@

<<function sqrt_float>>=
value sqrt_float(value f)             /* ML */
{
  return copy_double(sqrt(Double_val(f)));
}
@

<<function power_float>>=
value power_float(value f, value g)         /* ML */
{
  return copy_double(pow(Double_val(f), Double_val(g)));
}
@

<<function sin_float>>=
value sin_float(value f)              /* ML */
{
  return copy_double(sin(Double_val(f)));
}
@

<<function sinh_float>>=
value sinh_float(value f)              /* ML */
{
  return copy_double(sinh(Double_val(f)));
}
@

<<function cos_float>>=
value cos_float(value f)              /* ML */
{
  return copy_double(cos(Double_val(f)));
}
@

<<function cosh_float>>=
value cosh_float(value f)              /* ML */
{
  return copy_double(cosh(Double_val(f)));
}
@

<<function tan_float>>=
value tan_float(value f)              /* ML */
{
  return copy_double(tan(Double_val(f)));
}
@

<<function tanh_float>>=
value tanh_float(value f)              /* ML */
{
  return copy_double(tanh(Double_val(f)));
}
@

<<function asin_float>>=
value asin_float(value f)             /* ML */
{
  return copy_double(asin(Double_val(f)));
}
@

<<function acos_float>>=
value acos_float(value f)             /* ML */
{
  return copy_double(acos(Double_val(f)));
}
@

<<function atan_float>>=
value atan_float(value f)             /* ML */
{
  return copy_double(atan(Double_val(f)));
}
@

<<function atan2_float>>=
value atan2_float(value f, value g)        /* ML */
{
  return copy_double(atan2(Double_val(f), Double_val(g)));
}
@

<<function ceil_float>>=
value ceil_float(value f)              /* ML */
{
  return copy_double(ceil(Double_val(f)));
}
@

<<function eq_float>>=
value eq_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) == Double_val(g));
}
@

<<function neq_float>>=
value neq_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) != Double_val(g));
}
@

<<function le_float>>=
value le_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) <= Double_val(g));
}
@

<<function lt_float>>=
value lt_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) < Double_val(g));
}
@

<<function ge_float>>=
value ge_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) >= Double_val(g));
}
@

<<function gt_float>>=
value gt_float(value f, value g)        /* ML */
{
  return Val_bool(Double_val(f) > Double_val(g));
}
@

<<function init_ieee_floats>>=
void init_ieee_floats(void)
{
#ifdef __i386__
#ifdef __FreeBSD__
  fpsetmask(0);
#endif
#endif
}
@


%-------------------------------------------------------------

<<byterun/floats.c>>=
<<copyright header C xavier>>

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "mlvalues.h"
#include "misc.h"
#include "stacks.h"

#ifdef ARCH_ALIGN_DOUBLE

<<function Double_val>>

<<function Store_double_val>>

#endif

<<function copy_double>>

<<function format_float>>

<<function float_of_string>>

<<function int_of_float>>

<<function float_of_int>>

<<function neg_float>>

<<function abs_float>>

<<function add_float>>

<<function sub_float>>

<<function mul_float>>

<<function div_float>>

<<function exp_float>>

<<function floor_float>>

<<function fmod_float>>

<<function frexp_float>>

<<function ldexp_float>>

<<function log_float>>

<<function log10_float>>

<<function modf_float>>

<<function sqrt_float>>

<<function power_float>>

<<function sin_float>>

<<function sinh_float>>

<<function cos_float>>

<<function cosh_float>>

<<function tan_float>>

<<function tanh_float>>

<<function asin_float>>

<<function acos_float>>

<<function atan_float>>

<<function atan2_float>>

<<function ceil_float>>

<<function eq_float>>

<<function neq_float>>

<<function le_float>>

<<function lt_float>>

<<function ge_float>>

<<function gt_float>>

/* The init_ieee_float function should initialize floating-point hardware
   so that it behaves as much as possible like the IEEE standard.
   In particular, return special numbers like Infinity and NaN instead
   of signalling exceptions. So far, only the Intel 386 under
   FreeBSD is not in IEEE mode at program startup.  */

#ifdef __i386__
#ifdef __FreeBSD__
#include <floatingpoint.h>
#endif
#endif

<<function init_ieee_floats>>
@


\subsection*{[[byterun/io.h]]}

<<constant _io_>>=
#define _io_
@

<<constant IO_BUFFER_SIZE>>=
#define IO_BUFFER_SIZE 4096
@

<<struct channel>>=
struct channel {
  int fd;                       /* Unix file descriptor */
  long offset;                  /* Absolute position of fd in the file */
  char * end;                   /* Physical end of the buffer */
  char * curr;                  /* Current position in the buffer */
  char * max;                   /* Logical end of the buffer (for input) */
  void * mutex;                 /* Placeholder for mutex (for systhreads) */
  char buff[IO_BUFFER_SIZE];    /* The buffer itself */
};
@

<<function putch>>=
/* Functions and macros that can be called from C.  Take arguments of
   type struct channel *.  No locking is performed. */

#define putch(channel, ch)                                                  \
  { if ((channel)->curr >= (channel)->end) flush_partial(channel);          \
    *((channel)->curr)++ = (ch); }
@

<<function getch>>=
#define getch(channel)                                                      \
  ((channel)->curr >= (channel)->max                                        \
   ? refill(channel)                                                        \
   : (unsigned char) *((channel))->curr++)
@

<<function Channel>>=
/* Extract a struct channel * from the heap object representing it */

#define Channel(v) ((struct channel *) Field(v, 1))
@


%-------------------------------------------------------------

<<byterun/io.h>>=
<<copyright header C xavier>>

/* Buffered input/output */

#ifndef _io_
<<constant _io_>>


#include "misc.h"
#include "mlvalues.h"

#ifndef IO_BUFFER_SIZE
<<constant IO_BUFFER_SIZE>>
#endif

<<struct channel>>

/* For an output channel:
     [offset] is the absolute position of the beginning of the buffer [buff].
   For an input channel:
     [offset] is the absolute position of the logical end of the buffer, [max].
*/

<<function putch>>

<<function getch>>

struct channel * open_descriptor (int);
void close_channel (struct channel *);

int flush_partial (struct channel *);
void flush (struct channel *);
void putword (struct channel *, uint32);
int putblock (struct channel *, char *, long);
void really_putblock (struct channel *, char *, long);

unsigned char refill (struct channel *);
uint32 getword (struct channel *);
int getblock (struct channel *, char *, long);
int really_getblock (struct channel *, char *, long);

<<function Channel>>

/* The locking machinery */

extern void (*channel_mutex_free) (struct channel *);
extern void (*channel_mutex_lock) (struct channel *);
extern void (*channel_mutex_unlock) (struct channel *);
extern void (*channel_mutex_unlock_exn) (void);

#define Lock(channel) \
  if (channel_mutex_lock != NULL) (*channel_mutex_lock)(channel)
#define Unlock(channel) \
  if (channel_mutex_unlock != NULL) (*channel_mutex_unlock)(channel)
#define Unlock_exn() \
  if (channel_mutex_unlock_exn != NULL) (*channel_mutex_unlock_exn)()

#endif /* _io_ */
@


\subsection*{[[byterun/io.c]]}

<<constant INT_MAX>>=
#define INT_MAX 0x7FFFFFFF
@

<<constant SEEK_SET>>=
#define SEEK_SET 0
@

<<constant SEEK_CUR>>=
#define SEEK_CUR 1
@

<<constant SEEK_END>>=
#define SEEK_END 2
@

<<global channel_mutex_free>>=
/* Hooks for locking channels */

void (*channel_mutex_free) (struct channel *) = NULL;
@

<<global channel_mutex_lock>>=
void (*channel_mutex_lock) (struct channel *) = NULL;
@

<<global channel_mutex_unlock>>=
void (*channel_mutex_unlock) (struct channel *) = NULL;
@

<<global channel_mutex_unlock_exn>>=
void (*channel_mutex_unlock_exn) (void) = NULL;
@

<<function open_descriptor>>=
/* Basic functions over type struct channel *.
   These functions can be called directly from C.
   No locking is performed. */

struct channel * open_descriptor(int fd)
{
  struct channel * channel;

  channel = (struct channel *) stat_alloc(sizeof(struct channel));
  channel->fd = fd;
  channel->offset = 0;
  channel->curr = channel->max = channel->buff;
  channel->end = channel->buff + IO_BUFFER_SIZE;
  channel->mutex = NULL;
  return channel;
}
@

<<function close_channel>>=
void close_channel(struct channel *channel)
{
  close(channel->fd);
  if (channel_mutex_free != NULL) (*channel_mutex_free)(channel);
  stat_free(channel);
}  
@

<<function channel_size>>=
long channel_size(struct channel *channel)
{
  long end;

  end = lseek(channel->fd, 0, SEEK_END);
  if (end == -1 ||
      lseek(channel->fd, channel->offset, SEEK_SET) != channel->offset) {
    sys_error(NO_ARG);
  }
  return end;
}
@

<<constant EINTR>>=
#define EINTR (-1)
@

<<constant EAGAIN>>=
#define EAGAIN (-1)
@

<<constant EWOULDBLOCK>>=
#define EWOULDBLOCK (-1)
@

<<function do_write>>=
static int do_write(int fd, char *p, int n)
{
  int retcode;

  Assert(!Is_young(p));
#ifdef HAS_UI
  retcode = ui_write(fd, p, n);
#else
again:
  enter_blocking_section();
  retcode = write(fd, p, n);
  leave_blocking_section();
  if (retcode == -1) {
    if (errno == EINTR) goto again;
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
      /* We couldn't do a partial write here, probably because
         n <= PIPE_BUF and POSIX says that writes of less than
         PIPE_BUF characters must be atomic.
         So, we force a partial write of 1 character.
         This should always succeed if we've done a select
         on writing just before. */
      if (n > 1) { n = 1; goto again; }
    }
  }
#endif
  if (retcode == -1) sys_error(NO_ARG);
  return retcode;
}
@

<<function flush_partial>>=
/* Attempt to flush the buffer. This will make room in the buffer for
   at least one character. Returns true if the buffer is empty at the
   end of the flush, or false if some data remains in the buffer. */

int flush_partial(struct channel *channel)
{
  int towrite, written;

  Lock(channel);
  towrite = channel->curr - channel->buff;
  if (towrite > 0) {
    written = do_write(channel->fd, channel->buff, towrite);
    channel->offset += written;
    if (written < towrite)
      bcopy(channel->buff + written, channel->buff, towrite - written);
    channel->curr -= written;
  }
  Unlock(channel);
  return (channel->curr == channel->buff);
}
@

<<function flush>>=
/* Flush completely the buffer. */

void flush(struct channel *channel)
{
  while (! flush_partial(channel)) /*nothing*/;
}
@

<<function putword>>=
/* Output data */

void putword(struct channel *channel, uint32 w)
{
  putch(channel, w >> 24);
  putch(channel, w >> 16);
  putch(channel, w >> 8);
  putch(channel, w);
}
@

<<function putblock>>=
int putblock(struct channel *channel, char *p, long int len)
{
  int n, free, towrite, written;

  n = len >= INT_MAX ? INT_MAX : (int) len;
  free = channel->end - channel->curr;
  if (n <= free) {
    /* Write request small enough to fit in buffer: transfer to buffer. */
    bcopy(p, channel->curr, n);
    channel->curr += n;
    return n;
  } else {
    /* Write request overflows buffer: transfer whatever fits to buffer
       and write the buffer */
    bcopy(p, channel->curr, free);
    towrite = channel->end - channel->buff;
    written = do_write(channel->fd, channel->buff, towrite);
    if (written < towrite)
      bcopy(channel->buff + written, channel->buff, towrite - written);
    channel->offset += written;
    channel->curr = channel->end - written;
    channel->max = channel->end - written;
    return free;
  }
}
@

<<function really_putblock>>=
void really_putblock(struct channel *channel, char *p, long int len)
{
  int written;
  while (len > 0) {
    written = putblock(channel, p, len);
    p += written;
    len -= written;
  }
}
@

<<function seek_out>>=
void seek_out(struct channel *channel, long int dest)
{
  flush(channel);
  if (lseek(channel->fd, dest, 0) != dest) sys_error(NO_ARG);
  channel->offset = dest;
}
@

<<function pos_out>>=
long pos_out(struct channel *channel)
{
  return channel->offset + channel->curr - channel->buff;
}
@

<<function do_read>>=
/* Input */

static int do_read(int fd, char *p, unsigned int n)
{
  int retcode;

  Assert(!Is_young(p));
  enter_blocking_section();
#ifdef HAS_UI
  retcode = ui_read(fd, p, n);
#else
#ifdef EINTR
  do { retcode = read(fd, p, n); } while (retcode == -1 && errno == EINTR);
#else
  retcode = read(fd, p, n);
#endif
#endif
  leave_blocking_section();
  if (retcode == -1) sys_error(NO_ARG);
  return retcode;
}
@

<<function refill>>=
unsigned char refill(struct channel *channel)
{
  int n;

  n = do_read(channel->fd, channel->buff, IO_BUFFER_SIZE);
  if (n == 0) raise_end_of_file();
  channel->offset += n;
  channel->max = channel->buff + n;
  channel->curr = channel->buff + 1;
  return (unsigned char)(channel->buff[0]);
}
@

<<function getword>>=
uint32 getword(struct channel *channel)
{
  int i;
  uint32 res;

  res = 0;
  for(i = 0; i < 4; i++) {
    res = (res << 8) + getch(channel);
  }
  return res;
}
@

<<function getblock>>=
int getblock(struct channel *channel, char *p, long int len)
{
  int n, avail, nread;

  n = len >= INT_MAX ? INT_MAX : (int) len;
  avail = channel->max - channel->curr;
  if (n <= avail) {
    bcopy(channel->curr, p, n);
    channel->curr += n;
    return n;
  } else if (avail > 0) {
    bcopy(channel->curr, p, avail);
    channel->curr += avail;
    return avail;
  } else if (n < IO_BUFFER_SIZE) {
    nread = do_read(channel->fd, channel->buff, IO_BUFFER_SIZE);
    channel->offset += nread;
    channel->max = channel->buff + nread;
    if (n > nread) n = nread;
    bcopy(channel->buff, p, n);
    channel->curr = channel->buff + n;
    return n;
  } else {
    nread = do_read(channel->fd, p, n);
    channel->offset += nread;
    return nread;
  }
}
@

<<function really_getblock>>=
int really_getblock(struct channel *chan, char *p, long int n)
{
  int r;
  while (n > 0) {
    r = getblock(chan, p, n);
    if (r == 0) break;
    p += r;
    n -= r;
  }
  return (n == 0);
}
@

<<function seek_in>>=
void seek_in(struct channel *channel, long int dest)
{
  if (dest >= channel->offset - (channel->max - channel->buff) &&
      dest <= channel->offset) {
    channel->curr = channel->max - (channel->offset - dest);
  } else {
    if (lseek(channel->fd, dest, SEEK_SET) != dest) sys_error(NO_ARG);
    channel->offset = dest;
    channel->curr = channel->max = channel->buff;
  }
}
@

<<function pos_in>>=
long pos_in(struct channel *channel)
{
  return channel->offset - (channel->max - channel->curr);
}
@

<<function input_scan_line>>=
long input_scan_line(struct channel *channel)
{
  char * p;
  int n;

  p = channel->curr;
  do {
    if (p >= channel->max) {
      /* No more characters available in the buffer */
      if (channel->curr > channel->buff) {
        /* Try to make some room in the buffer by shifting the unread
           portion at the beginning */
        bcopy(channel->curr, channel->buff, channel->max - channel->curr);
        n = channel->curr - channel->buff;
        channel->curr -= n;
        channel->max -= n;
        p -= n;
      }
      if (channel->max >= channel->end) {
        /* Buffer is full, no room to read more characters from the input.
           Return the number of characters in the buffer, with negative
           sign to indicate that no newline was encountered. */
        return -(channel->max - channel->curr);
      }
      /* Fill the buffer as much as possible */
      n = do_read(channel->fd, channel->max, channel->end - channel->max);
      if (n == 0) {
        /* End-of-file encountered. Return the number of characters in the
           buffer, with negative sign since we haven't encountered 
           a newline. */
        return -(channel->max - channel->curr);
      }
      channel->offset += n;
      channel->max += n;
    }
  } while (*p++ != '\n');
  /* Found a newline. Return the length of the line, newline included. */
  return (p - channel->curr);
}
@

<<function finalize_channel>>=
/* Caml entry points for the I/O functions.  Wrap struct channel *
   objects into a heap-allocated, finalized object.  Perform locking
   and unlocking around the I/O operations. */

static void finalize_channel(value vchan)
{
  struct channel * chan = Channel(vchan);
  if (channel_mutex_free != NULL) (*channel_mutex_free)(chan);
  stat_free(chan);
}
@

<<function alloc_channel>>=
static value alloc_channel(struct channel *chan)
{
  value res = alloc_final(2, finalize_channel, 1, 32);
  Field(res, 1) = (value) chan;
  return res;
}
@

<<function caml_open_descriptor>>=
value caml_open_descriptor(value fd)       /* ML */
{
  return alloc_channel(open_descriptor(Int_val(fd)));
}
@

<<function channel_descriptor>>=
value channel_descriptor(value vchannel)   /* ML */
{
  return Val_long(Channel(vchannel)->fd);
}
@

<<function caml_close_channel>>=
value caml_close_channel(value vchannel)      /* ML */
{
  /* For output channels, must have flushed before */
  struct channel * channel = Channel(vchannel);
  close(channel->fd);
  channel->fd = -1;
  return Val_unit;
}
@

<<function caml_channel_size>>=
value caml_channel_size(value vchannel)      /* ML */
{
  return Val_long(channel_size(Channel(vchannel)));
}
@

<<function caml_flush_partial>>=
value caml_flush_partial(value vchannel)            /* ML */
{
  return Val_bool(flush_partial(Channel(vchannel)));
}
@

<<function caml_flush>>=
value caml_flush(value vchannel)            /* ML */
{
  flush(Channel(vchannel));
  return Val_unit;
}
@

<<function caml_output_char>>=
value caml_output_char(value vchannel, value ch)  /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  putch(channel, Long_val(ch));
  Unlock(channel);
  return Val_unit;
}
@

<<function caml_output_int>>=
value caml_output_int(value vchannel, value w)    /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  putword(channel, Long_val(w));
  Unlock(channel);
  return Val_unit;
}
@

<<function caml_seek_out>>=
value caml_seek_out(value vchannel, value pos)    /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  seek_out(channel, Long_val(pos));
  Unlock(channel);
  return Val_unit;
}
@

<<function caml_pos_out>>=
value caml_pos_out(value vchannel)          /* ML */
{
  return Val_long(pos_out(Channel(vchannel)));
}
@

<<function caml_input_char>>=
value caml_input_char(value vchannel)       /* ML */
{
  struct channel * channel = Channel(vchannel);
  unsigned char c;

  Lock(channel);
  c = getch(channel);
  Unlock(channel);
  return Val_long(c);
}
@

<<function caml_input_int>>=
value caml_input_int(value vchannel)        /* ML */
{
  struct channel * channel = Channel(vchannel);
  long i;

  Lock(channel);
  i = getword(channel);
  Unlock(channel);
#ifdef ARCH_SIXTYFOUR
  i = (i << 32) >> 32;          /* Force sign extension */
#endif
  return Val_long(i);
}
@

<<function caml_seek_in>>=
value caml_seek_in(value vchannel, value pos)     /* ML */
{
  struct channel * channel = Channel(vchannel);
  Lock(channel);
  seek_in(channel, Long_val(pos));
  Unlock(channel);
  return Val_unit;
}
@

<<function caml_pos_in>>=
value caml_pos_in(value vchannel)           /* ML */
{
  return Val_long(pos_in(Channel(vchannel)));
}
@

<<function caml_input_scan_line>>=
value caml_input_scan_line(value vchannel)       /* ML */
{
  struct channel * channel = Channel(vchannel);
  long res;

  Lock(channel);
  res = input_scan_line(channel);
  Unlock(channel);
  return Val_long(res);
}
@


%-------------------------------------------------------------

<<byterun/io.c>>=
<<copyright header C xavier>>

/* Buffered input/output. */

#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include "config.h"
#ifdef HAS_UNISTD
#include <unistd.h>
#endif
#ifdef __STDC__
#include <limits.h>
#endif
#include "alloc.h"
#include "fail.h"
#include "io.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "signals.h"
#include "sys.h"
#ifdef HAS_UI
#include "ui.h"
#endif

#ifndef INT_MAX
<<constant INT_MAX>>
#endif

#ifndef SEEK_SET
<<constant SEEK_SET>>
<<constant SEEK_CUR>>
<<constant SEEK_END>>
#endif

<<global channel_mutex_free>>
<<global channel_mutex_lock>>
<<global channel_mutex_unlock>>
<<global channel_mutex_unlock_exn>>

<<function open_descriptor>>

<<function close_channel>>

<<function channel_size>>

/* Output */

#ifndef EINTR
<<constant EINTR>>
#endif
#ifndef EAGAIN
<<constant EAGAIN>>
#endif
#ifndef EWOULDBLOCK
<<constant EWOULDBLOCK>>
#endif

<<function do_write>>

<<function flush_partial>>

<<function flush>>

<<function putword>>

<<function putblock>>

<<function really_putblock>>

<<function seek_out>>

<<function pos_out>>

<<function do_read>>

<<function refill>>

<<function getword>>

<<function getblock>>

<<function really_getblock>>

<<function seek_in>>

<<function pos_in>>

<<function input_scan_line>>

<<function finalize_channel>>

<<function alloc_channel>>

<<function caml_open_descriptor>>

<<function channel_descriptor>>

<<function caml_close_channel>>

<<function caml_channel_size>>

<<function caml_flush_partial>>

<<function caml_flush>>

<<function caml_output_char>>

<<function caml_output_int>>

value caml_output_partial(value vchannel, value buff, value start, value length) /* ML */
{
  struct channel * channel = Channel(vchannel);
  int res;
  Begin_root(buff)
    Lock(channel);
    res = putblock(channel, &Byte(buff, Long_val(start)), Long_val(length));
    Unlock(channel);
  End_roots();
  return Val_int(res);
}

value caml_output(value vchannel, value buff, value start, value length) /* ML */
{
  struct channel * channel = Channel(vchannel);
  long pos = Long_val(start);
  long len = Long_val(length);

  Begin_root(buff)
    Lock(channel);
      while (len > 0) {
        int written = putblock(channel, &Byte(buff, pos), len);
        pos += written;
        len -= written;
      }
    Unlock(channel);
  End_roots();
  return Val_unit;
}

<<function caml_seek_out>>

<<function caml_pos_out>>

<<function caml_input_char>>

<<function caml_input_int>>

value caml_input(value vchannel, value buff, value start, value length) /* ML */
{
  struct channel * channel = Channel(vchannel);
  long res;

  Begin_root(buff)
    Lock(channel);
    res = getblock(channel, &Byte(buff, Long_val(start)), Long_val(length));
    Unlock(channel);
  End_roots();
  return Val_long(res);
}

<<function caml_seek_in>>

<<function caml_pos_in>>

<<function caml_input_scan_line>>

@


\subsection*{[[byterun/lexing.c]]}

<<struct lexer_buffer>>=
struct lexer_buffer {
  value refill_buff;
  value lex_buffer;
  value lex_buffer_len;
  value lex_abs_pos;
  value lex_start_pos;
  value lex_curr_pos;
  value lex_last_pos;
  value lex_last_action;
  value lex_eof_reached;
};
@

<<struct lexing_table>>=
struct lexing_table {
  value lex_base;
  value lex_backtrk;
  value lex_default;
  value lex_trans;
  value lex_check;
};
@

<<function Short>>=
#define Short(tbl,n) \
  (*((unsigned char *)((tbl) + (n) * sizeof(short))) + \
          (*((schar *)((tbl) + (n) * sizeof(short) + 1)) << 8))
@

<<function Short (byterun/lexing.c)>>=
#define Short(tbl,n) (((short *)(tbl))[n])
@

<<function lex_engine>>=
value lex_engine(struct lexing_table *tbl, value start_state, struct lexer_buffer *lexbuf)     /* ML */
{
  int state, base, backtrk, c;

  state = Int_val(start_state);
  if (state >= 0) {
    /* First entry */
    lexbuf->lex_last_pos = lexbuf->lex_start_pos = lexbuf->lex_curr_pos;
    lexbuf->lex_last_action = Val_int(-1);
  } else {
    /* Reentry after refill */
    state = -state - 1;
  }
  while(1) {
    /* Lookup base address or action number for current state */
    base = Short(tbl->lex_base, state);
    if (base < 0) return Val_int(-base-1);
    /* See if it's a backtrack point */
    backtrk = Short(tbl->lex_backtrk, state);
    if (backtrk >= 0) {
      lexbuf->lex_last_pos = lexbuf->lex_curr_pos;
      lexbuf->lex_last_action = Val_int(backtrk);
    }
    /* See if we need a refill */
    if (lexbuf->lex_curr_pos >= lexbuf->lex_buffer_len){
      if (lexbuf->lex_eof_reached == Val_bool (0)){
        return Val_int(-state - 1);
      }else{
        c = 256;
      }
    }else{
      /* Read next input char */
      c = Byte_u(lexbuf->lex_buffer, Long_val(lexbuf->lex_curr_pos));
      lexbuf->lex_curr_pos += 2;
    }
    /* Determine next state */
    if (Short(tbl->lex_check, base + c) == state)
      state = Short(tbl->lex_trans, base + c);
    else
      state = Short(tbl->lex_default, state);
    /* If no transition on this char, return to last backtrack point */
    if (state < 0) {
      lexbuf->lex_curr_pos = lexbuf->lex_last_pos;
      if (lexbuf->lex_last_action == Val_int(-1)) {
        failwith("lexing: empty token");
      } else {
        return lexbuf->lex_last_action;
      }
    }else{
      /* Erase the EOF condition only if the EOF pseudo-character was
         consumed by the automaton (i.e. there was no backtrack above)
       */
      if (c == 256) lexbuf->lex_eof_reached = Val_bool (0);
    }
  }
}
@


%-------------------------------------------------------------

<<byterun/lexing.c>>=
<<copyright header C xavier>>

/* The table-driven automaton for lexers generated by camllex. */

#include "fail.h"
#include "mlvalues.h"
#include "stacks.h"
#include "str.h"

<<struct lexer_buffer>>

<<struct lexing_table>>

#ifdef ARCH_BIG_ENDIAN
<<function Short>>
#else
<<function Short (byterun/lexing.c)>>
#endif

<<function lex_engine>>

@


\subsection*{[[byterun/md5.h]]}

<<constant _md5>>=
#define _md5
@

<<struct MD5Context>>=
struct MD5Context {
        uint32 buf[4];
        uint32 bits[2];
        unsigned char in[64];
};
@


%-------------------------------------------------------------

<<byterun/md5.h>>=
/* MD5 message digest */

#ifndef _md5
<<constant _md5>>


#include "mlvalues.h"
#include "io.h"

value md5_string (value str, value ofs, value len);
value md5_chan (value vchan, value len);

<<struct MD5Context>>

void MD5Init (struct MD5Context *context);
void MD5Update (struct MD5Context *context, unsigned char *buf, unsigned len);
void MD5Final (unsigned char *digest, struct MD5Context *ctx);
void MD5Transform (uint32 *buf, uint32 *in);


#endif
@


\subsection*{[[byterun/md5.c]]}

<<function md5_string>>=
/* MD5 message digest */

value md5_string(value str, value ofs, value len) /* ML */
{
  struct MD5Context ctx;
  value res;
  MD5Init(&ctx);
  MD5Update(&ctx, &Byte_u(str, Long_val(ofs)), Long_val(len));
  res = alloc_string(16);
  MD5Final(&Byte_u(res, 0), &ctx);
  return res;
}
@

<<function md5_chan>>=
value md5_chan(value vchan, value len)       /* ML */
{
  struct channel * chan = Channel(vchan);
  struct MD5Context ctx;
  value res;
  long toread, read;
  char buffer[4096];

  Lock(chan);
  MD5Init(&ctx);
  toread = Long_val(len);
  while (toread > 0) {
    read = getblock(chan, buffer,
                    toread > sizeof(buffer) ? sizeof(buffer) : toread);
    if (read == 0) raise_end_of_file();
    MD5Update(&ctx, (unsigned char *) buffer, read);
    toread -= read;
  }
  res = alloc_string(16);
  MD5Final(&Byte_u(res, 0), &ctx);
  Unlock(chan);
  return res;
}
@

<<macro byteReverse>>=
#define byteReverse(buf, len)   /* Nothing */
@

<<function byteReverse>>=
static void byteReverse(unsigned char * buf, unsigned longs)
{
    uint32 t;
    do {
        t = (uint32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
            ((unsigned) buf[1] << 8 | buf[0]);
        *(uint32 *) buf = t;
        buf += 4;
    } while (--longs);
}
@

<<function MD5Init>>=
/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void MD5Init(struct MD5Context *ctx)
{
    ctx->buf[0] = 0x67452301;
    ctx->buf[1] = 0xefcdab89;
    ctx->buf[2] = 0x98badcfe;
    ctx->buf[3] = 0x10325476;

    ctx->bits[0] = 0;
    ctx->bits[1] = 0;
}
@

<<function MD5Update>>=
/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
void MD5Update(struct MD5Context *ctx, unsigned char *buf, unsigned int len)
{
    uint32 t;

    /* Update bitcount */

    t = ctx->bits[0];
    if ((ctx->bits[0] = t + ((uint32) len << 3)) < t)
        ctx->bits[1]++;         /* Carry from low to high */
    ctx->bits[1] += len >> 29;

    t = (t >> 3) & 0x3f;        /* Bytes already in shsInfo->data */

    /* Handle any leading odd-sized chunks */

    if (t) {
        unsigned char *p = (unsigned char *) ctx->in + t;

        t = 64 - t;
        if (len < t) {
            memcpy(p, buf, len);
            return;
        }
        memcpy(p, buf, t);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);
        buf += t;
        len -= t;
    }
    /* Process data in 64-byte chunks */

    while (len >= 64) {
        memcpy(ctx->in, buf, 64);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);
        buf += 64;
        len -= 64;
    }

    /* Handle any remaining bytes of data. */

    memcpy(ctx->in, buf, len);
}
@

<<function MD5Final>>=
/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern 
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void MD5Final(unsigned char *digest, struct MD5Context *ctx)
{
    unsigned count;
    unsigned char *p;

    /* Compute number of bytes mod 64 */
    count = (ctx->bits[0] >> 3) & 0x3F;

    /* Set the first char of padding to 0x80.  This is safe since there is
       always at least one byte free */
    p = ctx->in + count;
    *p++ = 0x80;

    /* Bytes of padding needed to make 64 bytes */
    count = 64 - 1 - count;

    /* Pad out to 56 mod 64 */
    if (count < 8) {
        /* Two lots of padding:  Pad the first block to 64 bytes */
        memset(p, 0, count);
        byteReverse(ctx->in, 16);
        MD5Transform(ctx->buf, (uint32 *) ctx->in);

        /* Now fill the next block with 56 bytes */
        memset(ctx->in, 0, 56);
    } else {
        /* Pad block to 56 bytes */
        memset(p, 0, count - 8);
    }
    byteReverse(ctx->in, 14);

    /* Append length in bits and transform */
    ((uint32 *) ctx->in)[14] = ctx->bits[0];
    ((uint32 *) ctx->in)[15] = ctx->bits[1];

    MD5Transform(ctx->buf, (uint32 *) ctx->in);
    byteReverse((unsigned char *) ctx->buf, 4);
    memcpy(digest, ctx->buf, 16);
    memset(ctx, 0, sizeof(*ctx));        /* In case it's sensitive */
}
@

<<function F1>>=
/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
@

<<function F2>>=
#define F2(x, y, z) F1(z, x, y)
@

<<function F3>>=
#define F3(x, y, z) (x ^ y ^ z)
@

<<function F4>>=
#define F4(x, y, z) (y ^ (x | ~z))
@

<<function MD5STEP>>=
/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f, w, x, y, z, data, s) \
        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
@

<<function MD5Transform>>=
/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
void MD5Transform(uint32 *buf, uint32 *in)
{
    register uint32 a, b, c, d;

    a = buf[0];
    b = buf[1];
    c = buf[2];
    d = buf[3];

    MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
    MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
    MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
    MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
    MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
    MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
    MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
    MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
    MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
    MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
    MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
    MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
    MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
    MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
    MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
    MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

    MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
    MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
    MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
    MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
    MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
    MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
    MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
    MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
    MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
    MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
    MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
    MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
    MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
    MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
    MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
    MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

    MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
    MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
    MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
    MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
    MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
    MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
    MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
    MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
    MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
    MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
    MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
    MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
    MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
    MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
    MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
    MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

    MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
    MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
    MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
    MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
    MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
    MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
    MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
    MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
    MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
    MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
    MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
    MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
    MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
    MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
    MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
    MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

    buf[0] += a;
    buf[1] += b;
    buf[2] += c;
    buf[3] += d;
}
@


%-------------------------------------------------------------

<<byterun/md5.c>>=
<<copyright header C xavier>>

#include <string.h>
#include "alloc.h"
#include "fail.h"
#include "md5.h"
#include "mlvalues.h"
#include "io.h"
#include "reverse.h"

<<function md5_string>>

<<function md5_chan>>

/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

#ifndef ARCH_BIG_ENDIAN
<<macro byteReverse>>
#else
<<function byteReverse>>
#endif

<<function MD5Init>>

<<function MD5Update>>

<<function MD5Final>>

/* The four core functions - F1 is optimized somewhat */

<<function F1>>
<<function F2>>
<<function F3>>
<<function F4>>

<<function MD5STEP>>

<<function MD5Transform>>

@


\subsection*{[[byterun/meta.c]]}

<<function get_global_data>>=
value get_global_data(value unit)     /* ML */
{
  return global_data;
}
@

<<function reify_bytecode>>=
value reify_bytecode(value prog, value len) /* ML */
{
  value clos;
#ifdef ARCH_BIG_ENDIAN
  fixup_endianness((code_t) prog, (asize_t) Long_val(len));
#endif
#ifdef THREADED_CODE
  thread_code((code_t) prog, (asize_t) Long_val(len));
#endif
  clos = alloc(1, Closure_tag);
  Code_val(clos) = (code_t) prog;
  return clos;
}
@

<<function realloc_global>>=
value realloc_global(value size)      /* ML */
{
  mlsize_t requested_size, actual_size, i;
  value new_global_data;

  requested_size = Long_val(size);
  actual_size = Wosize_val(global_data);
  if (requested_size >= actual_size) {
    requested_size = (requested_size + 0x100) & 0xFFFFFF00;
    gc_message ("Growing global data to %lu entries.\n", requested_size);
    new_global_data = alloc_shr(requested_size, 0);
    for (i = 0; i < actual_size; i++)
      initialize(&Field(new_global_data, i), Field(global_data, i));
    for (i = actual_size; i < requested_size; i++){
      Field (new_global_data, i) = Val_long (0);
    }
    global_data = new_global_data;
  }
  return Val_unit;
}
@

<<function available_primitives>>=
value available_primitives(value unit)    /* ML */
{
  return copy_string_array(names_of_cprim);
}
@

<<function get_current_environment>>=
value get_current_environment(value unit) /* ML */
{
  return *extern_sp;
}
@

<<function get_global_data (byterun/meta.c)>>=
/* Dummy definitions to support compilation of ocamlc.opt */

value get_global_data(value unit)
{
  invalid_argument("Meta.get_global_data");
}
@

<<function realloc_global (byterun/meta.c)>>=
value realloc_global(value size)
{
  invalid_argument("Meta.realloc_global");
}
@

<<function available_primitives (byterun/meta.c)>>=
value available_primitives(value unit)
{
  invalid_argument("Meta.available_primitives");
}
@


%-------------------------------------------------------------

<<byterun/meta.c>>=
<<copyright header C xavier>>

/* Primitives for the toplevel */

#include "alloc.h"
#include "config.h"
#include "fail.h"
#include "fix_code.h"
#include "interp.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"
#include "stacks.h"

#ifndef NATIVE_CODE

<<function get_global_data>>

<<function reify_bytecode>>

<<function realloc_global>>
    
<<function available_primitives>>

<<function get_current_environment>>

#else

<<function get_global_data (byterun/meta.c)>>

<<function realloc_global (byterun/meta.c)>>
    
<<function available_primitives (byterun/meta.c)>>

#endif
@


\subsection*{[[byterun/misc.h]]}

<<constant _misc_>>=
#define _misc_
@

<<constant NULL>>=
#define NULL 0
@

<<constant Noreturn>>=
/* Works only in GCC 2.5 and later */
#define Noreturn __attribute ((noreturn))
@

<<constant Noreturn (byterun/misc.h)>>=
#define Noreturn
@

<<constant __LINE__>>=
#define __LINE__ 0
@

<<constant __FILE__>>=
#define __FILE__ "(?)"
@

<<function Assert>>=
#define Assert(x)
@


%-------------------------------------------------------------

<<byterun/misc.h>>=
<<copyright header C xavier and damien>>

/* Miscellaneous macros and variables. */

#ifndef _misc_
<<constant _misc_>>


#include "config.h"

/* Standard definitions */

#ifdef __STDC__
#include <stddef.h>
#include <stdlib.h>
#endif

/* Basic types and constants */

#ifdef __STDC__
typedef size_t asize_t;
#else
typedef int asize_t;
#endif

#ifndef NULL
<<constant NULL>>
#endif

typedef char * addr;

#ifdef __GNUC__
<<constant Noreturn>>
#else
<<constant Noreturn (byterun/misc.h)>>
#endif

/* Assertions */

#ifdef DEBUG
#ifdef __STDC__
#define Assert(x) if (!(x)) failed_assert ( #x , __FILE__, __LINE__)
#else
#ifndef __LINE__
<<constant __LINE__>>
#endif
#ifndef __FILE__
<<constant __FILE__>>
#endif
#define Assert(x) if (!(x)) failed_assert ("(?)" , __FILE__, __LINE__)
#endif
#else
<<function Assert>>
#endif

void failed_assert (char *, char *, int) Noreturn;
void fatal_error (char *) Noreturn;
void fatal_error_arg (char *, char *) Noreturn;

/* GC flags and messages */

extern int verb_gc;
void gc_message (char *, unsigned long);

/* Memory routines */

void memmov (char *, char *, unsigned long);
char *aligned_malloc (asize_t, int, void **);

#ifdef DEBUG
unsigned long not_random (void);
#endif


#endif /* _misc_ */
@


\subsection*{[[byterun/misc.c]]}

<<function failed_assert>>=
void failed_assert (char * expr, char * file, int line)
{
  fprintf (stderr, "Assertion failed: %s; file %s; line %d\n",
           expr, file, line);
  exit (100);
}
@

<<global seed>>=
static unsigned long seed = 0x12345;
@

<<function not_random>>=
unsigned long not_random (void)
{
  seed = seed * 65537 + 12345;
  return seed;
}
@

<<global verb_gc>>=
int verb_gc;
@

<<function gc_message>>=
void gc_message (char *msg, long unsigned int arg)
{
  if (verb_gc){
#ifdef HAS_UI
    ui_print_stderr(msg, (void *) arg);
#else
    fprintf (stderr, msg, arg);
    fflush (stderr);
#endif
  }
}
@

<<function fatal_error>>=
void fatal_error (char *msg)
{
#ifdef HAS_UI
  ui_print_stderr("%s", msg);
  ui_exit (2);
#else
  fprintf (stderr, "%s", msg);
  exit(2);
#endif
}
@

<<function fatal_error_arg>>=
void fatal_error_arg (char *fmt, char *arg)
{
#ifdef HAS_UI
  ui_print_stderr(fmt, arg);
  ui_exit (2);
#else
  fprintf (stderr, fmt, arg);
  exit(2);
#endif
}
@

<<function memmov>>=
/* This should work on 64-bit machines as well as 32-bit machines.
   It assumes a long is the natural size for memory reads and writes.
*/
void memmov (char * dst, char * src, unsigned long length)
{
  unsigned long i;

  if ((unsigned long) dst <= (unsigned long) src){

      /* Copy in ascending order. */
    if (((unsigned long) src - (unsigned long) dst) % sizeof (long) != 0){

        /* The pointers are not equal modulo sizeof (long).
           Copy byte by byte. */
      for (; length != 0; length--){
        *dst++ = *src++;
      }
    }else{

        /* Copy the first few bytes. */
      i = (unsigned long) dst % sizeof (long);
      if (i != 0){
        i = sizeof (long) - i;              /* Number of bytes to copy. */
        if (i > length) i = length;         /* Never copy more than length.*/
        for (; i != 0; i--){
          *dst++ = *src++; --length;
        }
      }                    Assert ((unsigned long) dst % sizeof (long) == 0);
                           Assert ((unsigned long) src % sizeof (long) == 0);

      /* Then copy as many entire words as possible. */
      for (i = length / sizeof (long); i > 0; i--){
        *(long *) dst = *(long *) src;
        dst += sizeof (long); src += sizeof (long);
      }

      /* Then copy the last few bytes. */
      for (i = length % sizeof (long); i > 0; i--){
        *dst++ = *src++;
      }
    }
  }else{                                       /* Copy in descending order. */
    src += length; dst += length;
    if (((unsigned long) dst - (unsigned long) src) % sizeof (long) != 0){

        /* The pointers are not equal modulo sizeof (long).
           Copy byte by byte. */
      for (; length > 0; length--){
        *--dst = *--src;
      }
    }else{

        /* Copy the first few bytes. */
      i = (unsigned long) dst % sizeof (long);
      if (i > length) i = length;           /* Never copy more than length. */
      for (; i > 0; i--){
        *--dst = *--src; --length;
      }

        /* Then copy as many entire words as possible. */
      for (i = length / sizeof (long); i > 0; i--){
        dst -= sizeof (long); src -= sizeof (long);
        *(long *) dst = *(long *) src;
      }

        /* Then copy the last few bytes. */
      for (i = length % sizeof (long); i > 0; i--){
        *--dst = *--src;
      }
    }
  }
}
@

<<function aligned_malloc>>=
char *aligned_malloc (asize_t size, int modulo, void **block)
                  
                
                        /* output */
{
  char *raw_mem;
  unsigned long aligned_mem;
                                                 Assert (modulo < Page_size);
  raw_mem = (char *) malloc (size + Page_size);
  if (raw_mem == NULL) return NULL;
  *block = raw_mem;
  raw_mem += modulo;                /* Address to be aligned */
  aligned_mem = (((unsigned long) raw_mem / Page_size + 1) * Page_size);
  return (char *) (aligned_mem - modulo);
}
@


%-------------------------------------------------------------

<<byterun/misc.c>>=
<<copyright header C xavier and damien>>

#include <stdio.h>
#include "config.h"
#include "misc.h"
#ifdef HAS_UI
#include "ui.h"
#endif

#ifdef DEBUG

<<function failed_assert>>

<<global seed>>

<<function not_random>>

#endif

<<global verb_gc>>

<<function gc_message>>

<<function fatal_error>>

<<function fatal_error_arg>>

#ifdef USING_MEMMOV

<<function memmov>>

#endif /* USING_MEMMOV */

<<function aligned_malloc>>
@


\subsection*{[[byterun/obj.c]]}

<<function static_alloc>>=
value static_alloc(value size)        /* ML */
{
  return (value) stat_alloc((asize_t) Long_val(size));
}
@

<<function static_free>>=
value static_free(value blk)          /* ML */
{
  stat_free((void *) blk);
  return Val_unit;
}
@

<<function static_resize>>=
value static_resize(value blk, value new_size) /* ML */
{
  return (value) stat_resize((char *) blk, (asize_t) Long_val(new_size));
}
@

<<function obj_is_block>>=
value obj_is_block(value arg)             /* ML */
{
  return Val_bool(Is_block(arg));
}
@

<<function obj_tag>>=
value obj_tag(value arg)                 /* ML */
{
  return Val_int(Tag_val(arg));
}
@

<<function obj_block>>=
value obj_block(value tag, value size) /* ML */
{
  value res;
  mlsize_t sz, i;
  tag_t tg;

  sz = Long_val(size);
  tg = Long_val(tag);
  if (sz == 0) return Atom(tg);
  res = alloc(sz, tg);
  for (i = 0; i < sz; i++)
    Field(res, i) = Val_long(0);

  return res;
}
@


%-------------------------------------------------------------

<<byterun/obj.c>>=
<<copyright header C xavier>>

/* Operations on objects */

#include "alloc.h"
#include "major_gc.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"

<<function static_alloc>>

<<function static_free>>

<<function static_resize>>

<<function obj_is_block>>

<<function obj_tag>>

<<function obj_block>>

@


\subsection*{[[byterun/parsing.c]]}

<<constant ERRCODE>>=
#define ERRCODE 256
@

<<struct parser_tables>>=
struct parser_tables {    /* Mirrors parse_tables in ../stdlib/parsing.mli */
  value actions;
  value transl_const;
  value transl_block;
  char * lhs;
  char * len;
  char * defred;
  char * dgoto;
  char * sindex;
  char * rindex;
  char * gindex;
  value tablesize;
  char * table;
  char * check;
  value error_function;
};
@

<<struct parser_env>>=
struct parser_env {       /* Mirrors parser_env in ../stdlib/parsing.ml */
  value s_stack;
  value v_stack;
  value symb_start_stack;
  value symb_end_stack;
  value stacksize;
  value stackbase;
  value curr_char;
  value lval;
  value symb_start;
  value symb_end;
  value asp;
  value rule_len;
  value rule_number;
  value sp;
  value state;
  value errflag;
};
@

<<function Short (byterun/parsing.c)>>=
#define Short(tbl,n) \
  (*((unsigned char *)((tbl) + (n) * sizeof(short))) + \
          (*((schar *)((tbl) + (n) * sizeof(short) + 1)) << 8))
@

<<function Short (byterun/parsing.c)2>>=
#define Short(tbl,n) (((short *)(tbl))[n])
@

<<global parser_trace>>=
int parser_trace = 0;
@

<<function Trace>>=
#define Trace(act) if(parser_trace) act
@

<<function Trace (byterun/parsing.c)>>=
#define Trace(act)
@

<<constant START>>=
/* Mirrors parser_input in ../stdlib/parsing.ml */
#define START 0
@

<<constant TOKEN_READ>>=
#define TOKEN_READ 1
@

<<constant STACKS_GROWN_1>>=
#define STACKS_GROWN_1 2
@

<<constant STACKS_GROWN_2>>=
#define STACKS_GROWN_2 3
@

<<constant SEMANTIC_ACTION_COMPUTED>>=
#define SEMANTIC_ACTION_COMPUTED 4
@

<<constant ERROR_DETECTED>>=
#define ERROR_DETECTED 5
@

<<constant READ_TOKEN>>=
/* Mirrors parser_output in ../stdlib/parsing.ml */
#define READ_TOKEN Val_int(0) 
@

<<constant RAISE_PARSE_ERROR>>=
#define RAISE_PARSE_ERROR Val_int(1)
@

<<constant GROW_STACKS_1>>=
#define GROW_STACKS_1 Val_int(2)
@

<<constant GROW_STACKS_2>>=
#define GROW_STACKS_2 Val_int(3)
@

<<constant COMPUTE_SEMANTIC_ACTION>>=
#define COMPUTE_SEMANTIC_ACTION Val_int(4)
@

<<constant CALL_ERROR_FUNCTION>>=
#define CALL_ERROR_FUNCTION Val_int(5)
@

<<constant SAVE>>=
/* To preserve local variables when communicating with the ML code */

#define SAVE \
  env->sp = Val_int(sp), \
  env->state = Val_int(state), \
  env->errflag = Val_int(errflag)
@

<<constant RESTORE>>=
#define RESTORE \
  sp = Int_val(env->sp), \
  state = Int_val(env->state), \
  errflag = Int_val(env->errflag)
@

<<function parse_engine>>=
/* The pushdown automata */

value parse_engine(struct parser_tables *tables, struct parser_env *env, value cmd, value arg) /* ML */
{
  int state;
  mlsize_t sp, asp;
  int errflag;
  int n, n1, n2, m, state1;

  switch(Int_val(cmd)) {

  case START:
    state = 0;
    sp = Int_val(env->sp);
    errflag = 0;

  loop:
    Trace(printf("Loop %d\n", state));
    n = Short(tables->defred, state);
    if (n != 0) goto reduce;
    if (Int_val(env->curr_char) >= 0) goto testshift;
    SAVE;
    return READ_TOKEN;
                                /* The ML code calls the lexer and updates */
                                /* symb_start and symb_end */
  case TOKEN_READ:
    RESTORE;
    if (Is_block(arg)) {
      env->curr_char = Field(tables->transl_block, Tag_val(arg));
      modify(&env->lval, Field(arg, 0));
    } else {
      env->curr_char = Field(tables->transl_const, Int_val(arg));
      modify(&env->lval, Val_long(0));
    }
    Trace(printf("Token %d (0x%lx)\n", Int_val(env->curr_char), env->lval));
    
  testshift:
    n1 = Short(tables->sindex, state);
    n2 = n1 + Int_val(env->curr_char);
    if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
        Short(tables->check, n2) == Int_val(env->curr_char)) goto shift;
    n1 = Short(tables->rindex, state);
    n2 = n1 + Int_val(env->curr_char);
    if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
        Short(tables->check, n2) == Int_val(env->curr_char)) {
      n = Short(tables->table, n2);
      goto reduce;
    }
    if (errflag > 0) goto recover;
    SAVE;
    return CALL_ERROR_FUNCTION;
                                /* The ML code calls the error function */
  case ERROR_DETECTED:
    RESTORE;
  recover:
    if (errflag < 3) {
      errflag = 3;
      while (1) {
        state1 = Int_val(Field(env->s_stack, sp));
        n1 = Short(tables->sindex, state1);
        n2 = n1 + ERRCODE;
        if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
            Short(tables->check, n2) == ERRCODE) {
          Trace(printf("Recovering in state %d\n", state1));
          goto shift_recover;
        } else {
          Trace(printf("Discarding state %d\n", state1));
          if (sp <= Int_val(env->stackbase)) {
            Trace(printf("Fallen off bottom\n"));
            return RAISE_PARSE_ERROR; /* The ML code raises Parse_error */
          }
          sp--;
        }
      }
    } else {
      if (Int_val(env->curr_char) == 0)
        return RAISE_PARSE_ERROR; /* The ML code raises Parse_error */
      Trace(printf("Discarding token %d (0x%lx)\n",
                   Int_val(env->curr_char), env->lval));
      env->curr_char = Val_int(-1);
      goto loop;
    }
    
  shift:
    env->curr_char = Val_int(-1);
    if (errflag > 0) errflag--;
  shift_recover:
    state = Short(tables->table, n2);
    Trace(printf("Shift %d\n", state));
    sp++;
    if (sp < Long_val(env->stacksize)) goto push;
    SAVE;
    return GROW_STACKS_1;
                                 /* The ML code resizes the stacks */
  case STACKS_GROWN_1:
    RESTORE;
  push:
    Field(env->s_stack, sp) = Val_int(state);
    modify(&Field(env->v_stack, sp), env->lval);
    Field(env->symb_start_stack, sp) = env->symb_start;
    Field(env->symb_end_stack, sp) = env->symb_end;
    goto loop;

  reduce:
    Trace(printf("Reduce %d\n", n));
    m = Short(tables->len, n);
    env->asp = Val_int(sp);
    env->rule_number = Val_int(n);
    env->rule_len = Val_int(m);
    sp = sp - m + 1;
    m = Short(tables->lhs, n);
    state1 = Int_val(Field(env->s_stack, sp - 1));
    n1 = Short(tables->gindex, m);
    n2 = n1 + state1;
    if (n1 != 0 && n2 >= 0 && n2 <= Int_val(tables->tablesize) &&
        Short(tables->check, n2) == state1) {
      state = Short(tables->table, n2);
    } else {
      state = Short(tables->dgoto, m);
    }
    if (sp < Long_val(env->stacksize)) goto semantic_action;
    SAVE;
    return GROW_STACKS_2;
                                /* The ML code resizes the stacks */
  case STACKS_GROWN_2:
    RESTORE;
  semantic_action:
    SAVE;
    return COMPUTE_SEMANTIC_ACTION;
                                /* The ML code calls the semantic action */
  case SEMANTIC_ACTION_COMPUTED:
    RESTORE;
    Field(env->s_stack, sp) = Val_int(state);
    modify(&Field(env->v_stack, sp), arg);
    asp = Int_val(env->asp);
    Field(env->symb_end_stack, sp) = Field(env->symb_end_stack, asp);
    if (sp > asp) {
      /* This is an epsilon production. Take symb_start equal to symb_end. */
      Field(env->symb_start_stack, sp) = Field(env->symb_end_stack, asp);
    }
    goto loop;

  default:                      /* Should not happen */
    Assert(0);
    return RAISE_PARSE_ERROR;   /* Keeps gcc -Wall happy */
  }
  
}
@


%-------------------------------------------------------------

<<byterun/parsing.c>>=
<<copyright header C xavier>>

/* The PDA automaton for parsers generated by camlyacc */

#include <stdio.h>
#include "config.h"
#include "mlvalues.h"
#include "memory.h"
#include "alloc.h"

<<constant ERRCODE>>

<<struct parser_tables>>

<<struct parser_env>>

#ifdef ARCH_BIG_ENDIAN
<<function Short (byterun/parsing.c)>>
#else
<<function Short (byterun/parsing.c)2>>
#endif

#ifdef DEBUG
<<global parser_trace>>
<<function Trace>>
#else
<<function Trace (byterun/parsing.c)>>
#endif

/* Input codes */
<<constant START>>
<<constant TOKEN_READ>>
<<constant STACKS_GROWN_1>>
<<constant STACKS_GROWN_2>>
<<constant SEMANTIC_ACTION_COMPUTED>>
<<constant ERROR_DETECTED>>

/* Output codes */
<<constant READ_TOKEN>>
<<constant RAISE_PARSE_ERROR>>
<<constant GROW_STACKS_1>>
<<constant GROW_STACKS_2>>
<<constant COMPUTE_SEMANTIC_ACTION>>
<<constant CALL_ERROR_FUNCTION>>

<<constant SAVE>>

<<constant RESTORE>>

<<function parse_engine>>
@


\subsection*{[[byterun/printexc.c]]}

<<struct stringbuf>>=
struct stringbuf {
  char * ptr;
  char * end;
  char data[256];
};
@

<<function add_char>>=
static void add_char(struct stringbuf *buf, char c)
{
  if (buf->ptr < buf->end) *(buf->ptr++) = c;
}
@

<<function add_string>>=
static void add_string(struct stringbuf *buf, char *s)
{
  int len = strlen(s);
  if (buf->ptr + len > buf->end) len = buf->end - buf->ptr;
  if (len > 0) bcopy(s, buf->ptr, len);
  buf->ptr += len;
}
@

<<function errprintf>>=
#define errprintf(fmt,arg) ui_print_stderr(fmt, arg)
@

<<function errprintf (byterun/printexc.c)>>=
#define errprintf(fmt,arg) fprintf(stderr, fmt, arg)
@

<<function fatal_uncaught_exception>>=
void fatal_uncaught_exception(value exn)
{
  mlsize_t start, i;
  value bucket, v;
  struct stringbuf buf;
  char intbuf[64];

  buf.ptr = buf.data;
  buf.end = buf.data + sizeof(buf.data) - 1;
  add_string(&buf, String_val(Field(Field(exn, 0), 0)));
  if (Wosize_val(exn) >= 2) {
    /* Check for exceptions in the style of Match_failure and Assert_failure */
    if (Wosize_val(exn) == 2 &&
        Is_block(Field(exn, 1)) &&
        Tag_val(Field(exn, 1)) == 0) {
      bucket = Field(exn, 1);
      start = 0;
    } else {
      bucket = exn;
      start = 1;
    }
    add_char(&buf, '(');
    for (i = start; i < Wosize_val(bucket); i++) {
      if (i > start) add_string(&buf, ", ");
      v = Field(bucket, i);
      if (Is_long(v)) {
        sprintf(intbuf, "%ld", Long_val(v));
        add_string(&buf, intbuf);
      } else if (Tag_val(v) == String_tag) {
        add_char(&buf, '"');
        add_string(&buf, String_val(v));
        add_char(&buf, '"');
      } else {
        add_char(&buf, '_');
      }
    }
    add_char(&buf, ')');
  }
  *buf.ptr = 0;              /* Terminate string */
  errprintf("Fatal error: uncaught exception %s\n", buf.data);
#ifdef HAS_UI
  ui_exit(2);
#else
  exit(2);
#endif
}
@


%-------------------------------------------------------------

<<byterun/printexc.c>>=
<<copyright header C xavier>>

/* Print an uncaught exception and abort */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "fail.h"
#include "misc.h"
#include "mlvalues.h"
#ifdef HAS_UI
#include "ui.h"
#endif

<<struct stringbuf>>

<<function add_char>>

<<function add_string>>
  
#ifdef HAS_UI
<<function errprintf>>
#else
<<function errprintf (byterun/printexc.c)>>
#endif

<<function fatal_uncaught_exception>>
@


\subsection*{[[byterun/reverse.h]]}

<<constant _reverse_>>=
#define _reverse_
@

<<function Reverse_int32>>=
#define Reverse_int32(w) {                                                    \
  char * _p;                                                                  \
  int _a;                                                                     \
  _p = (char *) (w);                                                          \
  _a = _p[0];                                                                 \
  _p[0] = _p[3];                                                              \
  _p[3] = _a;                                                                 \
  _a = _p[1];                                                                 \
  _p[1] = _p[2];                                                              \
  _p[2] = _a;                                                                 \
}
@

<<function Reverse_int64>>=
#define Reverse_int64(d) {                                                    \
  char * _p;                                                                  \
  int _a;                                                                     \
  _p = (char *) (d);                                                          \
  _a = _p[0];                                                                 \
  _p[0] = _p[7];                                                              \
  _p[7] = _a;                                                                 \
  _a = _p[1];                                                                 \
  _p[1] = _p[6];                                                              \
  _p[6] = _a;                                                                 \
  _a = _p[2];                                                                 \
  _p[2] = _p[5];                                                              \
  _p[5] = _a;                                                                 \
  _a = _p[3];                                                                 \
  _p[3] = _p[4];                                                              \
  _p[4] = _a;                                                                 \
}
@

<<constant Reverse_double>>=
#define Reverse_double Reverse_int64
@


%-------------------------------------------------------------

<<byterun/reverse.h>>=
<<copyright header C xavier>>

/* Swap byte-order in 32-bit integers and in words */

#ifndef _reverse_
<<constant _reverse_>>

<<function Reverse_int32>>

<<function Reverse_int64>>

<<constant Reverse_double>>


#endif /* _reverse_ */
@


\subsection*{[[byterun/signals.h]]}

<<constant _signals_>>=
#define _signals_
@


%-------------------------------------------------------------

<<byterun/signals.h>>=
<<copyright header C xavier and damien>>

#ifndef _signals_
<<constant _signals_>>

#include "misc.h"
#include "mlvalues.h"

extern value signal_handlers;
extern volatile int pending_signal;
extern volatile int something_to_do;
extern volatile int force_major_slice;
extern volatile int async_signal_mode;

void enter_blocking_section (void);
void leave_blocking_section (void);
void urge_major_slice (void);

extern void (*enter_blocking_section_hook)();
extern void (*leave_blocking_section_hook)();

#endif /* _signals_ */

@


\subsection*{[[byterun/signals.c]]}

<<global async_signal_mode>>=
volatile int async_signal_mode = 0;
@

<<global pending_signal>>=
volatile int pending_signal = 0;
@

<<global something_to_do>>=
volatile int something_to_do = 0;
@

<<global force_major_slice>>=
volatile int force_major_slice = 0;
@

<<global signal_handlers>>=
value signal_handlers = 0;
@

<<global enter_blocking_section_hook>>=
void (*enter_blocking_section_hook)() = NULL;
@

<<global leave_blocking_section_hook>>=
void (*leave_blocking_section_hook)() = NULL;
@

<<function execute_signal>>=
static void execute_signal(int signal_number)
{
  Assert (!async_signal_mode);
  callback(Field(signal_handlers, signal_number), Val_int(signal_number));
}
@

<<function handle_signal>>=
void handle_signal(int signal_number)
{
#ifndef POSIX_SIGNALS
#ifndef BSD_SIGNALS
  signal(signal_number, handle_signal);
#endif
#endif
  if (async_signal_mode){
    leave_blocking_section ();
    execute_signal(signal_number);
    enter_blocking_section ();
  }else{
    pending_signal = signal_number;
    something_to_do = 1;
  }
}
@

<<function urge_major_slice>>=
void urge_major_slice (void)
{
  force_major_slice = 1;
  something_to_do = 1;
}
@

<<function enter_blocking_section>>=
void enter_blocking_section(void)
{
  int temp;

  while (1){
    Assert (!async_signal_mode);
    /* If a signal arrives between the next two instructions,
       it will be lost. */
    temp = pending_signal;   pending_signal = 0;
    if (temp) execute_signal(temp);
    async_signal_mode = 1;
    if (!pending_signal) break;
    async_signal_mode = 0;
  }
  if (enter_blocking_section_hook != NULL) enter_blocking_section_hook();
}
@

<<function leave_blocking_section>>=
void leave_blocking_section(void)
{
  if (leave_blocking_section_hook != NULL) leave_blocking_section_hook();
  Assert(async_signal_mode);
  async_signal_mode = 0;
}
@

<<constant SIGABRT>>=
#define SIGABRT -1
@

<<constant SIGALRM>>=
#define SIGALRM -1
@

<<constant SIGFPE>>=
#define SIGFPE -1
@

<<constant SIGHUP>>=
#define SIGHUP -1
@

<<constant SIGILL>>=
#define SIGILL -1
@

<<constant SIGINT>>=
#define SIGINT -1
@

<<constant SIGKILL>>=
#define SIGKILL -1
@

<<constant SIGPIPE>>=
#define SIGPIPE -1
@

<<constant SIGQUIT>>=
#define SIGQUIT -1
@

<<constant SIGSEGV>>=
#define SIGSEGV -1
@

<<constant SIGTERM>>=
#define SIGTERM -1
@

<<constant SIGUSR1>>=
#define SIGUSR1 -1
@

<<constant SIGUSR2>>=
#define SIGUSR2 -1
@

<<constant SIGCHLD>>=
#define SIGCHLD -1
@

<<constant SIGCONT>>=
#define SIGCONT -1
@

<<constant SIGSTOP>>=
#define SIGSTOP -1
@

<<constant SIGTSTP>>=
#define SIGTSTP -1
@

<<constant SIGTTIN>>=
#define SIGTTIN -1
@

<<constant SIGTTOU>>=
#define SIGTTOU -1
@

<<constant SIGVTALRM>>=
#define SIGVTALRM -1
@

<<constant SIGPROF>>=
#define SIGPROF -1
@

<<global posix_signals>>=
int posix_signals[] = {
  SIGABRT, SIGALRM, SIGFPE, SIGHUP, SIGILL, SIGINT, SIGKILL, SIGPIPE,
  SIGQUIT, SIGSEGV, SIGTERM, SIGUSR1, SIGUSR2, SIGCHLD, SIGCONT,
  SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGVTALRM, SIGPROF
};
@

<<constant NSIG>>=
#define NSIG 32
@

<<function install_signal_handler>>=
value install_signal_handler(value signal_number, value action) /* ML */
{
  int sig;
  void (*act)(int signo);
#ifdef POSIX_SIGNALS
  struct sigaction sigact;
#endif

  sig = Int_val(signal_number);
  if (sig < 0) sig = posix_signals[-sig-1];
  if (sig < 0 || sig >= NSIG) 
    invalid_argument("Sys.signal: unavailable signal");
  switch(action) {
  case Val_int(0):              /* Signal_default */
    act = SIG_DFL;
    break;
  case Val_int(1):              /* Signal_ignore */
    act = SIG_IGN;
    break;
  default:                      /* Signal_handle */
    if (signal_handlers == 0) {
      int i;
      Begin_root(action);
        signal_handlers = alloc_tuple(NSIG);
      End_roots();
      for (i = 0; i < NSIG; i++) Field(signal_handlers, i) = Val_int(0);
      register_global_root(&signal_handlers);
    }
    modify(&Field(signal_handlers, sig), Field(action, 0));
    act = handle_signal;
    break;
  }
#ifdef POSIX_SIGNALS
  sigact.sa_handler = act;
  sigemptyset(&sigact.sa_mask);
  sigact.sa_flags = 0;
  sigaction(sig, &sigact, NULL);
#else
  signal(sig, act);
#endif
  return Val_unit;
}
@


%-------------------------------------------------------------

<<byterun/signals.c>>=
<<copyright header C xavier and damien>>

#include <signal.h>
#include "alloc.h"
#include "callback.h"
#include "config.h"
#include "fail.h"
#include "memory.h"
#include "misc.h"
#include "mlvalues.h"
#include "roots.h"
#include "signals.h"

<<global async_signal_mode>>
<<global pending_signal>>
<<global something_to_do>>
<<global force_major_slice>>
<<global signal_handlers>>
<<global enter_blocking_section_hook>>
<<global leave_blocking_section_hook>>

<<function execute_signal>>

<<function handle_signal>>

<<function urge_major_slice>>

<<function enter_blocking_section>>

<<function leave_blocking_section>>

#ifndef SIGABRT
<<constant SIGABRT>>
#endif
#ifndef SIGALRM
<<constant SIGALRM>>
#endif
#ifndef SIGFPE
<<constant SIGFPE>>
#endif
#ifndef SIGHUP
<<constant SIGHUP>>
#endif
#ifndef SIGILL
<<constant SIGILL>>
#endif
#ifndef SIGINT
<<constant SIGINT>>
#endif
#ifndef SIGKILL
<<constant SIGKILL>>
#endif
#ifndef SIGPIPE
<<constant SIGPIPE>>
#endif
#ifndef SIGQUIT
<<constant SIGQUIT>>
#endif
#ifndef SIGSEGV
<<constant SIGSEGV>>
#endif
#ifndef SIGTERM
<<constant SIGTERM>>
#endif
#ifndef SIGUSR1
<<constant SIGUSR1>>
#endif
#ifndef SIGUSR2
<<constant SIGUSR2>>
#endif
#ifndef SIGCHLD
<<constant SIGCHLD>>
#endif
#ifndef SIGCONT
<<constant SIGCONT>>
#endif
#ifndef SIGSTOP
<<constant SIGSTOP>>
#endif
#ifndef SIGTSTP
<<constant SIGTSTP>>
#endif
#ifndef SIGTTIN
<<constant SIGTTIN>>
#endif
#ifndef SIGTTOU
<<constant SIGTTOU>>
#endif
#ifndef SIGVTALRM
<<constant SIGVTALRM>>
#endif
#ifndef SIGPROF
<<constant SIGPROF>>
#endif

<<global posix_signals>>

#ifndef NSIG
<<constant NSIG>>
#endif

<<function install_signal_handler>>
@


\subsection*{[[byterun/str.h]]}

<<constant _str_>>=
#define _str_
@


%-------------------------------------------------------------

<<byterun/str.h>>=
<<copyright header C xavier>>

#ifndef _str_
<<constant _str_>>


#include "misc.h"
#include "mlvalues.h"

mlsize_t string_length (value);


#endif /* _str_ */
@


\subsection*{[[byterun/str.c]]}

<<function string_length>>=
mlsize_t string_length(value s)
{
  mlsize_t temp;
  temp = Bosize_val(s) - 1;
  Assert (Byte (s, temp - Byte (s, temp)) == 0);
  return temp - Byte (s, temp);
}
@

<<function ml_string_length>>=
value ml_string_length(value s)     /* ML */
{
  mlsize_t temp;
  temp = Bosize_val(s) - 1;
  Assert (Byte (s, temp - Byte (s, temp)) == 0);
  return Val_long(temp - Byte (s, temp));
}
@

<<function create_string>>=
value create_string(value len)        /* ML */
{
  mlsize_t size = Long_val(len);
  if (size > Bsize_wsize (Max_wosize) - 1) invalid_argument("String.create");
  return alloc_string(size);
}
@

<<function string_get>>=
value string_get(value str, value index)    /* ML */
{
  long idx = Long_val(index);
  if (idx < 0 || idx >= string_length(str)) invalid_argument("String.get");
  return Val_int(Byte_u(str, idx));
}
@

<<function string_set>>=
value string_set(value str, value index, value newval)    /* ML */
{
  long idx = Long_val(index);
  if (idx < 0 || idx >= string_length(str)) invalid_argument("String.set");
  Byte_u(str, idx) = Int_val(newval);
  return Val_unit;
}
@

<<function string_equal>>=
value string_equal(value s1, value s2)      /* ML */
{
  mlsize_t sz1 = Wosize_val(s1);
  mlsize_t sz2 = Wosize_val(s2);
  value * p1, * p2;
  if (sz1 != sz2) return Val_false;
  for(p1 = Op_val(s1), p2 = Op_val(s2); sz1 > 0; sz1--, p1++, p2++)
    if (*p1 != *p2) return Val_false;
  return Val_true;
}
@

<<function string_notequal>>=
value string_notequal(value s1, value s2)   /* ML */
{
  return Val_not(string_equal(s1, s2));
}
@

<<function blit_string>>=
value blit_string(value s1, value ofs1, value s2, value ofs2, value n)   /* ML */
{
  bcopy(&Byte(s1, Long_val(ofs1)), &Byte(s2, Long_val(ofs2)), Int_val(n));
  return Val_unit;
}
@

<<function fill_string>>=
value fill_string(value s, value offset, value len, value init) /* ML */
{
  register char * p;
  register mlsize_t n;
  register char c;

  c = Long_val(init);
  for(p = &Byte(s, Long_val(offset)), n = Long_val(len);
      n > 0; n--, p++)
    *p = c;
  return Val_unit;
}
@

<<global printable_chars_ascii>>=
static unsigned char printable_chars_ascii[] = /* 0x20-0x7E */
  "\000\000\000\000\377\377\377\377\377\377\377\377\377\377\377\177\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000";
@

<<global printable_chars_iso>>=
static unsigned char printable_chars_iso[] = /* 0x20-0x7E 0xA1-0xFF */
  "\000\000\000\000\377\377\377\377\377\377\377\377\377\377\377\177\000\000\000\000\376\377\377\377\377\377\377\377\377\377\377\377";
@

<<function is_printable>>=
value is_printable(value chr) /* ML */
{
  int c;
  unsigned char * printable_chars;

  static int iso_charset = -1;
  if (iso_charset == -1) {
    char * lc_ctype = (char *) getenv("LC_CTYPE");
    iso_charset = (lc_ctype != 0 && strcmp(lc_ctype, "iso_8859_1") == 0);
  }
  printable_chars = iso_charset ? printable_chars_iso : printable_chars_ascii;
  c = Int_val(chr);
  return Val_bool(printable_chars[c >> 3] & (1 << (c & 7)));
}
@

<<function bitvect_test>>=
value bitvect_test(value bv, value n)       /* ML */
{
  int pos = Int_val(n);
  return Val_int(Byte_u(bv, pos >> 3) & (1 << (pos & 7)));
}
@


%-------------------------------------------------------------

<<byterun/str.c>>=
<<copyright header C xavier>>

/* Operations on strings */

#include <string.h>
#include "alloc.h"
#include "fail.h"
#include "mlvalues.h"
#include "misc.h"

<<function string_length>>

<<function ml_string_length>>

<<function create_string>>

<<function string_get>>

<<function string_set>>

<<function string_equal>>

<<function string_notequal>>
  
<<function blit_string>>

<<function fill_string>>

<<global printable_chars_ascii>>
<<global printable_chars_iso>>

<<function is_printable>>

<<function bitvect_test>>

@


\subsection*{[[byterun/sys.h]]}

<<constant _sys_>>=
#define _sys_
@

<<constant NO_ARG>>=
#define NO_ARG Val_int(0)
@


%-------------------------------------------------------------

<<byterun/sys.h>>=
<<copyright header C xavier>>

#ifndef _sys_
<<constant _sys_>>

#include "misc.h"

<<constant NO_ARG>>
void sys_error (value);
void sys_init (char **);
value sys_exit (value);
char * searchpath (char * name);

#endif /* _sys_ */
@


\subsection*{[[byterun/sys.c]]}

<<function error_message>>=
char * error_message(void)
{
  return strerror(errno);
}
@

<<function sys_error>>=
void sys_error(value arg)
{
  char * err = error_message();
  value str;
  
  if (arg == NO_ARG) {
    str = copy_string(err);
  } else {
    int err_len = strlen(err);
    int arg_len = string_length(arg);
    Begin_root(arg);
      str = alloc_string(arg_len + 2 + err_len);
    End_roots();
    bcopy(String_val(arg), &Byte(str, 0), arg_len);
    bcopy(": ", &Byte(str, arg_len), 2);
    bcopy(err, &Byte(str, arg_len + 2), err_len);
  }
  raise_sys_error(str);
}
@

<<function sys_exit>>=
value sys_exit(value retcode)          /* ML */
{
#ifndef NATIVE_CODE
  debugger(PROGRAM_EXIT);
#endif
#ifdef HAS_UI
  ui_exit(Int_val(retcode));
#else
  exit(Int_val(retcode));
#endif
  return Val_unit;
}
@

<<constant O_BINARY>>=
#define O_BINARY 0
@

<<constant O_TEXT>>=
#define O_TEXT 0
@

<<constant O_NONBLOCK>>=
#define O_NONBLOCK O_NDELAY
@

<<constant O_NONBLOCK (byterun/sys.c)>>=
#define O_NONBLOCK 0
@

<<global sys_open_flags>>=
static int sys_open_flags[] = {
  O_RDONLY, O_WRONLY, O_APPEND, O_CREAT, O_TRUNC, O_EXCL,
  O_BINARY, O_TEXT, O_NONBLOCK
};
@

<<function sys_open>>=
value sys_open(value path, value flags, value perm) /* ML */
{
  int ret;
  ret = open(String_val(path), convert_flag_list(flags, sys_open_flags), 
             Int_val(perm));
  if (ret == -1) sys_error(path);
  return Val_long(ret);
}
@

<<function sys_close>>=
value sys_close(value fd)             /* ML */
{
  close(Int_val(fd));
  return Val_unit;
}
@

<<function sys_file_exists>>=
value sys_file_exists(value name)     /* ML */
{
  struct stat st;
  return Val_bool(stat(String_val(name), &st) == 0);
}
@

<<function sys_remove>>=
value sys_remove(value name)          /* ML */
{
  int ret;
  ret = unlink(String_val(name));
  if (ret != 0) sys_error(name);
  return Val_unit;
}
@

<<function sys_rename>>=
value sys_rename(value oldname, value newname) /* ML */
{
  if (rename(String_val(oldname), String_val(newname)) != 0)
    sys_error(oldname);
  return Val_unit;
}
@

<<function sys_chdir>>=
value sys_chdir(value dirname)        /* ML */
{
  if (chdir(String_val(dirname)) != 0) sys_error(dirname);
  return Val_unit;
}
@

<<function sys_getcwd>>=
value sys_getcwd(value unit)          /* ML */
{
  char buff[4096];
#ifdef HAS_GETCWD
  if (getcwd(buff, sizeof(buff)) == 0) sys_error(NO_ARG);
#else
  if (getwd(buff) == 0) sys_error(NO_ARG);
#endif /* HAS_GETCWD */
  return copy_string(buff);
}
@

<<function sys_getenv>>=
value sys_getenv(value var)           /* ML */
{
  char * res;

  res = getenv(String_val(var));
  if (res == 0) raise_not_found();
  return copy_string(res);
}
@

<<global main_argv>>=
static char ** main_argv;
@

<<function sys_get_argv>>=
value sys_get_argv(value unit)        /* ML */
{
  return copy_string_array(main_argv);
}
@

<<function sys_init>>=
void sys_init(char **argv)
{
  main_argv = argv;
}
@

<<function sys_system_command>>=
value sys_system_command(value command)   /* ML */
{
  int retcode = system(String_val(command));
  if (retcode == -1) sys_error(command);
  return Val_int(retcode);
}
@

<<function sys_get_config>>=
value sys_get_config(value unit)  /* ML */
{
  value result;
  value ostype;

  ostype = copy_string(OCAML_OS_TYPE);
  Begin_root(ostype);
    result = alloc_tuple(2);
    Field(result, 0) = ostype;
    Field(result, 1) = Val_long (8 * sizeof(value));
  End_roots ();
  return result;
}
@

<<function S_ISREG>>=
#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
@

<<function searchpath>>=
char * searchpath(char * name)
{
  char * fullname;
  char * path;
  char * p;
  char * q;
  struct stat st;

  for (p = name; *p != 0; p++) {
    if (*p == '/') return name;
  }
  path = getenv("PATH");
  if (path == NULL) return 0;
  fullname = stat_alloc(strlen(name) + strlen(path) + 2);
  while(1) {
    for (p = fullname; *path != 0 && *path != ':'; p++, path++) *p = *path;
    if (p != fullname) *p++ = '/';
    for (q = name; *q != 0; p++, q++) *p = *q;
    *p = 0;
    if (stat(fullname, &st) == 0 && S_ISREG(st.st_mode)) break;
    if (*path == 0) return 0;
    path++;
  }
  return fullname;
}
@


%-------------------------------------------------------------

<<byterun/sys.c>>=
<<copyright header C xavier>>

/* Basic system calls */

#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "config.h"
#ifdef HAS_UNISTD
#include <unistd.h>
#endif
#include "alloc.h"
#include "debugger.h"
#include "fail.h"
#include "instruct.h"
#include "mlvalues.h"
#include "signals.h"
#include "stacks.h"
#include "str.h"
#include "sys.h"
#ifdef HAS_UI
#include "ui.h"
#endif

extern int errno;

extern char * strerror(int);

<<function error_message>>

<<function sys_error>>

<<function sys_exit>>

#ifndef O_BINARY
<<constant O_BINARY>>
#endif
#ifndef O_TEXT
<<constant O_TEXT>>
#endif
#ifndef O_NONBLOCK
#ifdef O_NDELAY
<<constant O_NONBLOCK>>
#else
<<constant O_NONBLOCK (byterun/sys.c)>>
#endif
#endif

<<global sys_open_flags>>

<<function sys_open>>

<<function sys_close>>

<<function sys_file_exists>>

<<function sys_remove>>

<<function sys_rename>>

<<function sys_chdir>>

<<function sys_getcwd>>

<<function sys_getenv>>

<<global main_argv>>

<<function sys_get_argv>>

<<function sys_init>>

<<function sys_system_command>>

<<function sys_get_config>>

/* Search path function */


#ifndef S_ISREG
<<function S_ISREG>>
#endif

<<function searchpath>>
@


\subsection*{[[byterun/terminfo.c]]}

<<function terminfo_setup>>=
value terminfo_setup(value unit)      /* ML */
{
  static char buffer[1024];
  if (tgetent(buffer, getenv("TERM")) != 1) failwith("Terminfo.setupterm");
  return Val_unit;
}
@

<<function terminfo_getstr>>=
value terminfo_getstr(value capa)     /* ML */
{
  char buff[1024];
  char * p = buff;
  char * s = tgetstr(String_val(capa), &p);
  if (s == NULL) raise_not_found();
  return copy_string(s);
}
@

<<function terminfo_getnum>>=
value terminfo_getnum(value capa)     /* ML */
{
  int res = tgetnum(String_val(capa));
  if (res == -1) raise_not_found();
  return Val_int(res);
}
@

<<global terminfo_putc_channel>>=
static struct channel * terminfo_putc_channel;
@

<<function terminfo_putc>>=
static int terminfo_putc(int c)
{
  putch(terminfo_putc_channel, c);
  return c;
}
@

<<function terminfo_puts>>=
value terminfo_puts(value vchan, value str, value count) /* ML */
{
  terminfo_putc_channel = Channel(vchan);
  tputs(String_val(str), Int_val(count), terminfo_putc);
  return Val_unit;
}
@

<<function terminfo_setup (byterun/terminfo.c)>>=
value terminfo_setup(value unit)
{
  failwith("Terminfo.setupterm");
  return Val_unit;
}
@

<<function terminfo_getstr (byterun/terminfo.c)>>=
value terminfo_getstr(value capa)
{
  raise_not_found();
  return Val_unit;
}
@

<<function terminfo_getnum (byterun/terminfo.c)>>=
value terminfo_getnum(value capa)
{
  raise_not_found();
  return Val_unit;
}
@

<<function terminfo_puts (byterun/terminfo.c)>>=
value terminfo_puts(value vchan, value str, value count)
{
  invalid_argument("Terminfo.puts");
  return Val_unit;
}
@


%-------------------------------------------------------------

<<byterun/terminfo.c>>=
<<copyright header C xavier>>


/* Read and output terminal commands */

#include "config.h"
#include "alloc.h"
#include "fail.h"
#include "io.h"
#include "mlvalues.h"

#ifdef HAS_TERMCAP

extern int tgetent (char * buffer, char * name);
extern char * tgetstr (char * id, char ** area);
extern int tgetnum (char * id);
extern int tputs (char * str, int count, int (*outchar)(int c));

<<function terminfo_setup>>

<<function terminfo_getstr>>

<<function terminfo_getnum>>

<<global terminfo_putc_channel>>

<<function terminfo_putc>>

<<function terminfo_puts>>

#else

<<function terminfo_setup (byterun/terminfo.c)>>

<<function terminfo_getstr (byterun/terminfo.c)>>

<<function terminfo_getnum (byterun/terminfo.c)>>

<<function terminfo_puts (byterun/terminfo.c)>>

#endif
@


\subsection*{[[byterun/weak.h]]}


%-------------------------------------------------------------

<<byterun/weak.h>>=
<<copyright header C damien 1997>>


/* Operations on weak arrays */

#include "mlvalues.h"

extern value weak_list_head;
@


\subsection*{[[byterun/weak.c]]}

<<global weak_list_head>>=
value weak_list_head = 0;
@

<<function weak_create>>=
value weak_create (value len)        /* ML */
{
  mlsize_t size, i;
  value res;

  size = Long_val (len) + 1;
  if (size > Max_wosize) invalid_argument ("Weak.create");
  res = alloc_shr (size, Abstract_tag);
  for (i = 1; i < size; i++) Field (res, i) = 0;
  Field (res, 0) = weak_list_head;
  weak_list_head = res;
  return res;
}
@

<<constant None_val>>=
#define None_val 1
@

<<constant Some_tag>>=
#define Some_tag 0
@

<<function weak_set>>=
value weak_set (value ar, value n, value el)     /* ML */
{
  mlsize_t offset = Long_val (n) + 1;
                                                   Assert (Is_in_heap (ar));
  if (offset < 1 || offset >= Wosize_val (ar)) invalid_argument ("Weak.set");
  Field (ar, offset) = 0;
  if (el != None_val){                  Assert (Wosize_val (el) == 1);
    Modify (&Field (ar, offset), Field (el, 0));
  }
  return Val_unit;
}
@

<<constant Setup_for_gc (byterun/weak.c)>>=
#define Setup_for_gc
@

<<constant Restore_after_gc (byterun/weak.c)>>=
#define Restore_after_gc
@

<<function weak_get>>=
value weak_get (value ar, value n)        /* ML */
{
  mlsize_t offset = Long_val (n) + 1;
  value res;
  value elt;
                                                   Assert (Is_in_heap (ar));
  if (offset < 1 || offset >= Wosize_val (ar)) invalid_argument ("Weak.get");
  if (Field (ar, offset) == 0){
    res = None_val;
  }else{
    elt = Field (ar, offset);
    if (gc_phase == Phase_mark) darken (elt, NULL);
    Begin_root(elt);
      res = alloc (1, Some_tag);
    End_roots ();
    Field (res, 0) = elt;
  }
  return res;
}
@


%-------------------------------------------------------------

<<byterun/weak.c>>=
<<copyright header C damien 1997>>


/* Operations on weak arrays */

#include "alloc.h"
#include "fail.h"
#include "memory.h"
#include "mlvalues.h"

<<global weak_list_head>>

<<function weak_create>>

<<constant None_val>>
<<constant Some_tag>>

<<function weak_set>>

<<constant Setup_for_gc (byterun/weak.c)>>
<<constant Restore_after_gc (byterun/weak.c)>>

<<function weak_get>>

#undef Setup_for_gc
#undef Restore_after_gc
@


\subsection*{[[byterun/startup.c]]}

<<constant O_BINARY (byterun/startup.c)>>=
#define O_BINARY 0
@

<<constant SEEK_END (byterun/startup.c)>>=
#define SEEK_END 2
@

<<global atom_table>>=
header_t atom_table[256];
@

<<function init_atoms>>=
/* Initialize the atom table */

static void init_atoms(void)
{
  int i;
  for(i = 0; i < 256; i++) atom_table[i] = Make_header(0, i, White);
}
@

<<function read_size>>=
/* Read the trailer of a bytecode file */

static unsigned long read_size(char * ptr)
{
  unsigned char * p = (unsigned char *) ptr;
  return ((unsigned long) p[0] << 24) + ((unsigned long) p[1] << 16) +
         ((unsigned long) p[2] << 8) + p[3];
}
@

<<constant FILE_NOT_FOUND>>=
#define FILE_NOT_FOUND (-1)
@

<<constant TRUNCATED_FILE>>=
#define TRUNCATED_FILE (-2)
@

<<constant BAD_MAGIC_NUM>>=
#define BAD_MAGIC_NUM (-3)
@

<<function read_trailer>>=
static int read_trailer(int fd, struct exec_trailer *trail)
{
  char buffer[TRAILER_SIZE];

  lseek(fd, (long) -TRAILER_SIZE, SEEK_END);
  if (read(fd, buffer, TRAILER_SIZE) < TRAILER_SIZE) return TRUNCATED_FILE;
  trail->code_size = read_size(buffer);
  trail->prim_size = read_size(buffer + 4);
  trail->data_size = read_size(buffer + 8);
  trail->symbol_size = read_size(buffer + 12);
  trail->debug_size = read_size(buffer + 16);
  if (strncmp(buffer + 20, EXEC_MAGIC, 12) == 0)
    return 0;
  else
    return BAD_MAGIC_NUM;
}
@

<<function attempt_open>>=
static int attempt_open(char **name, struct exec_trailer *trail, int do_open_script)
{
  char * truename;
  int fd;
  int err;
  char buf [2];

  truename = searchpath(*name);
  if (truename == 0) truename = *name; else *name = truename;
  fd = open(truename, O_RDONLY | O_BINARY);
  if (fd == -1) return FILE_NOT_FOUND;
  if (!do_open_script){
    err = read (fd, buf, 2);
    if (err < 2) { close(fd); return TRUNCATED_FILE; }
    if (buf [0] == '#' && buf [1] == '!') { close(fd); return BAD_MAGIC_NUM; }
  }
  err = read_trailer(fd, trail);
  if (err != 0) { close(fd); return err; }
  return fd;
}
@

<<function check_primitives>>=
/* Check the primitives used by the bytecode file against the table of
   primitives linked in this interpreter */

static void check_primitives(int fd, int prim_size)
{
  char * prims = stat_alloc(prim_size);
  char * p;
  int idx;

  if (read(fd, prims, prim_size) != prim_size)
    fatal_error("Fatal error: cannot read primitive table\n");
  /* prims contains 0-terminated strings, concatenated. */
  for (p = prims, idx = 0;
       p < prims + prim_size;
       p = p + strlen(p) + 1, idx++) {
    if (names_of_cprim[idx] == NULL ||
        strcmp(p, names_of_cprim[idx]) != 0)
      fatal_error_arg("Fatal error: this bytecode file cannot run on this bytecode interpreter\nMismatch on primitive `%s'\n", p);
  }
  stat_free(prims);
}
@

<<global verbose_init>>=
/* Configuration parameters and flags */

static unsigned long verbose_init = 0;
@

<<global percent_free_init>>=
static unsigned long percent_free_init = Percent_free_def;
@

<<global max_percent_free_init>>=
static unsigned long max_percent_free_init = Max_percent_free_def;
@

<<global minor_heap_init>>=
static unsigned long minor_heap_init = Minor_heap_def;
@

<<global heap_chunk_init>>=
static unsigned long heap_chunk_init = Heap_chunk_def;
@

<<global heap_size_init>>=
static unsigned long heap_size_init = Init_heap_def;
@

<<global max_stack_init>>=
static unsigned long max_stack_init = Max_stack_def;
@

<<function parse_command_line>>=
/* Parse options on the command line */

static int parse_command_line(char **argv)
{
  int i;

  for(i = 1; argv[i] != NULL && argv[i][0] == '-'; i++) {
    switch(argv[i][1]) {
#ifdef DEBUG
    case 't':
      trace_flag = 1;
      break;
#endif
    case 'v':
      verbose_init = 1;
      break;
    default:
      fatal_error_arg("Unknown option %s.\n", argv[i]);
    }
  }
  return i;
}
@

<<function scanmult>>=
/* The option letter for each runtime option is the first letter of the
   last word of the ML name of the option (see [stdlib/gc.mli]).
   Except for l (maximum stack size) and h (initial heap size).
*/

static void scanmult (char *opt, long unsigned int *var)
{
  char mult = ' ';
  sscanf (opt, "=%lu%c", var, &mult);
  if (mult == 'k') *var = *var * 1024;
  if (mult == 'M') *var = *var * (1024 * 1024);
  if (mult == 'G') *var = *var * (1024 * 1024 * 1024);
}
@

<<function parse_camlrunparam>>=
static void parse_camlrunparam(void)
{
  char *opt = getenv ("CAMLRUNPARAM");
  if (opt != NULL){
    while (*opt != '\0'){
      switch (*opt++){
      case 's': scanmult (opt, &minor_heap_init); break;
      case 'i': scanmult (opt, &heap_chunk_init); break;
      case 'h': scanmult (opt, &heap_size_init); break;
      case 'l': scanmult (opt, &max_stack_init); break;
      case 'o': scanmult (opt, &percent_free_init); break;
      case 'O': scanmult (opt, &max_percent_free_init); break;
      case 'v': scanmult (opt, &verbose_init); break;
      }
    }
  }
}
@

<<function caml_main>>=
/* Main entry point when loading code from a file */

void caml_main(char **argv)
{
  int fd;
  struct exec_trailer trail;
  int pos;
  struct longjmp_buffer raise_buf;
  struct channel * chan;

  /* Machine-dependent initialization of the floating-point hardware
     so that it behaves as much as possible as specified in IEEE */
  init_ieee_floats();
  /* Set up a catch-all exception handler */
  if (sigsetjmp(raise_buf.buf, 1) == 0) {
    external_raise = &raise_buf;
    /* Determine options and position of bytecode file */
#ifdef DEBUG
    verbose_init = 1;
#endif
    parse_camlrunparam();
    pos = 0;
    fd = attempt_open(&argv[0], &trail, 0);
    if (fd < 0) {
      pos = parse_command_line(argv);
      if (argv[pos] == 0)
        fatal_error("No bytecode file specified.\n");
      fd = attempt_open(&argv[pos], &trail, 1);
      switch(fd) {
      case FILE_NOT_FOUND:
        fatal_error_arg("Fatal error: cannot find file %s\n", argv[pos]);
        break;
      case TRUNCATED_FILE:
      case BAD_MAGIC_NUM:
        fatal_error_arg(
          "Fatal error: the file %s is not a bytecode executable file\n",
          argv[pos]);
        break;
      }
    }
    /* Initialize the abstract machine */
    init_gc (minor_heap_init, heap_size_init, heap_chunk_init,
             percent_free_init, max_percent_free_init, verbose_init);
    init_stack (max_stack_init);
    init_atoms();
    /* Initialize the interpreter */
    interprete(NULL, 0);
    /* Initialize the debugger, if needed */
    debugger_init();
    /* Load the code */
    lseek(fd, - (long) (TRAILER_SIZE + trail.code_size + trail.prim_size
                        + trail.data_size + trail.symbol_size
                        + trail.debug_size), SEEK_END);
    load_code(fd, trail.code_size);
    /* Check the primitives */
    check_primitives(fd, trail.prim_size);
    /* Load the globals */
    chan = open_descriptor(fd);
    global_data = input_val(chan);
    close_channel(chan);
    /* Ensure that the globals are in the major heap. */
    oldify(global_data, &global_data);
    /* Record the command-line arguments */
    sys_init(argv + pos);
    /* Execute the program */
    debugger(PROGRAM_START);
    interprete(start_code, trail.code_size);
  } else {
    extern_sp = &exn_bucket; /* The debugger needs the exception value. */
    debugger(UNCAUGHT_EXC);
    fatal_uncaught_exception(exn_bucket);
  }
}
@

<<function caml_startup_code>>=
/* Main entry point when code is linked in as initialized data */

void caml_startup_code(code_t code, asize_t code_size, char *data, char **argv)
{
  struct longjmp_buffer raise_buf;

  init_ieee_floats();
#ifdef DEBUG
  verbose_init = 1;
#endif
  parse_camlrunparam();
  /* Set up a catch-all exception handler */
  if (sigsetjmp(raise_buf.buf, 1) == 0) {
    external_raise = &raise_buf;
    /* Initialize the abstract machine */
    init_gc (minor_heap_init, heap_size_init, heap_chunk_init,
             percent_free_init, max_percent_free_init, verbose_init);
    init_stack (max_stack_init);
    init_atoms();
    /* Initialize the interpreter */
    interprete(NULL, 0);
    /* Load the code */
    start_code = code;
#ifdef THREADED_CODE
    thread_code(start_code, code_size);
#endif
    /* Load the globals */
    global_data = input_val_from_string((value)data, 0);
    /* Ensure that the globals are in the major heap. */
    oldify(global_data, &global_data);
    /* Run the code */
    sys_init(argv);
    interprete(start_code, code_size);
  } else {
    fatal_uncaught_exception(exn_bucket);
  }
}
@


%-------------------------------------------------------------

<<byterun/startup.c>>=
<<copyright header C xavier and damien>>

/* Start-up code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include "config.h"
#ifdef HAS_UNISTD
#include <unistd.h>
#endif
#include "alloc.h"
#include "debugger.h"
#include "exec.h"
#include "fail.h"
#include "fix_code.h"
#include "gc_ctrl.h"
#include "interp.h"
#include "intext.h"
#include "io.h"
#include "memory.h"
#include "minor_gc.h"
#include "misc.h"
#include "mlvalues.h"
#include "prims.h"
#include "stacks.h"
#include "sys.h"

#ifndef O_BINARY
<<constant O_BINARY (byterun/startup.c)>>
#endif

#ifndef SEEK_END
<<constant SEEK_END (byterun/startup.c)>>
#endif

<<global atom_table>>

<<function init_atoms>>

<<function read_size>>

<<constant FILE_NOT_FOUND>>
<<constant TRUNCATED_FILE>>
<<constant BAD_MAGIC_NUM>>

<<function read_trailer>>

<<function attempt_open>>

<<function check_primitives>>

/* Invocation of camlrun: 4 cases.

   1.  runtime + bytecode
       user types:  camlrun [options] bytecode args...
       arguments:  camlrun [options] bytecode args...

   2.  bytecode script
       user types:  bytecode args...
   2a  (kernel 1) arguments:  camlrun ./bytecode args...
   2b  (kernel 2) arguments:  bytecode bytecode args...

   3.  concatenated runtime and bytecode
       user types:  composite args...
       arguments:  composite args...

Algorithm:
  1-  If argument 0 is a valid byte-code file that does not start with #!,
      then we are in case 3 and we pass the same command line to the
      Caml Light program.
  2-  In all other cases, we parse the command line as:
        (whatever) [options] bytecode args...
      and we strip "(whatever) [options]" from the command line.

*/

<<global verbose_init>>
<<global percent_free_init>>
<<global max_percent_free_init>>
<<global minor_heap_init>>
<<global heap_chunk_init>>
<<global heap_size_init>>
<<global max_stack_init>>
extern int trace_flag;

<<function parse_command_line>>

/* Parse the CAMLRUNPARAM variable */
<<function scanmult>>

<<function parse_camlrunparam>>

extern void init_ieee_floats (void);

<<function caml_main>>

<<function caml_startup_code>>
  
@


\subsection*{[[byterun/main.c]]}

<<function main>>=
int main(int argc, char **argv)
{
  caml_main(argv);
  sys_exit(Val_int(0));
  return 0; /* not reached */
}
@


%-------------------------------------------------------------

<<byterun/main.c>>=
<<copyright header C xavier and damien>>

/* Main entry point (can be overriden by a user-provided main()
   function that calls caml_main() later. */

#include "misc.h"
#include "mlvalues.h"
#include "sys.h"

extern void caml_main (char **);

<<function main>>
@


