\section{[[./utils/]]}

\subsection*{[[./utils/config.mli]]}

<<signature Config.version>>=
(* System configuration *)

val version: string
        (* The current version number of the system *)
@

<<signature Config.standard_library>>=
val standard_library: string
        (* The directory containing the standard libraries *)
@

<<signature Config.bytecomp_c_compiler>>=
val bytecomp_c_compiler: string
        (* The C compiler to use for the custom runtime mode of the
           bytecode compiler *)
@

<<signature Config.native_c_compiler>>=
val native_c_compiler: string
        (* The C compiler to use for the native code compiler *)
@

<<signature Config.native_partial_linker>>=
val native_partial_linker: string
        (* The linker to use for partial links (-output-obj option) *)
@

<<signature Config.c_libraries>>=
val c_libraries: string
        (* The C libraries to link with custom runtimes *)
@

<<signature Config.ranlib>>=
val ranlib: string
        (* Command to randomize a library, or "" if not needed *)
@

<<signature Config.load_path>>=
val load_path: string list ref
        (* Directories in the search path for .cmi and .cmo files *)
@

<<signature Config.exec_magic_number>>=
val exec_magic_number: string
        (* Magic number for bytecode executable files *)
@

<<signature Config.cmi_magic_number>>=
val cmi_magic_number: string
        (* Magic number for compiled interface files *)
@

<<signature Config.cmo_magic_number>>=
val cmo_magic_number: string
        (* Magic number for object bytecode files *)
@

<<signature Config.cma_magic_number>>=
val cma_magic_number: string
        (* Magic number for archive files *)
@

<<signature Config.cmx_magic_number>>=
val cmx_magic_number: string
        (* Magic number for compilation unit descriptions *)
@

<<signature Config.cmxa_magic_number>>=
val cmxa_magic_number: string
        (* Magic number for libraries of compilation unit descriptions *)
@

<<signature Config.ast_intf_magic_number>>=
val ast_intf_magic_number: string
        (* Magic number for file holding an interface syntax tree *)
@

<<signature Config.ast_impl_magic_number>>=
val ast_impl_magic_number: string
        (* Magic number for file holding an implementation syntax tree *)
@

<<signature Config.max_tag>>=
val max_tag: int
        (* Biggest tag that can be stored in the header of a block. *)
@

<<signature Config.max_young_wosize>>=
val max_young_wosize: int
        (* Maximal size of arrays that are directly allocated in the
           minor heap *)
@

<<signature Config.architecture>>=
val architecture: string
        (* Name of processor type for the native-code compiler *)
@

<<signature Config.model>>=
val model: string
        (* Name of processor submodel for the native-code compiler *)
@

<<signature Config.system>>=
val system: string
        (* Name of operating system for the native-code compiler *)
@

<<signature Config.ext_obj>>=
val ext_obj: string
        (* Extension for object files, e.g. [.o] under Unix. *)
@

<<signature Config.ext_asm>>=
val ext_asm: string
        (* Extension for assembler files, e.g. [.s] under Unix. *)
@

<<signature Config.ext_lib>>=
val ext_lib: string
        (* Extension for library files, e.g. [.a] under Unix. *)
@


%-------------------------------------------------------------

<<./utils/config.mli>>=

<<copyright header>>

<<signature Config.version>>

<<signature Config.standard_library>>
<<signature Config.bytecomp_c_compiler>>
<<signature Config.native_c_compiler>>
<<signature Config.native_partial_linker>>
<<signature Config.c_libraries>>
<<signature Config.ranlib>>

<<signature Config.load_path>>

<<signature Config.exec_magic_number>>
<<signature Config.cmi_magic_number>>
<<signature Config.cmo_magic_number>>
<<signature Config.cma_magic_number>>
<<signature Config.cmx_magic_number>>
<<signature Config.cmxa_magic_number>>
<<signature Config.ast_intf_magic_number>>
<<signature Config.ast_impl_magic_number>>

<<signature Config.max_tag>>
<<signature Config.max_young_wosize>>
<<signature Config.architecture>>
<<signature Config.model>>
<<signature Config.system>>

<<signature Config.ext_obj>>
<<signature Config.ext_asm>>
<<signature Config.ext_lib>>
@


\subsection*{[[./utils/misc.mli]]}


%-------------------------------------------------------------

<<./utils/misc.mli>>=
<<copyright header>>

(* Miscellaneous useful types and functions *)

<<signature Misc.fatal_error>>
<<exception Misc.Fatal_error>>

<<signature Misc.map_end>>
<<signature Misc.for_all2>>
<<signature Misc.filter>>
<<signature Misc.mem_assq>>
<<signature Misc.replicate_list>>

<<signature Misc.find_in_path>>
<<signature Misc.remove_file>>

<<signature Misc.create_hashtable>>

<<signature Misc.copy_file>>
<<signature Misc.copy_file_chunk>>

<<signature Misc.log2>>
<<signature Misc.align>>
<<signature Misc.no_overflow_add>>
<<signature Misc.no_overflow_sub>>
@


\subsection*{[[./utils/misc.ml]]}



%-------------------------------------------------------------

<<./utils/misc.ml>>=
<<copyright header>>

(* Errors *)

<<exception Misc.Fatal_error>>

<<function Misc.fatal_error>>

(* List functions *)

<<function Misc.map_end>>

<<function Misc.for_all2>>

<<function Misc.filter>>

<<function Misc.mem_assq>>

<<function Misc.replicate_list>>

(* File functions *)

<<function Misc.find_in_path>>

<<function Misc.remove_file>>

(* Hashtable functions *)

<<function Misc.create_hashtable>>

<<function Misc.copy_file>>

<<function Misc.copy_file_chunk>>

(* Integer operations *)

<<function Misc.log2>>

<<function Misc.align>>

<<function Misc.no_overflow_add>>

<<function Misc.no_overflow_sub>>

@


\subsection*{[[./utils/tbl.mli]]}

<<signature Tbl.empty>>=
val empty: ('a, 'b) t
@

<<signature Tbl.add>>=
val add: 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t
@

<<signature Tbl.find>>=
val find: 'a -> ('a, 'b) t -> 'b
@

<<signature Tbl.remove>>=
val remove: 'a -> ('a,  'b) t -> ('a, 'b) t
@

<<signature Tbl.iter>>=
val iter: ('a -> 'b -> 'c) -> ('a, 'b) t -> unit
@

<<signature Tbl.print>>=
val print: ('a -> unit) -> ('b -> unit) -> ('a, 'b) t -> unit
@


%-------------------------------------------------------------

<<./utils/tbl.mli>>=
<<copyright header>>

(* Association tables from any ordered type to any type.
   We use the generic ordering to compare keys. *)

type ('a, 'b) t

<<signature Tbl.empty>>
<<signature Tbl.add>>
<<signature Tbl.find>>
<<signature Tbl.remove>>
<<signature Tbl.iter>>

<<signature Tbl.print>>
@


\subsection*{[[./utils/tbl.ml]]}

% lol, can now use Map :)

<<type Tbl.t>>=

type ('a, 'b) t =
    Empty
  | Node of ('a, 'b) t * 'a * 'b * ('a, 'b) t * int
@

<<constant Tbl.empty>>=
let empty = Empty
@

<<constant Tbl.height>>=
let height = function
    Empty -> 0
  | Node(_,_,_,_,h) -> h
@

<<function Tbl.create>>=
let create l x d r =
  let hl = height l and hr = height r in
  Node(l, x, d, r, (if hl >= hr then hl + 1 else hr + 1))
@

<<function Tbl.bal>>=
let bal l x d r =
  let hl = height l and hr = height r in
  if hl > hr + 1 then
    match l with
    | Node (ll, lv, ld, lr, _) when height ll >= height lr ->
        create ll lv ld (create lr x d r)
    | Node (ll, lv, ld, Node (lrl, lrv, lrd, lrr, _), _) ->
        create (create ll lv ld lrl) lrv lrd (create lrr x d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rv, rd, rr, _) when height rr >= height rl ->
        create (create l x d rl) rv rd rr
    | Node (Node (rll, rlv, rld, rlr, _), rv, rd, rr, _) ->
        create (create l x d rll) rlv rld (create rlr rv rd rr)
    | _ -> assert false
  else
    create l x d r
@

<<function Tbl.add>>=
let rec add x data = function
    Empty ->
      Node(Empty, x, data, Empty, 1)
  | Node(l, v, d, r, h) as t ->
      let c = compare x v in
      if c = 0 then
        Node(l, x, data, r, h)
      else if c < 0 then
        bal (add x data l) v d r
      else
        bal l v d (add x data r)
@

<<function Tbl.find>>=
let rec find x = function
    Empty ->
      raise Not_found
  | Node(l, v, d, r, _) ->
      let c = compare x v in
      if c = 0 then d
      else find x (if c < 0 then l else r)
@

<<function Tbl.merge>>=
let rec merge t1 t2 =
  match (t1, t2) with
    (Empty, t) -> t
  | (t, Empty) -> t
  | (Node(l1, v1, d1, r1, h1), Node(l2, v2, d2, r2, h2)) ->
      bal l1 v1 d1 (bal (merge r1 l2) v2 d2 r2)
@

<<function Tbl.remove>>=
let rec remove x = function
    Empty ->
      Empty
  | Node(l, v, d, r, h) as t ->
      let c = compare x v in
      if c = 0 then
        merge l r
      else if c < 0 then
        bal (remove x l) v d r
      else
        bal l v d (remove x r)
@

<<function Tbl.iter>>=
let rec iter f = function
    Empty -> ()
  | Node(l, v, d, r, _) ->
      iter f l; f v d; iter f r
@

<<function Tbl.print>>=
(* @Scheck: dumper *)
let print print_key print_data tbl =
  open_hvbox 2;
  print_string "[[";
  iter (fun k d ->
          open_box 2;
          print_key k; print_string " ->"; print_space();
          print_data d; print_string ";";
          close_box(); print_space())
        tbl;
  print_string "]]";
  close_box()
@


%-------------------------------------------------------------

<<./utils/tbl.ml>>=
<<copyright header>>
<<type Tbl.t>>

<<constant Tbl.empty>>

<<constant Tbl.height>>

<<function Tbl.create>>

<<function Tbl.bal>>

<<function Tbl.add>>

<<function Tbl.find>>

<<function Tbl.merge>>

<<function Tbl.remove>>

<<function Tbl.iter>>

open Format

<<function Tbl.print>>
@


\subsection*{[[./utils/terminfo.mli]]}


%-------------------------------------------------------------

<<./utils/terminfo.mli>>=
<<copyright header>>

(* Basic interface to the terminfo database *)

external setupterm: unit -> unit = "terminfo_setup"
external getstr: string -> string = "terminfo_getstr"
external getnum: string -> int = "terminfo_getnum"
external puts: out_channel -> string -> int -> unit = "terminfo_puts"

@


\subsection*{[[./utils/terminfo.ml]]}


%-------------------------------------------------------------

<<./utils/terminfo.ml>>=
<<copyright header>>

(* Basic interface to the terminfo database *)

external setupterm: unit -> unit = "terminfo_setup"
external getstr: string -> string = "terminfo_getstr"
external getnum: string -> int = "terminfo_getnum"
external puts: out_channel -> string -> int -> unit = "terminfo_puts"

@


\subsection*{[[./utils/clflags.ml]]}



%-------------------------------------------------------------

<<./utils/clflags.ml>>=
<<copyright header>>

(* Command-line parameters *)

<<constant Clflags.objfiles>>
<<constant Clflags.ccobjs>>
<<constant Clflags.compile_only>>
<<constant Clflags.exec_name>>
<<constant Clflags.archive_name>>
<<constant Clflags.object_name>>
<<constant Clflags.include_dirs>>
<<constant Clflags.print_types>>
<<constant Clflags.make_archive>>
<<constant Clflags.debug>>
<<constant Clflags.fast>>
<<constant Clflags.link_everything>>
<<constant Clflags.custom_runtime>>
<<constant Clflags.output_c_object>>
<<constant Clflags.ccopts>>
<<constant Clflags.nopervasives>>
<<constant Clflags.preprocessor>>
<<constant Clflags.thread_safe>>
<<constant Clflags.noassert>>
<<constant Clflags.verbose>>

<<constant Clflags.dump_rawlambda>>
<<constant Clflags.dump_lambda>>
<<constant Clflags.dump_instr>>

<<constant Clflags.keep_asm_file>>
<<constant Clflags.optimize_for_speed>>

<<constant Clflags.dump_cmm>>
<<constant Clflags.dump_selection>>
<<constant Clflags.dump_live>>
<<constant Clflags.dump_spill>>
<<constant Clflags.dump_split>>
<<constant Clflags.dump_scheduling>>
<<constant Clflags.dump_interf>>
<<constant Clflags.dump_prefer>>
<<constant Clflags.dump_regalloc>>
<<constant Clflags.dump_reload>>
<<constant Clflags.dump_linear>>
<<constant Clflags.keep_startup_file>>

<<constant Clflags.native_code>>

<<constant Clflags.inline_threshold>>
@


\subsection*{[[./utils/ccomp.mli]]}



%-------------------------------------------------------------

<<./utils/ccomp.mli>>=
<<copyright header>>

(* Compiling C files and building C libraries *)

<<signature Ccomp.command>>
<<signature Ccomp.compile_file_bytecode>>
<<signature Ccomp.compile_file_native>>
<<signature Ccomp.create_archive>>
@


\subsection*{[[./utils/ccomp.ml]]}

%-------------------------------------------------------------

<<./utils/ccomp.ml>>=
<<copyright header>>

(* Compiling C files and building C libraries *)

<<function Ccomp.command>>

<<function Ccomp.compile_file_bytecode>>

<<function Ccomp.compile_file_native>>

<<function Ccomp.create_archive>>
@


\section{[[./parsing/]]}

\subsection*{[[./parsing/asttypes.mli]]}




%-------------------------------------------------------------

<<./parsing/asttypes.mli>>=
<<copyright header>>

(* Auxiliary a.s.t. types used by parsetree and typedtree. *)

<<type Asttypes.constant>>

<<type Asttypes.rec_flag>>

<<type Asttypes.direction_flag>>

<<type Asttypes.mutable_flag>>
@


\subsection*{[[./parsing/linenum.mli]]}

<<signature Linenum.for_position>>=
(* An auxiliary lexer for determining the line number corresponding to
   a file position, honoring the directives # linenum "filename" *)

val for_position: string -> int -> string * int * int
        (* [Linenum.for_position file loc] returns a triple describing
           the location [loc] in the file named [file].
           First result is name of actual source file.
           Second result is line number in that source file.
           Third result is position of beginning of that line in [file]. *)
@


%-------------------------------------------------------------

<<./parsing/linenum.mli>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


<<signature Linenum.for_position>>
@


\subsection*{[[./parsing/longident.mli]]}


%-------------------------------------------------------------

<<./parsing/longident.mli>>=
<<copyright header>>

<<type Longident.t>>

<<signature Longident.flatten>>
@


\subsection*{[[./parsing/longident.ml]]}


%-------------------------------------------------------------

<<./parsing/longident.ml>>=
<<copyright header>>
<<type Longident.t>>

<<function Longident.flat>>

<<function Longident.flatten>>
@


\subsection*{[[./parsing/location.mli]]}


<<signature Location.input_lexbuf>>=
val input_lexbuf: Lexing.lexbuf option ref
@


<<signature Location.echo_eof>>=
val echo_eof: unit -> unit
@

<<signature Location.reset>>=
val reset: unit -> unit
@

<<signature Location.highlight_locations>>=
val highlight_locations: t -> t -> bool
@


%-------------------------------------------------------------

<<./parsing/location.mli>>=
<<copyright header>>

<<type Location.t>>

<<signature Location.none>>
<<signature Location.symbol_loc>>
<<signature Location.rhs_loc>>

<<signature Location.input_name>>
<<signature Location.input_lexbuf>>

<<signature Location.print>>
<<signature Location.print_warning>>
<<signature Location.echo_eof>>
<<signature Location.reset>>

<<signature Location.highlight_locations>>
@


\subsection*{[[./parsing/location.ml]]}





<<constant Location.input_lexbuf>>=
let input_lexbuf = ref (None : lexbuf option)
@

<<type Location.terminal_info_status>>=
(* Terminal info *)

type terminal_info_status = Unknown | Bad_term | Good_term
@

<<function Location.setup_terminal_info>>=
let setup_terminal_info() =
  try
    Terminfo.setupterm();
    num_lines := Terminfo.getnum "li";
    cursor_up := Terminfo.getstr "up";
    cursor_down := Terminfo.getstr "do";
    begin try
      start_standout := Terminfo.getstr "us";
      end_standout := Terminfo.getstr "ue"
    with Not_found ->
      start_standout := Terminfo.getstr "so";
      end_standout := Terminfo.getstr "se"
    end;
    status := Good_term
  with _ ->
    status := Bad_term
@

<<constant Location.num_loc_lines>>=
(* Print the location using standout mode. *)

let num_loc_lines = ref 0 (* number of lines already printed after input *)
@

<<function Location.highlight_locations>>=
let rec highlight_locations loc1 loc2 =
  match !status with
    Unknown ->
      setup_terminal_info(); highlight_locations loc1 loc2
  | Bad_term ->
      false
  | Good_term ->
      match !input_lexbuf with
        None -> false
      | Some lb ->
          (* Char 0 is at offset -lb.lex_abs_pos in lb.lex_buffer. *)
          let pos0 = -lb.lex_abs_pos in
          (* Do nothing if the buffer does not contain the whole phrase. *)
          if pos0 < 0 then false else begin
            (* Count number of lines in phrase *)
            let lines = ref !num_loc_lines in
            for i = pos0 to String.length lb.lex_buffer - 1 do
              if lb.lex_buffer.[i] = '\n' then incr lines
            done;
            (* If too many lines, give up *)
            if !lines >= !num_lines - 2 then false else begin
              (* Move cursor up that number of lines *)
              for i = 1 to !lines do
                Terminfo.puts stdout !cursor_up 1
              done;
              (* Print the input, switching to standout for the location *)
              let bol = ref false in
          print_string "# ";
              for pos = 0 to String.length lb.lex_buffer - pos0 - 1 do
                if !bol then (print_string "  "; bol := false);
                if pos = loc1.loc_start || pos = loc2.loc_start then
                  Terminfo.puts stdout !start_standout 1;
                if pos = loc1.loc_end || pos = loc2.loc_end then
                  Terminfo.puts stdout !end_standout 1;
                let c = lb.lex_buffer.[pos + pos0] in
                print_char c;
                bol := (c = '\n')
              done;
              (* Make sure standout mode is over *)
              Terminfo.puts stdout !end_standout 1;
              (* Position cursor back to original location *)
              for i = 1 to !num_loc_lines do
                Terminfo.puts stdout !cursor_down 1
              done;
              true
            end
          end
@

<<function Location.reset>>=
let reset () =
  num_loc_lines := 0
@



<<function Location.echo_eof>>=
let echo_eof () =
  print_newline ();
  incr num_loc_lines
@


%-------------------------------------------------------------

<<./parsing/location.ml>>=
<<copyright header>>

open Lexing

<<type Location.t>>

<<constant Location.none>>

<<function Location.symbol_loc>>

<<function Location.rhs_loc>>

<<constant Location.input_name>>

<<constant Location.input_lexbuf>>

<<type Location.terminal_info_status>>

let status = ref Unknown
and num_lines = ref 0
and cursor_up = ref ""
and cursor_down = ref ""
and start_standout = ref ""
and end_standout = ref ""

<<function Location.setup_terminal_info>>

<<constant Location.num_loc_lines>>

<<function Location.highlight_locations>>

(* Print the location in some way or another *)

open Format

<<function Location.reset>>

<<constants Location.msg_xxx>>

<<function Location.print>>

<<function Location.print_warning>>

<<function Location.echo_eof>>

@


\subsection*{[[./parsing/syntaxerr.mli]]}


%-------------------------------------------------------------

<<./parsing/syntaxerr.mli>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


<<type Syntaxerr.error>>

<<exception Syntaxerr.Error>>
<<exception Syntaxerr.Escape_error>>

<<signature Syntaxerr.report_error>>
@


\subsection*{[[./parsing/syntaxerr.ml]]}



%-------------------------------------------------------------

<<./parsing/syntaxerr.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1997 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


(* Auxiliary type for reporting syntax errors *)

open Format

<<type Syntaxerr.error>>

<<exception Syntaxerr.Error>>
<<exception Syntaxerr.Escape_error>>

<<function Syntaxerr.report_error>>


@


\subsection*{[[./parsing/parsetree.mli]]}


















%-------------------------------------------------------------

<<./parsing/parsetree.mli>>=
<<copyright header>>

(* Abstract syntax tree produced by parsing *)

open Asttypes

(* Type expressions for the core language *)

<<type Parsetree.core_type>>

<<type Parsetree.core_type_desc>>

(* Value expressions for the core language *)

<<type Parsetree.pattern>>

<<type Parsetree.pattern_desc>>

<<type Parsetree.expression>>

<<type Parsetree.expression_desc>>

<<type Parsetree.value_description>>

(* Type declarations *)

<<type Parsetree.type_declaration>>

<<type Parsetree.type_kind>>

<<type Parsetree.exception_declaration>>

(* Type expressions for the module language *)

<<type Parsetree.module_type>>

<<type Parsetree.module_type_desc>>


<<type Parsetree.signature>>

<<type Parsetree.signature_item>>

<<type Parsetree.signature_item_desc>>

<<type Parsetree.modtype_declaration>>

(* Value expressions for the module language *)

<<type Parsetree.module_expr>>

<<type Parsetree.module_expr_desc>>

<<type Parsetree.structure>>

<<type Parsetree.structure_item>>

<<type Parsetree.structure_item_desc>>

(* Toplevel phrases *)

<<type Parsetree.toplevel_phrase>>

<<type Parsetree.directive_argument>>
@


\subsection*{[[./parsing/lexer.mli]]}


%-------------------------------------------------------------

<<./parsing/lexer.mli>>=
<<copyright header>>

<<signature Lexer.token>>

<<type Lexer.error>>

<<exception Lexer.Error>>

<<signature Lexer.report_error>>

@


\subsection*{[[./parsing/parse.mli]]}


%-------------------------------------------------------------

<<./parsing/parse.mli>>=
<<copyright header>>

(* Entry points in the parser *)

<<signature Parse.implementation>>
<<signature Parse.interface>>
<<signature Parse.toplevel_phrase>>
<<signature Parse.use_file>>

@


\subsection*{[[./parsing/parse.ml]]}

%-------------------------------------------------------------

<<./parsing/parse.ml>>=
<<copyright header>>

(* Entry points in the parser *)

open Location

<<function Parse.skip_phrase>>

<<function Parse.maybe_skip_phrase>>

<<function Parse.wrap>>

<<function Parse.implementation>>
<<function Parse.interface>>

<<function Parse.xxx>>
@


\section{[[./typing/]]}

\subsection*{[[./typing/ident.mli]]}

<<signature Ident.create>>=
val create: string -> t
@

<<signature Ident.create_persistent>>=
val create_persistent: string -> t
@

<<signature Ident.name>>=
val name: t -> string
@

<<signature Ident.unique_name>>=
val unique_name: t -> string
@

<<signature Ident.persistent>>=
val persistent: t -> bool
@

<<signature Ident.equal>>=
val equal: t -> t -> bool
        (* Compare identifiers by name. *)      
@

<<signature Ident.same>>=
val same: t -> t -> bool
        (* Compare identifiers by binding location.
           Two identifiers are the same either if they are both
           non-persistent and have been created by the same call to
           [new], or if they are both persistent and have the same
           name. *)
@

<<signature Ident.hide>>=
val hide: t -> t
        (* Return an identifier with same name as the given identifier,
           but stamp different from any stamp returns by new.
           When put in a 'a tbl, this identifier can only be looked
           up by name. *)
@

<<signature Ident.make_global>>=
val make_global: t -> unit
@

<<signature Ident.global>>=
val global: t -> bool
@

<<signature Ident.binding_time>>=
val binding_time: t -> int
@

<<signature Ident.current_time>>=
val current_time: unit -> int
@

<<signature Ident.print>>=
val print: t -> unit
@

<<signature Ident.empty>>=
val empty: 'a tbl
@

<<signature Ident.add>>=
val add: t -> 'a -> 'a tbl -> 'a tbl
@

<<signature Ident.find_same>>=
val find_same: t -> 'a tbl -> 'a
@

<<signature Ident.find_name>>=
val find_name: string -> 'a tbl -> 'a
@

<<signature Ident.iter>>=
val iter: (t -> 'a -> unit) -> 'a tbl -> unit
@

<<signature Ident.print_tbl>>=
val print_tbl: ('a -> unit) -> 'a tbl -> unit
@


%-------------------------------------------------------------

<<./typing/ident.mli>>=
<<copyright header>>

(* Identifiers (unique names) *)

<<signature type t>>

<<signature Ident.create>>
<<signature Ident.create_persistent>>
<<signature Ident.name>>
<<signature Ident.unique_name>>
<<signature Ident.persistent>>
<<signature Ident.equal>>
<<signature Ident.same>>
<<signature Ident.hide>>

<<signature Ident.make_global>>
<<signature Ident.global>>

<<signature Ident.binding_time>>
<<signature Ident.current_time>>

<<signature Ident.print>>

type 'a tbl
        (* Association tables from identifiers to type 'a. *)

<<signature Ident.empty>>
<<signature Ident.add>>
<<signature Ident.find_same>>
<<signature Ident.find_name>>

<<signature Ident.iter>>
<<signature Ident.print_tbl>>
@


\subsection*{[[./typing/ident.ml]]}


<<constant Ident.currentstamp>>=
(* A stamp of 0 denotes a persistent identifier *)

let currentstamp = ref 0
@

<<function Ident.create>>=
let create s =
  incr currentstamp;
  { name = s; stamp = !currentstamp; global = false }
@

<<function Ident.create_persistent>>=
let create_persistent s =
  { name = s; stamp = 0; global = true }
@

<<function Ident.name>>=
let name i = i.name
@

<<function Ident.unique_name>>=
let unique_name i = i.name ^ "_" ^ string_of_int i.stamp
@

<<function Ident.persistent>>=
let persistent i = (i.stamp = 0)
@

<<function Ident.equal>>=
(* @Scheck: dead but should be used? TODO? *)
let equal i1 i2 = i1.name = i2.name
@

<<function Ident.same>>=
let same i1 i2 = i1 = i2
  (* Possibly more efficient version (with a real compiler, at least):
       if i1.stamp <> 0
       then i1.stamp = i2.stamp
       else i2.stamp = 0 & i1.name = i2.name *)
@

<<function Ident.binding_time>>=
let binding_time i = i.stamp
@

<<function Ident.current_time>>=
let current_time() = !currentstamp
@

<<function Ident.hide>>=
let hide i =
  { stamp = -1; name = i.name; global = i.global }
@

<<function Ident.make_global>>=
let make_global i =
  i.global <- true
@

<<function Ident.global>>=
let global i =
  i.global
@

<<function Ident.print>>=
let print i =
  print_string i.name;
  match i.stamp with
    0 -> print_string "!"
  | -1 -> print_string "#"
  | n -> print_string "/"; print_int n; if i.global then print_string "g"
@

<<type Ident.tbl>>=
type 'a tbl =
    Empty
  | Node of 'a tbl * 'a data * 'a tbl * int
@

<<type Ident.data>>=
and 'a data =
  { ident: t;
    data: 'a;
    previous: 'a data option }
@

<<constant Ident.empty>>=
let empty = Empty
@

<<function Ident.mknode>>=
(* Inline expansion of height for better speed
 * let height = function
 *     Empty -> 0
 *   | Node(_,_,_,h) -> h
 *)

let mknode l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  Node(l, d, r, (if hl >= hr then hl + 1 else hr + 1))
@

<<function Ident.balance>>=
let balance l d r =
  let hl = match l with Empty -> 0 | Node(_,_,_,h) -> h
  and hr = match r with Empty -> 0 | Node(_,_,_,h) -> h in
  if hl > hr + 1 then
    match l with
    | Node (ll, ld, lr, _)
      when (match ll with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match lr with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode ll ld (mknode lr d r)
    | Node (ll, ld, Node(lrl, lrd, lrr, _), _) ->
        mknode (mknode ll ld lrl) lrd (mknode lrr d r)
    | _ -> assert false
  else if hr > hl + 1 then
    match r with
    | Node (rl, rd, rr, _)
      when (match rr with Empty -> 0 | Node(_,_,_,h) -> h) >=
           (match rl with Empty -> 0 | Node(_,_,_,h) -> h) ->
        mknode (mknode l d rl) rd rr
    | Node (Node (rll, rld, rlr, _), rd, rr, _) ->
        mknode (mknode l d rll) rld (mknode rlr rd rr)
    | _ -> assert false
  else
    mknode l d r
@

<<function Ident.add>>=
let rec add id data = function
    Empty ->
      Node(Empty, {ident = id; data = data; previous = None}, Empty, 1)
  | Node(l, k, r, h) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        Node(l, {ident = id; data = data; previous = Some k}, r, h)
      else if c < 0 then
        balance (add id data l) k r
      else
        balance l k (add id data r)
@

<<function Ident.find_stamp>>=
let rec find_stamp s = function
    None ->
      raise Not_found
  | Some k ->
      if k.ident.stamp = s then k.data else find_stamp s k.previous
@

<<function Ident.find_same>>=
let rec find_same id = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare id.name k.ident.name in
      if c = 0 then
        if id.stamp = k.ident.stamp
        then k.data
        else find_stamp id.stamp k.previous
      else
        find_same id (if c < 0 then l else r)
@

<<function Ident.find_name>>=
let rec find_name name = function
    Empty ->
      raise Not_found
  | Node(l, k, r, _) ->
      let c = compare name k.ident.name in
      if c = 0 then
        k.data
      else
        find_name name (if c < 0 then l else r)
@

<<function Ident.print_tbl>>=
(* @Scheck: dumper *)
let print_tbl print_elt tbl =
  open_box 2;
  print_string "[[";
  iter (fun id data -> 
          open_box 2;
          print id; print_string " ->"; print_space(); print_elt data;
          print_string ";"; close_box(); print_space())
       tbl;
  print_string "]]";
  close_box()
@


%-------------------------------------------------------------

<<./typing/ident.ml>>=
<<copyright header>>

open Format

<<type Ident.t>>

<<constant Ident.currentstamp>>

<<function Ident.create>>

<<function Ident.create_persistent>>

<<function Ident.name>>

<<function Ident.unique_name>>

<<function Ident.persistent>>

<<function Ident.equal>>

<<function Ident.same>>

<<function Ident.binding_time>>

<<function Ident.current_time>>

<<function Ident.hide>>

<<function Ident.make_global>>

<<function Ident.global>>

<<function Ident.print>>

<<type Ident.tbl>>

<<type Ident.data>>

<<constant Ident.empty>>

<<function Ident.mknode>>

<<function Ident.balance>>

<<function Ident.add>>

<<function Ident.find_stamp>>

<<function Ident.find_same>>

<<function Ident.find_name>>

let rec iter fn = function
    Empty -> ()
  | Node(l, k, r, _) ->
      iter fn l; iter_node fn k; iter fn r
and iter_node fn k =
  fn k.ident k.data;
  match k.previous with None -> () | Some prev_k -> iter_node fn prev_k

<<function Ident.print_tbl>>

@


\subsection*{[[./typing/primitive.mli]]}

<<type Primitive.description>>=
(* Description of primitive functions *)

type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)
@

<<signature Primitive.parse_declaration>>=
val parse_declaration: int -> string list -> description
@

<<signature Primitive.print_description>>=
val print_description: description -> unit
@


%-------------------------------------------------------------

<<./typing/primitive.mli>>=
<<copyright header>>

<<type Primitive.description>>

<<signature Primitive.parse_declaration>>
<<signature Primitive.print_description>>
@


\subsection*{[[./typing/primitive.ml]]}

<<type Primitive.description (./typing/primitive.ml)>>=
type description =
  { prim_name: string;         (* Name of primitive  or C function *)
    prim_arity: int;           (* Number of arguments *)
    prim_alloc: bool;          (* Does it allocates or raise? *)
    prim_native_name: string;  (* Name of C function for the nat. code gen. *)
    prim_native_float: bool }  (* Does the above operate on unboxed floats? *)
@

<<function Primitive.parse_declaration>>=
let parse_declaration arity decl =
  match decl with
    name :: "noalloc" :: name2 :: "float" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: name2 :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = name2; prim_native_float = false}
  | name :: name2 :: "float" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = name2; prim_native_float = true}
  | name :: "noalloc" :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = false;
       prim_native_name = ""; prim_native_float = false}
  | name :: name2 :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = name2; prim_native_float = false}
  | name :: _ ->
      {prim_name = name; prim_arity = arity; prim_alloc = true;
       prim_native_name = ""; prim_native_float = false}
  | [] ->
      fatal_error "Primitive.parse_declaration"
@

<<function Primitive.print_quoted>>=
let print_quoted s = print_char '"'; print_string s; print_char '"'
@

<<function Primitive.print_description>>=
let print_description p =
  print_quoted p.prim_name;
  if not p.prim_alloc then
    (print_space(); print_quoted "noalloc");
  if p.prim_native_name <> "" then
    (print_space(); print_quoted p.prim_native_name);
  if p.prim_native_float then
    (print_space(); print_quoted "float")
@


%-------------------------------------------------------------

<<./typing/primitive.ml>>=
<<copyright header>>

(* Description of primitive functions *)

open Misc
open Format

<<type Primitive.description (./typing/primitive.ml)>>

<<function Primitive.parse_declaration>>

<<function Primitive.print_quoted>>

<<function Primitive.print_description>>
@


\subsection*{[[./typing/path.mli]]}


<<signature Path.same>>=
val same: t -> t -> bool
@

<<signature Path.isfree>>=
val isfree: Ident.t -> t -> bool
@

<<signature Path.binding_time>>=
val binding_time: t -> int
@

<<signature Path.nopos>>=
val nopos: int
@


%-------------------------------------------------------------

<<./typing/path.mli>>=
<<copyright header>>

<<type Path.t>>

<<signature Path.same>>
<<signature Path.isfree>>
<<signature Path.binding_time>>

<<signature Path.nopos>>
@


\subsection*{[[./typing/path.ml]]}

<<constant Path.nopos>>=
let nopos = -1
@

<<function Path.same>>=
let rec same p1 p2 =
  match (p1, p2) with
    (Pident id1, Pident id2) -> Ident.same id1 id2
  | (Pdot(p1, s1, pos1), Pdot(p2, s2, pos2)) -> s1 = s2 & same p1 p2
  | (_, _) -> false
@

<<function Path.isfree>>=
let rec isfree id = function
    Pident id' -> Ident.same id id'
  | Pdot(p, s, pos) -> isfree id p
@

<<constant Path.binding_time>>=
let rec binding_time = function
    Pident id -> Ident.binding_time id
  | Pdot(p, s, pos) -> binding_time p
@


%-------------------------------------------------------------

<<./typing/path.ml>>=
<<copyright header>>
<<type Path.t>>

<<constant Path.nopos>>

<<function Path.same>>

<<function Path.isfree>>

<<constant Path.binding_time>>
@


\subsection*{[[./typing/types.mli]]}



<<type Types.value_description>>=
type value_description =
  { val_type: type_expr;                (* Type of the value *)
    val_kind: value_kind }
@

<<type Types.value_kind>>=
and value_kind =
    Val_reg                             (* Regular value *)
  | Val_prim of Primitive.description   (* Primitive *)
@

<<type Types.constructor_description>>=
type constructor_description =
  { cstr_res: type_expr;                (* Type of the result *)
    cstr_args: type_expr list;          (* Type of the arguments *)
    cstr_arity: int;                    (* Number of arguments *)
    cstr_tag: constructor_tag;          (* Tag for heap blocks *)
    cstr_consts: int;                   (* Number of constant constructors *)
    cstr_nonconsts: int }               (* Number of non-const constructors *)
@

<<type Types.constructor_tag>>=
and constructor_tag =
    Cstr_constant of int                (* Constant constructor (an int) *)
  | Cstr_block of int                   (* Regular constructor (a block) *)
  | Cstr_exception of Path.t            (* Exception constructor *)
@

<<type Types.label_description>>=
type label_description =
  { lbl_res: type_expr;                 (* Type of the result *)
    lbl_arg: type_expr;                 (* Type of the argument *)
    lbl_mut: mutable_flag;              (* Is this a mutable field? *)
    lbl_pos: int;                       (* Position in block *)
    lbl_all: label_description array;   (* All the labels in this type *)
    lbl_repres: record_representation } (* Representation for this record *)
@

<<type Types.record_representation>>=
and record_representation =
    Record_regular                      (* All fields are boxed / tagged *)
  | Record_float                        (* All fields are floats *)
@

<<type Types.type_declaration>>=
type type_declaration =
  { type_params: type_expr list;
    type_arity: int;
    type_kind: type_kind;
    type_manifest: type_expr option }
@

<<type Types.type_kind>>=
and type_kind =
    Type_abstract
  | Type_variant of (string * type_expr list) list
  | Type_record of (string * mutable_flag * type_expr) list
@

<<type Types.exception_declaration>>=
type exception_declaration = type_expr list
@

<<type Types.module_type>>=
type module_type =
    Tmty_ident of Path.t
  | Tmty_signature of signature
@

<<type Types.signature>>=
and signature = signature_item list
@

<<type Types.signature_item>>=
and signature_item =
    Tsig_value of Ident.t * value_description
  | Tsig_type of Ident.t * type_declaration
  | Tsig_exception of Ident.t * exception_declaration
  | Tsig_module of Ident.t * module_type
  | Tsig_modtype of Ident.t * modtype_declaration
@

<<type Types.modtype_declaration>>=
and modtype_declaration =
    Tmodtype_abstract
  | Tmodtype_manifest of module_type
@


%-------------------------------------------------------------

<<./typing/types.mli>>=
<<copyright header>>

(* Representation of types and declarations *)

open Asttypes

(* Type expressions for the core language *)

<<type Types.type_expr>>

<<type Types.type_desc>>

<<type Types.abbrev_memo>>

(* Value descriptions *)

<<type Types.value_description>>

<<type Types.value_kind>>

(* Constructor descriptions *)

<<type Types.constructor_description>>

<<type Types.constructor_tag>>

(* Record label descriptions *)

<<type Types.label_description>>

<<type Types.record_representation>>

(* Type definitions *)

<<type Types.type_declaration>>

<<type Types.type_kind>>

<<type Types.exception_declaration>>

(* Type expressions for the module language *)

<<type Types.module_type>>

<<type Types.signature>>

<<type Types.signature_item>>

<<type Types.modtype_declaration>>
@


\subsection*{[[./typing/btype.mli]]}

<<signature Btype.generic_level>>=
val generic_level: int
@

<<signature Btype.newgenty>>=
val newgenty: type_desc -> type_expr
        (* Create a generic type *)
@

<<signature Btype.newgenvar>>=
val newgenvar: unit -> type_expr
        (* Return a fresh generic variable *)
@

<<signature Btype.newmarkedgenvar>>=
val newmarkedgenvar: unit -> type_expr
        (* Return a fresh marked generic variable *)
@

<<signature Btype.repr>>=
val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)
@

<<signature Btype.iter_type_expr>>=
(**** Utilities for type traversal ****)

val iter_type_expr: (type_expr -> unit) -> type_expr -> unit
        (* Iteration on types *)
@

<<signature Btype.save_desc>>=
val save_desc: type_expr -> type_desc -> unit
        (* Save a type description *)
@

<<signature Btype.cleanup_types>>=
val cleanup_types: unit -> unit
        (* Restore type descriptions *)
@

<<signature Btype.lowest_level>>=
val lowest_level: int
        (* Marked type: ty.level < lowest_level *)
@

<<signature Btype.pivot_level>>=
val pivot_level: int
        (* Type marking: ty.level <- pivot_level - ty.level *)
@

<<signature Btype.unmark_type>>=
val unmark_type: type_expr -> unit
        (* Remove marks from a type *)
@

<<signature Btype.cleanup_abbrev>>=
(**** Memorization of abbreviation expansion ****)

val cleanup_abbrev: unit -> unit
        (* Flush the cache of abbreviation expansions.
           When some types are saved (using [output_value]), this
           function MUST be called just before. *)
@

<<signature Btype.memorize_abbrev>>=
val memorize_abbrev:
        abbrev_memo ref -> Path.t -> type_expr -> unit
        (* Add an expansion in the cache *)
@


%-------------------------------------------------------------

<<./typing/btype.mli>>=
<<copyright header>>

(* Basic operations on core types *)

open Types

<<signature Btype.generic_level>>

<<signature Btype.newgenty>>
<<signature Btype.newgenvar>>
<<signature Btype.newmarkedgenvar>>

<<signature Btype.repr>>

<<signature Btype.iter_type_expr>>

<<signature Btype.save_desc>>
<<signature Btype.cleanup_types>>

<<signature Btype.lowest_level>>
<<signature Btype.pivot_level>>
<<signature Btype.unmark_type>>

<<signature Btype.cleanup_abbrev>>
<<signature Btype.memorize_abbrev>>
@


\subsection*{[[./typing/btype.ml]]}

<<constant Btype.generic_level>>=
(**** Type level management ****)

let generic_level = 100000000
@

<<constant Btype.lowest_level>>=
(* Used to mark a type during a traversal. *)
let lowest_level = 0
@

<<constant Btype.pivot_level>>=
let pivot_level = 2 * lowest_level - 1
    (* pivot_level - lowest_level < lowest_level *)
@

<<function Btype.newgenty>>=
(**** Some type creators ****)

let newgenty desc      = { desc = desc; level = generic_level }
@

<<function Btype.newgenvar>>=
let newgenvar ()       = newgenty Tvar
@

<<function Btype.newmarkedgenvar>>=
let newmarkedgenvar () = { desc = Tvar; level = pivot_level - generic_level }
@

<<constant Btype.repr>>=
(**** Representative of a type ****)

let rec repr =
  function
    {desc = Tlink t'} ->
      (* 
         We do no path compression. Path compression does not seem to
         improve notably efficiency, and it prevents from changing a
         [Tlink] into another type (for instance, for undoing a
         unification).
      *)
      repr t'
  | t -> t
@

<<function Btype.iter_type_expr>>=
let iter_type_expr f ty =
  match ty.desc with
    Tvar               -> ()
  | Tarrow (ty1, ty2) -> f ty1; f ty2
  | Ttuple l           -> List.iter f l
  | Tconstr (_, l, _)          -> List.iter f l
  | Tnil               -> ()
  | Tlink ty           -> f ty
@

<<constant Btype.saved_desc>>=
let saved_desc = ref []
  (* Saved association of generic nodes with their description. *)
@

<<function Btype.save_desc>>=
let save_desc ty desc = 
  saved_desc := (ty, desc)::!saved_desc
@

<<function Btype.cleanup_types>>=
(* Restored type descriptions *)
let cleanup_types () =
  List.iter (fun (ty, desc) -> ty.desc <- desc) !saved_desc;
  saved_desc := []
@

<<function Btype.unmark_type>>=
(* Remove marks from a type. *)
let rec unmark_type ty =
  let ty = repr ty in
  if ty.level < lowest_level then begin
    ty.level <- pivot_level - ty.level;
    iter_type_expr unmark_type ty
  end
@

<<constant Btype.memo>>=
let memo = ref []
        (* Contains the list of saved abbreviation expansions. *)
@

<<function Btype.cleanup_abbrev>>=
let cleanup_abbrev () =
        (* Remove all memorized abbreviation expansions. *)
  List.iter (fun abbr -> abbr := Mnil) !memo;
  memo := []
@

<<function Btype.memorize_abbrev>>=
let memorize_abbrev mem path v =
        (* Memorize the expansion of an abbreviation. *)
  mem := Mcons (path, v, !mem);
  memo := mem :: !memo
@


%-------------------------------------------------------------

<<./typing/btype.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


(* Basic operations on core types *)

open Types

<<constant Btype.generic_level>>

<<constant Btype.lowest_level>>
<<constant Btype.pivot_level>>

<<function Btype.newgenty>>
<<function Btype.newgenvar>>
<<function Btype.newmarkedgenvar>>

<<constant Btype.repr>>

                  (**********************************)
                  (*  Utilities for type traversal  *)
                  (**********************************)


<<function Btype.iter_type_expr>>

<<constant Btype.saved_desc>>

<<function Btype.save_desc>>

<<function Btype.cleanup_types>>

<<function Btype.unmark_type>>


                  (*******************************************)
                  (*  Memorization of abbreviation expansion *)
                  (*******************************************)

<<constant Btype.memo>>

<<function Btype.cleanup_abbrev>>

<<function Btype.memorize_abbrev>>
@


\subsection*{[[./typing/subst.mli]]}

<<signature Subst.identity>>=
(*
   Substitutions are used to translate a type from one context to
   another.  This requires substituing paths for identifiers, and
   possibly also lowering the level of non-generic variables so that
   it be inferior to the maximum level of the new context.

   Substitutions can also be used to create a "clean" copy of a type.
   Indeed, non-variable node of a type are duplicated, with their
   levels set to generic level.  That way, the resulting type is
   well-formed (decreasing levels), even if the original one was not.
*)

val identity: t
@

<<signature Subst.add_type>>=
val add_type: Ident.t -> Path.t -> t -> t
@

<<signature Subst.add_module>>=
val add_module: Ident.t -> Path.t -> t -> t
@

<<signature Subst.add_modtype>>=
val add_modtype: Ident.t -> module_type -> t -> t
@

<<signature Subst.type_expr>>=
val type_expr: t -> type_expr -> type_expr
@

<<signature Subst.value_description>>=
val value_description: t -> value_description -> value_description
@

<<signature Subst.type_declaration>>=
val type_declaration: t -> type_declaration -> type_declaration
@

<<signature Subst.exception_declaration>>=
val exception_declaration:
        t -> exception_declaration -> exception_declaration
@

<<signature Subst.modtype>>=
val modtype: t -> module_type -> module_type
@

<<signature Subst.signature>>=
val signature: t -> signature -> signature
@

<<signature Subst.modtype_declaration>>=
val modtype_declaration: t -> modtype_declaration -> modtype_declaration
@


%-------------------------------------------------------------

<<./typing/subst.mli>>=
<<copyright header>>

(* Substitutions *)

open Types

type t

<<signature Subst.identity>>

<<signature Subst.add_type>>
<<signature Subst.add_module>>
<<signature Subst.add_modtype>>

<<signature Subst.type_expr>>
<<signature Subst.value_description>>
<<signature Subst.type_declaration>>
<<signature Subst.exception_declaration>>
<<signature Subst.modtype>>
<<signature Subst.signature>>
<<signature Subst.modtype_declaration>>
@


\subsection*{[[./typing/subst.ml]]}


<<constant Subst.identity>>=
let identity =
  { types = Tbl.empty; modules = Tbl.empty; modtypes = Tbl.empty }
@

<<function Subst.add_type>>=
let add_type id p s =
  { types = Tbl.add id p s.types;
    modules = s.modules;
    modtypes = s.modtypes }
@

<<function Subst.add_module>>=
let add_module id p s =
  { types = s.types;
    modules = Tbl.add id p s.modules;
    modtypes = s.modtypes }
@

<<function Subst.add_modtype>>=
let add_modtype id ty s =
  { types = s.types;
    modules = s.modules;
    modtypes = Tbl.add id ty s.modtypes }
@

<<function Subst.remove_type>>=
let remove_type id s =
  { types = Tbl.remove id s.types;
    modules = s.modules;
    modtypes = s.modtypes }
@

<<function Subst.remove_module>>=
let remove_module id s =
  { types = s.types;
    modules = Tbl.remove id s.modules;
    modtypes = s.modtypes }
@

<<function Subst.remove_modtype>>=
let remove_modtype id s =
  { types = s.types;
    modules = s.modules;
    modtypes = Tbl.remove id s.modtypes }
@

<<function Subst.module_path>>=
let rec module_path s = function
    Pident id as p ->
      begin try Tbl.find id s.modules with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
@

<<function Subst.type_path>>=
let type_path s = function
    Pident id as p ->
      begin try Tbl.find id s.types with Not_found -> p end
  | Pdot(p, n, pos) ->
      Pdot(module_path s p, n, pos)
@

<<function Subst.typexp>>=
(* Similar to [Ctype.nondep_type_rec]. *)
let rec typexp s ty =
  let ty = repr ty in
  if (ty.desc = Tvar) || (ty.level < lowest_level) then
    ty
  else begin
    let desc = ty.desc in
    save_desc ty desc;
    let ty' = newmarkedgenvar () in     (* Stub *)
    ty.desc <- Tlink ty';
    ty'.desc <-
      begin match desc with
        Tvar | Tlink _ ->
          fatal_error "Subst.typexp"
      | Tarrow(t1, t2) ->
          Tarrow(typexp s t1, typexp s t2)
      | Ttuple tl ->
          Ttuple(List.map (typexp s) tl)
      | Tconstr(p, tl, abbrev) ->
          Tconstr(type_path s p, List.map (typexp s) tl, ref Mnil)
      | Tnil ->
          Tnil
      end;
    ty'
  end
@

<<function Subst.type_expr>>=
(*
   Always make a copy of the type. If this is not done, type levels
   might not be correct.
*)
let type_expr s ty =
  let ty' = typexp s ty in
  cleanup_types ();
  unmark_type ty';
  ty'
@

<<function Subst.type_declaration>>=
let type_declaration s decl =
  let decl =
    { type_params = List.map (typexp s) decl.type_params;
      type_arity = decl.type_arity;
      type_kind =
        begin match decl.type_kind with
          Type_abstract -> Type_abstract
        | Type_variant cstrs ->
            Type_variant(
              List.map (fun (n, args) -> (n, List.map (typexp s) args))
                       cstrs)
        | Type_record lbls ->
            Type_record(
              List.map (fun (n, mut, arg) -> (n, mut, typexp s arg))
                       lbls)
        end;
      type_manifest =
        begin match decl.type_manifest with
          None -> None
        | Some ty -> Some(typexp s ty)
        end
    }
  in
  cleanup_types ();
  List.iter unmark_type decl.type_params;
  begin match decl.type_kind with
    Type_abstract -> ()
  | Type_variant cstrs ->
      List.iter (fun (c, tl) -> List.iter unmark_type tl) cstrs
  | Type_record lbls ->
      List.iter (fun (c, mut, t) -> unmark_type t) lbls
  end;
  begin match decl.type_manifest with
    None    -> ()
  | Some ty -> unmark_type ty
  end;
  decl
@

<<function Subst.value_description>>=
let value_description s descr =
  { val_type = type_expr s descr.val_type;
    val_kind = descr.val_kind }
@

<<function Subst.exception_declaration>>=
let exception_declaration s tyl =
  List.map (type_expr s) tyl
@


%-------------------------------------------------------------

<<./typing/subst.ml>>=
<<copyright header>>

(* Substitutions *)

open Misc
open Path
open Types
open Btype

<<type Subst.t>>

<<constant Subst.identity>>

<<function Subst.add_type>>

<<function Subst.add_module>>

<<function Subst.add_modtype>>

<<function Subst.remove_type>>

<<function Subst.remove_module>>

<<function Subst.remove_modtype>>

<<function Subst.module_path>>

<<function Subst.type_path>>

<<function Subst.typexp>>

<<function Subst.type_expr>>

<<function Subst.type_declaration>>


<<function Subst.value_description>>

<<function Subst.exception_declaration>>

let rec modtype s = function
    Tmty_ident p as mty ->
      begin match p with
        Pident id ->
          begin try Tbl.find id s.modtypes with Not_found -> mty end
      | Pdot(p, n, pos) ->
          Tmty_ident(Pdot(module_path s p, n, pos))
      end
  | Tmty_signature sg ->
      Tmty_signature(signature s sg)

and signature s = function
    [] -> []
  | Tsig_value(id, d) :: sg ->
      Tsig_value(id, value_description s d) :: signature s sg
  | Tsig_type(id, d) :: sg ->
      Tsig_type(id, type_declaration s d) :: signature (remove_type id s) sg
  | Tsig_exception(id, d) :: sg ->
      Tsig_exception(id, exception_declaration s d) :: signature s sg
  | Tsig_module(id, mty) :: sg ->
      Tsig_module(id, modtype s mty) :: signature (remove_module id s) sg
  | Tsig_modtype(id, d) :: sg ->
      Tsig_modtype(id, modtype_declaration s d) ::
      signature (remove_modtype id s) sg

and modtype_declaration s = function
    Tmodtype_abstract -> Tmodtype_abstract
  | Tmodtype_manifest mty -> Tmodtype_manifest(modtype s mty)
@


\subsection*{[[./typing/predef.mli]]}


%-------------------------------------------------------------

<<./typing/predef.mli>>=
<<copyright header>>

(* Predefined type constructors (with special typing rules in typecore) *)

open Types

<<signatures Predef.type_xxx>>

<<signatures Predef.path_xxx>>

<<signature Predef.path_match_failure>>

<<signature Predef.build_initial_env>>

<<signature Predef.builtin_values>>
@


\subsection*{[[./typing/predef.ml]]}



%-------------------------------------------------------------

<<./typing/predef.ml>>=
<<copyright header>>

(* Predefined type constructors (with special typing rules in typecore) *)

open Path
open Types
open Btype

<<constants Predef.ident_xxx>>

<<constants Predef.path_xxx>>

<<constants Predef.type_xxx>>

<<constants Predef.ident_exn_xxx>>


<<constant Predef.path_match_failure>>

<<function Predef.build_initial_env>>

<<constant Predef.builtin_values>>
@


\subsection*{[[./typing/datarepr.mli]]}

<<signature Datarepr.constructor_descrs>>=
val constructor_descrs:
  type_expr -> (string * type_expr list) list ->
    (string * constructor_description) list
@

<<signature Datarepr.exception_descr>>=
val exception_descr:
  Path.t -> type_expr list -> constructor_description
@

<<signature Datarepr.label_descrs>>=
val label_descrs:
  type_expr -> (string * mutable_flag * type_expr) list ->
    (string * label_description) list
@


%-------------------------------------------------------------

<<./typing/datarepr.mli>>=
<<copyright header>>

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Asttypes
open Types

<<signature Datarepr.constructor_descrs>>
<<signature Datarepr.exception_descr>>
<<signature Datarepr.label_descrs>>
@


\subsection*{[[./typing/datarepr.ml]]}

<<function Datarepr.constructor_descrs>>=
let constructor_descrs ty_res cstrs =
  let num_consts = ref 0 and num_nonconsts = ref 0 in
  List.iter
    (function (name, []) -> incr num_consts
            | (name, _)  -> incr num_nonconsts)
    cstrs;
  let rec describe_constructors idx_const idx_nonconst = function
      [] -> []
    | (name, ty_args) :: rem ->
        let (tag, descr_rem) =
          match ty_args with
            [] -> (Cstr_constant idx_const,
                   describe_constructors (idx_const+1) idx_nonconst rem)
          | _  -> (Cstr_block idx_nonconst,
                   describe_constructors idx_const (idx_nonconst+1) rem) in
        let cstr =
          { cstr_res = ty_res;
            cstr_args = ty_args;
            cstr_arity = List.length ty_args;
            cstr_tag = tag;
            cstr_consts = !num_consts;
            cstr_nonconsts = !num_nonconsts } in
        (name, cstr) :: descr_rem in
  describe_constructors 0 0 cstrs
@

<<function Datarepr.exception_descr>>=
let exception_descr path_exc decl =
  { cstr_res = Predef.type_exn;
    cstr_args = decl;
    cstr_arity = List.length decl;
    cstr_tag = Cstr_exception path_exc;
    cstr_consts = -1;
    cstr_nonconsts = -1 }
@

<<constant Datarepr.none>>=
let none = {desc = Ttuple []; level = -1}
                                        (* Clearly ill-formed type *)
@

<<constant Datarepr.dummy_label>>=
let dummy_label =
  { lbl_res = none; lbl_arg = none; lbl_mut = Immutable;
    lbl_pos = (-1); lbl_all = [||]; lbl_repres = Record_regular }
@

<<constant Datarepr.is_float>>=
(* Cannot call ctype.repres here *)

let rec is_float = 
  function
    {desc = Tlink ty} -> is_float ty
  | {desc = Tconstr(p, _, _)} -> Path.same p Predef.path_float
  | _ -> false
@

<<function Datarepr.label_descrs>>=
let label_descrs ty_res lbls =
  let all_labels = Array.create (List.length lbls) dummy_label in
  let repres =
    if List.for_all (fun (name, flag, ty) -> is_float ty) lbls
    then Record_float
    else Record_regular in
  let rec describe_labels num = function
      [] -> []
    | (name, mut_flag, ty_arg) :: rest ->
        let lbl =
          { lbl_res = ty_res;
            lbl_arg = ty_arg;
            lbl_mut = mut_flag;
            lbl_pos = num;
            lbl_all = all_labels;
            lbl_repres = repres } in
        all_labels.(num) <- lbl;
        (name, lbl) :: describe_labels (num+1) rest in
  describe_labels 0 lbls
@


%-------------------------------------------------------------

<<./typing/datarepr.ml>>=
<<copyright header>>

(* Compute constructor and label descriptions from type declarations,
   determining their representation. *)

open Misc
open Asttypes
open Types

<<function Datarepr.constructor_descrs>>

<<function Datarepr.exception_descr>>

<<constant Datarepr.none>>
<<constant Datarepr.dummy_label>>

<<constant Datarepr.is_float>>

<<function Datarepr.label_descrs>>
@


\subsection*{[[./typing/env.mli]]}


<<signature Env.find_module>>=
val find_module: Path.t -> t -> module_type
@

<<signature Env.find_modtype>>=
val find_modtype: Path.t -> t -> modtype_declaration
@

<<signature Env.find_type_expansion>>=
val find_type_expansion: Path.t -> t -> type_expr list * type_expr
@

<<signature Env.find_modtype_expansion>>=
val find_modtype_expansion: Path.t -> t -> Types.module_type
@


<<signature Env.lookup_modtype>>=
val lookup_modtype: Longident.t -> t -> Path.t * modtype_declaration
@

<<signature Env.add_value>>=
(* Insertion by identifier *)

val add_value: Ident.t -> value_description -> t -> t
@

<<signature Env.add_type>>=
val add_type: Ident.t -> type_declaration -> t -> t
@

<<signature Env.add_exception>>=
val add_exception: Ident.t -> exception_declaration -> t -> t
@

<<signature Env.add_module>>=
val add_module: Ident.t -> module_type -> t -> t
@

<<signature Env.add_modtype>>=
val add_modtype: Ident.t -> modtype_declaration -> t -> t
@

<<signature Env.add_item>>=
(* Insertion of all fields of a signature. *)

val add_item: signature_item -> t -> t
@

<<signature Env.add_signature>>=
val add_signature: signature -> t -> t
@

<<signature Env.open_signature>>=
(* Insertion of all fields of a signature, relative to the given path.
   Used to implement open. *)

val open_signature: Path.t -> signature -> t -> t
@

<<signature Env.open_pers_signature>>=
val open_pers_signature: string -> t -> t
@

<<signature Env.enter_value>>=
(* Insertion by name *)

val enter_value: string -> value_description -> t -> Ident.t * t
@

<<signature Env.enter_exception>>=
val enter_exception: string -> exception_declaration -> t -> Ident.t * t
@

<<signature Env.enter_module>>=
val enter_module: string -> module_type -> t -> Ident.t * t
@

<<signature Env.enter_modtype>>=
val enter_modtype: string -> modtype_declaration -> t -> Ident.t * t
@

<<signature Env.reset_cache>>=
(* Reset the cache of in-core module interfaces.
   To be called in particular when load_path changes. *)

val reset_cache: unit -> unit
@

<<signature Env.read_signature>>=
(* Read, save a signature to/from a file *)

val read_signature: string -> string -> signature
        (* Arguments: module name, file name. Results: signature. *)
@

<<signature Env.save_signature>>=
val save_signature: signature -> string -> string -> unit
        (* Arguments: signature, module name, file name. *)
@

<<signature Env.imported_units>>=
(* Return the set of compilation units imported, with their CRC *)

val imported_units: unit -> (string * Digest.t) list
@

<<type Env.summary>>=
(* Summaries -- compact representation of an environment, to be
   exported in debugging information. *)

type summary =
    Env_empty
  | Env_value of summary * Ident.t * value_description
  | Env_type of summary * Ident.t * type_declaration
  | Env_exception of summary * Ident.t * exception_declaration
  | Env_module of summary * Ident.t * module_type
  | Env_modtype of summary * Ident.t * modtype_declaration
  | Env_open of summary * Path.t
@

<<signature Env.summary>>=
val summary: t -> summary
@


<<signature Env.check_modtype_inclusion>>=
(* Forward declaration to break mutual recursion with includemod. *)

val check_modtype_inclusion: (t -> module_type -> module_type -> unit) ref
@


%-------------------------------------------------------------

<<./typing/env.mli>>=
<<copyright header>>

(* Environment handling *)

open Types

<<signature type Env.t>>

<<signature Env.empty>>
<<signature Env.initial>>

(* Lookup by paths *)

<<signature Env.find_value>>
<<signature Env.find_type>>
<<signature Env.find_module>>
<<signature Env.find_modtype>>

<<signature Env.find_type_expansion>>
<<signature Env.find_modtype_expansion>>

(* Lookup by long identifiers *)

<<signature Env.lookup_value>>
<<signature Env.lookup_constructor>>
<<signature Env.lookup_label>>
<<signature Env.lookup_type>>
<<signature Env.lookup_module>>
<<signature Env.lookup_modtype>>

<<signature Env.add_value>>
<<signature Env.add_type>>
<<signature Env.add_exception>>
<<signature Env.add_module>>
<<signature Env.add_modtype>>

<<signature Env.add_item>>
<<signature Env.add_signature>>

<<signature Env.open_signature>>
<<signature Env.open_pers_signature>>

<<signature Env.enter_value>>
<<signature Env.enter_exception>>
<<signature Env.enter_module>>
<<signature Env.enter_modtype>>

<<signature Env.reset_cache>>

<<signature Env.read_signature>>
<<signature Env.save_signature>>

<<signature Env.imported_units>>

<<type Env.summary>>

<<signature Env.summary>>

<<type Env.error>>

<<exception Env.Error>>

<<signature Env.report_error>>

<<signature Env.check_modtype_inclusion>>
@


\subsection*{[[./typing/env.ml]]}


<<type Env.module_components>>=
and module_components =
    Structure_comps of structure_components
@

<<type Env.structure_components>>=
and structure_components = {
  mutable comp_values: (string, (value_description * int)) Tbl.t;
  mutable comp_constrs: (string, (constructor_description * int)) Tbl.t;
  mutable comp_labels: (string, (label_description * int)) Tbl.t;
  mutable comp_types: (string, (type_declaration * int)) Tbl.t;
  mutable comp_modules: (string, (module_type * int)) Tbl.t;
  mutable comp_modtypes: (string, (modtype_declaration * int)) Tbl.t;
  mutable comp_components: (string, (module_components * int)) Tbl.t;
}
@


<<type Env.pers_struct>>=
(* Persistent structure descriptions *)

type pers_struct =
  { ps_name: string;
    ps_sig: signature;
    ps_comps: module_components;
    ps_crcs: (string * Digest.t) list }
@

<<constant Env.persistent_structures>>=
let persistent_structures =
  (Hashtbl.create 17 : (string, pers_struct) Hashtbl.t)
@

<<function Env.read_pers_struct>>=
let read_pers_struct modname filename =
  let ic = open_in_bin filename in
  try
    let buffer = String.create (String.length cmi_magic_number) in
    really_input ic buffer 0 (String.length cmi_magic_number);
    if buffer <> cmi_magic_number then begin
      close_in ic;
      raise(Error(Not_an_interface filename))
    end;
    let (name, sign, comps) = input_value ic in
    let crcs = input_value ic in
    close_in ic;
    let ps = { ps_name = name;
               ps_sig = sign;
               ps_comps = comps;
               ps_crcs = crcs } in
    if ps.ps_name <> modname then
      raise(Error(Illegal_renaming(ps.ps_name, filename)));
    Hashtbl.add persistent_structures modname ps;
    ps
  with End_of_file | Failure _ ->
    close_in ic;
    raise(Error(Corrupted_interface(filename)))
@

<<function Env.find_pers_struct>>=
let find_pers_struct name =
  try
    Hashtbl.find persistent_structures name
  with Not_found ->
    read_pers_struct name
      (find_in_path !load_path (String.uncapitalize name ^ ".cmi"))
@

<<function Env.reset_cache>>=
let reset_cache() =
  Hashtbl.clear persistent_structures
@

<<constant Env.check_modtype_inclusion>>=
(* Forward declarations *)

let check_modtype_inclusion =
  (* to be filled with includemod.check_modtype_inclusion *)
  ref ((fun env mty1 mty2 -> fatal_error "Env.include_modtypes") :
       t -> module_type -> module_type -> unit)
@

<<function Env.find_module_descr>>=
(* Lookup by identifier *)

let rec find_module_descr path env =
  match path with
    Pident id ->
      begin try
        let (p, desc) = Ident.find_same id env.components
        in desc
      with Not_found ->
        if Ident.persistent id
        then (find_pers_struct (Ident.name id)).ps_comps
        else raise Not_found
      end
  | Pdot(p, s, pos) ->
      begin match find_module_descr p env with
        Structure_comps c ->
          let (descr, pos) = Tbl.find s c.comp_components in
          descr
      end
@

<<function Env.find>>=
let find proj1 proj2 path env =
  match path with
    Pident id ->
      let (p, data) = Ident.find_same id (proj1 env)
      in data
  | Pdot(p, s, pos) ->
      begin match find_module_descr p env with
        Structure_comps c ->
          let (data, pos) = Tbl.find s (proj2 c) in data
      end
@

<<function Env.find_type_expansion>>=
let find_type_expansion path env =
  let decl = find_type path env in
  match decl.type_manifest with
    None      -> raise Not_found
  | Some body -> (decl.type_params, body)
@

<<function Env.find_modtype_expansion>>=
let find_modtype_expansion path env =
  match find_modtype path env with
    Tmodtype_abstract     -> raise Not_found
  | Tmodtype_manifest mty -> mty
@

<<function Env.find_module>>=
(* @Scheck: used by the debugger *)
let find_module path env =
  match path with
    Pident id ->
      begin try
        let (p, data) = Ident.find_same id env.modules
        in data
      with Not_found ->
        if Ident.persistent id then
          let ps = find_pers_struct (Ident.name id) in
          Tmty_signature(ps.ps_sig)
        else raise Not_found
      end
  | Pdot(p, s, pos) ->
      begin match find_module_descr p env with
        Structure_comps c ->
          let (data, pos) = Tbl.find s c.comp_modules in data
      end
@

<<function Env.lookup>>=
let lookup proj1 proj2 lid env =
  match lid with
    Lident s ->
      Ident.find_name s (proj1 env)
  | Ldot(l, s) ->
      begin match lookup_module_descr l env with
        (p, Structure_comps c) ->
          let (data, pos) = Tbl.find s (proj2 c) in
          (Pdot(p, s, pos), data)
      end
@

<<function Env.lookup_simple>>=
let lookup_simple proj1 proj2 lid env =
  match lid with
    Lident s ->
      Ident.find_name s (proj1 env)
  | Ldot(l, s) ->
      begin match lookup_module_descr l env with
        (p, Structure_comps c) ->
          let (data, pos) = Tbl.find s (proj2 c) in
          data
      end
@

<<function Env.scrape_modtype>>=
(* Scrape a module type *)

let rec scrape_modtype mty env =
  match mty with
    Tmty_ident path ->
      begin try
        scrape_modtype (find_modtype_expansion path env) env
      with Not_found ->
        mty
      end
  | _ -> mty
@

<<function Env.constructors_of_type>>=
(* Compute constructor descriptions *)

let constructors_of_type ty_path decl =
  match decl.type_kind with
    Type_variant cstrs ->
      Datarepr.constructor_descrs
        (Btype.newgenty (Tconstr(ty_path, decl.type_params, ref Mnil)))
        cstrs
  | _ -> []
@

<<function Env.labels_of_type>>=
(* Compute label descriptions *)

let labels_of_type ty_path decl =
  match decl.type_kind with
    Type_record labels ->
      Datarepr.label_descrs
        (Btype.newgenty (Tconstr(ty_path, decl.type_params, ref Mnil)))
        labels
  | _ -> []
@

<<function Env.prefix_idents>>=
(* Given a signature and a root path, prefix all idents in the signature
   by the root path and build the corresponding substitution. *)

let rec prefix_idents root pos sub = function
    [] -> ([], sub)
  | Tsig_value(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let nextpos = match decl.val_kind with Val_prim _ -> pos | _ -> pos+1 in
      let (pl, final_sub) = prefix_idents root nextpos sub rem in
      (p::pl, final_sub)
  | Tsig_type(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos (Subst.add_type id p sub) rem in
      (p::pl, final_sub)
  | Tsig_exception(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) = prefix_idents root (pos+1) sub rem in
      (p::pl, final_sub)
  | Tsig_module(id, mty) :: rem ->
      let p = Pdot(root, Ident.name id, pos) in
      let (pl, final_sub) =
        prefix_idents root (pos+1) (Subst.add_module id p sub) rem in
      (p::pl, final_sub)
  | Tsig_modtype(id, decl) :: rem ->
      let p = Pdot(root, Ident.name id, nopos) in
      let (pl, final_sub) =
        prefix_idents root pos
                      (Subst.add_modtype id (Tmty_ident p) sub) rem in
      (p::pl, final_sub)
@

<<constant Env.funappl_memo>>=
(* Memoized function to compute the components of a functor application
   in a path. *)

let funappl_memo =
@

<<function Env.enter>>=
(* Insertion of bindings by name *)

let enter store_fun name data env =
  let id = Ident.create name in (id, store_fun id (Pident id) data env)
@

<<function Env.add_item>>=
(* Insertion of all components of a signature *)

let add_item comp env =
  match comp with
    Tsig_value(id, decl) -> add_value id decl env
  | Tsig_type(id, decl) -> add_type id decl env
  | Tsig_exception(id, decl) -> add_exception id decl env
  | Tsig_module(id, mty) -> add_module id mty env
  | Tsig_modtype(id, decl) -> add_modtype id decl env
@

<<function Env.add_signature>>=
let rec add_signature sg env =
  match sg with
    [] -> env
  | comp :: rem -> add_signature rem (add_item comp env)
@

<<function Env.open_signature>>=
(* Open a signature path *)

let open_signature root sg env =
  (* First build the paths and substitution *)
  let (pl, sub) = prefix_idents root 0 Subst.identity sg in
  (* Then enter the components in the environment after substitution *)
  let newenv =
    List.fold_left2
      (fun env item p ->
        match item with
          Tsig_value(id, decl) ->
            store_value (Ident.hide id) p
                        (Subst.value_description sub decl) env
        | Tsig_type(id, decl) ->
            store_type (Ident.hide id) p
                       (Subst.type_declaration sub decl) env
        | Tsig_exception(id, decl) ->
            store_exception (Ident.hide id) p
                            (Subst.exception_declaration sub decl) env
        | Tsig_module(id, mty) ->
            store_module (Ident.hide id) p (Subst.modtype sub mty) env
        | Tsig_modtype(id, decl) ->
            store_modtype (Ident.hide id) p
                          (Subst.modtype_declaration sub decl) env
      )
      env sg pl in
  { values = newenv.values;
    constrs = newenv.constrs;
    labels = newenv.labels;
    types = newenv.types;
    modules = newenv.modules;
    modtypes = newenv.modtypes;
    components = newenv.components;
    summary = Env_open(env.summary, root) }
@

<<function Env.open_pers_signature>>=
(* Open a signature from a file *)

let open_pers_signature name env =
  let ps = find_pers_struct name in
  open_signature (Pident(Ident.create_persistent name)) ps.ps_sig env
@

<<function Env.read_signature>>=
(* Read a signature from a file *)

let read_signature modname filename =
  let ps = read_pers_struct modname filename in ps.ps_sig
@

<<function Env.imported_units>>=
(* Return the list of imported interfaces with their CRCs *)

let imported_units() =
  let imported_units =
    ref ([] : (string * Digest.t) list) in
  let units_xref =
    (Hashtbl.create 13 : (string, Digest.t * string) Hashtbl.t) in
  let add_unit source (name, crc) =
    try
      let (oldcrc, oldsource) = Hashtbl.find units_xref name in
      if oldcrc <> crc then
        raise(Error(Inconsistent_import(name, oldsource, source)))
    with Not_found ->
      Hashtbl.add units_xref name (crc, source);
      imported_units := (name, crc) :: !imported_units in
  Hashtbl.iter
    (fun name ps -> List.iter (add_unit ps.ps_name) ps.ps_crcs)
    persistent_structures;
  !imported_units
@

<<function Env.save_signature>>=
(* Save a signature to a file *)

let save_signature sg modname filename =
  Btype.cleanup_abbrev ();
  let oc = open_out_bin filename in
  output_string oc cmi_magic_number;
  let comps =
    components_of_module empty Subst.identity
       (Pident(Ident.create_persistent modname)) (Tmty_signature sg) in
  output_value oc (modname, sg, comps);
  flush oc;
  let crc = Digest.file filename in
  let crcs = (modname, crc) :: imported_units() in
  output_value oc crcs;
  close_out oc;
  (* Enter signature in persistent table so that imported_unit()
     will also return its crc *)
  let ps =
    { ps_name = modname; ps_sig = sg; ps_comps = comps; ps_crcs = crcs } in
  Hashtbl.add persistent_structures modname ps
@

<<constant Env.initial>>=
(* Make the initial environment *)

let initial = Predef.build_initial_env add_type add_exception empty
@

<<function Env.summary>>=
(* Return the environment summary *)

let summary env = env.summary
@

<<constant Env.report_error>>=
(* Error report *)

let report_error = function
    Not_an_interface filename ->
      print_string filename; print_space();
      print_string "is not a compiled interface."
  | Corrupted_interface filename ->
      print_string "Corrupted compiled interface"; print_space();
      print_string filename
  | Illegal_renaming(modname, filename) ->
      print_string "Wrong file naming:"; print_space();
      print_string filename; print_space();
      print_string "contains the compiled interface for"; print_space();
      print_string modname
  | Inconsistent_import(name, source1, source2) ->
      open_hvbox 0;
      print_string "The compiled interfaces for "; print_string source1;
      print_string " and "; print_string source2; print_space();
      print_string "make inconsistent assumptions over interface ";
      print_string name;
      close_box()
@


%-------------------------------------------------------------

<<./typing/env.ml>>=
<<copyright header>>

(* Environment handling *)

open Format
open Config
open Misc
open Asttypes
open Longident
open Path
open Types


<<type Env.error>>

<<exception Env.Error>>

<<type Env.summary>>

<<type Env.t>>

<<type Env.module_components>>


<<type Env.structure_components>>


<<constant Env.empty>>

<<type Env.pers_struct>>

<<constant Env.persistent_structures>>

<<function Env.read_pers_struct>>

<<function Env.find_pers_struct>>

<<function Env.reset_cache>>

<<constant Env.check_modtype_inclusion>>

<<function Env.find_module_descr>>

<<function Env.find>>

let find_value =
  find (fun env -> env.values) (fun sc -> sc.comp_values)
and find_type =
  find (fun env -> env.types) (fun sc -> sc.comp_types)
and find_modtype =
  find (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)

<<function Env.find_type_expansion>>

<<function Env.find_modtype_expansion>>

<<function Env.find_module>>

(* Lookup by name *)

let rec lookup_module_descr lid env =
  match lid with
    Lident s ->
      begin try
        Ident.find_name s env.components
      with Not_found ->
        let ps = find_pers_struct s in
        (Pident(Ident.create_persistent s), ps.ps_comps)
      end
  | Ldot(l, s) ->
      let (p, descr) = lookup_module_descr l env in
      begin match descr with
        Structure_comps c ->
          let (descr, pos) = Tbl.find s c.comp_components in
          (Pdot(p, s, pos), descr)
      end

and lookup_module lid env =
  match lid with
    Lident s ->
      begin try
        Ident.find_name s env.modules
      with Not_found ->
        let ps = find_pers_struct s in
        (Pident(Ident.create_persistent s), Tmty_signature ps.ps_sig)
      end
  | Ldot(l, s) ->
      let (p, descr) = lookup_module_descr l env in
      begin match descr with
        Structure_comps c ->
          let (data, pos) = Tbl.find s c.comp_modules in
          (Pdot(p, s, pos), data)
      end

<<function Env.lookup>>

<<function Env.lookup_simple>>

let lookup_value =
  lookup (fun env -> env.values) (fun sc -> sc.comp_values)
and lookup_constructor =
  lookup_simple (fun env -> env.constrs) (fun sc -> sc.comp_constrs)
and lookup_label =
  lookup_simple (fun env -> env.labels) (fun sc -> sc.comp_labels)
and lookup_type =
  lookup (fun env -> env.types) (fun sc -> sc.comp_types)
and lookup_modtype =
  lookup (fun env -> env.modtypes) (fun sc -> sc.comp_modtypes)
  
<<function Env.scrape_modtype>>

<<function Env.constructors_of_type>>

<<function Env.labels_of_type>>

<<function Env.prefix_idents>>

(* Compute structure descriptions *)

let rec components_of_module env sub path mty =
  match scrape_modtype mty env with
    Tmty_signature sg ->
      let c =
        { comp_values = Tbl.empty; comp_constrs = Tbl.empty;
          comp_labels = Tbl.empty; comp_types = Tbl.empty;
          comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
          comp_components = Tbl.empty; } in
      let (pl, sub) = prefix_idents path 0 sub sg in
      let env = ref env in
      let pos = ref 0 in
      List.iter2 (fun item path ->
        match item with
          Tsig_value(id, decl) ->
            let decl' = Subst.value_description sub decl in
            c.comp_values <-
              Tbl.add (Ident.name id) (decl', !pos) c.comp_values;
            begin match decl.val_kind with
              Val_prim _ -> () | _ -> incr pos
            end
        | Tsig_type(id, decl) ->
            let decl' = Subst.type_declaration sub decl in
            c.comp_types <-
              Tbl.add (Ident.name id) (decl', nopos) c.comp_types;
            List.iter
              (fun (name, descr) ->
                c.comp_constrs <- Tbl.add name (descr, nopos) c.comp_constrs)
              (constructors_of_type path decl');
            List.iter
              (fun (name, descr) ->
                c.comp_labels <- Tbl.add name (descr, nopos) c.comp_labels)
              (labels_of_type path decl')
        | Tsig_exception(id, decl) ->
            let decl' = Subst.exception_declaration sub decl in
            let cstr = Datarepr.exception_descr path decl' in
            c.comp_constrs <-
              Tbl.add (Ident.name id) (cstr, !pos) c.comp_constrs;
            incr pos
        | Tsig_module(id, mty) ->
            let mty' = Subst.modtype sub mty in
            c.comp_modules <-
              Tbl.add (Ident.name id) (mty', !pos) c.comp_modules;
            let comps = components_of_module !env sub path mty in
            c.comp_components <-
              Tbl.add (Ident.name id) (comps, !pos) c.comp_components;
            env := store_components id path comps !env;
            incr pos
        | Tsig_modtype(id, decl) ->
            let decl' = Subst.modtype_declaration sub decl in
            c.comp_modtypes <-
              Tbl.add (Ident.name id) (decl', nopos) c.comp_modtypes;
            env := store_modtype id path decl' !env
        )
        sg pl;
        Structure_comps c
  | Tmty_ident p ->
        Structure_comps {
          comp_values = Tbl.empty; comp_constrs = Tbl.empty;
          comp_labels = Tbl.empty; comp_types = Tbl.empty;
          comp_modules = Tbl.empty; comp_modtypes = Tbl.empty;
          comp_components = Tbl.empty; }

(* Insertion of bindings by identifier + path *)

and store_value id path decl env =
  { values = Ident.add id (path, decl) env.values;
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
    modtypes = env.modtypes;
    components = env.components;
    summary = Env_value(env.summary, id, decl) }

and store_type id path info env =
  { values = env.values;
    constrs =
      List.fold_right
        (fun (name, descr) constrs ->
          Ident.add (Ident.create name) descr constrs)
        (constructors_of_type path info)
        env.constrs;
    labels =
      List.fold_right
        (fun (name, descr) labels ->
          Ident.add (Ident.create name) descr labels)
        (labels_of_type path info)
        env.labels;
    types = Ident.add id (path, info) env.types;
    modules = env.modules;
    modtypes = env.modtypes;
    components = env.components;
    summary = Env_type(env.summary, id, info) }

and store_exception id path decl env =
  { values = env.values;
    constrs = Ident.add id (Datarepr.exception_descr path decl) env.constrs;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
    modtypes = env.modtypes;
    components = env.components;
    summary = Env_exception(env.summary, id, decl) }

and store_module id path mty env =
  { values = env.values;
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
    modules = Ident.add id (path, mty) env.modules;
    modtypes = env.modtypes;
    components =
      Ident.add id (path, components_of_module env Subst.identity path mty)
                   env.components;
    summary = Env_module(env.summary, id, mty) }

and store_modtype id path info env =
  { values = env.values;
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
    modtypes = Ident.add id (path, info) env.modtypes;
    components = env.components;
    summary = Env_modtype(env.summary, id, info) }

and store_components id path comps env =
  { values = env.values;
    constrs = env.constrs;
    labels = env.labels;
    types = env.types;
    modules = env.modules;
    modtypes = env.modtypes;
    components = Ident.add id (path, comps) env.components;
    summary = env.summary }


<<constant Env.funappl_memo>>
  (Hashtbl.create 17 : (Path.t, module_components) Hashtbl.t)

(* Insertion of bindings by identifier *)

let add_value id desc env =
  store_value id (Pident id) desc env

and add_type id info env =
  store_type id (Pident id) info env

and add_exception id decl env =
  store_exception id (Pident id) decl env

and add_module id mty env =
  store_module id (Pident id) mty env

and add_modtype id info env =
  store_modtype id (Pident id) info env

<<function Env.enter>>

let enter_value = enter store_value
and enter_exception = enter store_exception
and enter_module = enter store_module
and enter_modtype = enter store_modtype

<<function Env.add_item>>

<<function Env.add_signature>>

<<function Env.open_signature>>
  
<<function Env.open_pers_signature>>

<<function Env.read_signature>>

<<function Env.imported_units>>

<<function Env.save_signature>>

<<constant Env.initial>>

<<function Env.summary>>

<<constant Env.report_error>>
@


\subsection*{[[./typing/typedtree.mli]]}


<<signature Typedtree.let_bound_idents>>=
(* Auxiliary functions over the a.s.t. *)

val let_bound_idents: (pattern * expression) list -> Ident.t list
@

<<signature Typedtree.rev_let_bound_idents>>=
val rev_let_bound_idents: (pattern * expression) list -> Ident.t list
@


%-------------------------------------------------------------

<<./typing/typedtree.mli>>=
<<copyright header>>

(* Abstract syntax tree after typing *)

open Asttypes
open Types

(* Value expressions for the core language *)

<<type Typedtree.pattern>>

<<type Typedtree.pattern_desc>>

<<type Typedtree.expression>>

<<type Typedtree.expression_desc>>

(* Value expressions for the module language *)

<<type Typedtree.module_expr>>

<<type Typedtree.module_expr_desc>>

<<type Typedtree.structure>>

<<type Typedtree.structure_item>>

<<type Typedtree.module_coercion>>

<<signature Typedtree.let_bound_idents>>
<<signature Typedtree.rev_let_bound_idents>>
@


\subsection*{[[./typing/typedtree.ml]]}

<<constant Typedtree.idents>>=
(* List the identifiers bound by a pattern or a let *)
let idents = ref([]: Ident.t list)
@

<<function Typedtree.bound_idents>>=
let rec bound_idents pat =
  match pat.pat_desc with
    Tpat_any -> ()
  | Tpat_var id -> idents := id :: !idents
  | Tpat_alias(p, id) -> bound_idents p; idents := id :: !idents
  | Tpat_constant cst -> ()
  | Tpat_tuple patl -> List.iter bound_idents patl
  | Tpat_construct(cstr, patl) -> List.iter bound_idents patl
  | Tpat_record lbl_pat_list ->
      List.iter (fun (lbl, pat) -> bound_idents pat) lbl_pat_list
  | Tpat_or(p1, p2) -> bound_idents p1; bound_idents p2
@

<<function Typedtree.rev_let_bound_idents>>=
let rev_let_bound_idents pat_expr_list =
  idents := [];
  List.iter (fun (pat, expr) -> bound_idents pat) pat_expr_list;
  let res = !idents in idents := []; res
@

<<function Typedtree.let_bound_idents>>=
let let_bound_idents pat_expr_list =
  List.rev(rev_let_bound_idents pat_expr_list)
@


%-------------------------------------------------------------

<<./typing/typedtree.ml>>=
<<copyright header>>

(* Abstract syntax tree after typing *)

open Misc
open Asttypes
open Types

(* Value expressions for the core language *)

<<type Typedtree.pattern>>

<<type Typedtree.pattern_desc>>

<<type Typedtree.expression>>

<<type Typedtree.expression_desc>>

(* Value expressions for the module language *)

<<type Typedtree.module_expr>>

<<type Typedtree.module_expr_desc>>

<<type Typedtree.structure>>

<<type Typedtree.structure_item>>

<<type Typedtree.module_coercion>>

(* Auxiliary functions over the a.s.t. *)

<<constant Typedtree.idents>>

<<function Typedtree.bound_idents>>

<<function Typedtree.rev_let_bound_idents>>

<<function Typedtree.let_bound_idents>>
@


\subsection*{[[./typing/ctype.mli]]}


<<exception Ctype.Cannot_expand>>=
exception Cannot_expand
@

<<exception Ctype.Cannot_apply>>=
exception Cannot_apply
@

<<exception Ctype.Recursive_abbrev>>=
exception Recursive_abbrev
@

<<signature Ctype.init_def>>=
val init_def: int -> unit
        (* Set the initial variable level *)
@

<<signature Ctype.begin_def>>=
val begin_def: unit -> unit
        (* Raise the variable level by one at the beginning of a definition. *)
@

<<signature Ctype.end_def>>=
val end_def: unit -> unit
        (* Lower the variable level by one at the end of a definition *)
@

<<signature Ctype.reset_global_level>>=
val reset_global_level: unit -> unit
@

<<signature Ctype.newty>>=
val newty: type_desc -> type_expr
@

<<signature Ctype.newgenty>>=
val newgenty: type_desc -> type_expr
@

<<signature Ctype.newvar>>=
val newvar: unit -> type_expr
        (* Return a fresh variable *)
@

<<signature Ctype.new_global_var>>=
val new_global_var: unit -> type_expr
        (* Return a fresh variable, bound at toplevel
           (as type variables ['a] in type constraints). *)
@

<<signature Ctype.none>>=
val none: type_expr
        (* A dummy type expression *)
@

<<signature Ctype.repr>>=
val repr: type_expr -> type_expr
        (* Return the canonical representative of a type. *)
@

<<signature Ctype.generalize>>=
val generalize: type_expr -> unit
        (* Generalize in-place the given type *)
@

<<signature Ctype.make_nongen>>=
val make_nongen: type_expr -> unit
        (* Make non-generalizable the given type *)
@

<<signature Ctype.correct_levels>>=
val correct_levels: type_expr -> type_expr
        (* Returns a copy with decreasing levels *)
@

<<signature Ctype.instance>>=
val instance: type_expr -> type_expr
        (* Take an instance of a type scheme *)
@

<<signature Ctype.instance_list>>=
val instance_list: type_expr list -> type_expr list
        (* Take an instance of a list of type schemes *)
@

<<signature Ctype.instance_constructor>>=
val instance_constructor:
        constructor_description -> type_expr list * type_expr
        (* Same, for a constructor *)
@

<<signature Ctype.instance_label>>=
val instance_label: label_description -> type_expr * type_expr
        (* Same, for a label *)
@

<<signature Ctype.instance_parameterized_type>>=
val instance_parameterized_type:
        type_expr list -> type_expr -> type_expr list * type_expr
@

<<signature Ctype.apply>>=
val apply:
        Env.t -> type_expr list -> type_expr -> type_expr list -> type_expr
        (* [apply [p1...pN] t [a1...aN]] match the arguments [ai] to
        the parameters [pi] and returns the corresponding instance of
        [t]. Exception [Cannot_apply] is raised in case of failure. *)
@

<<signature Ctype.expand_head>>=
(*         (* Expand an abbreviation *) *)
val expand_head: Env.t -> type_expr -> type_expr
@

<<signature Ctype.full_expand>>=
val full_expand: Env.t -> type_expr -> type_expr
@

<<signature Ctype.unify>>=
val unify: Env.t -> type_expr -> type_expr -> unit
        (* Unify the two types given. Raise [Unify] if not possible. *)
@

<<signature Ctype.filter_arrow>>=
val filter_arrow: Env.t -> type_expr -> type_expr * type_expr
        (* A special case of unification (with 'a -> 'b). *)
@

<<signature Ctype.moregeneral>>=
val moregeneral: Env.t -> bool -> type_expr -> type_expr -> bool
        (* Check if the first type scheme is more general than the second. *)
@

<<signature Ctype.equal>>=
val equal: Env.t -> bool -> type_expr list -> type_expr list -> bool
        (* [equal env [x1...xn] tau [y1...yn] sigma]
           checks whether the parameterized types
           [/\x1.../\xn.tau] and [/\y1.../\yn.sigma] are equivalent. *)
@

<<signature Ctype.enlarge_type>>=
val enlarge_type: Env.t -> type_expr -> type_expr
        (* Make a type larger *)
@

<<signature Ctype.subtype>>=
val subtype : Env.t -> type_expr -> type_expr -> unit -> unit
        (* [subtype env t1 t2] checks that [t1] is a subtype of [t2].
           It accumulates the constraints the type variables must
           enforce and returns a function that inforce this
           constraints. *)
@

<<signature Ctype.nondep_type>>=
val nondep_type: Env.t -> Ident.t -> type_expr -> type_expr
        (* Return a type equivalent to the given type but without
           references to the given module identifier. Raise [Not_found]
           if no such type exists. *)
@

<<signature Ctype.nondep_type_decl>>=
val nondep_type_decl:
        Env.t -> Ident.t -> Ident.t -> bool -> type_declaration ->
        type_declaration
        (* Same for type declarations. *)
@

<<signature Ctype.correct_abbrev>>=
val correct_abbrev: Env.t -> Ident.t -> type_expr list -> type_expr -> unit
@

<<signature Ctype.cyclic_abbrev>>=
val cyclic_abbrev: Env.t -> Ident.t -> type_expr -> bool
@

<<type Ctype.closed_schema_result>>=
type closed_schema_result = Var of type_expr | Row_var of type_expr
@

<<signature Ctype.closed_schema>>=
val closed_schema: type_expr -> bool
@

<<signature Ctype.unalias>>=
val unalias: type_expr -> type_expr
@

<<signature Ctype.unroll_abbrev>>=
val unroll_abbrev: Ident.t -> type_expr list -> type_expr -> type_expr
@

<<signature Ctype.arity>>=
val arity: type_expr -> int
        (* Return the arity (as for curried functions) of the given type. *)
@


%-------------------------------------------------------------

<<./typing/ctype.mli>>=
<<copyright header>>

(* Operations on core types *)

open Asttypes
open Types

<<exception Ctype.Unify>>
<<exception Ctype.Subtype>>
<<exception Ctype.Cannot_expand>>
<<exception Ctype.Cannot_apply>>
<<exception Ctype.Recursive_abbrev>>

<<signature Ctype.init_def>>
<<signature Ctype.begin_def>>
<<signature Ctype.end_def>>
<<signature Ctype.reset_global_level>>

<<signature Ctype.newty>>
<<signature Ctype.newgenty>>
<<signature Ctype.newvar>>
<<signature Ctype.new_global_var>>
<<signature Ctype.none>>

<<signature Ctype.repr>>

<<signature Ctype.generalize>>
<<signature Ctype.make_nongen>>
<<signature Ctype.correct_levels>>

<<signature Ctype.instance>>
<<signature Ctype.instance_list>>
<<signature Ctype.instance_constructor>>
<<signature Ctype.instance_label>>
<<signature Ctype.instance_parameterized_type>>
<<signature Ctype.apply>>

(* val expand_abbrev: *)
(*         Env.t -> Path.t -> type_expr list -> Types.abbrev_memo ref -> *)
(*         int -> type_expr *)
<<signature Ctype.expand_head>>
<<signature Ctype.full_expand>>

<<signature Ctype.unify>>
<<signature Ctype.filter_arrow>>

<<signature Ctype.moregeneral>>

<<signature Ctype.equal>>

<<signature Ctype.enlarge_type>>
<<signature Ctype.subtype>>

<<signature Ctype.nondep_type>>
<<signature Ctype.nondep_type_decl>>

<<signature Ctype.correct_abbrev>>
<<signature Ctype.cyclic_abbrev>>

<<type Ctype.closed_schema_result>>
<<signature Ctype.closed_schema>>

<<signature Ctype.unalias>>
<<signature Ctype.unroll_abbrev>>
<<signature Ctype.arity>>
@


\subsection*{[[./typing/ctype.ml]]}



<<constant Ctype.current_level>>=
(**** Type level management ****)

let current_level = ref 0
@

<<constant Ctype.global_level>>=
let global_level = ref 1
@

<<function Ctype.init_def>>=
let init_def level = current_level := level
@

<<function Ctype.begin_def>>=
let begin_def () = incr current_level
@

<<function Ctype.end_def>>=
let end_def () = decr current_level
@

<<function Ctype.reset_global_level>>=
let reset_global_level () =
  global_level := !current_level + 1
@

<<function Ctype.newty>>=
(* Re-export generic type creators *)

let newty desc         = { desc = desc; level = !current_level }
@

<<constant Ctype.newgenty>>=
let newgenty           = newgenty
@

<<function Ctype.new_global_ty>>=
let new_global_ty desc = { desc = desc; level = !global_level }
@

<<function Ctype.newvar>>=
let newvar ()          = { desc = Tvar; level = !current_level }
@

<<function Ctype.newmarkedvar>>=
let newmarkedvar () = { desc = Tvar; level = pivot_level - !current_level }
@

<<function Ctype.new_global_var>>=
let new_global_var ()  = new_global_ty Tvar
@

<<constant Ctype.none>>=
let none = newty (Ttuple [])                (* Clearly ill-formed type *)
@

<<constant Ctype.repr>>=
(* Re-export repr *)
let repr = repr
@

<<constant Ctype.try_expand_head'>>=
let try_expand_head' = (* Forward declaration *)
  ref (fun env ty -> raise Cannot_expand)
@

<<function Ctype.update_level>>=
(*
    The level of a type constructor must be greater than its binding
    time. That way, a type constructor cannot escape the scope of its
    definition, as would be the case in
      let x = ref []
      module M = struct type t let _ = (x : t list ref) end
    (without this constraint, the type system would actually be unsound.)
*)
let rec update_level env level ty =
  let ty = repr ty in
  if ty.level > level then begin
    begin match ty.desc with
      Tconstr(p, tl, abbrev)  when level < Path.binding_time p ->
        (* Try first to replace an abbreviation by its expansion. *)
        begin try
          ty.desc <- Tlink (!try_expand_head' env ty);
          update_level env level ty
        with Cannot_expand ->
          (* +++ Levels should be restored... *)
          raise (Unify [])
        end
    | _ ->
        ty.level <- level;
        iter_type_expr (update_level env level) ty
    end
  end
@

<<function Ctype.make_nongen>>=
(* 
   Function [update_level] will never try to expand an abbreviation in
   this case ([current_level] is greater than the binding time of any
   type constructor path). So, it can be called with the empty
   environnement.
*)
let make_nongen ty = update_level Env.empty !current_level ty
@

<<function Ctype.correct_levels>>=
(* Correct the levels of type [ty]. *)
let correct_levels ty =
  Subst.type_expr Subst.identity ty
@

<<constant Ctype.abbreviations>>=
(*
   Generic nodes are duplicated, while non-generic nodes are left
   as-is.
   During instantiation, the description of a generic node is first
   replaced by a link to a stub ([Tlink (newmarkedvar ())]). Once the
   copy is made, it replaces the stub.
   After instantiation, the description of generic node, which was
   stored by [save_desc], must be put back, using [cleanup_types].
   Marked on the copy are removed by [unmark].
*)

let abbreviations = ref (ref Mnil)
  (* Abbreviation memorized. *)
@

<<function Ctype.copy>>=
let rec copy ty =
  let ty = repr ty in
  if ty.level <> generic_level then
    ty
  else begin
    let desc = ty.desc in
    save_desc ty desc;
    let t = newmarkedvar () in          (* Stub *)
    ty.desc <- Tlink t;
    t.desc <-
      begin match desc with
        Tvar ->
          Tvar
      | Tarrow (t1, t2) ->
          Tarrow (copy t1, copy t2)
      | Ttuple tl ->
          Ttuple (List.map copy tl)
      | Tconstr (p, tl, _) ->
          (*
             One must allocate a new reference, so that abbrevia-
             tions belonging to different branches of a type are
             independent.
             Moreover, a reference containing a [Mcons] must be
             shared, so that the memorized expansion of an abbrevi-
             ation can be released by changing the content of just
             one reference.
          *)
          Tconstr (p, List.map copy tl,
                   ref (match ! !abbreviations with
                          Mcons _ -> Mlink !abbreviations
                        | abbrev  -> abbrev))
      | Tnil ->
          Tnil
      | Tlink t -> (* Actually unused *)
          Tlink (copy t)
      end;
    t
  end
@

<<function Ctype.instance>>=
(**** Variants of instantiations ****)

let instance sch =
  let ty = copy sch in
  cleanup_types ();
  unmark_type ty;
  ty
@

<<function Ctype.instance_list>>=
let instance_list schl =
  let tyl = List.map copy schl in
  cleanup_types ();
  List.iter unmark_type tyl;
  tyl
@

<<function Ctype.instance_constructor>>=
let instance_constructor cstr =
  let ty_res = copy cstr.cstr_res in
  let ty_args = List.map copy cstr.cstr_args in
  cleanup_types ();
  List.iter unmark_type ty_args; unmark_type ty_res;
  (ty_args, ty_res)
@

<<function Ctype.instance_label>>=
let instance_label lbl =
  let ty_res = copy lbl.lbl_res in
  let ty_arg = copy lbl.lbl_arg in
  cleanup_types ();
  unmark_type ty_arg; unmark_type ty_res;
  (ty_arg, ty_res)
@

<<function Ctype.instance_parameterized_type>>=
let instance_parameterized_type sch_args sch =
  let ty_args = List.map copy sch_args in
  let ty = copy sch in
  cleanup_types ();
  List.iter unmark_type ty_args; unmark_type ty;
  (ty_args, ty)
@

<<constant Ctype.unify'>>=
(**** Instantiation with parameter substitution ****)

let unify' = (* Forward declaration *)
  ref (fun env ty1 ty2 -> raise (Unify []))
@

<<function Ctype.subst>>=
let rec subst env level abbrev path params args body =
  let old_level = !current_level in
  current_level := level;
  try
    let body0 = newvar () in          (* Stub *)
    begin match path with
      None      -> ()
    | Some path -> memorize_abbrev abbrev path body0
    end;
    abbreviations := abbrev;
    let (params', body') = instance_parameterized_type params body in
    abbreviations := ref Mnil;
    !unify' env body0 body';
    List.iter2 (!unify' env) params' args;
    current_level := old_level;
    body'
  with Unify _ as exn ->
    current_level := old_level;
    raise exn
@

<<function Ctype.apply>>=
(*
   Only the shape of the type matters, not whether is is generic or
   not. [generic_level] might be somewhat slower, but it ensures
   invariants on types are enforced (decreasing levels.), and we don't
   care about efficiency here.
*)
let apply env params body args =
  try
    subst env generic_level (ref Mnil) None params args body
  with
    Unify _ -> raise Cannot_apply
@

<<function Ctype.find_expans>>=
(* Search whether the expansion has been memorized. *)
let rec find_expans p1 =
  function
    Mnil ->
      None
  | Mcons (p2, ty, _) when Path.same p1 p2 ->
      Some ty
  | Mcons (_, _, rem) ->
      find_expans p1 rem
  | Mlink {contents = rem} ->
      find_expans p1 rem
@

<<constant Ctype.previous_env>>=
let previous_env = ref Env.empty
@

<<function Ctype.expand_abbrev>>=
(*
   An abbreviation expansion will fail in either of these cases:
   1. The type constructor does not correspond to a manifest type.
   2. The type constructor is defined in an external file, and this
      file is not in the path (missing -I options).
   3. The type constructor is not in the "local" environment. This can
      happens when a non-generic type variable has been instantiated
      afterwards to the not yet defined type constructor. (Actually,
      this cannot happen at the moment due to the strong constraints
      between type levels and constructor binding time.)
   4. The expansion requires the expansion of another abbreviation,
      and this other expansion fails.
*)
let expand_abbrev env path args abbrev level =
  (* 
     If the environnement has changed, memorized expansions might not
     be correct anymore, and so we flush the cache. This is safe but
     quite pessimistic: it would be enough to flush the cache at the
     ends of structures and signatures.
     +++ Do it !
  *)
  if env != !previous_env then begin
    cleanup_abbrev ();
    previous_env := env
  end;
  match find_expans path !abbrev with
    Some ty ->
      if level <> generic_level then
        update_level env level ty;
      ty
  | None ->
      let (params, body) =
        try Env.find_type_expansion path env with Not_found ->
          raise Cannot_expand
      in
      try
        subst env level abbrev (Some path) params args body
      with Unify _ -> raise Cannot_expand
@

<<function Ctype.try_expand_head>>=
(* Fully expand the head of a type. Raise an exception if the type
   cannot be expanded. *)
let rec try_expand_head env ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr(p, tl, abbrev) ->
      let ty' = expand_abbrev env p tl abbrev ty.level in
      begin try
        try_expand_head env ty'
      with Cannot_expand ->
        repr ty'
      end
  | _ ->
      raise Cannot_expand
@

<<toplevel Ctype._1>>=
let _ = try_expand_head' := try_expand_head
@

<<function Ctype.expand_head>>=
(* Fully expand the head of a type. *)
let rec expand_head env ty =
  try try_expand_head env ty with Cannot_expand -> repr ty
@

<<function Ctype.full_expand>>=
(* Recursively expand the head of a type.
   Also expand #-types. *)
let rec full_expand env ty =
  let ty = repr (expand_head env ty) in
  match ty.desc with
  | _ ->
      ty
@

<<function Ctype.generic_abbrev>>=
(*
   Check whether the abbreviation expands to a well-defined type.
   During the typing of a class, abbreviations for correspondings
   types expand to non-generic types.
*)
let generic_abbrev env path =
  try
    let (_, body) = Env.find_type_expansion path env in
    (repr body).level = generic_level
  with
    Not_found ->
      false
@

<<exception Ctype.Occur>>=
exception Occur
@

<<constant Ctype.visited>>=
(* The marks are already used by [expand_abbrev]... *)
let visited = ref []
@

<<function Ctype.non_recursive_abbrev>>=
let rec non_recursive_abbrev env ty =
  let ty = repr ty in
  if ty == none then raise Recursive_abbrev;
  if not (List.memq ty !visited) then begin
    let level = ty.level in
    visited := ty :: !visited;
    match ty.desc with
      Tconstr(p, args, abbrev) ->
        begin try
          non_recursive_abbrev env (try_expand_head env ty)
        with Cannot_expand ->
          iter_type_expr (non_recursive_abbrev env) ty
        end
    | _ ->
        iter_type_expr (non_recursive_abbrev env) ty
  end
@

<<function Ctype.correct_abbrev>>=
let correct_abbrev env ident params ty =
  visited := [];
  non_recursive_abbrev env
    (subst env generic_level (ref (Mcons (Path.Pident ident, none, Mnil))) None
       [] [] ty);
  visited := []
@

<<function Ctype.occur_rec>>=
let rec occur_rec env visited ty0 ty =
  if ty == ty0  then raise Occur;
  match ty.desc with
    Tconstr(p, tl, abbrev) ->
      begin try
        if List.memq ty visited then raise Occur;
        iter_type_expr (occur_rec env (ty::visited) ty0) ty
      with Occur -> try
        occur_rec env visited ty0 (try_expand_head env ty)
      with Cannot_expand ->
        raise Occur
      end
  | _ ->
      iter_type_expr (occur_rec env visited ty0) ty
@

<<function Ctype.occur>>=
let occur env ty0 ty =
  try occur_rec env [] ty0 ty with Occur -> raise (Unify [])
@

<<function Ctype.expand_trace>>=
(* +++ Move it to some other place ? *)

let expand_trace env trace =
  List.fold_right
    (fun (t1, t2) rem ->
       (repr t1, full_expand env t1)::(repr t2, full_expand env t2)::rem)
    trace []
@

<<constant Ctype.filter_trace>>=
let rec filter_trace =
  function
    (t1, t1')::(t2, t2')::rem ->
      let rem' = filter_trace rem in
      if (t1 == t1') & (t2 == t2')
      then rem'
      else (t1, t1')::(t2, t2')::rem'
  | _ ->
      []
@

<<function Ctype.deep_occur>>=
(* Return whether [t0] occurs in [ty]. Objects are also traversed. *)
let deep_occur t0 ty =
  let rec occur_rec ty =
    let ty = repr ty in
    if ty.level >= lowest_level then begin
      if ty == t0 then raise Occur;
      ty.level <- pivot_level - ty.level;
      iter_type_expr occur_rec ty
    end
  in
  try
    occur_rec ty; unmark_type ty; false
  with Occur ->
    unmark_type ty; true
@

<<function Ctype.unify>>=
let unify env ty1 ty2 =
  try
    unify env ty1 ty2
  with Unify trace ->
    let trace = expand_trace env trace in
    match trace with
      t1::t2::rem ->
        raise (Unify (t1::t2::filter_trace rem))
    | _ ->
        fatal_error "Ctype.unify"
@

<<toplevel Ctype._2>>=
let _ = unify' := unify
@

<<function Ctype.filter_arrow>>=
(* Unify [t] and ['a -> 'b]. Return ['a] and ['b]. *)
let rec filter_arrow env t =
  let t = expand_head env t in
  match t.desc with
    Tvar ->
      let t1 = newvar () and t2 = newvar () in
      let t' = newty (Tarrow (t1, t2)) in
      update_level env t.level t';
      t.desc <- Tlink t';
      (t1, t2)
  | Tarrow(t1, t2) ->
      (t1, t2)
  | _ ->
      raise (Unify [])
@

<<function Ctype.moregen_occur>>=
(*
   Update the level of [ty]. First check that the levels of variables
   from the subject are not lowered.
*)
let moregen_occur env level ty = 
  let rec occur ty =
    let ty = repr ty in
    if ty.level > level then begin
      if ty.desc = Tvar then raise Occur;
      ty.level <- pivot_level - ty.level;
      iter_type_expr occur ty
    end
  in
  begin try
    occur ty; unmark_type ty
  with Occur ->
    unmark_type ty; raise (Unify [])
  end;
  update_level env level ty
@

<<function Ctype.moregeneral>>=
(*
   Non-generic variable can be instanciated only if [inst_nongen] is
   true. So, [inst_nongen] should be set to false if the subject might
   contain non-generic variables.
   Usually, the subject is given by the user, and the pattern
   is unimportant.  So, no need to propagate abbreviations.
*)
let moregeneral env inst_nongen pat_sch subj_sch =
  let type_pairs = ref [] in

  let rec moregen env t1 t2 =
    if t1 == t2 then () else
    let t1 = repr t1 in
    let t2 = repr t2 in
    if t1 == t2 then () else

    match (t1.desc, t2.desc) with
      (Tvar, _) when if inst_nongen then t1.level <> generic_level - 1
                                    else t1.level =  generic_level ->
        moregen_occur env t1.level t2;
        t1.desc <- Tlink t2
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        ()
    | _ ->
        let t1' = expand_head env t1 in
        let t2' = expand_head env t2 in
        (* Expansion may have changed the representative of the types... *)
        let t1' = repr t1' and t2' = repr t2' in
        if t1' == t2' then () else
        if
          List.exists (function (t1, t2) -> t1 == t1' && t2 == t2') !type_pairs
        then
          ()
        else begin
          type_pairs := (t1', t2') :: !type_pairs;

          match (t1'.desc, t2'.desc) with
            (Tvar, _) when if inst_nongen then t1'.level <> generic_level - 1
                                          else t1'.level =  generic_level ->
              moregen_occur env t1'.level t2;
              t1'.desc <- Tlink t2
          | (Tarrow (t1, u1), Tarrow (t2, u2)) ->
              moregen env t1 t2; moregen env u1 u2
          | (Ttuple tl1, Ttuple tl2) ->
              moregen_list env tl1 tl2
          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
                when Path.same p1 p2 ->
              moregen_list env tl1 tl2
          | (Tnil, Tnil) ->
              ()
          | (_, _) ->
              raise (Unify [])
        end

  and moregen_list env tl1 tl2 =
    if List.length tl1 <> List.length tl2 then
      raise (Unify []);
    List.iter2 (moregen env) tl1 tl2

  in
  let old_level = !current_level in
  current_level := generic_level - 1;
  (*
     Generic variables are first duplicated with [instance].  So,
     their levels are lowered to [generic_level - 1].  The subject is
     then copied with [correct_levels].  That way, its levels won't be
     changed.
  *)
  let subj = correct_levels (instance subj_sch) in
  current_level := generic_level;
  (* Duplicate generic variables *)
  let patt = instance pat_sch in
  let res = try moregen env patt subj; true with Unify _ -> false in
  current_level := old_level;
  res
@

<<function Ctype.equal>>=
(* Two modes: with or without renaming of variables *)

let equal env rename tyl1 tyl2 =
  let subst = ref [] in
  let type_pairs = ref [] in

  let rec eqtype t1 t2 =
    if t1 == t2 then true else
    let t1 = repr t1 in
    let t2 = repr t2 in
    if t1 == t2 then true else
    match (t1.desc, t2.desc) with
    | (Tvar, Tvar) when rename ->
        begin try
          List.assq t1 !subst == t2
        with Not_found ->
          subst := (t1, t2) :: !subst;
          true
        end
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        true
    | _ ->
        let t1 = expand_head env t1 in
        let t2 = expand_head env t2 in
        (* Expansion may have changed the representative of the types... *)
        let t1 = repr t1 and t2 = repr t2 in
        if t1 == t2 then true else
        List.exists (function (t1', t2') -> t1 == t1' & t2 == t2') !type_pairs
              (* XXX Possibly slow... *)
          ||
        begin
          type_pairs := (t1, t2) :: !type_pairs;
          match (t1.desc, t2.desc) with
            (Tvar, Tvar) when rename ->
              begin try
                List.assq t1 !subst == t2
              with Not_found ->
                subst := (t1, t2) :: !subst;
                true
              end
          | (Tarrow (t1, u1), Tarrow (t2, u2)) ->
              eqtype t1 t2 && eqtype u1 u2
          | (Ttuple tl1, Ttuple tl2) ->
              eqtype_list tl1 tl2
          | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _))
                when Path.same p1 p2 ->
              eqtype_list tl1 tl2
          | (Tnil, Tnil) ->
              true
          | (_, _) ->
              false
        end

  and eqtype_list tl1 tl2 =
    List.length tl1 = List.length tl2
                   &&
    List.for_all2 eqtype tl1 tl2

  in
    eqtype_list tyl1 tyl2
@

<<constant Ctype.subtypes>>=
(**** Build a subtype of a given type. ****)

let subtypes = ref []
@

<<function Ctype.build_subtype>>=
(* XXX Types rcursifs ? *)
let rec build_subtype env t =
  let t = repr t in
  match t.desc with
    Tlink t' ->                         (* Redundant ! *)
      build_subtype env t'
  | Tvar ->
      (t, false)
  | Tarrow(t1, t2) ->
      let (t1', c1) = (t1, false) in
      let (t2', c2) = build_subtype env t2 in
      if c1 or c2 then (new_global_ty (Tarrow(t1', t2')), true)
      else (t, false)
  | Ttuple tlist ->
      let (tlist', clist) =
        List.split (List.map (build_subtype env) tlist)
      in
      if List.exists (function c -> c) clist then
        (new_global_ty (Ttuple tlist'), true)
      else (t, false)
  | Tconstr(p, tl, abbrev) when generic_abbrev env p ->
      let t' = expand_abbrev env p tl abbrev t.level in
      let (t'', c) = build_subtype env t' in
      if c then (t'', true)
      else (t, false)
  | Tconstr(p, tl, abbrev) ->
      (t, false)
  | Tnil ->
      let v = new_global_var () in
      (v, true)
@

<<function Ctype.enlarge_type>>=
let enlarge_type env ty =
  subtypes := [];
  let (ty', _) = build_subtype env ty in
  subtypes := [];
  ty'
@

<<constant Ctype.subtypes (./typing/ctype.ml)>>=
(*
    During the traversal, a trace of visited types is maintained. It
    is printed in case of error.
    Constraints (pairs of types that must be equals) are accumulated
    rather than being enforced straight. Indeed, the result would
    otherwise depend on the order in which these constraints are
    enforced.
    A function enforcing these constraints is returned. That way, type
    variables can be bound to their actual values before this function
    is called (see Typecore).
    Only well-defined abbreviations are expanded (hence the tests
    [generic_abbrev ...]).
*)

let subtypes = ref [];;
@

<<function Ctype.subtype_error>>=
let subtype_error env trace =
  raise (Subtype (expand_trace env (List.rev trace), []))
@

<<function Ctype.subtype>>=
let subtype env ty1 ty2 =
  subtypes := [];
  (* Build constraint set. *)
  let cstrs = subtype_rec env [(ty1, ty2)] ty1 ty2 in
  (* Enforce constraints. *)
  function () ->
    List.iter
      (function (trace0, t1, t2) ->
         try unify env t1 t2 with Unify trace ->
           raise (Subtype (expand_trace env (List.rev trace0),
                           List.tl (List.tl trace))))
      cstrs;
    subtypes := []
@

<<function Ctype.unalias>>=
let unalias ty =
  let ty = repr ty in
  match ty.desc with
    Tvar ->
      ty
  | _ ->
      {desc = ty.desc; level = ty.level}
@

<<function Ctype.unroll_abbrev>>=
let unroll_abbrev id tl ty =
  let ty = repr ty in
  if (ty.desc = Tvar) || (List.exists (deep_occur ty) tl) then
    ty
  else
    let ty' = {desc = ty.desc; level = ty.level} in
    ty.desc <- Tlink {desc = Tconstr (Path.Pident id, tl, ref Mnil);
                      level = ty.level};
    ty'
@

<<function Ctype.arity>>=
(* Return the arity (as for curried functions) of the given type. *)
let rec arity ty =
  match (repr ty).desc with
    Tarrow(t1, t2) -> 1 + arity t2
  | _ -> 0
@

<<function Ctype.cyclic_abbrev>>=
(* Check whether an abbreviation expands to itself. *)
let rec cyclic_abbrev env id ty =
  let ty = repr ty in
  match ty.desc with
    Tconstr (Path.Pident id', _, _) when Ident.same id id' ->
      true
  | Tconstr (p, tl, abbrev) ->
      begin try
        cyclic_abbrev env id (try_expand_head env ty)
      with Cannot_expand ->
        false
      end
  | _ ->
      false
@

<<function Ctype.nondep_type_rec>>=
(*
   Variables are left unchanged. Other type nodes are duplicated, with
   levels set to generic level.
   During copying, the description of a (non-variable) node is first
   replaced by a link to a marked stub ([Tlink (newmarkedgenvar ())]).
   The mark allows to differentiate the original type from the copy.
   Once the copy is made, it replaces the stub.
   After copying, the description of node, which was stored by
   [save_desc], must be put back, using [cleanup_types], and the
   marks on the copy must be removed.
*)

let rec nondep_type_rec env id ty =
  let ty = repr ty in
  if (ty.desc = Tvar) || (ty.level < lowest_level) then
    ty
  else begin
    let desc = ty.desc in
    save_desc ty desc;
    let ty' = newmarkedgenvar () in        (* Stub *)
    ty.desc <- Tlink ty';
    ty'.desc <-
      begin match desc with
        Tvar ->
          fatal_error "Ctype.nondep_type_rec"
      | Tarrow(t1, t2) ->
          Tarrow(nondep_type_rec env id t1, nondep_type_rec env id t2)
      | Ttuple tl ->
          Ttuple(List.map (nondep_type_rec env id) tl)
      | Tconstr(p, tl, abbrev) ->
          if Path.isfree id p then
            begin try
              Tlink (nondep_type_rec env id
                       (expand_abbrev env p tl abbrev ty.level))
              (*
                 The [Tlink] is important. The expanded type may be a
                 variable, or may not be completely copied yet
                 (recursive type), so one cannot just take its
                 description.
               *)
            with Cannot_expand ->
              raise Not_found
            end
          else
            Tconstr(p, List.map (nondep_type_rec env id) tl, ref Mnil)
      | Tnil ->
          Tnil
      | Tlink ty ->                    (* Actually unused *)
          Tlink(nondep_type_rec env id ty)
      end;
    ty'
  end
@

<<function Ctype.nondep_type>>=
let nondep_type env id ty =
  try
    let ty' = nondep_type_rec env id ty in
    cleanup_types ();
    unmark_type ty';
    ty'
  with Not_found ->
    cleanup_types ();
    raise Not_found
@

<<function Ctype.nondep_type_decl>>=
(* Preserve sharing inside type declarations. *)
let nondep_type_decl env mid id is_covariant decl =
  try
    let params = List.map (nondep_type_rec env mid) decl.type_params in
    let decl =
      { type_params = params;
        type_arity = decl.type_arity;
        type_kind =
          begin try
            match decl.type_kind with
              Type_abstract ->
                Type_abstract
            | Type_variant cstrs ->
                Type_variant(List.map
                  (fun (c, tl) -> (c, List.map (nondep_type_rec env mid) tl))
                  cstrs)
            | Type_record lbls ->
                Type_record(List.map
                  (fun (c, mut, t) -> (c, mut, nondep_type_rec env mid t))
                  lbls)
          with Not_found when is_covariant ->
            Type_abstract
          end;
        type_manifest =
          begin try
            match decl.type_manifest with
              None -> None
            | Some ty ->
                Some (unroll_abbrev id params (nondep_type_rec env mid ty))
          with Not_found when is_covariant ->
            None
          end }
    in
    cleanup_types ();
    List.iter unmark_type decl.type_params;
    begin match decl.type_kind with
      Type_abstract -> ()
    | Type_variant cstrs ->
        List.iter (fun (c, tl) -> List.iter unmark_type tl) cstrs
    | Type_record lbls ->
        List.iter (fun (c, mut, t) -> unmark_type t) lbls
    end;
    begin match decl.type_manifest with
      None    -> ()
    | Some ty -> unmark_type ty
    end;
    decl
  with Not_found ->
    cleanup_types ();
    raise Not_found
@

<<type Ctype.closed_schema_result (./typing/ctype.ml)>>=
type closed_schema_result = Var of type_expr | Row_var of type_expr
@

<<exception Ctype.Failed>>=
exception Failed of closed_schema_result
@

<<function Ctype.closed_schema_rec>>=
let rec closed_schema_rec row ty =
  let ty = repr ty in
  if ty.level >= lowest_level then begin
    let level = ty.level in
    ty.level <- pivot_level - level;
    match ty.desc with
      Tvar when level <> generic_level ->
        raise (Failed (if row then Row_var ty else Var ty))
    | _ ->
        iter_type_expr (closed_schema_rec false) ty
  end
@

<<function Ctype.closed_schema>>=
(* Return whether all variables of type [ty] are generic. *)
let closed_schema ty =
  try
    closed_schema_rec false ty;
    unmark_type ty;
    true
  with Failed _ ->
    unmark_type ty;
    false
@


%-------------------------------------------------------------

<<./typing/ctype.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


(* Operations on core types *)

open Misc
open Asttypes
open Types
open Btype

(*
   Type manipulation after type inference
   ======================================
   If one wants to manipulate a type after type inference (for
   instance, during code generation or in the debugger), one must
   first make sure that the type levels are correct, using the
   function [correct_levels]. Then, this type can be correctely
   manipulated by [apply], [expand_head] and [moregeneral].
*)

(*
   General notes
   =============
   - As much sharing as possible should be kept : it makes types
     smaller and better abbreviated.
     When necessary, some sharing can be lost. Types will still be
     printed correctly (+++ TO DO...), and abbreviations defined by a
     class do not depend on sharing thanks to constrained
     abbreviations. (Of course, even if some sharing is lost, typing
     will still be correct.)
   - All nodes of a type have a level : that way, one know whether a
     node need to be duplicated or not when instantiating a type.
   - Levels of a type are decreasing (generic level being considered
     as greatest).
   - The level of a type constructor is superior to the binding
     time of its path.
   - Recursive types without limitation should be handled (even if
     there is still an occur check). This avoid treating specially the
     case for objects, for instance. Furthermore, the occur check
     policy can then be easily changed.
*)

(*
   A faire
   =======
   - Revoir affichage des types.
   - Etendre la portee d'un alias [... as 'a] a tout le type englobant.
   - #-type implementes comme de vraies abreviations.
   - Niveaux plus fins pour les identificateurs :
       Champ [global] renomme en [level];
       Niveau -1 : global
               0 : module toplevel
               1 : module contenu dans module toplevel
              ...
     En fait, incrementer le niveau a chaque fois que l'on rentre dans
     un module.

       3   4 6
        \ / /
       1 2 5
        \|/
         0

     [Subst] doit ecreter les niveaux (pour qu'un variable non
     generalisable dans un module de niveau 2 ne se retrouve pas
     generalisable lorsque l'on l'utilise au niveau 0).

   - Traitement de la trace de l'unification separe de la fonction
     [unify].
*)

<<exception Ctype.Unify>>

<<exception Ctype.Subtype>>

<<exception Ctype.Cannot_expand>>

<<exception Ctype.Cannot_apply>>

<<exception Ctype.Recursive_abbrev>>

<<constant Ctype.current_level>>
<<constant Ctype.global_level>>

<<function Ctype.init_def>>
<<function Ctype.begin_def>>
<<function Ctype.end_def>>

<<function Ctype.reset_global_level>>

(**** Some type creators ****)

<<function Ctype.newty>>
<<constant Ctype.newgenty>>
<<function Ctype.new_global_ty>>

<<function Ctype.newvar>>
<<function Ctype.newmarkedvar>>
<<function Ctype.new_global_var>>

<<constant Ctype.none>>

(**** Representative of a type ****)

<<constant Ctype.repr>>


                         (*****************************)
                         (*  Type level manipulation  *)
                         (*****************************)

(*
   It would be a bit more efficient to remove abbreviation expansions
   rather than generalizing them: these expansions will usually not be
   used anymore. However, this is not possible in the general case, as
   [expand_abbrev] (via [subst]) requires these expansions to be
   preserved. Does it worth duplicating this code ?
*)
let rec generalize ty =
  let ty = repr ty in
  if (ty.level > !current_level) && (ty.level <> generic_level) then begin
    ty.level <- generic_level;
    begin match ty.desc with
      Tconstr (_, _, abbrev) ->
        generalize_expans !abbrev
    | _ -> ()
    end;
    iter_type_expr generalize ty
  end

and generalize_expans =
  function
    Mnil              ->  ()
  | Mcons(_, ty, rem) ->  generalize ty; generalize_expans rem
  | Mlink rem         ->  generalize_expans !rem

<<constant Ctype.try_expand_head'>>

(*
   Lower the levels of a type (assume [level] is not
   [generic_level]).
*)
<<function Ctype.update_level>>

<<function Ctype.make_nongen>>

<<function Ctype.correct_levels>>


                              (*******************)
                              (*  Instantiation  *)
                              (*******************)


<<constant Ctype.abbreviations>>

<<function Ctype.copy>>

<<function Ctype.instance>>

<<function Ctype.instance_list>>

<<function Ctype.instance_constructor>>

<<function Ctype.instance_label>>

<<function Ctype.instance_parameterized_type>>

<<constant Ctype.unify'>>

<<function Ctype.subst>>

<<function Ctype.apply>>


                              (****************************)
                              (*  Abbreviation expansion  *)
                              (****************************)


<<function Ctype.find_expans>>

<<constant Ctype.previous_env>>

(* Expand an abbreviation. The expansion is memorized. *)
(* 
   Assume the level is greater than the path binding time of the
   expanded abbreviation.
*)
<<function Ctype.expand_abbrev>>

<<function Ctype.try_expand_head>>

<<toplevel Ctype._1>>

<<function Ctype.expand_head>>

<<function Ctype.full_expand>>

<<function Ctype.generic_abbrev>>


                              (*****************)
                              (*  Occur check  *)
                              (*****************)


<<exception Ctype.Occur>>

<<constant Ctype.visited>>

<<function Ctype.non_recursive_abbrev>>

<<function Ctype.correct_abbrev>>

<<function Ctype.occur_rec>>

<<function Ctype.occur>>


                              (*****************)
                              (*  Unification  *)
                              (*****************)



(**** Transform error trace ****)
<<function Ctype.expand_trace>>

<<constant Ctype.filter_trace>>

(**** Unification ****)

<<function Ctype.deep_occur>>

(*
   1. When unifying two non-abbreviated types, one type is made a link
      to the other. When unifying an abbreviated type with a
      non-abbreviated type, the non-abbreviated type is made a link to
      the other one. When unifying to abbreviated types, these two
      types are kept distincts, but they are made to (temporally)
      expand to the same type.
   2. Abbreviations with at least one parameter are systematically
      expanded. The overhead does not seem to high, and that way
      abbreviations where some parameters does not appear in the
      expansion, such as ['a t = int], are correctly handled. In
      particular, for this example, unifying ['a t] with ['b t] keeps
      ['a] and ['b] distincts. (Is it really important ?)
   3. Unifying an abbreviation ['a t = 'a] with ['a] should not yield
      ['a t as 'a]. Indeed, the type variable would otherwise be lost.
      This problem occurs for abbreviations expanding to a type
      variable, but also to many other constrained abbreviations (for
      instance, [(< x : 'a > -> unit) t = <x : 'a>]). The solution is
      that, if an abbreviation is unified with some subpart of its
      parameters, then the parameter actually does not get
      abbreviated.  It would be possible to check whether some
      information is indeed lost, but it probably does not worth it.
*)
let rec unify env t1 t2 =
  (* First step: special cases (optimizations) *)
  if t1 == t2 then () else
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then () else

  try
    match (t1.desc, t2.desc) with
      (Tvar, Tconstr _) when deep_occur t1 t2 ->
        unify2 env t1 t2
    | (Tconstr _, Tvar) when deep_occur t2 t1 ->
        unify2 env t1 t2
    | (Tvar, _) ->
        occur env t1 t2;
        update_level env t1.level t2;
        t1.desc <- Tlink t2
    | (_, Tvar) ->
        occur env t2 t1;
        update_level env t2.level t1;
        t2.desc <- Tlink t1
    | (Tconstr (p1, [], _), Tconstr (p2, [], _)) when Path.same p1 p2 ->
        update_level env t1.level t2;
        t1.desc <- Tlink t2
    | _ ->
        unify2 env t1 t2
  with Unify trace ->
    raise (Unify ((t1, t2)::trace))

and unify2 env t1 t2 =
  (* Second step: expansion of abbreviations *)
  let t1' = expand_head env t1 in
  let t2' = expand_head env t2 in
  (* Expansion may have changed the representative of the types... *)
  let t1' = repr t1' and t2' = repr t2' in
  if t1' == t2' then () else

  let t1 = repr t1 and t2 = repr t2 in
  if (t1 == t1') || (t2 != t2') then
    unify3 env t1 t1' t2 t2'
  else
    try unify3 env t2 t2' t1 t1' with Unify trace ->
      raise (Unify (List.map (fun (x, y) -> (y, x)) trace))

and unify3 env t1 t1' t2 t2' =
  (* Third step: truly unification *)
  (* Assumes either [t1 == t1'] or [t2 != t2'] *)
  let d1 = t1'.desc and d2 = t2'.desc in
  
  if (t2 != t2') && (deep_occur t1' t2) then begin
    (* See point 3. *)
    occur env t1' t2';
    update_level env t1'.level t2';
    t1'.desc <- Tlink t2'
  end else begin
    occur env t1' t2;
    update_level env t1'.level t2;
    t1'.desc <- Tlink t2
  end;

  try
    begin match (d1, d2) with
      (Tvar, _) ->
        ()
    | (_, Tvar) ->
        occur env t2' (newty d1);
        if t1 == t1' then begin
          (* The variable must be instantiated... *)
          let ty = {desc = d1; level = t1'.level} in
          update_level env t2'.level ty;
          t2'.desc <- Tlink ty
        end else begin
          t1'.desc <- d1;
          update_level env t2'.level t1;
          t2'.desc <- Tlink t1
        end
    | (Tarrow (t1, u1), Tarrow (t2, u2)) ->
        unify env t1 t2; unify env u1 u2
    | (Ttuple tl1, Ttuple tl2) ->
        unify_list env tl1 tl2
    | (Tconstr (p1, tl1, _), Tconstr (p2, tl2, _)) when Path.same p1 p2 ->
        unify_list env tl1 tl2
    | (Tnil, Tnil) ->
        ()
    | (_, _) ->
        raise (Unify [])
    end
(*
    (* 
       Can only be done afterwards, once the row variable has
       (possibly) been instantiated.
    *)
    if t1 != t1' (* && t2 != t2' *) then begin
      match (t1.desc, t2.desc) with
        (Tconstr (p, ty::_, _), _)
            when ((repr ty).desc <> Tvar)
              && weak_abbrev p
              && not (deep_occur t1 t2) ->
          update_level env t1.level t2;
          t1.desc <- Tlink t2
      | (_, Tconstr (p, ty::_, _))
            when ((repr ty).desc <> Tvar)
              && weak_abbrev p
              && not (deep_occur t2 t1) ->
          update_level env t2.level t1;
          t2.desc <- Tlink t1;
          t1'.desc <- Tlink t2'
      | _ ->
          ()
    end
*)
  with Unify trace ->
    t1'.desc <- d1;
    raise (Unify trace)

and unify_list env tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    raise (Unify []);
  List.iter2 (unify env) tl1 tl2



<<function Ctype.unify>>

<<toplevel Ctype._2>>

(**** Special cases of unification ****)

<<function Ctype.filter_arrow>>



                        (***********************************)
                        (*  Matching between type schemes  *)
                        (***********************************)

<<function Ctype.moregen_occur>>

<<function Ctype.moregeneral>>


                 (*********************************************)
                 (*  Equivalence between parameterized types  *)
                 (*********************************************)


<<function Ctype.equal>>


                              (***************)
                              (*  Subtyping  *)
                              (***************)


<<constant Ctype.subtypes>>

<<function Ctype.build_subtype>>

<<function Ctype.enlarge_type>>

(**** Check whether a type is a subtype of another type. ****)

<<constant Ctype.subtypes (./typing/ctype.ml)>>

<<function Ctype.subtype_error>>

let rec subtype_rec env trace t1 t2 =
  let t1 = repr t1 in
  let t2 = repr t2 in
  if t1 == t2 then [] else
  if List.exists (fun (t1', t2') -> t1 == t1' & t2 == t2') !subtypes then
      (* +++ Possibly slow *)
    []
  else begin
    subtypes := (t1, t2) :: !subtypes;
    match (t1.desc, t2.desc) with
      (Tvar, _) | (_, Tvar) ->
        [(trace, t1, t2)]
    | (Tarrow(t1, u1), Tarrow(t2, u2)) ->
        (subtype_rec env ((t2, t1)::trace) t2 t1) @
        (subtype_rec env ((u1, u2)::trace) u1 u2)
    | (Ttuple tl1, Ttuple tl2) ->
        subtype_list env trace tl1 tl2
    | (Tconstr(p1, tl1, abbrev1), Tconstr _) when generic_abbrev env p1 ->
        subtype_rec env trace (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
    | (Tconstr _, Tconstr(p2, tl2, abbrev2)) when generic_abbrev env p2 ->
        subtype_rec env trace t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
    | (Tconstr _, Tconstr _) ->
        [(trace, t1, t2)]
    | (Tconstr(p1, tl1, abbrev1), _) when generic_abbrev env p1 ->
        subtype_rec env trace (expand_abbrev env p1 tl1 abbrev1 t1.level) t2
    | (_, Tconstr (p2, tl2, abbrev2)) when generic_abbrev env p2 ->
        subtype_rec env trace t1 (expand_abbrev env p2 tl2 abbrev2 t2.level)
    | (_, _) ->
        subtype_error env trace
  end

and subtype_list env trace tl1 tl2 =
  if List.length tl1 <> List.length tl2 then
    subtype_error env trace;
  List.fold_left2
    (fun cstrs t1 t2 -> cstrs @ (subtype_rec env ((t1, t2)::trace) t1 t2))
    [] tl1 tl2


<<function Ctype.subtype>>


                              (*******************)
                              (*  Miscellaneous  *)
                              (*******************)


<<function Ctype.unalias>>

<<function Ctype.unroll_abbrev>>

<<function Ctype.arity>>

<<function Ctype.cyclic_abbrev>>


                              (*************************)
                              (*  Remove dependencies  *)
                              (*************************)


<<function Ctype.nondep_type_rec>>

<<function Ctype.nondep_type>>

<<function Ctype.nondep_type_decl>>


                    (**************************************)
                    (*  Check genericity of type schemes  *)
                    (**************************************)


<<type Ctype.closed_schema_result (./typing/ctype.ml)>>
<<exception Ctype.Failed>>

<<function Ctype.closed_schema_rec>>

<<function Ctype.closed_schema>>

@


\subsection*{[[./typing/includecore.mli]]}

<<exception Includecore.Dont_match>>=
exception Dont_match
@

<<signature Includecore.value_descriptions>>=
val value_descriptions:
        Env.t -> value_description -> value_description -> module_coercion
@

<<signature Includecore.type_declarations>>=
val type_declarations:
        Env.t -> Ident.t -> type_declaration -> type_declaration -> bool
@

<<signature Includecore.exception_declarations>>=
val exception_declarations:
        Env.t -> exception_declaration -> exception_declaration -> bool
@


%-------------------------------------------------------------

<<./typing/includecore.mli>>=
<<copyright header>>

(* Inclusion checks for the core language *)

open Types
open Typedtree

<<exception Includecore.Dont_match>>

<<signature Includecore.value_descriptions>>
<<signature Includecore.type_declarations>>
<<signature Includecore.exception_declarations>>
@


\subsection*{[[./typing/includecore.ml]]}

<<exception Includecore.Dont_match (./typing/includecore.ml)>>=
(* Inclusion between value descriptions *)

exception Dont_match
@

<<function Includecore.value_descriptions>>=
let value_descriptions env vd1 vd2 =
  if Ctype.moregeneral env true vd1.val_type vd2.val_type then begin
    match (vd1.val_kind, vd2.val_kind) with
        (Val_prim p1, Val_prim p2) ->
          if p1 = p2 then Tcoerce_none else raise Dont_match
      | (Val_prim p, _) -> Tcoerce_primitive p
      | (_, Val_prim p) -> raise Dont_match
      | (_, _) -> Tcoerce_none
  end else
    raise Dont_match
@

<<function Includecore.type_declarations>>=
(* Inclusion between type declarations *)

let type_declarations env id decl1 decl2 =
  decl1.type_arity = decl2.type_arity &
  begin match (decl1.type_kind, decl2.type_kind) with
      (_, Type_abstract) -> true
    | (Type_variant cstrs1, Type_variant cstrs2) ->
        for_all2
          (fun (cstr1, arg1) (cstr2, arg2) ->
            cstr1 = cstr2 &
            for_all2
              (fun ty1 ty2 ->
                Ctype.equal env true (ty1::decl1.type_params)
                                     (ty2::decl2.type_params))
              arg1 arg2)
          cstrs1 cstrs2
    | (Type_record labels1, Type_record labels2) ->
        for_all2
          (fun (lbl1, mut1, ty1) (lbl2, mut2, ty2) ->
            lbl1 = lbl2 & mut1 = mut2 &
            Ctype.equal env true (ty1::decl1.type_params)
                                 (ty2::decl2.type_params))
          labels1 labels2
    | (_, _) -> false
  end &
  begin match (decl1.type_manifest, decl2.type_manifest) with
      (_, None) ->
        Ctype.equal env true decl1.type_params decl2.type_params
    | (Some ty1, Some ty2) ->
        Ctype.equal env true (ty1::decl1.type_params)
                             (ty2::decl2.type_params)
    | (None, Some ty2) ->
        let ty1 =
          Btype.newgenty (Tconstr(Pident id, decl2.type_params, ref Mnil))
        in
        Ctype.equal env true decl1.type_params decl2.type_params
          &
        Ctype.equal env false [ty1] [ty2]
  end
@

<<function Includecore.exception_declarations>>=
(* Inclusion between exception declarations *)

let exception_declarations env ed1 ed2 =
  for_all2 (fun ty1 ty2 -> Ctype.equal env false [ty1] [ty2]) ed1 ed2
@


%-------------------------------------------------------------

<<./typing/includecore.ml>>=
<<copyright header>>

(* Inclusion checks for the core language *)

open Misc
open Path
open Types
open Typedtree

<<exception Includecore.Dont_match (./typing/includecore.ml)>>

<<function Includecore.value_descriptions>>

<<function Includecore.type_declarations>>

<<function Includecore.exception_declarations>>
@


\subsection*{[[./typing/mtype.mli]]}

<<signature Mtype.scrape>>=
val scrape: Env.t -> module_type -> module_type
        (* Expand toplevel module type abbreviations
           till hitting a "hard" module type (signature, functor,
           or abstract module type ident. *)
@

<<signature Mtype.strengthen>>=
val strengthen: Env.t -> module_type -> Path.t -> module_type
        (* Strengthen abstract type components relative to the
           given path. *)
@


%-------------------------------------------------------------

<<./typing/mtype.mli>>=
<<copyright header>>

(* Operations on module types *)

open Types

<<signature Mtype.scrape>>
<<signature Mtype.strengthen>>
@


\subsection*{[[./typing/mtype.ml]]}

<<function Mtype.scrape>>=
let rec scrape env mty =
  match mty with
    Tmty_ident p ->
      begin try
        Env.find_modtype_expansion p env
      with Not_found ->
        mty
      end
  | _ -> mty
@


%-------------------------------------------------------------

<<./typing/mtype.ml>>=
<<copyright header>>

(* Operations on module types *)

open Path
open Types


<<function Mtype.scrape>>

let rec strengthen env mty p =
  match scrape env mty with
    Tmty_signature sg ->
      Tmty_signature(strengthen_sig env sg p)
  | mty ->
      mty

and strengthen_sig env sg p =
  match sg with
    [] -> []
  | (Tsig_value(id, desc) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Tsig_type(id, decl) :: rem ->
      let newdecl =
        match decl.type_manifest with
          None ->
            { type_params = decl.type_params;
              type_arity = decl.type_arity;
              type_kind = decl.type_kind;
              type_manifest = Some(Ctype.newgenty(
                                   Tconstr(Pdot(p, Ident.name id, nopos),
                                           decl.type_params,
                                           ref Mnil))) }
        | _ -> decl in
      Tsig_type(id, newdecl) :: strengthen_sig env rem p
  | (Tsig_exception(id, d) as sigelt) :: rem ->
      sigelt :: strengthen_sig env rem p
  | Tsig_module(id, mty) :: rem ->
      Tsig_module(id, strengthen env mty (Pdot(p, Ident.name id, nopos))) ::
      strengthen_sig (Env.add_module id mty env) rem p
      (* Need to add the module in case it defines manifest module types *)
  | Tsig_modtype(id, decl) :: rem ->
      let newdecl =
        match decl with
          Tmodtype_abstract ->
            Tmodtype_manifest(Tmty_ident(Pdot(p, Ident.name id, nopos)))
        | Tmodtype_manifest _ ->
            decl in
      Tsig_modtype(id, newdecl) ::
      strengthen_sig (Env.add_modtype id decl env) rem p
      (* Need to add the module type in case it is manifest *)

@


\subsection*{[[./typing/printtyp.mli]]}

<<signature Printtyp.longident>>=
val longident: Longident.t -> unit
@

<<signature Printtyp.ident>>=
val ident: Ident.t -> unit
@

<<signature Printtyp.path>>=
val path: Path.t -> unit
@

<<signature Printtyp.reset>>=
val reset: unit -> unit
@

<<signature Printtyp.mark_loops>>=
val mark_loops: type_expr -> unit
@

<<signature Printtyp.type_expr>>=
val type_expr: type_expr -> unit
@

<<signature Printtyp.type_scheme>>=
val type_scheme: type_expr -> unit
@

<<signature Printtyp.value_description>>=
val value_description: Ident.t -> value_description -> unit
@

<<signature Printtyp.type_declaration>>=
val type_declaration: Ident.t -> type_declaration -> unit
@

<<signature Printtyp.exception_declaration>>=
val exception_declaration: Ident.t -> exception_declaration -> unit
@

<<signature Printtyp.modtype>>=
val modtype: module_type -> unit
@

<<signature Printtyp.signature>>=
val signature: signature -> unit
@

<<signature Printtyp.signature_body>>=
val signature_body: bool -> signature -> unit
@

<<signature Printtyp.modtype_declaration>>=
val modtype_declaration: Ident.t -> modtype_declaration -> unit
@

<<signature Printtyp.type_expansion>>=
val type_expansion: type_expr -> type_expr -> unit
@

<<signature Printtyp.trace>>=
val trace: bool -> (unit -> unit) -> (type_expr * type_expr) list -> unit
@

<<signature Printtyp.unification_error>>=
val unification_error:
        (type_expr * type_expr) list -> (unit -> unit) -> (unit -> unit) ->
        unit
@


%-------------------------------------------------------------

<<./typing/printtyp.mli>>=
<<copyright header>>

(* Printing functions *)

open Types

<<signature Printtyp.longident>>
<<signature Printtyp.ident>>
<<signature Printtyp.path>>
<<signature Printtyp.reset>>
<<signature Printtyp.mark_loops>>
<<signature Printtyp.type_expr>>
<<signature Printtyp.type_scheme>>
<<signature Printtyp.value_description>>
<<signature Printtyp.type_declaration>>
<<signature Printtyp.exception_declaration>>
<<signature Printtyp.modtype>>
<<signature Printtyp.signature>>
<<signature Printtyp.signature_body>>
<<signature Printtyp.modtype_declaration>>
<<signature Printtyp.type_expansion>>
<<signature Printtyp.trace>>
<<signature Printtyp.unification_error>>
@


\subsection*{[[./typing/printtyp.ml]]}

<<constant Printtyp.longident>>=
(* Print a long identifier *)

let rec longident = function
    Lident s -> print_string s
  | Ldot(p, s) -> longident p; print_string "."; print_string s
@

<<function Printtyp.ident>>=
(* Print an identifier *)

let ident id =
  print_string(Ident.name id)
@

<<constant Printtyp.ident_pervasive>>=
(* Print a path *)

let ident_pervasive = Ident.create_persistent "Pervasives"
@

<<constant Printtyp.path>>=
let rec path = function
    Pident id ->
      ident id
  | Pdot(Pident id, s, pos) when Ident.same id ident_pervasive ->
      print_string s
  | Pdot(p, s, pos) ->
      path p; print_string "."; print_string s
@

<<constant Printtyp.names>>=
(* Print a type expression *)

let names = ref ([] : (type_expr * string) list)
@

<<constant Printtyp.name_counter>>=
let name_counter = ref 0
@

<<function Printtyp.reset_names>>=
let reset_names () = names := []; name_counter := 0
@

<<function Printtyp.new_name>>=
let new_name () =
  let name =
    if !name_counter < 26
    then String.make 1 (Char.chr(97 + !name_counter)) 
    else String.make 1 (Char.chr(97 + !name_counter mod 26)) ^
           string_of_int(!name_counter / 26)
  in
    incr name_counter;
    name
@

<<function Printtyp.name_of_type>>=
let name_of_type t =
  try List.assq t !names with Not_found ->
    let name = new_name () in
    names := (t, name) :: !names;
    name
@

<<function Printtyp.list_removeq>>=
let rec list_removeq a =
  function
    [] ->
      []
  | (b, _) as e::l ->
      if a == b then l else e::list_removeq a l
@

<<function Printtyp.remove_name_of_type>>=
let remove_name_of_type t =
  names := list_removeq t !names
@

<<constant Printtyp.visited_objects>>=
let visited_objects = ref ([] : type_expr list)
@

<<constant Printtyp.aliased>>=
let aliased = ref ([] : type_expr list)
@

<<function Printtyp.mark_loops_rec>>=
let rec mark_loops_rec visited ty =
  let ty = repr ty in
  if List.memq ty visited then begin
    if not (List.memq ty !aliased) then
      aliased := ty :: !aliased
  end else
    let visited = ty :: visited in
    match ty.desc with
      Tvar                -> ()
    | Tarrow(ty1, ty2)    ->
        mark_loops_rec visited ty1; mark_loops_rec visited ty2
    | Ttuple tyl          -> List.iter (mark_loops_rec visited) tyl
    | Tconstr(_, tyl, _)  ->
        List.iter (mark_loops_rec visited) tyl
    | Tnil                -> ()
    | Tlink _             -> fatal_error "Printtyp.mark_loops_rec (2)"
@

<<function Printtyp.mark_loops>>=
let mark_loops ty = mark_loops_rec [] ty
@

<<function Printtyp.reset_loop_marks>>=
let reset_loop_marks () =
  visited_objects := []; aliased := []
@

<<function Printtyp.reset>>=
let reset () =
  reset_names (); reset_loop_marks ()
@

<<function Printtyp.constrain>>=
(* Print one type declaration *)

let constrain ty =
  let ty' = unalias ty in
  if ty != ty' then begin
    print_space ();
    open_box 2;
    print_string "constraint ";
    type_sch ty;
    print_string " =";
    print_space();
    type_sch ty';
    close_box()
  end
@

<<function Printtyp.exception_declaration>>=
(* Print an exception declaration *)

let exception_declaration id decl =
  print_string "exception "; constructor (Ident.name id, decl)
@

<<function Printtyp.value_description>>=
(* Print a value declaration *)

let value_description id decl =
  open_box 2;
  print_string (if decl.val_kind = Val_reg then "val " else "external ");
  ident id; print_string " :"; print_space();
  type_scheme decl.val_type;
  begin match decl.val_kind with
    Val_prim p ->
      print_space(); print_string "= "; Primitive.print_description p
  | _ -> ()
  end;
  close_box()
@

<<function Printtyp.signature>>=
(* Print a signature body (used when compiling a .mli and printing results
   in interactive use). *)

let signature sg =
  open_vbox 0;
  signature_body false sg;
  close_box()
@

<<function Printtyp.type_expansion>>=
(* Print an unification error *)

let type_expansion t t' =
  if t == t' then
    type_expr t
  else begin
    open_box 2;
    type_expr t;
    print_space (); print_string "="; print_space ();
    type_expr t';
    close_box ()
  end
@

<<function Printtyp.trace>>=
let rec trace fst txt =
  function
    (t1, t1')::(t2, t2')::rem ->
      if not fst then
        print_cut ();
      open_box 0;
      print_string "Type"; print_break 1 2;
      type_expansion t1 t1'; print_space ();
      txt (); print_break 1 2;
      type_expansion t2 t2';
      close_box ();
      trace false txt rem
  | _ ->
      ()
@

<<function Printtyp.unification_error>>=
let unification_error tr txt1 txt2 =
  reset ();
  List.iter
    (function (t, t') -> mark_loops t; if t != t' then mark_loops t')
    tr;
  open_box 0;
  let (t1, t1') = List.hd tr in
  let (t2, t2') = List.hd (List.tl tr) in
  txt1 (); print_break 1 2;
  type_expansion t1 t1'; print_space();
  txt2 (); print_break 1 2;
  type_expansion t2 t2';
  close_box();
  trace false (fun _ -> print_string "is not compatible with type")
        (List.tl (List.tl tr))
@


%-------------------------------------------------------------

<<./typing/printtyp.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


(* Printing functions *)

open Misc
open Ctype
open Format
open Longident
open Path
open Asttypes
open Types
open Btype

<<constant Printtyp.longident>>

<<function Printtyp.ident>>

<<constant Printtyp.ident_pervasive>>

<<constant Printtyp.path>>

<<constant Printtyp.names>>
<<constant Printtyp.name_counter>>

<<function Printtyp.reset_names>>

<<function Printtyp.new_name>>

<<function Printtyp.name_of_type>>

<<function Printtyp.list_removeq>>

<<function Printtyp.remove_name_of_type>>

<<constant Printtyp.visited_objects>>
<<constant Printtyp.aliased>>

<<function Printtyp.mark_loops_rec>>

<<function Printtyp.mark_loops>>

<<function Printtyp.reset_loop_marks>>

<<function Printtyp.reset>>

let rec typexp sch prio0 ty =
  let ty = repr ty in
  try
    List.assq ty !names;
    if (ty.desc = Tvar) && sch && (ty.level <> generic_level)
    then print_string "'_"
    else print_string "'";
    print_string (name_of_type ty)
  with Not_found ->
    let alias = List.memq ty !aliased in
    if alias then begin
      name_of_type ty;
      if prio0 >= 1 then begin open_box 1; print_string "(" end
      else open_box 0
    end;
    let prio = if alias then 0 else prio0 in
    begin match ty.desc with
      Tvar ->
        if (not sch) or ty.level = generic_level
        then print_string "'"
        else print_string "'_";
        print_string(name_of_type ty)
    | Tarrow(ty1, ty2) ->
        if prio >= 2 then begin open_box 1; print_string "(" end
                     else open_box 0;
        typexp sch 2 ty1;
        print_string " ->"; print_space();
        typexp sch 1 ty2;
        if prio >= 2 then print_string ")";
        close_box()
    | Ttuple tyl ->
        if prio >= 3 then begin open_box 1; print_string "(" end
                     else open_box 0;
        typlist sch 3 " *" tyl;
        if prio >= 3 then print_string ")";
        close_box()
    | Tconstr(p, tyl, abbrev) ->
        open_box 0;
        begin match tyl with
          [] -> ()
        | [ty1] ->
            typexp sch 3 ty1; print_space()
        | tyl ->
            open_box 1; print_string "("; typlist sch 0 "," tyl;
            print_string ")"; close_box(); print_space()
        end;
        path p;
        close_box()
(*
| Tfield _ -> typobject sch ty ty (ref None)
| Tnil -> typobject sch ty ty (ref None)
*)
    | _ ->
        fatal_error "Printtyp.typexp"
    end;
    if alias then begin
      print_string " as ";
      print_string "'";
      print_string (name_of_type ty);
      (* if not (opened_object ty) then *)
      remove_name_of_type ty;
      if prio0 >= 1 then print_string ")";
      close_box()
    end
(* ; print_string "["; print_int ty.level; print_string "]" *)

and typlist sch prio sep = function
    [] -> ()
  | [ty] -> typexp sch prio ty
  | ty::tyl ->
      typexp sch prio ty; print_string sep; print_space();
      typlist sch prio sep tyl

and typfields sch rest =
  function
    [] ->
      begin match rest.desc with
        Tvar -> if sch & rest.level <> generic_level then
                  print_string "_";
                print_string ".."
      | Tnil -> ()
      | _    -> fatal_error "typfields (1)"
      end
  | [(s, t)] ->
      print_string s;
      print_string " : ";
      typexp sch 0 t;
      begin match rest.desc with
        Tvar -> print_string ";"; print_space ()
      | Tnil -> ()
      | _    -> fatal_error "typfields (2)"
      end;
      typfields sch rest []
  | (s, t)::l ->
      print_string s;
      print_string " : ";
      typexp sch 0 t;
      print_string ";"; print_space ();
      typfields sch rest l

let type_expr ty =
  typexp false 0 ty

and type_sch ty =
  typexp true 0 ty

and type_scheme ty =
  reset(); mark_loops ty; typexp true 0 ty

<<function Printtyp.constrain>>

let rec type_declaration id decl =
  reset();

  let params = List.map repr decl.type_params in

  aliased := params @ !aliased;
  List.iter mark_loops params;
  List.iter (fun x -> name_of_type x; ()) params;
  begin match decl.type_manifest with
    None    -> ()
  | Some ty -> mark_loops ty
  end;
  begin match decl.type_kind with
    Type_abstract -> ()
  | Type_variant [] -> ()
  | Type_variant cstrs ->
      List.iter (fun (_, args) -> List.iter mark_loops args) cstrs
  | Type_record (lbl1 :: lbls as l) ->
      List.iter (fun (_, _, ty) -> mark_loops ty) l
  | _ -> assert false
  end;

  open_hvbox 2;
  print_string "type ";
  type_expr {desc = Tconstr(Pident id, params, ref Mnil);
             level = generic_level};
  begin match decl.type_manifest with
    None -> ()
  | Some ty ->
      print_string " ="; print_space(); type_expr ty
  end;
  begin match decl.type_kind with
    Type_abstract -> ()
  | Type_variant [] -> ()
      (* A fatal error actually, except when printing type exn... *)
  | Type_variant cstrs ->
      print_string " =";
      List.iter
        (fun cstr -> print_space(); print_string "| "; constructor cstr)
        cstrs
  | Type_record (lbl1 :: lbls as l) ->
      print_string " ="; print_space();
      print_string "{ "; label lbl1;
      List.iter
        (fun lbl -> print_string ";"; print_break 1 2; label lbl)
        lbls;
      print_string " }"
  | _ -> assert false
  end;
  List.iter constrain params;
  close_box()

and constructor (name, args) =
  print_string name;
  match args with
    [] -> ()
  | _  -> print_string " of ";
          open_box 2; typlist false 3 " *" args; close_box()

and label (name, mut, arg) =
  begin match mut with
      Immutable -> ()
    | Mutable -> print_string "mutable "
  end;
  print_string name;
  print_string ": ";
  type_expr arg

<<function Printtyp.exception_declaration>>

<<function Printtyp.value_description>>


(* Print a module type *)

let rec modtype = function
    Tmty_ident p ->
      path p
  | Tmty_signature sg ->
      open_hvbox 2;
      print_string "sig"; signature_body true sg; 
      print_break 1 (-2); print_string "end";
      close_box()

and signature_body spc = function
    [] -> ()
  | item :: rem ->
      if spc then print_space();
      let cont =
        match item with
          Tsig_value(id, decl) ->
            value_description id decl; rem
        | Tsig_type(id, decl)  ->
            type_declaration id decl; rem
        | Tsig_exception(id, decl)  ->
            exception_declaration id decl; rem
        | Tsig_module(id, mty)  ->
            open_box 2; print_string "module "; ident id; print_string " :";
            print_space(); modtype mty; close_box(); rem
        | Tsig_modtype(id, decl)  ->
            modtype_declaration id decl; rem
      in signature_body true cont

and modtype_declaration id decl =
  open_box 2; print_string "module type "; ident id;
  begin match decl with
    Tmodtype_abstract -> ()
  | Tmodtype_manifest mty ->
      print_string " ="; print_space(); modtype mty
  end;
  close_box()

<<function Printtyp.signature>>

<<function Printtyp.type_expansion>>

<<function Printtyp.trace>>

<<function Printtyp.unification_error>>
@


\subsection*{[[./typing/parmatch.mli]]}


%-------------------------------------------------------------

<<./typing/parmatch.mli>>=
<<copyright header>>

(* Detection of partial matches and unused match cases. *)

open Typedtree

<<signature Parmatch.check_partial>>
<<signature Parmatch.check_unused>>
@


\subsection*{[[./typing/parmatch.ml]]}

<<function Parmatch.make_pat>>=
let make_pat desc ty =
  {pat_desc = desc; pat_loc = Location.none; pat_type = ty}
@

<<constant Parmatch.omega>>=
let omega = make_pat Tpat_any Ctype.none
@

<<function Parmatch.omegas>>=
let rec omegas i =
  if i <= 0 then [] else omega :: omegas (i-1)
@

<<function Parmatch.omega_list>>=
let omega_list l = omegas(List.length l)
@

<<function Parmatch.has_guard>>=
let has_guard act =
  match act.exp_desc with
    Texp_when(_, _) -> true
  | _ -> false
@

<<function Parmatch.simple_match>>=
let simple_match p1 p2 = 
  match p1.pat_desc, p2.pat_desc with
    Tpat_construct(c1, _), Tpat_construct(c2, _) ->
      c1.cstr_tag = c2.cstr_tag
  | Tpat_constant(c1), Tpat_constant(c2) ->
      c1 = c2
  | Tpat_tuple(_), Tpat_tuple(_) -> true
  | Tpat_record(_), Tpat_record(_) -> true
  | _, (Tpat_any | Tpat_var(_)) -> true
  | _, _ -> false
@

<<function Parmatch.record_labels>>=
(* Return the set of labels and number of fields for a record pattern. *)

let record_labels p =
  match p.pat_desc with
    Tpat_record((lbl1, pat1) :: rem) -> Array.to_list lbl1.lbl_all
  | _ -> fatal_error "Parmatch.record_labels"
@

<<function Parmatch.record_num_fields>>=
let record_num_fields p =
  match p.pat_desc with
    Tpat_record((lbl1, pat1) :: rem) -> Array.length lbl1.lbl_all
  | _ -> fatal_error "Parmatch.record_num_fields"
@

<<function Parmatch.set_fields>>=
let set_fields size l =
  let v = Array.create size omega in
  let rec change_rec l = match l with
    (lbl,p)::l ->  v.(lbl.lbl_pos) <- p ;  change_rec l 
  | [] -> () in
  change_rec l;
  Array.to_list v
@

<<function Parmatch.simple_match_args>>=
let simple_match_args p1 p2 =
  match p2.pat_desc with
    Tpat_construct(cstr, args) -> args
  | Tpat_tuple(args)  -> args
  | Tpat_record(args) ->  set_fields (record_num_fields p1) args
  | (Tpat_any | Tpat_var(_)) ->
      begin match p1.pat_desc with
        Tpat_construct(_, args) -> omega_list args
      | Tpat_tuple(args) -> omega_list args
      | Tpat_record(args) ->  omega_list args
      | _ -> []
      end
  | _ -> []
@

<<function Parmatch.simple_pat>>=
(*
  Computes the discriminating pattern for matching by the first
  column of pss, that is:
     checks for a tuple or a record when q is a variable.
*)

let rec simple_pat q pss = match pss with
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        simple_pat q ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        simple_pat q ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
        simple_pat q pss
  | (({pat_desc = Tpat_tuple(args)} as p)::_)::_ ->
        make_pat (Tpat_tuple(omega_list args)) p.pat_type
  | (({pat_desc = Tpat_record(args)} as p)::_)::pss ->
        make_pat (Tpat_record (List.map (fun lbl -> (lbl,omega)) (record_labels p)))
                 p.pat_type
  | _ -> q
@

<<function Parmatch.filter_one>>=
let filter_one q pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | (p::ps)::pss ->
        if simple_match q p
        then (simple_match_args q p @ ps) :: filter_rec pss
        else filter_rec pss
    | _ -> [] in
  filter_rec pss
@

<<function Parmatch.filter_extra>>=
let filter_extra pss =
  let rec filter_rec = function
      ({pat_desc = Tpat_alias(p,_)}::ps)::pss -> 
        filter_rec ((p::ps)::pss)
    | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
        filter_rec ((p1::ps)::(p2::ps)::pss)
    | ({pat_desc = (Tpat_any | Tpat_var(_))} :: qs) :: pss ->
        qs :: filter_rec pss
    | _::pss  -> filter_rec pss
    | [] -> [] in
  filter_rec pss
@

<<function Parmatch.filter_all>>=
let filter_all pat0 pss =

  let rec insert q qs env =
    match env with
      [] -> [q, [simple_match_args q q @ qs]]
    | ((p,pss) as c)::env ->
        if simple_match q p
        then (p, ((simple_match_args p q @ qs) :: pss)) :: env
        else c :: insert q qs env in

  let rec filter_rec env = function
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss ->
      filter_rec env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
      filter_rec env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::_)::pss ->
      filter_rec env pss
  | (p::ps)::pss ->
      filter_rec (insert p ps env) pss
  | _ -> env

  and filter_omega env = function
    ({pat_desc = Tpat_alias(p,_)}::ps)::pss ->
      filter_omega env ((p::ps)::pss)
  | ({pat_desc = Tpat_or(p1,p2)}::ps)::pss ->
      filter_omega env ((p1::ps)::(p2::ps)::pss)
  | ({pat_desc = (Tpat_any | Tpat_var(_))}::ps)::pss ->
      filter_omega
        (List.map (fun (q,qss) -> (q,(simple_match_args q omega @ ps) :: qss)) env)
        pss
  | _::pss -> filter_omega env pss
  | [] -> env in
        
  filter_omega
    (filter_rec
      (match pat0.pat_desc with
        (Tpat_record(_) | Tpat_tuple(_)) -> [pat0,[]]
      | _ -> [])
      pss)
    pss
@

<<function Parmatch.full_match>>=
let full_match env =
  match env with
    ({pat_desc = Tpat_construct(c,_)},_) :: _ ->
      List.length env = c.cstr_consts + c.cstr_nonconsts
  | ({pat_desc = Tpat_constant(Const_char _)},_) :: _ ->
      List.length env = 256
  | ({pat_desc = Tpat_constant(_)},_) :: _ -> false
  | ({pat_desc = Tpat_tuple(_)},_) :: _ -> true
  | ({pat_desc = Tpat_record(_)},_) :: _ -> true
  | _ -> fatal_error "Parmatch.full_match"
@

<<function Parmatch.satisfiable>>=
(*
  Is the last row of pattern matrix pss + qs satisfiable ?
        That is :
  Does there List.exists at least one value vector, es such that :
   1/ for all ps in pss ps # es (ps and es are not compatible)
   2/ qs <= es                  (es matches qs)
*)

let rec satisfiable pss qs =
  match pss with
    [] -> true
  | _ ->
    match qs with
      [] -> false
    | {pat_desc = Tpat_or(q1,q2)}::qs ->
        satisfiable pss (q1::qs) or satisfiable pss (q2::qs)
    | {pat_desc = Tpat_alias(q,_)}::qs ->
        satisfiable pss (q::qs)
    | {pat_desc = (Tpat_any | Tpat_var(_))}::qs ->
        let q0 = simple_pat omega pss in     
        begin match filter_all q0 pss with
          (* first column of pss is made of variables only *)
          [] -> satisfiable (filter_extra pss) qs 
        | constrs ->          
            let try_non_omega (p,pss) =
              satisfiable pss (simple_match_args p omega @ qs)  in
            if full_match constrs
            then List.exists try_non_omega constrs
            else satisfiable (filter_extra pss) qs or
                 List.exists try_non_omega constrs
        end
    | q::qs ->
        let q0 = simple_pat q pss in
        satisfiable (filter_one q0 pss) (simple_match_args q0 q @ qs)
@

<<constant Parmatch.initial_matrix>>=
let rec initial_matrix = function
    [] -> []
  | (pat, act) :: rem ->
       if has_guard act
       then initial_matrix rem
       else [pat] :: initial_matrix rem
@

<<function Parmatch.get_mins>>=
let get_mins ps =
  let rec select_rec r = function
    [] -> r
  | p::ps ->
      if List.exists (fun p0 -> le_pats p0 p) ps
      then select_rec r ps
      else select_rec (p::r) ps in
  select_rec [] (select_rec [] ps)
@

<<function Parmatch.check_partial>>=
let check_partial loc casel =
  let pss = get_mins (initial_matrix casel) in
  if match pss with
      []     -> if casel = [] then false else true
    | ps::_  -> satisfiable pss (List.map (fun _ -> omega) ps)
  then Location.print_warning loc "this pattern-matching is not exhaustive"
@

<<constant Parmatch.location_of_clause>>=
let location_of_clause = function
    pat :: _ -> pat.pat_loc
  | _ -> fatal_error "Parmatch.location_of_clause"
@

<<function Parmatch.check_unused>>=
let check_unused casel =
  let prefs =   
    List.fold_right
      (fun (pat,act as clause) r ->
         if has_guard act
         then ([], ([pat], act)) :: r
         else ([], ([pat], act)) :: 
              List.map (fun (pss,clause) -> [pat]::pss,clause) r)
      casel [] in
  List.iter
    (fun (pss, ((qs, _) as clause)) ->
      if not (satisfiable pss qs) then
        Location.print_warning (location_of_clause qs)
                                "this match case is unused.")
    prefs
@


%-------------------------------------------------------------

<<./typing/parmatch.ml>>=
<<copyright header>>

(* Detection of partial matches and unused match cases. *)

open Misc
open Asttypes
open Types
open Typedtree

<<function Parmatch.make_pat>>

<<constant Parmatch.omega>>

<<function Parmatch.omegas>>

<<function Parmatch.omega_list>>

<<function Parmatch.has_guard>>

<<function Parmatch.simple_match>>

<<function Parmatch.record_labels>>

<<function Parmatch.record_num_fields>>

<<function Parmatch.set_fields>>

<<function Parmatch.simple_match_args>>

<<function Parmatch.simple_pat>>

<<function Parmatch.filter_one>>

<<function Parmatch.filter_extra>>

<<function Parmatch.filter_all>>

      
<<function Parmatch.full_match>>

<<function Parmatch.satisfiable>>

<<constant Parmatch.initial_matrix>>

let rec le_pat p q =
  match (p.pat_desc, q.pat_desc) with
    (Tpat_var _ | Tpat_any), _ -> true
  | Tpat_alias(p,_), _ -> le_pat p q
  | _, Tpat_alias(q,_) -> le_pat p q
  | Tpat_or(p1,p2), _ -> le_pat p1 q or le_pat p2 q
  | _, Tpat_or(q1,q2) -> le_pat p q1 & le_pat p q2
  | Tpat_constant(c1), Tpat_constant(c2) -> c1 = c2
  | Tpat_construct(c1,ps), Tpat_construct(c2,qs) ->
      c1.cstr_tag = c2.cstr_tag & le_pats ps qs
  | Tpat_tuple(ps), Tpat_tuple(qs) -> le_pats ps qs
  | Tpat_record(l1), Tpat_record(l2) ->
     let size = record_num_fields p in
     le_pats (set_fields size l1) (set_fields size l2)
  | _, _ -> false  

and le_pats ps qs =
  match ps,qs with
    p::ps, q::qs -> le_pat p q & le_pats ps qs
  | _, _         -> true

<<function Parmatch.get_mins>>

<<function Parmatch.check_partial>>

<<constant Parmatch.location_of_clause>>

<<function Parmatch.check_unused>>
@


\subsection*{[[./typing/typetexp.mli]]}


<<signature Typetexp.transl_simple_type_delayed>>=
val transl_simple_type_delayed:
        Env.t -> Parsetree.core_type -> Types.type_expr * (unit -> unit)
        (* Translate a type, but leave type variables unbound. Returns
           the type and a function that binds the type variable. *)
@

<<signature Typetexp.transl_type_scheme>>=
val transl_type_scheme:
        Env.t -> Parsetree.core_type -> Types.type_expr
@

<<signature Typetexp.reset_type_variables>>=
val reset_type_variables: unit -> unit
@

<<signature Typetexp.enter_type_variable>>=
val enter_type_variable: bool -> string -> Types.type_expr
@

<<signature Typetexp.type_variable>>=
val type_variable : Location.t -> string -> Types.type_expr
@

<<exception Typetexp.Already_bound>>=
exception Already_bound
@



%-------------------------------------------------------------

<<./typing/typetexp.mli>>=
<<copyright header>>

<<signature Typetexp.transl_simple_type>>
<<signature Typetexp.transl_simple_type_delayed>>
<<signature Typetexp.transl_type_scheme>>
<<signature Typetexp.reset_type_variables>>
<<signature Typetexp.enter_type_variable>>
<<signature Typetexp.type_variable>>

<<exception Typetexp.Already_bound>>

<<type Typetexp.error>>

<<exception Typetexp.Error>>

<<signature Typetexp.report_error>>
@


\subsection*{[[./typing/typetexp.ml]]}


<<constant Typetexp.type_variables>>=
(* Translation of type expressions *)

let type_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
@

<<constant Typetexp.aliases>>=
let aliases        = ref (Tbl.empty : (string, type_expr) Tbl.t)
@

<<constant Typetexp.used_variables>>=
let used_variables = ref (Tbl.empty : (string, type_expr) Tbl.t)
@

<<constant Typetexp.bindings>>=
let bindings       = ref ([] : (type_expr * type_expr) list)
        (* These two variables are used for the "delayed" policy. *)
@

<<function Typetexp.reset_type_variables>>=
let reset_type_variables () =
  reset_global_level ();
  type_variables := Tbl.empty
@

<<function Typetexp.enter_type_variable>>=
let enter_type_variable strict name =
  try
    let v = Tbl.find name !type_variables in
    if strict then raise Already_bound;
    v
  with Not_found ->
    let v = new_global_var() in
    type_variables := Tbl.add name v !type_variables;
    v
@

<<function Typetexp.type_variable>>=
let type_variable loc name =
  try
    Tbl.find name !type_variables
  with Not_found ->
    raise(Error(loc, Unbound_type_variable name))
@

<<type Typetexp.policy>>=
type policy = Fixed | Extensible | Delayed
@

<<function Typetexp.transl_type>>=
let rec transl_type env policy styp =
  match styp.ptyp_desc with
    Ptyp_any -> new_global_var()
  | Ptyp_var name ->
      begin try Tbl.find name !aliases with Not_found ->
        match policy with
          Fixed ->
            begin try
              Tbl.find name !type_variables
            with Not_found ->
              raise(Error(styp.ptyp_loc, Unbound_type_variable name))
            end
        | Extensible ->
            begin try
              Tbl.find name !type_variables
            with Not_found ->
              let v = new_global_var () in
              type_variables := Tbl.add name v !type_variables;
              v
            end
        | Delayed ->
            begin try
              Tbl.find name !used_variables
            with Not_found -> try
              let v1 = Tbl.find name !type_variables in
              let v2 = new_global_var () in
              used_variables := Tbl.add name v2 !used_variables;
              bindings := (v1, v2)::!bindings;
              v2
            with Not_found ->
              let v = new_global_var () in
              type_variables := Tbl.add name v !type_variables;
              used_variables := Tbl.add name v !used_variables;
              v
            end
      end
  | Ptyp_arrow(st1, st2) ->
      let ty1 = transl_type env policy st1 in
      let ty2 = transl_type env policy st2 in
      newty (Tarrow(ty1, ty2))
  | Ptyp_tuple stl ->
      newty (Ttuple(List.map (transl_type env policy) stl))
  | Ptyp_constr(lid, stl) ->
      let (path, decl) =
        try
          Env.lookup_type lid env
        with Not_found ->
          raise(Error(styp.ptyp_loc, Unbound_type_constructor lid)) in
      if List.length stl <> decl.type_arity then
        raise(Error(styp.ptyp_loc, Type_arity_mismatch(lid, decl.type_arity,
                                                           List.length stl)));
      let args = List.map (transl_type env policy) stl in
      let cstr = newty (Tconstr(path, args, ref Mnil)) in
      let params = Ctype.instance_list decl.type_params in
      List.iter2
        (fun (sty, ty) ty' ->
           try unify env ty ty' with Unify trace ->
             raise (Error(sty.ptyp_loc, Type_mismatch trace)))
        (List.combine stl args) params;
      cstr

  | Ptyp_alias(st, alias) ->
      begin try
        Tbl.find alias !type_variables;
        raise(Error(styp.ptyp_loc, Bound_type_variable alias))
      with Not_found -> try
        Tbl.find alias !aliases;
        raise(Error(styp.ptyp_loc, Bound_type_variable alias))
      with Not_found ->
        let ty' = newvar () in
        aliases := Tbl.add alias ty' !aliases;
        let ty = transl_type env policy st in
        begin try unify env ty ty' with Unify trace ->
          raise(Error(styp.ptyp_loc, Alias_type_mismatch trace))
        end;
        ty
      end 
@

<<function Typetexp.transl_simple_type>>=
let transl_simple_type env fixed styp =
  aliases := Tbl.empty;
  let typ = transl_type env (if fixed then Fixed else Extensible) styp in
  aliases := Tbl.empty;
  typ
@

<<function Typetexp.transl_simple_type_delayed>>=
let transl_simple_type_delayed env styp =
  aliases := Tbl.empty;
  used_variables := Tbl.empty;
  bindings := [];
  let typ = transl_type env Delayed styp in
  let b = !bindings in
  aliases := Tbl.empty;
  used_variables := Tbl.empty;
  bindings := [];
  (typ,
   function () -> List.iter (function (t1, t2) -> unify env t1 t2) b)
@

<<function Typetexp.transl_type_scheme>>=
let transl_type_scheme env styp =
  reset_type_variables();
  begin_def();
  let typ = transl_simple_type env false styp in
  end_def();
  generalize typ;
  typ
@



%-------------------------------------------------------------

<<./typing/typetexp.ml>>=
<<copyright header>>

(* Typechecking of type expressions for the core language *)

open Misc
open Parsetree
open Types
open Ctype

<<exception Typetexp.Already_bound>>

<<type Typetexp.error>>

<<exception Typetexp.Error>>

<<constant Typetexp.type_variables>>
<<constant Typetexp.aliases>>

<<constant Typetexp.used_variables>>
<<constant Typetexp.bindings>>

<<function Typetexp.reset_type_variables>>

<<function Typetexp.enter_type_variable>>

<<function Typetexp.type_variable>>

<<type Typetexp.policy>>

<<function Typetexp.transl_type>>

<<function Typetexp.transl_simple_type>>

<<function Typetexp.transl_simple_type_delayed>>

<<function Typetexp.transl_type_scheme>>

(* Error report *)

open Format
open Printtyp

<<constant Typetexp.report_error>>
@


\subsection*{[[./typing/includemod.mli]]}

<<signature Includemod.modtypes>>=
val modtypes: Env.t -> module_type -> module_type -> module_coercion
@

<<signature Includemod.signatures>>=
val signatures: Env.t -> signature -> signature -> module_coercion
@

<<signature Includemod.compunit>>=
val compunit: string -> signature -> string -> signature -> module_coercion
@

<<signature Includemod.type_declarations>>=
val type_declarations:
      Env.t -> Ident.t -> type_declaration -> type_declaration -> unit
@



%-------------------------------------------------------------

<<./typing/includemod.mli>>=
<<copyright header>>

(* Inclusion checks for the module language *)

open Types
open Typedtree

<<signature Includemod.modtypes>>
<<signature Includemod.signatures>>
<<signature Includemod.compunit>>
<<signature Includemod.type_declarations>>

<<type Includemod.error>>

<<exception Includemod.Error>>

<<signature Includemod.report_error>>
@


\subsection*{[[./typing/includemod.ml]]}

<<function Includemod.value_descriptions>>=
(* Inclusion between value descriptions *)

let value_descriptions env subst id vd1 vd2 =
  let vd2 = Subst.value_description subst vd2 in
  try
    Includecore.value_descriptions env vd1 vd2
  with Includecore.Dont_match ->
    raise(Error[Value_descriptions(id, vd1, vd2)])
@

<<function Includemod.type_declarations>>=
(* Inclusion between type declarations *)

let type_declarations env subst id decl1 decl2 =
  let decl2 = Subst.type_declaration subst decl2 in
  if Includecore.type_declarations env id decl1 decl2
  then ()
  else raise(Error[Type_declarations(id, decl1, decl2)])
@

<<function Includemod.exception_declarations>>=
(* Inclusion between exception declarations *)

let exception_declarations env subst id decl1 decl2 =
  let decl2 = Subst.exception_declaration subst decl2 in
  if Includecore.exception_declarations env decl1 decl2
  then ()
  else raise(Error[Exception_declarations(id, decl1, decl2)])
@

<<exception Includemod.Dont_match>>=
(* Expand a module type identifier when possible *)

exception Dont_match
@

<<function Includemod.expand_module_path>>=
let expand_module_path env path =
  try
    Env.find_modtype_expansion path env
  with Not_found ->
    raise Dont_match
@

<<type Includemod.field_desc>>=
(* Extract name, kind and ident from a signature item *)

type field_desc =
    Field_value of string
  | Field_type of string
  | Field_exception of string
  | Field_module of string
  | Field_modtype of string
@

<<constant Includemod.item_ident_name>>=
let item_ident_name = function
    Tsig_value(id, _) -> (id, Field_value(Ident.name id))
  | Tsig_type(id, _) -> (id, Field_type(Ident.name id))
  | Tsig_exception(id, _) -> (id, Field_exception(Ident.name id))
  | Tsig_module(id, _) -> (id, Field_module(Ident.name id))
  | Tsig_modtype(id, _) -> (id, Field_modtype(Ident.name id))
@

<<function Includemod.simplify_structure_coercion>>=
(* Simplify a structure coercion *)

let simplify_structure_coercion cc =
  let pos = ref 0 in
  try
    List.iter
      (fun (n, c) ->
        if n <> !pos or c <> Tcoerce_none then raise Exit;
        incr pos)
      cc;
    Tcoerce_none
  with Exit ->
    Tcoerce_structure cc
@

<<function Includemod.check_modtype_inclusion>>=
(* Simplified inclusion check between module types *)

let check_modtype_inclusion env mty1 mty2 =
  try
    modtypes env Subst.identity mty1 mty2; ()
  with Error reasons ->
    raise Not_found
@

<<toplevel Includemod._1>>=
let _ = Env.check_modtype_inclusion := check_modtype_inclusion
@

<<function Includemod.compunit>>=
(* Check that an implementation of a compilation unit meets its
   interface. *)

let compunit impl_name impl_sig intf_name intf_sig =
  try
    signatures Env.initial Subst.identity impl_sig intf_sig
  with Error reasons ->
    raise(Error(Interface_mismatch(impl_name, intf_name) :: reasons))
@

<<function Includemod.modtypes>>=
(* Hide the substitution parameter to the outside world *)

let modtypes env mty1 mty2 = modtypes env Subst.identity mty1 mty2
@

<<function Includemod.signatures>>=
let signatures env sig1 sig2 = signatures env Subst.identity sig1 sig2
@

<<function Includemod.type_declarations (./typing/includemod.ml)>>=
let type_declarations env id decl1 decl2 =
  type_declarations env Subst.identity id decl1 decl2
@



%-------------------------------------------------------------

<<./typing/includemod.ml>>=
<<copyright header>>

(* Inclusion checks for the module language *)

open Misc
open Path
open Types
open Typedtree

<<type Includemod.error>>

<<exception Includemod.Error>>

(* All functions "blah env x1 x2" check that x1 is included in x2,
   i.e. that x1 is the type of an implementation that fulfills the
   specification x2. If not, Error is raised with a backtrace of the error. *)

<<function Includemod.value_descriptions>>

<<function Includemod.type_declarations>>

<<function Includemod.exception_declarations>>

<<exception Includemod.Dont_match>>

<<function Includemod.expand_module_path>>

<<type Includemod.field_desc>>

<<constant Includemod.item_ident_name>>

<<function Includemod.simplify_structure_coercion>>

(* Inclusion between module types. 
   Return the restriction that transforms a value of the smaller type
   into a value of the bigger type. *)

let rec modtypes env subst mty1 mty2 =
  try
    try_modtypes env subst mty1 mty2
  with 
    Dont_match ->
      raise(Error[Module_types(mty1, Subst.modtype subst mty2)])
  | Error reasons ->
      raise(Error(Module_types(mty1, Subst.modtype subst mty2) :: reasons))

and try_modtypes env subst mty1 mty2 =
  match (mty1, mty2) with
    (_, Tmty_ident p2) ->
      try_modtypes2 env mty1 (Subst.modtype subst mty2)
  | (Tmty_ident p1, _) ->
      try_modtypes env subst (expand_module_path env p1) mty2
  | (Tmty_signature sig1, Tmty_signature sig2) ->
      signatures env subst sig1 sig2
(*
  | (_, _) ->
      raise Dont_match
*)

and try_modtypes2 env mty1 mty2 =
  (* mty2 is an identifier *)
  match (mty1, mty2) with
    (Tmty_ident p1, Tmty_ident p2) when Path.same p1 p2 ->
      Tcoerce_none
  | (_, Tmty_ident p2) ->
      try_modtypes env Subst.identity mty1 (expand_module_path env p2)
  | (_, _) ->
      fatal_error "Includemod.try_modtypes2"

(* Inclusion between signatures *)

and signatures env subst sig1 sig2 =
  (* Environment used to check inclusion of components *)
  let new_env =
    Env.add_signature sig1 env in
  (* Build a table of the components of sig1, along with their positions.
     The table is indexed by kind and name of component *)
  let rec build_component_table pos tbl = function
      [] -> tbl
    | item :: rem ->
        let (id, name) = item_ident_name item in
        let nextpos =
          match item with
            Tsig_value(_,{val_kind = Val_prim _})
          | Tsig_type(_,_)
          | Tsig_modtype(_,_) -> pos
          | Tsig_value(_,_)
          | Tsig_exception(_,_)
          | Tsig_module(_,_)
           -> pos+1 
        in
        build_component_table nextpos
                              (Tbl.add name (id, item, pos) tbl) rem in
  let comps1 =
    build_component_table 0 Tbl.empty sig1 in
  (* Pair each component of sig2 with a component of sig1,
     identifying the names along the way.
     Return a coercion list indicating, for all run-time components
     of sig2, the position of the matching run-time components of sig1
     and the coercion to be applied to it. *)
  let rec pair_components subst paired unpaired = function
      [] ->
        begin match unpaired with
            [] -> signature_components new_env subst (List.rev paired)
          | _  -> raise(Error unpaired)
        end
    | item2 :: rem ->
        let (id2, name2) = item_ident_name item2 in
        begin try
          let (id1, item1, pos1) = Tbl.find name2 comps1 in
          let new_subst =
            match item2 with
              Tsig_type _ ->
                Subst.add_type id2 (Pident id1) subst
            | Tsig_module _ ->
                Subst.add_module id2 (Pident id1) subst
            | Tsig_modtype _ ->
                Subst.add_modtype id2 (Tmty_ident (Pident id1)) subst
            | Tsig_value _ | Tsig_exception _  ->
                subst
          in
          pair_components new_subst
            ((item1, item2, pos1) :: paired) unpaired rem
        with Not_found ->
          pair_components subst paired (Missing_field id2 :: unpaired) rem
        end in
  (* Do the pairing and checking, and return the final coercion *)
  simplify_structure_coercion(pair_components subst [] [] sig2)

(* Inclusion between signature components *)

and signature_components env subst = function
    [] -> []
  | (Tsig_value(id1, valdecl1), Tsig_value(id2, valdecl2), pos) :: rem ->
      let cc = value_descriptions env subst id1 valdecl1 valdecl2 in
      begin match valdecl2.val_kind with
        Val_prim p -> signature_components env subst rem
      | _ -> (pos, cc) :: signature_components env subst rem
      end
  | (Tsig_type(id1, tydecl1), Tsig_type(id2, tydecl2), pos) :: rem ->
      type_declarations env subst id1 tydecl1 tydecl2;
      signature_components env subst rem
  | (Tsig_exception(id1, excdecl1), Tsig_exception(id2, excdecl2), pos)
    :: rem ->
      exception_declarations env subst id1 excdecl1 excdecl2;
      (pos, Tcoerce_none) :: signature_components env subst rem
  | (Tsig_module(id1, mty1), Tsig_module(id2, mty2), pos) :: rem ->
      let cc = modtypes env subst mty1 mty2 in
      (pos, cc) :: signature_components env subst rem
  | (Tsig_modtype(id1, info1), Tsig_modtype(id2, info2), pos) :: rem ->
      modtype_infos env subst id1 info1 info2;
      signature_components env subst rem
  | _ ->
      fatal_error "Includemod.signature_components"

(* Inclusion between module type specifications *)

and modtype_infos env subst id info1 info2 =
  let info2 = Subst.modtype_declaration subst info2 in
  try
    match (info1, info2) with
      (Tmodtype_abstract, Tmodtype_abstract) -> ()
    | (Tmodtype_manifest mty1, Tmodtype_abstract) -> ()
    | (Tmodtype_manifest mty1, Tmodtype_manifest mty2) ->
        check_modtype_equiv env mty1 mty2
    | (Tmodtype_abstract, Tmodtype_manifest mty2) ->
        check_modtype_equiv env (Tmty_ident(Pident id)) mty2
  with Error reasons ->
    raise(Error(Modtype_infos(id, info1, info2) :: reasons))

and check_modtype_equiv env mty1 mty2 =
  match
    (modtypes env Subst.identity mty1 mty2,
     modtypes env Subst.identity mty2 mty1)
  with
    (Tcoerce_none, Tcoerce_none) -> ()
  | (_, _) -> raise(Error [Modtype_permutation])

<<function Includemod.check_modtype_inclusion>>

<<toplevel Includemod._1>>

<<function Includemod.compunit>>

<<function Includemod.modtypes>>
<<function Includemod.signatures>>
<<function Includemod.type_declarations (./typing/includemod.ml)>>

(* Error report *)

open Format
open Printtyp

<<constant Includemod.include_err>>

<<function Includemod.report_error>>
@


\subsection*{[[./typing/typedecl.mli]]}




%-------------------------------------------------------------

<<./typing/typedecl.mli>>=
<<copyright header>>

(* Typing of type definitions and primitive definitions *)

open Types

<<signature Typedecl.transl_type_decl>>
<<signature Typedecl.transl_exception>>

<<signature Typedecl.transl_value_decl>>

<<type Typedecl.error>>

<<exception Typedecl.Error>>

<<signature Typedecl.report_error>>
@


\subsection*{[[./typing/typedecl.ml]]}

<<function Typedecl.enter_types>>=
(* Enter all declared types in the environment as abstract types *)

let rec enter_types env = function
    ([], []) ->
      (env, [])
  | ((name, sdecl) :: srem, id :: irem) ->
      let decl =
        { type_params = List.map (fun _ -> Ctype.newvar ()) sdecl.ptype_params;
          type_arity = List.length sdecl.ptype_params;
          type_kind = Type_abstract;
          type_manifest =
            match sdecl.ptype_manifest with
              None -> None
            | Some _ -> Some (Ctype.newvar ()) }
      in
      let extenv = Env.add_type id decl env in
      let (ext_env, decl_rem) = enter_types extenv (srem, irem) in
      (ext_env, (id, decl) :: decl_rem)
  | _ ->
      fatal_error "Typedecl.enter_types"
@

<<function Typedecl.transl_declaration>>=
(* First pass: parameters, constraints and expansion *)
let transl_declaration env (name, sdecl) (id, decl) =
  reset_type_variables();
  begin try
    List.iter2
      (fun ty sty -> Ctype.unify env ty (enter_type_variable true sty))
      decl.type_params sdecl.ptype_params
  with Already_bound ->
    raise(Error(sdecl.ptype_loc, Repeated_parameter))
  end;

  let cstr_params =
    List.map (function (v, _, loc) -> type_variable loc v) sdecl.ptype_cstrs
  in
  List.iter2
    (fun (v, sty, loc) ty' ->
       try
         Ctype.unify env (transl_simple_type env false sty) ty'
       with Ctype.Unify _ ->
         raise(Error(loc, Unconsistent_constraint)))
    sdecl.ptype_cstrs cstr_params;

  let decl' =
    { type_params = decl.type_params;
      type_arity = decl.type_arity;
      type_kind =
        Type_abstract;
      type_manifest =
        begin match (decl.type_manifest, sdecl.ptype_manifest) with
          (None, None) -> None
        | (Some ty, Some sty) ->
            let ty' =
              Ctype.unroll_abbrev id decl.type_params
                (transl_simple_type env true sty)
            in
            if Ctype.cyclic_abbrev env id ty' then
              raise(Error(sdecl.ptype_loc, Recursive_abbrev name));
            begin try Ctype.unify env ty' ty with Ctype.Unify trace ->
              raise(Error(sdecl.ptype_loc, Type_clash trace))
            end;
            Some ty
        | _ ->
            fatal_error "Typedecl.transl_declaration"
        end } in
  (id, decl')
@

<<function Typedecl.transl_declaration2>>=
(* Second pass: representation *)
let transl_declaration2 env (name, sdecl) (id, decl) =
  let (params, typ) =
    match decl.type_manifest with
      None -> (Ctype.instance_list decl.type_params, None)
    | Some typ ->
        let (params, typ) =
          Ctype.instance_parameterized_type decl.type_params typ
        in
        (params, Some typ)
  in

  (* Bind type parameters *)
  reset_type_variables();
  List.iter2
    (fun ty sty -> Ctype.unify env ty (enter_type_variable true sty))
    params sdecl.ptype_params;

  let decl' =
    { type_params = params;
      type_arity = decl.type_arity;
      type_kind =
        begin match sdecl.ptype_kind with
          Ptype_abstract ->
            Type_abstract
        | Ptype_variant cstrs ->
            let all_constrs = ref StringSet.empty in
            List.iter
              (fun (name, args) ->
                if StringSet.mem name !all_constrs then
                  raise(Error(sdecl.ptype_loc, Duplicate_constructor name));
                all_constrs := StringSet.add name !all_constrs)
              cstrs;
            if List.length cstrs > Config.max_tag then
              raise(Error(sdecl.ptype_loc, Too_many_constructors));
            Type_variant(List.map
              (fun (name, args) ->
                      (name, List.map (transl_simple_type env true) args))
              cstrs)
        | Ptype_record lbls ->
            let all_labels = ref StringSet.empty in
            List.iter
              (fun (name, mut, arg) ->
                if StringSet.mem name !all_labels then
                  raise(Error(sdecl.ptype_loc, Duplicate_label name));
                all_labels := StringSet.add name !all_labels)
              lbls;
            Type_record(List.map
              (fun (name, mut, arg) ->
                      (name, mut, transl_simple_type env true arg))
              lbls)
        end;
      type_manifest = typ } in
  (id, decl')
@

<<function Typedecl.generalize_decl>>=
(* Generalize a type declaration *)

let generalize_decl decl =
  List.iter Ctype.generalize decl.type_params;
  begin match decl.type_kind with
    Type_abstract ->
      ()
  | Type_variant v ->
      List.iter (fun (_, tyl) -> List.iter Ctype.generalize tyl) v
  | Type_record r ->
      List.iter (fun (_, _, ty) -> Ctype.generalize ty) r
  end;
  begin match decl.type_manifest with
    None    -> ()
  | Some ty -> Ctype.generalize ty
  end
@

<<function Typedecl.check_abbrev>>=
(*
   If both a variant/record definition and a type equation are given,
   need to check that the equation refers to a type of the same kind
   with the same constructors and labels.
*)
let check_abbrev env (_, sdecl) (id, decl) =
  match decl with
    {type_kind = (Type_variant _ | Type_record _); type_manifest = Some ty} ->
      begin match (Ctype.repr ty).desc with
        Tconstr(path, args, _) ->
          begin try
            let decl' = Env.find_type path env in
            if
              List.length args = List.length decl.type_params
                      &&
              Ctype.equal env false args decl.type_params
                      &&
              Includecore.type_declarations env id
                decl'
                (Subst.type_declaration (Subst.add_type id path Subst.identity)
                                        decl)
            then ()
            else raise(Error(sdecl.ptype_loc, Definition_mismatch ty))
          with Not_found ->
            raise(Error(sdecl.ptype_loc, Definition_mismatch ty))
          end
      | _ -> raise(Error(sdecl.ptype_loc, Definition_mismatch ty))
      end
  | _ -> ()
@

<<function Typedecl.check_recursive_abbrev>>=
(* Occur check *)
let check_recursive_abbrev env (name, sdecl) (id, decl) =
  match decl.type_manifest with
    Some ty ->
      begin try Ctype.correct_abbrev env id decl.type_params ty with
        Ctype.Recursive_abbrev ->
          raise(Error(sdecl.ptype_loc, Recursive_abbrev name))
      end
  | _ ->
      ()
@

<<function Typedecl.transl_type_decl>>=
(* Translate a set of mutually recursive type declarations *)
let transl_type_decl env name_sdecl_list =
  (* Create identifiers. *)
  let id_list =
    List.map (fun (name, _) -> Ident.create name) name_sdecl_list
  in
  (*
     Since we've introduced fresh idents, make sure the definition
     level is at least the binding time of these events. Otherwise,
     passing one of the recursively-defined type constrs as argument
     to an abbreviation may fail.
  *)
  Ctype.init_def(Ident.current_time());
  Ctype.begin_def();
  (* Enter types. *)
  let (temp_env, temp_decl) = enter_types env (name_sdecl_list, id_list) in
  (* Translate each declaration. *)
  let decls =
    List.map2 (transl_declaration temp_env) name_sdecl_list temp_decl in
  (* Generalize intermediate type declarations. *)
  Ctype.end_def();
  List.iter (function (_, decl) -> generalize_decl decl) decls;
  (* Build an env. containing type expansions *)
  let temp_env =
    List.fold_right
      (fun (id, decl) env -> Env.add_type id decl env)
      decls env
  in
  (* Check for recursive abbrevs *)
  List.iter2 (check_recursive_abbrev temp_env) name_sdecl_list decls;
  Ctype.begin_def();
  let decls =
    List.map2 (transl_declaration2 temp_env) name_sdecl_list decls in
  (* Generalize final type declarations. *)
  Ctype.end_def();
  List.iter (function (_, decl) -> generalize_decl decl) decls;
  (* Build the final env. *)
  let newenv =
    List.fold_right
      (fun (id, decl) env -> Env.add_type id decl env)
      decls env
  in
  (* Check re-exportation *)
  List.iter2 (check_abbrev newenv) name_sdecl_list decls;
  (* Done *)
  (decls, newenv)
@

<<function Typedecl.transl_exception>>=
(* Translate an exception declaration *)
let transl_exception env excdecl =
  reset_type_variables();
  Ctype.begin_def();
  let types = List.map (transl_simple_type env true) excdecl in
  Ctype.end_def();
  List.iter Ctype.generalize types;
  types
@

<<function Typedecl.transl_value_decl>>=
(* Translate a value declaration *)
let transl_value_decl env valdecl =
  let ty = Typetexp.transl_type_scheme env valdecl.pval_type in
  match valdecl.pval_prim with
    [] ->
      { val_type = ty; val_kind = Val_reg }
  | decl ->
      let arity = Ctype.arity ty in
      if arity = 0 then
        raise(Error(valdecl.pval_type.ptyp_loc, Null_arity_external));
      let prim = Primitive.parse_declaration arity decl in
      { val_type = ty; val_kind = Val_prim prim }
@


%-------------------------------------------------------------

<<./typing/typedecl.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(* Xavier Leroy and Jerome Vouillon, projet Cristal, INRIA Rocquencourt*)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)


(**** Typing of type definitions ****)

open Misc
open Parsetree
open Types
open Typedtree
open Typetexp

<<type Typedecl.error>>

<<exception Typedecl.Error>>

<<function Typedecl.enter_types>>

(* Translate one type declaration *)

module StringSet = Set

<<function Typedecl.transl_declaration>>

<<function Typedecl.transl_declaration2>>

<<function Typedecl.generalize_decl>>

<<function Typedecl.check_abbrev>>

(* Check for ill-defined abbrevs *)

<<function Typedecl.check_recursive_abbrev>>

<<function Typedecl.transl_type_decl>>

<<function Typedecl.transl_exception>>

<<function Typedecl.transl_value_decl>>

(**** Error report ****)

open Format

<<constant Typedecl.report_error>>
@


\subsection*{[[./typing/typecore.mli]]}


%-------------------------------------------------------------

<<./typing/typecore.mli>>=
<<copyright header>>

(* Type inference for the core language *)

open Asttypes
open Types

<<signature Typecore.type_binding>>
<<signature Typecore.type_expression>>
<<signature Typecore.type_pattern_list>>
<<signature Typecore.type_expect>>
<<signature Typecore.type_exp>>

<<type Typecore.error>>

<<exception Typecore.Error>>

<<signature Typecore.report_error>>
@


\subsection*{[[./typing/typecore.ml]]}


<<constant Typecore.type_constant>>=
(* Typing of constants *)

let type_constant = function
    Const_int _ -> instance Predef.type_int
  | Const_char _ -> instance Predef.type_char
  | Const_string _ -> instance Predef.type_string
  | Const_float _ -> instance Predef.type_float
@

<<function Typecore.unify_pat>>=
(* Typing of patterns *)

let unify_pat env pat expected_ty =
  try
    unify env pat.pat_type expected_ty
  with Unify trace ->
    raise(Error(pat.pat_loc, Pattern_type_clash(trace)))
@

<<constant Typecore.pattern_variables>>=
let pattern_variables = ref ([]: (Ident.t * type_expr) list)
@

<<function Typecore.enter_variable>>=
let enter_variable loc name ty =
  if List.exists (fun (id, ty) -> Ident.name id = name) !pattern_variables
  then raise(Error(loc, Multiply_bound_variable));
  let id = Ident.create name in
  pattern_variables := (id, ty) :: !pattern_variables;
  id
@

<<function Typecore.type_pat>>=
let rec type_pat env sp =
  match sp.ppat_desc with
    Ppat_any ->
      { pat_desc = Tpat_any;
        pat_loc = sp.ppat_loc;
        pat_type = newvar() }
  | Ppat_var name ->
      let ty = newvar() in
      let id = enter_variable sp.ppat_loc name ty in
      { pat_desc = Tpat_var id;
        pat_loc = sp.ppat_loc;
        pat_type = ty }
  | Ppat_alias(sp, name) ->
      let p = type_pat env sp in
      let id = enter_variable sp.ppat_loc name p.pat_type in
      { pat_desc = Tpat_alias(p, id);
        pat_loc = sp.ppat_loc;
        pat_type = p.pat_type }
  | Ppat_constant cst ->
      { pat_desc = Tpat_constant cst;
        pat_loc = sp.ppat_loc;
        pat_type = type_constant cst }
  | Ppat_tuple spl ->
      let pl = List.map (type_pat env) spl in
      { pat_desc = Tpat_tuple pl;
        pat_loc = sp.ppat_loc;
        pat_type = newty (Ttuple(List.map (fun p -> p.pat_type) pl)) }
  | Ppat_construct(lid, sarg, explicit_arity) ->
      let constr =
        try
          Env.lookup_constructor lid env
        with Not_found ->
          raise(Error(sp.ppat_loc, Unbound_constructor lid)) in
      let sargs =
        match sarg with
          None -> []
        | Some {ppat_desc = Ppat_tuple spl} when explicit_arity -> spl
        | Some {ppat_desc = Ppat_tuple spl} when constr.cstr_arity > 1 -> spl
        | Some({ppat_desc = Ppat_any} as sp) when constr.cstr_arity > 1 ->
            replicate_list sp constr.cstr_arity
        | Some sp -> [sp] in
      if List.length sargs <> constr.cstr_arity then
        raise(Error(sp.ppat_loc, Constructor_arity_mismatch(lid,
                                     constr.cstr_arity, List.length sargs)));
      let args = List.map (type_pat env) sargs in
      let (ty_args, ty_res) = instance_constructor constr in
      List.iter2 (unify_pat env) args ty_args;
      { pat_desc = Tpat_construct(constr, args);
        pat_loc = sp.ppat_loc;
        pat_type = ty_res }
  | Ppat_record lid_sp_list ->
      let ty = newvar() in
      let type_label_pat (lid, sarg) =
        let label =
          try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sp.ppat_loc, Unbound_label lid)) in
        let (ty_arg, ty_res) = instance_label label in
        begin try
          unify env ty_res ty
        with Unify trace ->
          raise(Error(sp.ppat_loc, Label_mismatch(lid, trace)))
        end;
        let arg = type_pat env sarg in
        unify_pat env arg ty_arg;
        (label, arg)
      in
      { pat_desc = Tpat_record(List.map type_label_pat lid_sp_list);
        pat_loc = sp.ppat_loc;
        pat_type = ty }
  | Ppat_or(sp1, sp2) ->
      let initial_pattern_variables = !pattern_variables in
      let p1 = type_pat env sp1 in
      let p2 = type_pat env sp2 in
      if !pattern_variables != initial_pattern_variables then
        raise(Error(sp.ppat_loc, Orpat_not_closed));
      unify_pat env p2 p1.pat_type;
      { pat_desc = Tpat_or(p1, p2);
        pat_loc = sp.ppat_loc;
        pat_type = p1.pat_type }
  | Ppat_constraint(sp, sty) ->
      let p = type_pat env sp in
      let ty = Typetexp.transl_simple_type env false sty in
      unify_pat env p ty;
      p
@

<<function Typecore.add_pattern_variables>>=
let add_pattern_variables env =
  let pv = !pattern_variables in
  pattern_variables := [];
  List.fold_right
    (fun (id, ty) env ->
      Env.add_value id {val_type = ty; val_kind = Val_reg} env)
    pv env
@

<<function Typecore.type_pattern>>=
let type_pattern env spat =
  pattern_variables := [];
  let pat = type_pat env spat in
  let new_env = add_pattern_variables env in
  (pat, new_env)
@

<<function Typecore.type_pattern_list>>=
let type_pattern_list env spatl =
  pattern_variables := [];
  let patl = List.map (type_pat env) spatl in
  let new_env = add_pattern_variables env in
  (patl, new_env)
@

<<function Typecore.iter_pattern>>=
let rec iter_pattern f p =
  f p;
  match p.pat_desc with
    Tpat_any | Tpat_var _ | Tpat_constant _ ->
      ()
  | Tpat_alias (p, _) ->
      iter_pattern f p
  | Tpat_tuple pl ->
      List.iter (iter_pattern f) pl
  | Tpat_construct (_, pl) ->
      List.iter (iter_pattern f) pl
  | Tpat_record fl ->
      List.iter (fun (_, p) -> iter_pattern f p) fl
  | Tpat_or (p, p') ->
      iter_pattern f p;
      iter_pattern f p'
@

<<function Typecore.is_nonexpansive>>=
(* Generalization criterion for expressions *)

let rec is_nonexpansive exp =
  match exp.exp_desc with
    Texp_ident(_,_) -> true
  | Texp_constant _ -> true
  | Texp_let(rec_flag, pat_exp_list, body) ->
      List.for_all (fun (pat, exp) -> is_nonexpansive exp) pat_exp_list &
      is_nonexpansive body
  | Texp_function _ -> true
  | Texp_tuple el ->
      List.for_all is_nonexpansive el
  | Texp_construct(_, el) ->
      List.for_all is_nonexpansive el
  | Texp_record lbl_exp_list ->
      List.for_all
        (fun (lbl, exp) -> lbl.lbl_mut = Immutable & is_nonexpansive exp)
        lbl_exp_list
  | Texp_field(exp, lbl) -> is_nonexpansive exp
  | Texp_array [] -> true
  | _ -> false
@

<<function Typecore.type_format>>=
(* Typing of printf formats *)

let type_format loc fmt =
  let len = String.length fmt in
  let ty_input = newvar()
  and ty_result = newvar() in
  let rec skip_args j =
    if j >= len then j else
      match fmt.[j] with
        '0' .. '9' | ' ' | '.' | '-' -> skip_args (j+1)
      | _ -> j in
  let rec scan_format i =
    if i >= len then ty_result else
    match fmt.[i] with
      '%' ->
        let j = skip_args(i+1) in
        begin match String.unsafe_get fmt j with
        (* We're using unsafe_get here so that if j = String.length fmt,
           we'll fall in the catch-all case of the match *)
          '%' ->
            scan_format (j+1)
        | 's' ->
            newty (Tarrow(instance Predef.type_string, scan_format (j+1)))
        | 'c' ->
            newty (Tarrow(instance Predef.type_char, scan_format (j+1)))
        | 'd' | 'o' | 'x' | 'X' | 'u' ->
            newty (Tarrow(instance Predef.type_int, scan_format (j+1)))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            newty (Tarrow(instance Predef.type_float, scan_format (j+1)))
        | 'b' ->
            newty (Tarrow(instance Predef.type_bool, scan_format (j+1)))
        | 'a' ->
            let ty_arg = newvar() in
            newty (Tarrow (newty (Tarrow(ty_input,
                                         newty (Tarrow (ty_arg, ty_result)))),
                           newty (Tarrow (ty_arg, scan_format (j+1)))))
        | 't' ->
            newty (Tarrow(newty (Tarrow(ty_input, ty_result)),
                          scan_format (j+1)))
        | c ->
            raise(Error(loc, Bad_format(String.sub fmt i (j-i+1))))
        end
    | _ -> scan_format (i+1) in
  newty
    (Tconstr(Predef.path_format, [scan_format 0; ty_input; ty_result], ref Mnil))
@

<<function Typecore.unify_exp>>=
(* Typing of expressions *)

let unify_exp env exp expected_ty =
  try
    unify env exp.exp_type expected_ty
  with Unify trace ->
    raise(Error(exp.exp_loc, Expr_type_clash(trace)))
@

<<function Typecore.type_binding>>=
(* Typing of toplevel bindings *)

let type_binding env rec_flag spat_sexp_list =
  Typetexp.reset_type_variables();
  type_let env rec_flag spat_sexp_list
@

<<function Typecore.type_expression>>=
(* Typing of toplevel expressions *)

let type_expression env sexp =
  Typetexp.reset_type_variables();
  begin_def();
  let exp = type_exp env sexp in
  end_def();
  if is_nonexpansive exp then generalize exp.exp_type
  else make_nongen exp.exp_type;
  exp
@

<<function Typecore.type_expect_fun>>=
(* Typing of methods *)

let rec type_expect_fun env sexp ty_expected =
  match sexp.pexp_desc with
    Pexp_function caselist ->
      let (ty_arg, ty_res) =
        try filter_arrow env ty_expected with Unify _ ->
          raise(Error(sexp.pexp_loc, Too_many_arguments))
      in
      let cases =
        List.map
          (fun (spat, sexp) ->
             let (pat, ext_env) = type_pattern env spat in
             unify_pat env pat ty_arg;
             let exp = type_expect_fun ext_env sexp ty_res in
             (pat, exp))
          caselist
      in
      Parmatch.check_unused cases;
      Parmatch.check_partial sexp.pexp_loc cases;
      { exp_desc = Texp_function cases;
        exp_loc = sexp.pexp_loc;
        exp_type = newty (Tarrow(ty_arg, ty_res));
        exp_env = env }
  | _ ->
      type_expect env sexp ty_expected
@

%-------------------------------------------------------------

<<./typing/typecore.ml>>=
<<copyright header>>

(* Typechecking for the core language *)

open Misc
open Asttypes
open Parsetree
open Types
open Typedtree
open Btype
open Ctype


<<type Typecore.error>>

<<exception Typecore.Error>>

<<constant Typecore.type_constant>>

<<function Typecore.unify_pat>>

<<constant Typecore.pattern_variables>>

<<function Typecore.enter_variable>>

<<function Typecore.type_pat>>

<<function Typecore.add_pattern_variables>>

<<function Typecore.type_pattern>>

<<function Typecore.type_pattern_list>>

<<function Typecore.iter_pattern>>

<<function Typecore.is_nonexpansive>>

<<function Typecore.type_format>>

<<function Typecore.unify_exp>>

let rec type_exp env sexp =
  match sexp.pexp_desc with
    Pexp_ident lid ->
      begin try
        let (path, desc) = Env.lookup_value lid env in
        { exp_desc =
            begin match (desc.val_kind, lid) with
            | _ ->
                Texp_ident(path, desc)
            end;
          exp_loc = sexp.pexp_loc;
          exp_type = instance desc.val_type;
          exp_env = env }
      with Not_found ->
        raise(Error(sexp.pexp_loc, Unbound_value lid))
      end
  | Pexp_constant cst ->
      { exp_desc = Texp_constant cst;
        exp_loc = sexp.pexp_loc;
        exp_type = type_constant cst;
        exp_env = env }
  | Pexp_let(rec_flag, spat_sexp_list, sbody) ->
      let (pat_exp_list, new_env) = type_let env rec_flag spat_sexp_list in
      let body = type_exp new_env sbody in
      { exp_desc = Texp_let(rec_flag, pat_exp_list, body);
        exp_loc = sexp.pexp_loc;
        exp_type = body.exp_type;
        exp_env = env }
  | Pexp_function caselist ->
      let ty_arg = newvar() and ty_res = newvar() in
      let cases = type_cases env ty_arg ty_res caselist in
      Parmatch.check_unused cases;
      Parmatch.check_partial sexp.pexp_loc cases;
      { exp_desc = Texp_function cases;
        exp_loc = sexp.pexp_loc;
        exp_type = newty (Tarrow(ty_arg, ty_res));
        exp_env = env }
  | Pexp_apply(sfunct, sargs) ->
      let funct = type_exp env sfunct in
      let rec type_args ty_fun = function
        [] ->
          ([], ty_fun)
      | sarg1 :: sargl ->
          let (ty1, ty2) =
            try
              filter_arrow env ty_fun
            with Unify _ ->
              raise(Error(sfunct.pexp_loc,
                          Apply_non_function funct.exp_type)) in
          let arg1 = type_expect env sarg1 ty1 in
          let (argl, ty_res) = type_args ty2 sargl in
          (arg1 :: argl, ty_res) in
      let (args, ty_res) = type_args funct.exp_type sargs in
      { exp_desc = Texp_apply(funct, args);
        exp_loc = sexp.pexp_loc;
        exp_type = ty_res;
        exp_env = env }
  | Pexp_match(sarg, caselist) ->
      let arg = type_exp env sarg in
      let ty_res = newvar() in
      let cases = type_cases env arg.exp_type ty_res caselist in
      Parmatch.check_unused cases;
      Parmatch.check_partial sexp.pexp_loc cases;
      { exp_desc = Texp_match(arg, cases);
        exp_loc = sexp.pexp_loc;
        exp_type = ty_res;
        exp_env = env }
  | Pexp_try(sbody, caselist) ->
      let body = type_exp env sbody in
      let cases =
        type_cases env (instance Predef.type_exn) body.exp_type caselist in
      Parmatch.check_unused cases;
      { exp_desc = Texp_try(body, cases);
        exp_loc = sexp.pexp_loc;
        exp_type = body.exp_type;
        exp_env = env }
  | Pexp_tuple sexpl ->
      let expl = List.map (type_exp env) sexpl in
      { exp_desc = Texp_tuple expl;
        exp_loc = sexp.pexp_loc;
        exp_type = newty (Ttuple(List.map (fun exp -> exp.exp_type) expl));
        exp_env = env }
  | Pexp_construct(lid, sarg, explicit_arity) ->
      let constr =
        try
          Env.lookup_constructor lid env
        with Not_found ->
          raise(Error(sexp.pexp_loc, Unbound_constructor lid)) in
      let sargs =
        match sarg with
          None -> []
        | Some {pexp_desc = Pexp_tuple sel} when explicit_arity -> sel
        | Some {pexp_desc = Pexp_tuple sel} when constr.cstr_arity > 1 -> sel
        | Some se -> [se] in
      if List.length sargs <> constr.cstr_arity then
        raise(Error(sexp.pexp_loc, Constructor_arity_mismatch(lid,
                                       constr.cstr_arity, List.length sargs)));
      let (ty_args, ty_res) = instance_constructor constr in
      let args = List.map2 (type_expect env) sargs ty_args in
      { exp_desc = Texp_construct(constr, args);
        exp_loc = sexp.pexp_loc;
        exp_type = ty_res;
        exp_env = env }
  | Pexp_record lid_sexp_list ->
      let ty = newvar() in
      let num_fields = ref 0 in
      let type_label_exp (lid, sarg) =
        let label =
          try
            Env.lookup_label lid env
          with Not_found ->
            raise(Error(sexp.pexp_loc, Unbound_label lid)) in
        let (ty_arg, ty_res) = instance_label label in
        begin try
          unify env ty_res ty
        with Unify trace ->
          raise(Error(sexp.pexp_loc, Label_mismatch(lid, trace)))
        end;
        let arg = type_expect env sarg ty_arg in
        num_fields := Array.length label.lbl_all;
        (label, arg) in
      let lbl_exp_list = List.map type_label_exp lid_sexp_list in
      let rec check_duplicates = function
        [] -> ()
      | (lid, sarg) :: remainder ->
          if List.mem_assoc lid remainder
          then raise(Error(sexp.pexp_loc, Label_multiply_defined lid))
          else check_duplicates remainder in
      check_duplicates lid_sexp_list;
      if List.length lid_sexp_list <> !num_fields then
        raise(Error(sexp.pexp_loc, Label_missing));
      { exp_desc = Texp_record lbl_exp_list;
        exp_loc = sexp.pexp_loc;
        exp_type = ty;
        exp_env = env }
  | Pexp_field(sarg, lid) ->
      let arg = type_exp env sarg in
      let label =
        try
          Env.lookup_label lid env
        with Not_found ->
          raise(Error(sexp.pexp_loc, Unbound_label lid)) in
      let (ty_arg, ty_res) = instance_label label in
      unify_exp env arg ty_res;
      { exp_desc = Texp_field(arg, label);
        exp_loc = sexp.pexp_loc;
        exp_type = ty_arg;
        exp_env = env }
  | Pexp_setfield(srecord, lid, snewval) ->
      let record = type_exp env srecord in
      let label =
        try
          Env.lookup_label lid env
        with Not_found ->
          raise(Error(sexp.pexp_loc, Unbound_label lid)) in
      if label.lbl_mut = Immutable then
        raise(Error(sexp.pexp_loc, Label_not_mutable lid));
      let (ty_arg, ty_res) = instance_label label in
      unify_exp env record ty_res;
      let newval = type_expect env snewval ty_arg in
      { exp_desc = Texp_setfield(record, label, newval);
        exp_loc = sexp.pexp_loc;
        exp_type = instance Predef.type_unit;
        exp_env = env }
  | Pexp_array(sargl) ->
      let ty = newvar() in
      let argl = List.map (fun sarg -> type_expect env sarg ty) sargl in
      { exp_desc = Texp_array argl;
        exp_loc = sexp.pexp_loc;
        exp_type = instance (Predef.type_array ty);
        exp_env = env }
  | Pexp_ifthenelse(scond, sifso, sifnot) ->
      let cond = type_expect env scond (instance Predef.type_bool) in
      begin match sifnot with
        None ->
          let ifso = type_expect env sifso (instance Predef.type_unit) in
          { exp_desc = Texp_ifthenelse(cond, ifso, None);
            exp_loc = sexp.pexp_loc;
            exp_type = instance Predef.type_unit;
            exp_env = env }
      | Some sifnot ->
          let ifso = type_exp env sifso in
          let ifnot = type_expect env sifnot ifso.exp_type in
          { exp_desc = Texp_ifthenelse(cond, ifso, Some ifnot);
            exp_loc = sexp.pexp_loc;
            exp_type = ifso.exp_type;
            exp_env = env }
      end
  | Pexp_sequence(sexp1, sexp2) ->
      let exp1 = type_statement env sexp1 in
      let exp2 = type_exp env sexp2 in
      { exp_desc = Texp_sequence(exp1, exp2);
        exp_loc = sexp.pexp_loc;
        exp_type = exp2.exp_type;
        exp_env = env }
  | Pexp_while(scond, sbody) ->
      let cond = type_expect env scond (instance Predef.type_bool) in
      let body = type_statement env sbody in
      { exp_desc = Texp_while(cond, body);
        exp_loc = sexp.pexp_loc;
        exp_type = instance Predef.type_unit;
        exp_env = env }
  | Pexp_for(param, slow, shigh, dir, sbody) ->
      let low = type_expect env slow (instance Predef.type_int) in
      let high = type_expect env shigh (instance Predef.type_int) in
      let (id, new_env) =
        Env.enter_value param {val_type = instance Predef.type_int;
                                val_kind = Val_reg} env in
      let body = type_statement new_env sbody in
      { exp_desc = Texp_for(id, low, high, dir, body);
        exp_loc = sexp.pexp_loc;
        exp_type = instance Predef.type_unit;
        exp_env = env }
  | Pexp_constraint(sarg, sty, sty') ->
      let (arg, ty') =
        match (sty, sty') with
          (None, None) ->               (* Case actually unused *)
            let arg = type_exp env sarg in
            (arg, arg.exp_type)
        | (Some sty, None) ->
            let ty = Typetexp.transl_simple_type env false sty in
            (type_expect env sarg ty, ty)
        | (None, Some sty') ->
            let (ty', force) =
              Typetexp.transl_simple_type_delayed env sty'
            in
            let ty = enlarge_type env ty' in
            force ();
            let arg = type_exp env sarg in
            begin try Ctype.unify env arg.exp_type ty with Unify trace ->
              raise(Error(sarg.pexp_loc,
                    Coercion_failure(ty', full_expand env ty', trace)))
            end;
            (arg, ty')
        | (Some sty, Some sty') ->
            let (ty, force) =
              Typetexp.transl_simple_type_delayed env sty
            and (ty', force') =
              Typetexp.transl_simple_type_delayed env sty'
            in
            begin try
              let force'' = subtype env ty ty' in
              force (); force' (); force'' ()
            with Subtype (tr1, tr2) ->
              raise(Error(sexp.pexp_loc, Not_subtype(tr1, tr2)))
            end;
            (type_expect env sarg ty, ty')
      in
      { exp_desc = arg.exp_desc;
        exp_loc = arg.exp_loc;
        exp_type = ty';
        exp_env = env }
  | Pexp_when(scond, sbody) ->
      let cond = type_expect env scond (instance Predef.type_bool) in
      let body = type_exp env sbody in
      { exp_desc = Texp_when(cond, body);
        exp_loc = sexp.pexp_loc;
        exp_type = body.exp_type;
        exp_env = env }

(* Typing of an expression with an expected type.
   Some constructs are treated specially to provide better error messages. *)

and type_expect env sexp ty_expected =
  match sexp.pexp_desc with
    Pexp_constant(Const_string s as cst) ->
      let exp =
        { exp_desc = Texp_constant cst;
          exp_loc = sexp.pexp_loc;
          exp_type =
            (* Terrible hack for format strings *)
            begin match (repr ty_expected).desc with
              Tconstr(path, _, _) when Path.same path Predef.path_format ->
                type_format sexp.pexp_loc s
            | _ -> instance Predef.type_string
            end;
          exp_env = env } in
      unify_exp env exp ty_expected;
      exp
  | Pexp_let(rec_flag, spat_sexp_list, sbody) ->
      let (pat_exp_list, new_env) = type_let env rec_flag spat_sexp_list in
      let body = type_expect new_env sbody ty_expected in
      { exp_desc = Texp_let(rec_flag, pat_exp_list, body);
        exp_loc = sexp.pexp_loc;
        exp_type = body.exp_type;
        exp_env = env }
  | Pexp_sequence(sexp1, sexp2) ->
      let exp1 = type_statement env sexp1 in
      let exp2 = type_expect env sexp2 ty_expected in
      { exp_desc = Texp_sequence(exp1, exp2);
        exp_loc = sexp.pexp_loc;
        exp_type = exp2.exp_type;
        exp_env = env }
  | _ ->
      let exp = type_exp env sexp in
      unify_exp env exp ty_expected;
      exp

(* Typing of statements (expressions whose values are discarded) *)

and type_statement env sexp =
    let exp = type_exp env sexp in
    match (repr exp.exp_type).desc with
      Tarrow(_, _) ->
        Location.print_warning sexp.pexp_loc
          "this function application is partial,\n\
           maybe some arguments are missing.";
        exp
    | _ -> exp

(* Typing of match cases *)

and type_cases env ty_arg ty_res caselist =
  List.map
    (fun (spat, sexp) ->
      let (pat, ext_env) = type_pattern env spat in
      unify_pat env pat ty_arg;
      let exp = type_expect ext_env sexp ty_res in
      (pat, exp))
    caselist

(* Typing of let bindings *)

and type_let env rec_flag spat_sexp_list =
  begin_def();
  let (pat_list, new_env) =
    type_pattern_list env (List.map (fun (spat, sexp) -> spat) spat_sexp_list)
  in
  let exp_env =
    match rec_flag with Nonrecursive -> env | Recursive -> new_env in
  let exp_list =
    List.map2
      (fun (spat, sexp) pat -> type_expect exp_env sexp pat.pat_type)
      spat_sexp_list pat_list in
  List.iter2
    (fun pat exp -> Parmatch.check_partial pat.pat_loc [pat, exp])
    pat_list exp_list;
  end_def();
  List.iter2
    (fun pat exp ->
       if not (is_nonexpansive exp) then
         iter_pattern (fun pat ->make_nongen pat.pat_type) pat)
    pat_list exp_list;
  List.iter
    (fun pat -> iter_pattern (fun pat -> generalize pat.pat_type) pat)
    pat_list;
  (List.combine pat_list exp_list, new_env)

<<function Typecore.type_binding>>

<<function Typecore.type_expression>>

<<function Typecore.type_expect_fun>>


(* Error report *)

open Format
open Printtyp

<<constant Typecore.report_error>>
@


\subsection*{[[./typing/typemod.mli]]}


<<signature Typemod.check_nongen_schemes>>=
val check_nongen_schemes:
        Env.t -> Typedtree.structure -> unit
@



%-------------------------------------------------------------

<<./typing/typemod.mli>>=
<<copyright header>>

(* Type-checking of the module language *)

open Types

<<signature Typemod.type_structure>>
<<signature Typemod.transl_signature>>
<<signature Typemod.check_nongen_schemes>>

<<type Typemod.error>>

<<exception Typemod.Error>>

<<signature Typemod.report_error>>
@


\subsection*{[[./typing/typemod.ml]]}

<<function Typemod.extract_sig_open>>=
(* Extract a signature from a module type *)

let extract_sig_open env loc mty =
  match Mtype.scrape env mty with
    Tmty_signature sg -> sg
  | _ -> raise(Error(loc, Structure_expected mty))
@

<<function Typemod.type_module_path>>=
(* Lookup the type of a module path *)

let type_module_path env loc lid =
  try
    Env.lookup_module lid env
  with Not_found ->
    raise(Error(loc, Unbound_module lid))
@

<<function Typemod.check_unique_names>>=
let check_unique_names sg =
  let type_names = ref StringSet.empty
  and module_names = ref StringSet.empty
  and modtype_names = ref StringSet.empty in
  let check cl loc set_ref name =
    if StringSet.mem name !set_ref
    then raise(Error(loc, Repeated_name(cl, name)))
    else set_ref := StringSet.add name !set_ref in
  let check_item item =
    match item.pstr_desc with
      Pstr_eval exp -> ()
    | Pstr_value(rec_flag, exps) -> ()
    | Pstr_primitive(name, desc) -> ()
    | Pstr_type name_decl_list ->
        List.iter
          (fun (name, decl) -> check "type" item.pstr_loc type_names name)
          name_decl_list
    | Pstr_exception(name, decl) -> ()
    | Pstr_module(name, smod) ->
        check "module" item.pstr_loc module_names name
    | Pstr_modtype(name, decl) ->
        check "module type" item.pstr_loc modtype_names name
    | Pstr_open lid -> ()
  in
    List.iter check_item sg
@

<<function Typemod.check_nongen_scheme>>=
let check_nongen_scheme env = function
    Tstr_value(rec_flag, pat_exp_list) ->
      List.iter
        (fun (pat, exp) ->
          if not (Ctype.closed_schema exp.exp_type) then
            raise(Error(exp.exp_loc, Non_generalizable exp.exp_type)))
        pat_exp_list
  | Tstr_module(id, md) ->
      if not (closed_modtype md.mod_type) then
        raise(Error(md.mod_loc, Non_generalizable_module md.mod_type))
  | _ -> ()
@

<<function Typemod.check_nongen_schemes>>=
let check_nongen_schemes env str =
  List.iter (check_nongen_scheme env) str
@



%-------------------------------------------------------------

<<./typing/typemod.ml>>=
<<copyright header>>

(* Type-checking of the module language *)

open Misc
open Longident
open Path
open Parsetree
open Types
open Typedtree


<<type Typemod.error>>

<<exception Typemod.Error>>

<<function Typemod.extract_sig_open>>

<<function Typemod.type_module_path>>

(* Check and translate a module type expression *)

let rec transl_modtype env smty =
  match smty.pmty_desc with
    Pmty_ident lid ->
      begin try
        let (path, info) = Env.lookup_modtype lid env in 
        Tmty_ident path
      with Not_found ->
        raise(Error(smty.pmty_loc, Unbound_modtype lid))
      end
  | Pmty_signature ssg ->
      Tmty_signature(transl_signature env ssg)
      
and transl_signature env sg =
  Ctype.init_def(Ident.current_time());
  match sg with
    [] -> []
  | {psig_desc = Psig_value(name, sdesc)} :: srem ->
      let desc = Typedecl.transl_value_decl env sdesc in
      let (id, newenv) = Env.enter_value name desc env in
      let rem = transl_signature newenv srem in
      Tsig_value(id, desc) :: rem
  | {psig_desc = Psig_type sdecls} :: srem ->
      let (decls, newenv) = Typedecl.transl_type_decl env sdecls in
      let rem = transl_signature newenv srem in
      map_end (fun (id, info) -> Tsig_type(id, info)) decls rem
  | {psig_desc = Psig_exception(name, sarg)} :: srem ->
      let arg = Typedecl.transl_exception env sarg in
      let (id, newenv) = Env.enter_exception name arg env in
      let rem = transl_signature newenv srem in
      Tsig_exception(id, arg) :: rem
  | {psig_desc = Psig_module(name, smty)} :: srem ->
      let mty = transl_modtype env smty in
      let (id, newenv) = Env.enter_module name mty env in
      let rem = transl_signature newenv srem in
      Tsig_module(id, mty) :: rem
  | {psig_desc = Psig_modtype(name, sinfo)} :: srem ->
      let info = transl_modtype_info env sinfo in
      let (id, newenv) = Env.enter_modtype name info env in
      let rem = transl_signature newenv srem in
      Tsig_modtype(id, info) :: rem
  | {psig_desc = Psig_open lid; psig_loc = loc} :: srem ->
      let (path, mty) = type_module_path env loc lid in
      let sg = extract_sig_open env loc mty in
      let newenv = Env.open_signature path sg env in
      transl_signature newenv srem

and transl_modtype_info env sinfo =
  match sinfo with
    Pmodtype_abstract ->
      Tmodtype_abstract
  | Pmodtype_manifest smty ->
      Tmodtype_manifest(transl_modtype env smty)

(* Check that all type and module identifiers in a structure have
   distinct names (so that access by named paths is unambiguous). *)

module StringSet = Set

<<function Typemod.check_unique_names>>

(* Check that all core type schemes in a structure are closed *)

let rec closed_modtype = function
    Tmty_ident p -> true
  | Tmty_signature sg -> List.for_all closed_signature_item sg

and closed_signature_item = function
    Tsig_value(id, desc) -> Ctype.closed_schema desc.val_type
  | Tsig_module(id, mty) -> closed_modtype mty
  | _ -> true

<<function Typemod.check_nongen_scheme>>

<<function Typemod.check_nongen_schemes>>

(* Type a module value expression *)

let rec type_module env smod =
  match smod.pmod_desc with
    Pmod_ident lid ->
      let (path, mty) = type_module_path env smod.pmod_loc lid in
      { mod_desc = Tmod_ident path;
        mod_type = Mtype.strengthen env mty path;
        mod_env = env;
        mod_loc = smod.pmod_loc }
  | Pmod_structure sstr ->
      let (str, sg, finalenv) = type_structure env sstr in
      { mod_desc = Tmod_structure str;
        mod_type = Tmty_signature sg;
        mod_env = env;
        mod_loc = smod.pmod_loc }
  | Pmod_constraint(sarg, smty) ->
      let arg = type_module env sarg in
      let mty = transl_modtype env smty in
      let coercion =
        try
          Includemod.modtypes env arg.mod_type mty
        with Includemod.Error msg ->
          raise(Error(sarg.pmod_loc, Not_included msg)) in
      { mod_desc = Tmod_constraint(arg, mty, coercion);
        mod_type = mty;
        mod_env = env;
        mod_loc = smod.pmod_loc }

and type_structure env sstr =
  check_unique_names sstr;
  type_struct env sstr

and type_struct env sstr =
  Ctype.init_def(Ident.current_time());
  match sstr with
    [] ->
      ([], [], env)
  | {pstr_desc = Pstr_eval sexpr} :: srem ->
      let expr = Typecore.type_expression env sexpr in
      let (str_rem, sig_rem, final_env) = type_struct env srem in
      (Tstr_eval expr :: str_rem, sig_rem, final_env)
  | {pstr_desc = Pstr_value(rec_flag, sdefs)} :: srem ->
      let (defs, newenv) =
        Typecore.type_binding env rec_flag sdefs in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      let bound_idents = let_bound_idents defs in
      let make_sig_value id =
        Tsig_value(id, Env.find_value (Pident id) newenv) in
      (Tstr_value(rec_flag, defs) :: str_rem,
       map_end make_sig_value bound_idents sig_rem,
       final_env)
  | {pstr_desc = Pstr_primitive(name, sdesc)} :: srem ->
      let desc = Typedecl.transl_value_decl env sdesc in
      let (id, newenv) = Env.enter_value name desc env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_primitive(id, desc) :: str_rem,
       Tsig_value(id, desc) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_type sdecls} :: srem ->
      let (decls, newenv) = Typedecl.transl_type_decl env sdecls in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_type decls :: str_rem,
       map_end (fun (id, info) -> Tsig_type(id, info)) decls sig_rem,
       final_env)
  | {pstr_desc = Pstr_exception(name, sarg)} :: srem ->
      let arg = Typedecl.transl_exception env sarg in
      let (id, newenv) = Env.enter_exception name arg env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_exception(id, arg) :: str_rem,
       Tsig_exception(id, arg) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_module(name, smodl)} :: srem ->
      let modl = type_module env smodl in
      let (id, newenv) = Env.enter_module name modl.mod_type env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_module(id, modl) :: str_rem,
       Tsig_module(id, modl.mod_type) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_modtype(name, smty)} :: srem ->
      let mty = transl_modtype env smty in
      let (id, newenv) = Env.enter_modtype name (Tmodtype_manifest mty) env in
      let (str_rem, sig_rem, final_env) = type_struct newenv srem in
      (Tstr_modtype(id, mty) :: str_rem,
       Tsig_modtype(id, Tmodtype_manifest mty) :: sig_rem,
       final_env)
  | {pstr_desc = Pstr_open lid; pstr_loc = loc} :: srem ->
      let (path, mty) = type_module_path env loc lid in
      let sg = extract_sig_open env loc mty in
      type_struct (Env.open_signature path sg env) srem

(* Error report *)

open Format
open Printtyp

<<constant Typemod.report_error>>
@


\section{[[./bytecomp/]]}


\subsection*{[[./bytecomp/lambda.mli]]}


<<signature Lambda.const_unit>>=
val const_unit: structured_constant
@

<<signature Lambda.lambda_unit>>=
val lambda_unit: lambda
@

<<signature Lambda.name_lambda>>=
val name_lambda: lambda -> (Ident.t -> lambda) -> lambda
@

<<signature Lambda.is_guarded>>=
val is_guarded: lambda -> bool
@

<<signature Lambda.free_variables>>=
val free_variables: lambda -> Ident.t Set.t
@

<<signature Lambda.transl_path>>=
val transl_path: Path.t -> lambda
@


%-------------------------------------------------------------

<<./bytecomp/lambda.mli>>=
<<copyright header>>

(* The "lambda" intermediate code *)

open Asttypes

<<type Lambda.primitive>>

<<type Lambda.comparison>>

<<type Lambda.array_kind>>

<<type Lambda.structured_constant>>

<<type Lambda.function_kind>>

<<type Lambda.let_kind>>

<<type Lambda.shared_code>>

<<type Lambda.lambda>>

<<type Lambda.lambda_switch>>

<<type Lambda.lambda_event>>

<<type Lambda.lambda_event_kind>>

<<signature Lambda.const_unit>>
<<signature Lambda.lambda_unit>>
<<signature Lambda.name_lambda>>
<<signature Lambda.is_guarded>>

<<signature Lambda.free_variables>>

<<signature Lambda.transl_path>>
@


\subsection*{[[./bytecomp/lambda.ml]]}



<<constant Lambda.const_unit>>=
let const_unit = Const_pointer 0
@

<<constant Lambda.lambda_unit>>=
let lambda_unit = Lconst const_unit
@

<<function Lambda.name_lambda>>=
let name_lambda arg fn =
  match arg with
    Lvar id -> fn id
  | _ -> let id = Ident.create "let" in Llet(Strict, id, arg, fn id)
@

<<function Lambda.free_variables>>=
let free_variables l =
  let fv = ref IdentSet.empty in
  let rec freevars = function
    Lvar id ->
      fv := IdentSet.add id !fv
  | Lconst sc -> ()
  | Lapply(fn, args) ->
      freevars fn; List.iter freevars args
  | Lfunction(kind, params, body) ->
      freevars body;
      List.iter (fun param -> fv := IdentSet.remove param !fv) params
  | Llet(str, id, arg, body) ->
      freevars arg; freevars body; fv := IdentSet.remove id !fv
  | Lletrec(decl, body) ->
      freevars body;
      List.iter (fun (id, exp) -> freevars exp) decl;
      List.iter (fun (id, exp) -> fv := IdentSet.remove id !fv) decl
  | Lprim(p, args) ->
      List.iter freevars args
  | Lswitch(arg, sw) ->
      freevars arg; 
      List.iter (fun (key, case) -> freevars case) sw.sw_consts;
      List.iter (fun (key, case) -> freevars case) sw.sw_blocks
  | Lstaticfail -> ()
  | Lcatch(e1, e2) ->
      freevars e1; freevars e2
  | Ltrywith(e1, exn, e2) ->
      freevars e1; freevars e2; fv := IdentSet.remove exn !fv
  | Lifthenelse(e1, e2, e3) ->
      freevars e1; freevars e2; freevars e3
  | Lsequence(e1, e2) ->
      freevars e1; freevars e2
  | Lwhile(e1, e2) ->
      freevars e1; freevars e2
  | Lfor(v, e1, e2, dir, e3) -> 
      freevars e1; freevars e2; freevars e3; fv := IdentSet.remove v !fv
  | Lassign(id, e) ->
      fv := IdentSet.add id !fv; freevars e
  | Levent (lam, evt) ->
      freevars lam
  in freevars l; !fv
@

<<constant Lambda.is_guarded>>=
(* Check if an action has a "when" guard *)

let rec is_guarded = function
    Lifthenelse(cond, body, Lstaticfail) -> true
  | Llet(str, id, lam, body) -> is_guarded body
  | Levent(lam, ev) -> is_guarded lam
  | _ -> false
@

<<constant Lambda.transl_path>>=
let rec transl_path = function
    Pident id ->
      if Ident.global id then Lprim(Pgetglobal id, []) else Lvar id
  | Pdot(p, s, pos) ->
      Lprim(Pfield pos, [transl_path p])
@


%-------------------------------------------------------------

<<./bytecomp/lambda.ml>>=
<<copyright header>>

open Misc
open Path
open Asttypes

<<type Lambda.primitive>>

<<type Lambda.comparison>>

<<type Lambda.array_kind>>

<<type Lambda.structured_constant>>

<<type Lambda.function_kind>>

<<type Lambda.let_kind>>

<<type Lambda.shared_code>>

<<type Lambda.lambda>>

<<type Lambda.lambda_switch>>

<<type Lambda.lambda_event>>

<<type Lambda.lambda_event_kind>>

<<constant Lambda.const_unit>>

<<constant Lambda.lambda_unit>>

<<function Lambda.name_lambda>>

module IdentSet = Set

<<function Lambda.free_variables>>

<<constant Lambda.is_guarded>>

<<constant Lambda.transl_path>>
@


\subsection*{[[./bytecomp/printlambda.mli]]}

%-------------------------------------------------------------

<<./bytecomp/printlambda.mli>>=
<<copyright header>>

open Lambda

<<signature Printlambda.structured_constant>>
<<signature Printlambda.lambda>>
@


\subsection*{[[./bytecomp/printlambda.ml]]}

%-------------------------------------------------------------

<<./bytecomp/printlambda.ml>>=
<<copyright header>>

open Format
open Asttypes
open Primitive
open Types
open Lambda


<<function Printlambda.structured_constant>>

<<function Printlambda.primitive>>

<<function Printlambda.lambda>>
@

\subsection*{[[./bytecomp/meta.mli]]}

<<type Meta.closure>>=
type closure = unit -> Obj.t
@


%-------------------------------------------------------------

<<./bytecomp/meta.mli>>=
<<copyright header>>

(* To control the runtime system and bytecode interpreter *)

external global_data : unit -> Obj.t array = "get_global_data"
external realloc_global_data : int -> unit = "realloc_global"
external static_alloc : int -> string = "static_alloc"
external static_free : string -> unit = "static_free"
<<type Meta.closure>>
external reify_bytecode : string -> int -> closure = "reify_bytecode"
external available_primitives : unit -> string array = "available_primitives"
@


\subsection*{[[./bytecomp/meta.ml]]}

<<type Meta.closure (./bytecomp/meta.ml)>>=
type closure = unit -> Obj.t
@


%-------------------------------------------------------------

<<./bytecomp/meta.ml>>=
<<copyright header>>

external global_data : unit -> Obj.t array = "get_global_data"
external realloc_global_data : int -> unit = "realloc_global"
external static_alloc : int -> string = "static_alloc"
external static_free : string -> unit = "static_free"
<<type Meta.closure (./bytecomp/meta.ml)>>
external reify_bytecode : string -> int -> closure = "reify_bytecode"
external available_primitives : unit -> string array = "available_primitives"
@


\subsection*{[[./bytecomp/runtimedef.mli]]}

<<signature Runtimedef.builtin_exceptions>>=
(* Values and functions known and/or provided by the runtime system *)

val builtin_exceptions: string array
@

<<signature Runtimedef.builtin_primitives>>=
val builtin_primitives: string array
@


%-------------------------------------------------------------

<<./bytecomp/runtimedef.mli>>=
<<copyright header>>

<<signature Runtimedef.builtin_exceptions>>
<<signature Runtimedef.builtin_primitives>>
@


\subsection*{[[./bytecomp/instruct.mli]]}


%-------------------------------------------------------------

<<./bytecomp/instruct.mli>>=
<<copyright header>>

(* The type of the instructions of the abstract machine *)

open Lambda

<<type Instruct.compilation_env>>

(* The ce_stack component gives locations of variables residing 
   in the stack. The locations are offsets w.r.t. the origin of the
   stack frame.
   The ce_heap component gives the positions of variables residing in the
   heap-allocated environment. *)

(* Debugging events *)

<<type Instruct.debug_event>>

<<type Instruct.debug_event_kind>>

<<type Instruct.debug_event_info>>

<<type Instruct.debug_event_repr>>

<<type Instruct.label>>

<<type Instruct.instruction>>

<<signature Instruct.immed_min>>
<<signature Instruct.immed_max>>
@


\subsection*{[[./bytecomp/instruct.ml]]}



%-------------------------------------------------------------

<<./bytecomp/instruct.ml>>=
<<copyright header>>

open Lambda

<<type Instruct.compilation_env>>


<<type Instruct.debug_event>>

<<type Instruct.debug_event_kind>>

<<type Instruct.debug_event_info>>

<<type Instruct.debug_event_repr>>

<<type Instruct.label>>

<<type Instruct.instruction>>

let immed_min = -0x40000000
and immed_max = 0x3FFFFFFF

(* Actually the abstract machine accomodates -0x80000000 to 0x7FFFFFFF,
   but these numbers overflow the Caml type int if the compiler runs on
   a 32-bit processor. *)
@


\subsection*{[[./bytecomp/printinstr.mli]]}

%-------------------------------------------------------------

<<./bytecomp/printinstr.mli>>=
<<copyright header>>

(* Pretty-print lists of instructions *)

open Instruct

<<signature Printinstr.instruction>>
<<signature Printinstr.instrlist>>
@


\subsection*{[[./bytecomp/printinstr.ml]]}


%-------------------------------------------------------------

<<./bytecomp/printinstr.ml>>=
<<copyright header>>

(* Pretty-print lists of instructions *)

open Format
open Lambda
open Instruct


<<constant Printinstr.instruction>>

<<constant Printinstr.instruction_list>>
 
<<function Printinstr.instrlist>>
@


\subsection*{[[./bytecomp/simplif.mli]]}



%-------------------------------------------------------------

<<./bytecomp/simplif.mli>>=
<<copyright header>>

(* Elimination of useless Llet(Alias) bindings *)

open Lambda

<<signature Simplif.simplify_lambda>>
@


\subsection*{[[./bytecomp/simplif.ml]]}

<<exception Simplif.Real_reference>>=
(* To transform let-bound references into variables *)

exception Real_reference
@

<<function Simplif.eliminate_ref>>=
let rec eliminate_ref id = function
    Lvar v as lam ->
      if Ident.same v id then raise Real_reference else lam
  | Lconst cst as lam -> lam
  | Lapply(e1, el) -> 
      Lapply(eliminate_ref id e1, List.map (eliminate_ref id) el)
  | Lfunction(kind, params, body) as lam ->
      if IdentSet.mem id (free_variables lam)
      then raise Real_reference
      else lam
  | Llet(str, v, e1, e2) ->
      Llet(str, v, eliminate_ref id e1, eliminate_ref id e2)
  | Lletrec(idel, e2) ->
      Lletrec(List.map (fun (v, e) -> (v, eliminate_ref id e)) idel,
              eliminate_ref id e2)
  | Lprim(Pfield 0, [Lvar v]) when Ident.same v id ->
      Lvar id
  | Lprim(Psetfield(0, _), [Lvar v; e]) when Ident.same v id ->
      Lassign(id, eliminate_ref id e)
  | Lprim(Poffsetref delta, [Lvar v]) when Ident.same v id ->
      Lassign(id, Lprim(Poffsetint delta, [Lvar id]))
  | Lprim(p, el) ->
      Lprim(p, List.map (eliminate_ref id) el)
  | Lswitch(e, sw) ->
      Lswitch(eliminate_ref id e,
        {sw_numconsts = sw.sw_numconsts;
         sw_consts =
            List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_consts;
         sw_numblocks = sw.sw_numblocks;
         sw_blocks =
            List.map (fun (n, e) -> (n, eliminate_ref id e)) sw.sw_blocks;
         sw_checked = sw.sw_checked})
  | Lstaticfail ->
      Lstaticfail
  | Lcatch(e1, e2) ->
      Lcatch(eliminate_ref id e1, eliminate_ref id e2)
  | Ltrywith(e1, v, e2) ->
      Ltrywith(eliminate_ref id e1, v, eliminate_ref id e2)
  | Lifthenelse(e1, e2, e3) ->
      Lifthenelse(eliminate_ref id e1,
                  eliminate_ref id e2,
                  eliminate_ref id e3)
  | Lsequence(e1, e2) ->
      Lsequence(eliminate_ref id e1, eliminate_ref id e2)
  | Lwhile(e1, e2) ->
      Lwhile(eliminate_ref id e1, eliminate_ref id e2)
  | Lfor(v, e1, e2, dir, e3) ->
      Lfor(v, eliminate_ref id e1, eliminate_ref id e2,
           dir, eliminate_ref id e3)
  | Lassign(v, e) ->
      Lassign(v, eliminate_ref id e)
  | Levent(l, ev) ->
      Levent(eliminate_ref id l, ev)
@

<<function Simplif.simplify_lambda>>=
(* Simplification of lets *)

let simplify_lambda lam =
  (* First pass: count the occurrences of all identifiers *)
  let occ = Hashtbl.create 83 in
  let count_var v =
    try
      !(Hashtbl.find occ v)
    with Not_found ->
      0 in
  let rec count = function
    Lvar v ->
      begin try
        incr(Hashtbl.find occ v)
      with Not_found ->
        Hashtbl.add occ v (ref 1)
      end
  | Lconst cst -> ()
  | Lapply(l1, ll) -> count l1; List.iter count ll
  | Lfunction(kind, params, l) -> count l
  | Llet(str, v, Lvar w, l2) ->
      (* v will be replaced by w in l2, so each occurrence of v in l2
         increases w's refcount *)
      count l2;
      let vc = count_var v in
      begin try
        let r = Hashtbl.find occ w in r := !r + vc
      with Not_found ->
        Hashtbl.add occ w (ref vc)
      end
  | Llet(str, v, l1, l2) ->
      count l2;
      (* If v is unused, l1 will be removed, so don't count its variables *)
      if str = Strict or count_var v > 0 then count l1
  | Lletrec(bindings, body) ->
      List.iter (fun (v, l) -> count l) bindings;
      count body
  | Lprim(p, ll) -> List.iter count ll
  | Lswitch(l, sw) ->
      count l;
      List.iter (fun (n, l) -> count l) sw.sw_consts;
      List.iter (fun (n, l) -> count l) sw.sw_blocks
  | Lstaticfail -> ()
  | Lcatch(l1, l2) -> count l1; count l2
  | Ltrywith(l1, v, l2) -> count l1; count l2
  | Lifthenelse(l1, l2, l3) -> count l1; count l2; count l3
  | Lsequence(l1, l2) -> count l1; count l2
  | Lwhile(l1, l2) -> count l1; count l2
  | Lfor(v, l1, l2, dir, l3) -> count l1; count l2; count l3
  | Lassign(v, l) ->
      (* Lalias-bound variables are never assigned, so don't increase
         v's refcount *)
      count l
  | Levent(l, ev) -> count l
  in
  count lam;
  (* Second pass: remove Lalias bindings of unused variables,
     and substitute the bindings of variables used exactly once. *)
  let subst = Hashtbl.create 83 in
  let rec simplif = function
    Lvar v as l ->
      begin try
        Hashtbl.find subst v
      with Not_found ->
        l
      end
  | Lconst cst as l -> l
  | Lapply(l1, ll) -> Lapply(simplif l1, List.map simplif ll)
  | Lfunction(kind, params, l) -> Lfunction(kind, params, simplif l)
  | Llet(str, v, Lvar w, l2) ->
      Hashtbl.add subst v (simplif (Lvar w));
      simplif l2
  | Llet(Strict, v, Lprim(Pmakeblock(0, Mutable), [linit]), lbody)
    when not !Clflags.debug ->
      let slinit = simplif linit in
      let slbody = simplif lbody in
      begin try
        Llet(Strict, v, slinit, eliminate_ref v slbody)
      with Real_reference ->
        Llet(Strict, v, Lprim(Pmakeblock(0, Mutable), [slinit]), slbody)
      end
  | Llet(Strict, v, l1, l2) -> Llet(Strict, v, simplif l1, simplif l2)
  | Llet(Alias, v, l1, l2) ->
      begin match count_var v with
        0 -> simplif l2
      | 1 -> Hashtbl.add subst v (simplif l1); simplif l2
      | n -> Llet(Alias, v, simplif l1, simplif l2)
      end
  | Llet(StrictOpt, v, l1, l2) ->
      begin match count_var v with
        0 -> simplif l2
      | n -> Llet(Alias, v, simplif l1, simplif l2)
      end
  | Lletrec(bindings, body) ->
      Lletrec(List.map (fun (v, l) -> (v, simplif l)) bindings, simplif body)
  | Lprim(p, ll) -> Lprim(p, List.map simplif ll)
  | Lswitch(l, sw) ->
      Lswitch(simplif l,
        {sw_numconsts = sw.sw_numconsts;
         sw_consts = List.map (fun (n, e) -> (n, simplif e)) sw.sw_consts;
         sw_numblocks = sw.sw_numblocks;
         sw_blocks = List.map (fun (n, e) -> (n, simplif e)) sw.sw_blocks;
         sw_checked = sw.sw_checked})
  | Lstaticfail -> Lstaticfail
  | Lcatch(l1, l2) -> Lcatch(simplif l1, simplif l2)
  | Ltrywith(l1, v, l2) -> Ltrywith(simplif l1, v, simplif l2)
  | Lifthenelse(l1, l2, l3) -> Lifthenelse(simplif l1, simplif l2, simplif l3)
  | Lsequence(l1, l2) -> Lsequence(simplif l1, simplif l2)
  | Lwhile(l1, l2) -> Lwhile(simplif l1, simplif l2)
  | Lfor(v, l1, l2, dir, l3) ->
      Lfor(v, simplif l1, simplif l2, dir, simplif l3)
  | Lassign(v, l) -> Lassign(v, simplif l)
  | Levent(l, ev) -> Levent(simplif l, ev)
  in
  simplif lam
@


%-------------------------------------------------------------

<<./bytecomp/simplif.ml>>=
<<copyright header>>

(* Elimination of useless Llet(Alias) bindings.
   Also transform let-bound references into variables. *)

open Asttypes
open Lambda

<<exception Simplif.Real_reference>>

module IdentSet = Set

<<function Simplif.eliminate_ref>>

<<function Simplif.simplify_lambda>>
@


\subsection*{[[./bytecomp/matching.mli]]}


<<exception Matching.Cannot_flatten>>=
exception Cannot_flatten
@

<<signature Matching.flatten_pattern>>=
val flatten_pattern: int -> pattern -> pattern list
@


%-------------------------------------------------------------

<<./bytecomp/matching.mli>>=
<<copyright header>>

(* Compilation of pattern-matching *)

open Typedtree
open Lambda

<<signature Matching.for_function>>
<<signature Matching.for_trywith>>
<<signature Matching.for_let>>
<<signature Matching.for_multiple_match>>
<<signature Matching.for_tupled_function>>

<<exception Matching.Cannot_flatten>>

<<signature Matching.flatten_pattern>>
@


\subsection*{[[./bytecomp/matching.ml]]}

<<type Matching.pattern_matching>>=
(*  See Peyton-Jones, "The Implementation of functional programming
    languages", chapter 5. *)

type pattern_matching =
  { mutable cases : (pattern list * lambda) list;
    args : (lambda * let_kind) list }
@

<<function Matching.add_line>>=
(* To group lines of patterns with identical keys *)

let add_line patl_action pm =
  pm.cases <- patl_action :: pm.cases; pm
@

<<function Matching.add>>=
let add make_matching_fun division key patl_action args =
  try
    let pm = List.assoc key division in
    pm.cases <- patl_action :: pm.cases;
    division
  with Not_found ->
    let pm = make_matching_fun args in
    pm.cases <- patl_action :: pm.cases;
    (key, pm) :: division
@

<<function Matching.name_pattern>>=
(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    (pat :: patl, action) :: rem ->
      begin match pat.pat_desc with
        Tpat_var id -> id
      | Tpat_alias(p, id) -> id
      | _ -> name_pattern default rem
      end
  | _ -> Ident.create default
@

<<constant Matching.any_pat>>=
(* To remove aliases and bind named components *)

let any_pat =
  {pat_desc = Tpat_any; pat_loc = Location.none; pat_type = Ctype.none}
@

<<function Matching.simplify_matching>>=
let simplify_matching m =
  match m.args with
    [] -> m
  | (arg, mut) :: argl ->
      let rec simplify = function
        (pat :: patl, action as patl_action) :: rem ->
          begin match pat.pat_desc with
            Tpat_var id ->
              (any_pat :: patl, Llet(Alias, id, arg, action)) ::
              simplify rem
          | Tpat_alias(p, id) ->
              simplify ((p :: patl, Llet(Alias, id, arg, action)) :: rem)
          | _ ->
              patl_action :: simplify rem
          end
      | cases -> cases in
    { args = m.args; cases = simplify m.cases }
@

<<constant Matching.make_constant_matching>>=
(* Matching against a constant *)

let make_constant_matching = function
    [] -> fatal_error "Matching.make_constant_matching"
  | (arg :: argl) -> {cases = []; args = argl}
@

<<function Matching.divide_constant>>=
let divide_constant {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_constant cst} :: patl, action) :: rem ->
        let (constants, others) = divide rem in
        (add make_constant_matching constants cst (patl, action) al, others)
    | cl ->
      ([], {cases = cl; args = al})
  in divide cl
@

<<function Matching.make_constr_matching>>=
(* Matching against a constructor *)

let make_constr_matching cstr = function
    [] -> fatal_error "Matching.make_constr_matching"
  | ((arg, mut) :: argl) ->
      let (first_pos, last_pos) =
        match cstr.cstr_tag with
          Cstr_constant _ | Cstr_block _ -> (0, cstr.cstr_arity - 1)
        | Cstr_exception _ -> (1, cstr.cstr_arity) in
      let rec make_args pos =
        if pos > last_pos
        then argl
        else (Lprim(Pfield pos, [arg]), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args first_pos}
@

<<function Matching.divide_constructor>>=
let divide_constructor {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_construct(cstr, args)} :: patl, action) :: rem ->
        let (constructs, others) = divide rem in
        (add (make_constr_matching cstr) constructs
             cstr.cstr_tag (args @ patl, action) al,
         others)
    | cl ->
      ([], {cases = cl; args = al})
  in divide cl
@

<<function Matching.divide_var>>=
(* Matching against a variable *)

let divide_var {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (vars, others) = divide rem in
        (add_line (patl, action) vars, others)
    | cl ->
        (make_constant_matching al, {cases = cl; args = al})
  in divide cl
@

<<function Matching.make_tuple_matching>>=
(* Matching against a tuple pattern *)

let make_tuple_matching num_comps = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | (arg, mut) :: argl ->
      let rec make_args pos =
        if pos >= num_comps
        then argl
        else (Lprim(Pfield pos, [arg]), Alias) :: make_args (pos + 1) in
      {cases = []; args = make_args 0}
@

<<function Matching.divide_tuple>>=
let divide_tuple arity {cases = cl; args = al} =
  let rec divide = function
      ({pat_desc = Tpat_tuple args} :: patl, action) :: rem ->
        let (tuples, others) = divide rem in
        (add_line (args @ patl, action) tuples, others)
    | ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (tuples, others) = divide rem in
        (add_line (replicate_list any_pat arity @ patl, action) tuples, others)
    | cl ->
        (make_tuple_matching arity al, {cases = cl; args = al})
  in divide cl
@

<<function Matching.make_record_matching>>=
(* Matching against a record pattern *)

let make_record_matching all_labels = function
    [] -> fatal_error "Matching.make_tuple_matching"
  | ((arg, mut) :: argl) ->
      let rec make_args pos =
        if pos >= Array.length all_labels then argl else begin
          let lbl = all_labels.(pos) in
          let access =
            match lbl.lbl_repres with
              Record_regular -> Pfield lbl.lbl_pos
            | Record_float -> Pfloatfield lbl.lbl_pos in
          let str =
            match lbl.lbl_mut with
              Immutable -> Alias
            | Mutable -> StrictOpt in
          (Lprim(access, [arg]), str) :: make_args(pos + 1)
        end in
      {cases = []; args = make_args 0}
@

<<function Matching.divide_record>>=
let divide_record all_labels {cases = cl; args = al} =
  let num_fields = Array.length all_labels in
  let record_matching_line lbl_pat_list =
    let patv = Array.create num_fields any_pat in
    List.iter (fun (lbl, pat) -> patv.(lbl.lbl_pos) <- pat) lbl_pat_list;
    Array.to_list patv in
  let rec divide = function
      ({pat_desc = Tpat_record lbl_pat_list} :: patl, action) :: rem ->
        let (records, others) = divide rem in
        (add_line (record_matching_line lbl_pat_list @ patl, action) records,
         others)
    | ({pat_desc = Tpat_any} :: patl, action) :: rem ->
        let (records, others) = divide rem in
        (add_line (record_matching_line [] @ patl, action) records, others)
    | cl ->
        (make_record_matching all_labels al, {cases = cl; args = al})
  in divide cl
@

<<function Matching.flatten_orpat_match>>=
(* Matching against an or pattern. *)

let rec flatten_orpat_match pat =
  match pat.pat_desc with
    Tpat_or(p1, p2) -> flatten_orpat_match p1 @ flatten_orpat_match p2
  | _ -> [[pat], lambda_unit]
@

<<constant Matching.divide_orpat>>=
let divide_orpat = function
    {cases = (orpat :: patl, act) :: casel; args = arg1 :: argl as args} ->
      ({cases = flatten_orpat_match orpat; args = [arg1]},
       {cases = [patl, act]; args = argl},
       {cases = casel; args = args})
  | _ ->
    fatal_error "Matching.divide_orpat"
@

<<function Matching.combine_var>>=
(* To combine sub-matchings together *)

let combine_var (lambda1, total1) (lambda2, total2) =
  if total1 then (lambda1, true)
  else if lambda2 = Lstaticfail then (lambda1, total1)
  else (Lcatch(lambda1, lambda2), total2)
@

<<function Matching.make_test_sequence>>=
let make_test_sequence tst arg const_lambda_list =
  List.fold_right
    (fun (c, act) rem ->
      Lifthenelse(Lprim(tst, [arg; Lconst(Const_base c)]), act, rem))
    const_lambda_list Lstaticfail
@

<<function Matching.make_switch_or_test_sequence>>=
let make_switch_or_test_sequence arg const_lambda_list int_lambda_list =
  let min_key =
    List.fold_right (fun (k, l) m -> min k m) int_lambda_list max_int in
  let max_key =
    List.fold_right (fun (k, l) m -> max k m) int_lambda_list min_int in
  (* min_key and max_key can be arbitrarily large, so watch out for
     overflow in the following comparison *)
  if List.length int_lambda_list <= 1 + max_key / 4 - min_key / 4 then
    (* Sparse matching -- use a sequence of tests
       (4 bytecode instructions per test)  *)
    make_test_sequence (Pintcomp Ceq) arg const_lambda_list
  else begin
    (* Dense matching -- use a jump table
       (2 bytecode instructions + 1 word per entry in the table) *)
    let numcases = max_key - min_key + 1 in
    let cases =
      List.map (fun (key, l) -> (key - min_key, l)) int_lambda_list in
    let offsetarg =
      if min_key = 0 then arg else Lprim(Poffsetint(-min_key), [arg]) in
    Lswitch(offsetarg,
            {sw_numconsts = numcases; sw_consts = cases;
             sw_numblocks = 0; sw_blocks = []; sw_checked = true})
  end
@

<<function Matching.make_bitvect_check>>=
let make_bitvect_check arg int_lambda_list =
  let bv = String.make 32 '\000' in
  List.iter
    (fun (n, l) ->
      bv.[n lsr 3] <- Char.chr(Char.code bv.[n lsr 3] lor (1 lsl (n land 7))))
    int_lambda_list;
  Lifthenelse(Lprim(Pbittest, [Lconst(Const_base(Const_string bv)); arg]),
              lambda_unit, Lstaticfail)
@

<<constant Matching.prim_string_equal>>=
let prim_string_equal =
  Pccall{prim_name = "string_equal";
         prim_arity = 2; prim_alloc = false;
         prim_native_name = ""; prim_native_float = false}
@

<<function Matching.combine_constant>>=
let combine_constant arg cst (const_lambda_list, total1) (lambda2, total2) =
  let lambda1 =
    match cst with
      Const_int _ ->
        let int_lambda_list =
          List.map (function Const_int n, l -> n,l | _ -> assert false)
                   const_lambda_list in
        make_switch_or_test_sequence arg const_lambda_list int_lambda_list
    | Const_char _ ->
        let int_lambda_list =
          List.map (function Const_char c, l -> (Char.code c, l)
                           | _ -> assert false)
                   const_lambda_list in
        if List.for_all (fun (c, l) -> l = lambda_unit) const_lambda_list then
          make_bitvect_check arg int_lambda_list 
        else
          make_switch_or_test_sequence arg const_lambda_list int_lambda_list
    | Const_string _ ->
        make_test_sequence prim_string_equal arg const_lambda_list
    | Const_float _ ->
        make_test_sequence (Pfloatcomp Ceq) arg const_lambda_list
  in (Lcatch(lambda1, lambda2), total2)
@

<<function Matching.combine_constructor>>=
let combine_constructor arg cstr (tag_lambda_list, total1) (lambda2, total2) =
  if cstr.cstr_consts < 0 then begin
    (* Special cases for exceptions *)
    let lambda1 =
      List.fold_right
        (fun (ex, act) rem ->
           match ex with
           | Cstr_exception path ->
               Lifthenelse(Lprim(Pintcomp Ceq, 
                                 [Lprim(Pfield 0, [arg]); transl_path path]),
                           act, rem)
           | _ -> assert false)
        tag_lambda_list Lstaticfail
    in (Lcatch(lambda1, lambda2), total2)
  end else begin
    (* Regular concrete type *)
    let rec split_cases = function
      [] -> ([], [])
    | (cstr, act) :: rem ->
        let (consts, nonconsts) = split_cases rem in
        match cstr with
          Cstr_constant n -> ((n, act) :: consts, nonconsts)
        | Cstr_block n    -> (consts, (n, act) :: nonconsts)
        | _ -> assert false in
    let (consts, nonconsts) = split_cases tag_lambda_list in
    let lambda1 =
      match (cstr.cstr_consts, cstr.cstr_nonconsts, consts, nonconsts) with
        (1, 0, [0, act], []) -> act
      | (0, 1, [], [0, act]) -> act
      | (1, 1, [0, act1], [0, act2]) ->
          Lifthenelse(arg, act2, act1)
      | (1, 1, [0, act1], []) ->
          Lifthenelse(arg, Lstaticfail, act1)
      | (1, 1, [], [0, act2]) ->
          Lifthenelse(arg, act2, Lstaticfail)
      | (_, _, _, _) ->
          Lswitch(arg, {sw_numconsts = cstr.cstr_consts;
                        sw_consts = consts;
                        sw_numblocks = cstr.cstr_nonconsts;
                        sw_blocks = nonconsts;
                        sw_checked = false}) in
    if total1
     & List.length tag_lambda_list = cstr.cstr_consts + cstr.cstr_nonconsts
    then (lambda1, true)
    else (Lcatch(lambda1, lambda2), total2)
  end
@

<<function Matching.combine_orpat>>=
let combine_orpat (lambda1, total1) (lambda2, total2) (lambda3, total3) =
  (Lcatch(Lsequence(lambda1, lambda2), lambda3), total3)
@

<<function Matching.event_branch>>=
(* Insertion of debugging events *)

let rec event_branch repr lam =
  begin match lam, repr with
    (_, None) ->
      lam
  | (Levent(lam', ev), Some r) ->
      incr r;
      Levent(lam', {lev_loc = ev.lev_loc;
                    lev_kind = ev.lev_kind;
                    lev_repr = repr;
                    lev_env = ev.lev_env})
  | (Llet(str, id, lam, body), _) ->
      Llet(str, id, lam, event_branch repr body)
  | (_, Some r) ->
(*      incr r;
      Levent(lam, {lev_loc = -1;
                   lev_kind = Lev_before;
                   lev_repr = repr;
                   lev_env = Env.Env_empty})
*)      fatal_error "Matching.event_branch"
  end
@

<<function Matching.compile_match>>=
(* The main compilation function.
   Input: a pattern matching.
   Output: a lambda term, a "total" flag (true if we're sure that the
     matching covers all cases; this is an approximation). *)

let rec compile_match repr m =

  let rec compile_list = function
    [] -> ([], true)
  | (key, pm) :: rem ->
      let (lambda1, total1) = compile_match repr pm in
      let (list2, total2) = compile_list rem in
      ((key, lambda1) :: list2, total1 & total2) in

  match m with
    { cases = [] } ->
      (Lstaticfail, false)
  | { cases = ([], action) :: rem; args = argl } ->
      if is_guarded action then begin
        let (lambda, total) =
          compile_match None { cases = rem; args = argl }
        in
        (Lcatch(event_branch repr action, lambda), total)
      end else
        (event_branch repr action, true)
  | { args = (arg, str) :: argl } ->
      let v = name_pattern "match" m.cases in
      let newarg = Lvar v in
      let pm =
        simplify_matching
          { cases = m.cases; args = (newarg, Alias) :: argl } in
      let (lam, total) =
        match pm.cases with
          (pat :: patl, action) :: _ ->
            begin match pat.pat_desc with
              Tpat_any ->
                let (vars, others) = divide_var pm in
                combine_var (compile_match repr vars)
                            (compile_match repr others)
            | Tpat_constant cst ->
                let (constants, others) = divide_constant pm in
                combine_constant newarg cst
                  (compile_list constants) (compile_match repr others)
            | Tpat_tuple patl ->
                let (tuples, others) = divide_tuple (List.length patl) pm in
                combine_var (compile_match repr tuples)
                            (compile_match repr others)
            | Tpat_construct(cstr, patl) ->
                let (constrs, others) = divide_constructor pm in
                combine_constructor newarg cstr
                  (compile_list constrs) (compile_match repr others)
            | Tpat_record((lbl, _) :: _) ->
                let (records, others) = divide_record lbl.lbl_all pm in
                combine_var (compile_match repr records)
                            (compile_match repr others)
            | Tpat_or(pat1, pat2) ->
                (* Avoid duplicating the code of the action *)
                let (or_match, remainder_line, others) = divide_orpat pm in
                combine_orpat (compile_match None or_match)
                              (compile_match repr remainder_line)
                              (compile_match repr others)
            | _ ->
                fatal_error "Matching.compile_match1"
            end
        | _ -> fatal_error "Matching.compile_match2" in
      (Llet(str, v, arg, lam), total)
  | _ -> assert false
@

<<function Matching.compile_matching>>=
(* The entry points *)

let compile_matching repr handler_fun arg pat_act_list =
  let pm =
    { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
      args = [arg, Strict] } in
  let (lambda, total) = compile_match repr pm in
  if total then lambda else Lcatch(lambda, handler_fun())
@

<<function Matching.partial_function>>=
let partial_function loc () =
  Lprim(Praise, [Lprim(Pmakeblock(0, Immutable),
          [transl_path Predef.path_match_failure;
           Lconst(Const_block(0,
              [Const_base(Const_string !Location.input_name);
               Const_base(Const_int loc.loc_start);
               Const_base(Const_int loc.loc_end)]))])])
@

<<function Matching.for_function>>=
let for_function loc repr param pat_act_list =
  compile_matching repr (partial_function loc) param pat_act_list
@

<<function Matching.for_trywith>>=
let for_trywith param pat_act_list =
  compile_matching None (fun () -> Lprim(Praise, [param])) param pat_act_list
@

<<function Matching.for_let>>=
let for_let loc param pat body =
  compile_matching None (partial_function loc) param [pat, body]
@

<<exception Matching.Cannot_flatten (./bytecomp/matching.ml)>>=
(* Handling of tupled functions and matches *)

exception Cannot_flatten
@

<<function Matching.flatten_pattern>>=
let flatten_pattern size p =
  match p.pat_desc with
    Tpat_tuple args -> args
  | Tpat_any -> replicate_list any_pat size
  | _ -> raise Cannot_flatten
@

<<function Matching.flatten_cases>>=
let flatten_cases size cases =
  List.map (function (pat :: _, act) -> (flatten_pattern size pat, act)
                   | _ -> assert false)
           cases
@

<<function Matching.for_tupled_function>>=
let for_tupled_function loc paraml pats_act_list =
  let pm =
    { cases = pats_act_list;
      args = List.map (fun id -> (Lvar id, Strict)) paraml } in
  let (lambda, total) = compile_match None pm in
  if total then lambda else Lcatch(lambda, partial_function loc ())
@

<<function Matching.for_multiple_match>>=
let for_multiple_match loc paraml pat_act_list =
  let pm1 =
    { cases = List.map (fun (pat, act) -> ([pat], act)) pat_act_list;
      args = [Lprim(Pmakeblock(0, Immutable), paraml), Strict] } in
  let pm2 =
    simplify_matching pm1 in
  let pm3 =
    try
      { cases = flatten_cases (List.length paraml) pm2.cases;
        args = List.map (fun lam -> (lam, Strict)) paraml }
    with Cannot_flatten ->
      pm2 in
  let (lambda, total) = compile_match None pm3 in
  if total then lambda else Lcatch(lambda, partial_function loc ())
@


%-------------------------------------------------------------

<<./bytecomp/matching.ml>>=
<<copyright header>>

(* Compilation of pattern matching *)

open Misc
open Location
open Asttypes
open Primitive
open Types
open Typedtree
open Lambda

<<type Matching.pattern_matching>>

<<function Matching.add_line>>

<<function Matching.add>>

<<function Matching.name_pattern>>

<<constant Matching.any_pat>>

<<function Matching.simplify_matching>>

<<constant Matching.make_constant_matching>>

<<function Matching.divide_constant>>

<<function Matching.make_constr_matching>>

<<function Matching.divide_constructor>>

<<function Matching.divide_var>>

<<function Matching.make_tuple_matching>>

<<function Matching.divide_tuple>>

<<function Matching.make_record_matching>>

<<function Matching.divide_record>>

<<function Matching.flatten_orpat_match>>

<<constant Matching.divide_orpat>>

<<function Matching.combine_var>>

<<function Matching.make_test_sequence>>

<<function Matching.make_switch_or_test_sequence>>

<<function Matching.make_bitvect_check>>

<<constant Matching.prim_string_equal>>

<<function Matching.combine_constant>>

<<function Matching.combine_constructor>>

<<function Matching.combine_orpat>>

<<function Matching.event_branch>>

<<function Matching.compile_match>>

<<function Matching.compile_matching>>

<<function Matching.partial_function>>

<<function Matching.for_function>>

<<function Matching.for_trywith>>

<<function Matching.for_let>>

<<exception Matching.Cannot_flatten (./bytecomp/matching.ml)>>

<<function Matching.flatten_pattern>>

<<function Matching.flatten_cases>>

<<function Matching.for_tupled_function>>

<<function Matching.for_multiple_match>>
@


\subsection*{[[./bytecomp/translcore.mli]]}

<<signature Translcore.name_pattern>>=
val name_pattern: string -> (pattern * 'a) list -> Ident.t
@

<<signature Translcore.maybe_pointer>>=
val maybe_pointer: expression -> bool
@




%-------------------------------------------------------------

<<./bytecomp/translcore.mli>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Asttypes
open Types
open Typedtree
open Lambda

<<signature Translcore.name_pattern>>
<<signature Translcore.maybe_pointer>>

<<signature Translcore.transl_exp>>
<<signature Translcore.transl_let>>
<<signature Translcore.transl_primitive>>
<<signature Translcore.transl_exception>>

<<type Translcore.error>>

<<exception Translcore.Error>>

<<signature Translcore.report_error>>
@


\subsection*{[[./bytecomp/translcore.ml]]}


<<function Translcore.has_base_type>>=
let has_base_type exp base_ty =
  let exp_ty =
    Ctype.expand_head exp.exp_env (Ctype.correct_levels exp.exp_type) in
  match (Ctype.repr exp_ty, Ctype.repr base_ty) with
    {desc = Tconstr(p1, _, _)}, {desc = Tconstr(p2, _, _)} -> Path.same p1 p2
  | (_, _) -> false
@

<<function Translcore.maybe_pointer>>=
let maybe_pointer arg =
  not(has_base_type arg Predef.type_int or has_base_type arg Predef.type_char)
@

<<function Translcore.array_element_kind>>=
let array_element_kind env ty =
  let ty = Ctype.repr (Ctype.expand_head env ty) in
  match ty.desc with
    Tvar ->
      Pgenarray
  | Tconstr(p, args, abbrev) ->
      if Path.same p Predef.path_int || Path.same p Predef.path_char then
        Pintarray
      else if Path.same p Predef.path_float then
        Pfloatarray
      else if Path.same p Predef.path_string
           || Path.same p Predef.path_array then
        Paddrarray
      else begin
        try
          match Env.find_type p env with
            {type_kind = Type_abstract} ->
              Pgenarray
          | {type_kind = Type_variant cstrs}
            when List.for_all (fun (name, args) -> args = []) cstrs ->
              Pintarray
          | {type_kind = _} ->
              Paddrarray
        with Not_found ->
          (* This can happen due to e.g. missing -I options,
             causing some .cmi files to be unavailable.
             Maybe we should emit a warning. *)
          Pgenarray
      end
  | _ ->
      Paddrarray
@

<<function Translcore.array_kind>>=
let array_kind arg =
  let ty = Ctype.correct_levels arg.exp_type in
  let array_ty = Ctype.expand_head arg.exp_env ty in
  match (Ctype.repr array_ty).desc with
    Tconstr(p, [elt_ty], _) when Path.same p Predef.path_array ->
      array_element_kind arg.exp_env elt_ty
  | _ ->
    fatal_error "Translcore.array_kind"
@

<<constant Translcore.prim_makearray>>=
let prim_makearray =
  { prim_name = "make_vect"; prim_arity = 2; prim_alloc = true;
    prim_native_name = ""; prim_native_float = false }
@

<<function Translcore.transl_prim>>=
let transl_prim prim args =
  try
    let (gencomp, intcomp, floatcomp, stringcomp) =
      Hashtbl.find comparisons_table prim.prim_name in
    begin match args with
      [arg1; {exp_desc = Texp_construct({cstr_tag = Cstr_constant _}, _)}] ->
        intcomp
    | [{exp_desc = Texp_construct({cstr_tag = Cstr_constant _}, _)}; arg2] ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_int
                     or has_base_type arg1 Predef.type_char ->
        intcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_float ->
        floatcomp
    | [arg1; arg2] when has_base_type arg1 Predef.type_string ->
        stringcomp
    | _ ->
        gencomp
    end
  with Not_found ->
  try
    let p = Hashtbl.find primitives_table prim.prim_name in
    (* Try strength reduction based on the type of the argument *)
    begin match (p, args) with
        (Psetfield(n, _), [arg1; arg2]) -> Psetfield(n, maybe_pointer arg2)
      | (Parraylength Pgenarray, [arg])   -> Parraylength(array_kind arg)
      | (Parrayrefu Pgenarray, arg1 :: _) -> Parrayrefu(array_kind arg1)
      | (Parraysetu Pgenarray, arg1 :: _) -> Parraysetu(array_kind arg1)
      | (Parrayrefs Pgenarray, arg1 :: _) -> Parrayrefs(array_kind arg1)
      | (Parraysets Pgenarray, arg1 :: _) -> Parraysets(array_kind arg1)
      | _ -> p
    end
  with Not_found ->
    Pccall prim
@

<<function Translcore.transl_primitive>>=
(* Eta-expand a primitive without knowing the types of its arguments *)

let transl_primitive p =
  let prim =
    try
      let (gencomp, intcomp, floatcomp, stringcomp) =
        Hashtbl.find comparisons_table p.prim_name in
      gencomp
    with Not_found ->
    try
      Hashtbl.find primitives_table p.prim_name
    with Not_found ->
      Pccall p in
  let rec make_params n =
    if n <= 0 then [] else Ident.create "prim" :: make_params (n-1) in
  let params = make_params p.prim_arity in
  Lfunction(Curried, params, Lprim(prim, List.map (fun id -> Lvar id) params))
@

<<function Translcore.check_recursive_lambda>>=
let check_recursive_lambda idlist lam =
  let rec check_top = function
      Lfunction(kind, params, body) as funct -> true
    | Lprim(Pmakeblock(tag, mut), args) -> List.for_all check args
    | Lprim(Pmakearray kind, args) -> List.for_all check args
    | Llet(str, id, arg, body) -> check arg & check_top body
    | Lletrec(bindings, body) ->
        List.for_all (fun (id, arg) -> check arg) bindings & check_top body
    | Levent (lam, _) -> check_top lam
    | _ -> false
  and check = function
      Lvar _ -> true
    | Lconst cst -> true
    | Lfunction(kind, params, body) -> true
    | Llet(str, id, arg, body) -> check arg & check body
    | Lletrec(bindings, body) ->
        List.for_all (fun (id, arg) -> check arg) bindings & check body
    | Lprim(Pmakeblock(tag, mut), args) -> List.for_all check args
    | Lprim(Pmakearray kind, args) -> List.for_all check args
    | Levent (lam, _) -> check lam
    | lam ->
        let fv = free_variables lam in
        List.for_all (fun id -> not(IdentSet.mem id fv)) idlist
  in check_top lam
@

<<exception Translcore.Not_constant>>=
(* To propagate structured constants *)

exception Not_constant
@

<<constant Translcore.extract_constant>>=
let extract_constant = function
    Lconst sc -> sc
  | _ -> raise Not_constant
@

<<constant Translcore.extract_float>>=
let extract_float = function
    Const_base(Const_float f) -> f
  | _ -> fatal_error "Translcore.extract_float"
@

<<function Translcore.name_pattern>>=
(* To find reasonable names for let-bound and lambda-bound idents *)

let rec name_pattern default = function
    [] -> Ident.create default
  | (p, e) :: rem ->
      match p.pat_desc with
        Tpat_var id -> id
      | Tpat_alias(p, id) -> id
      | _ -> name_pattern default rem
@

<<function Translcore.event_before>>=
(* Insertion of debugging events *)

let event_before exp lam =
  if !Clflags.debug && lam <> Lstaticfail
  then Levent(lam, {lev_loc = exp.exp_loc.Location.loc_start;
                    lev_kind = Lev_before;
                    lev_repr = None;
                    lev_env = Env.summary exp.exp_env})
  else lam
@

<<function Translcore.event_after>>=
let event_after exp lam =
  if !Clflags.debug
  then Levent(lam, {lev_loc = exp.exp_loc.Location.loc_end;
                    lev_kind = Lev_after exp.exp_type;
                    lev_repr = None;
                    lev_env = Env.summary exp.exp_env})
  else lam
@

<<function Translcore.event_function>>=
let event_function exp lam =
  if !Clflags.debug then
    let repr = Some (ref 0) in
    let (info, body) = lam repr in
    (info,
     Levent(body, {lev_loc = exp.exp_loc.Location.loc_start;
                   lev_kind = Lev_function;
                   lev_repr = repr;
                   lev_env = Env.summary exp.exp_env}))
  else
    lam None
@

<<function Translcore.transl_exception>>=
(* Compile an exception definition *)

let transl_exception id decl =
    Lprim(Pmakeblock(0, Immutable),
          [Lconst(Const_base(Const_string(Ident.name id)))])
@



%-------------------------------------------------------------

<<./bytecomp/translcore.ml>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the core language *)

open Misc
open Asttypes
open Primitive
open Path
open Types
open Typedtree
open Lambda

<<type Translcore.error>>

<<exception Translcore.Error>>

<<constant Translcore.comparisons_table>>

<<constant Translcore.primitives_table>>

<<function Translcore.has_base_type>>

<<function Translcore.maybe_pointer>>

<<function Translcore.array_element_kind>>

<<function Translcore.array_kind>>

<<constant Translcore.prim_makearray>>

<<function Translcore.transl_prim>>

<<function Translcore.transl_primitive>>

(* To check the well-formedness of r.h.s. of "let rec" definitions *)

module IdentSet = Set

<<function Translcore.check_recursive_lambda>>

<<exception Translcore.Not_constant>>

<<constant Translcore.extract_constant>>

<<constant Translcore.extract_float>>

<<function Translcore.name_pattern>>

<<function Translcore.event_before>>

<<function Translcore.event_after>>

<<function Translcore.event_function>>

(* Translation of expressions *)

let rec transl_exp e =
  match e.exp_desc with
    Texp_ident(path, {val_kind = Val_prim p}) ->
      transl_primitive p
  | Texp_ident(path, desc) ->
      transl_path path
  | Texp_constant cst ->
      Lconst(Const_base cst)
  | Texp_let(rec_flag, pat_expr_list, body) ->
      transl_let rec_flag pat_expr_list (event_before body (transl_exp body))
  | Texp_function pat_expr_list ->
      let ((kind, params), body) =
        event_function e
          (function repr ->
             transl_function e.exp_loc !Clflags.native_code repr pat_expr_list)
      in
      Lfunction(kind, params, body)
  | Texp_apply({exp_desc = Texp_ident(path, {val_kind = Val_prim p})}, args)
    when List.length args = p.prim_arity ->
      let prim = transl_prim p args in
      let lam = Lprim(prim, transl_list args) in
      begin match prim with Pccall _ -> event_after e lam | _ -> lam end
  | Texp_apply(funct, args) ->
      let lam =
        match transl_exp funct with
         lexp ->
            Lapply(lexp, transl_list args) in
      event_after e lam
  | Texp_match({exp_desc = Texp_tuple argl} as arg, pat_expr_list) ->
      Matching.for_multiple_match e.exp_loc
        (transl_list argl) (transl_cases pat_expr_list)
  | Texp_match(arg, pat_expr_list) ->
      Matching.for_function e.exp_loc None
        (transl_exp arg) (transl_cases pat_expr_list)
  | Texp_try(body, pat_expr_list) ->
      let id = name_pattern "exn" pat_expr_list in
      Ltrywith(transl_exp body, id,
               Matching.for_trywith (Lvar id) (transl_cases pat_expr_list))
  | Texp_tuple el ->
      let ll = transl_list el in
      begin try
        Lconst(Const_block(0, List.map extract_constant ll))
      with Not_constant ->
        Lprim(Pmakeblock(0, Immutable), ll)
      end
  | Texp_construct(cstr, args) ->
      let ll = transl_list args in
      begin match cstr.cstr_tag with
        Cstr_constant n ->
          Lconst(Const_pointer n)
      | Cstr_block n ->
          begin try
            Lconst(Const_block(n, List.map extract_constant ll))
          with Not_constant ->
            Lprim(Pmakeblock(n, Immutable), ll)
          end
      | Cstr_exception path ->
          Lprim(Pmakeblock(0, Immutable), transl_path path :: ll)
      end
  | Texp_record ((lbl1, _) :: _ as lbl_expr_list) ->
      let lv = Array.create (Array.length lbl1.lbl_all) Lstaticfail in
      List.iter
        (fun (lbl, expr) -> lv.(lbl.lbl_pos) <- transl_exp expr)
        lbl_expr_list;
      let ll = Array.to_list lv in
      if List.exists (fun (lbl, expr) -> lbl.lbl_mut = Mutable) lbl_expr_list
      then begin
        match lbl1.lbl_repres with
          Record_regular -> Lprim(Pmakeblock(0, Mutable), ll)
        | Record_float -> Lprim(Pmakearray Pfloatarray, ll)
      end else begin
        try
          let cl = List.map extract_constant ll in
          match lbl1.lbl_repres with
            Record_regular -> Lconst(Const_block(0, cl))
          | Record_float ->
              Lconst(Const_float_array(List.map extract_float cl))
        with Not_constant ->
          match lbl1.lbl_repres with
            Record_regular -> Lprim(Pmakeblock(0, Immutable), ll)
          | Record_float -> Lprim(Pmakearray Pfloatarray, ll)
      end
  | Texp_field(arg, lbl) ->
      let access =
        match lbl.lbl_repres with
          Record_regular -> Pfield lbl.lbl_pos
        | Record_float -> Pfloatfield lbl.lbl_pos in
      Lprim(access, [transl_exp arg])
  | Texp_setfield(arg, lbl, newval) ->
      let access =
        match lbl.lbl_repres with
          Record_regular -> Psetfield(lbl.lbl_pos, maybe_pointer newval)
        | Record_float -> Psetfloatfield lbl.lbl_pos in
      Lprim(access, [transl_exp arg; transl_exp newval])
  | Texp_array expr_list ->
      let kind = array_kind e in
      let len = List.length expr_list in
      if len <= Config.max_young_wosize then
        Lprim(Pmakearray kind, transl_list expr_list)
      else begin
        let v = Ident.create "makearray" in
        let rec fill_fields pos = function
          [] ->
            Lvar v
        | arg :: rem ->
            Lsequence(Lprim(Parraysetu kind,
                            [Lvar v;
                             Lconst(Const_base(Const_int pos));
                             transl_exp arg]),
                      fill_fields (pos+1) rem) in
        Llet(Strict, v,
             Lprim(Pccall prim_makearray,
                   [Lconst(Const_base(Const_int len));
                    transl_exp (List.hd expr_list)]),
             fill_fields 1 (List.tl expr_list))
      end
  | Texp_ifthenelse(cond, ifso, Some ifnot) ->
      Lifthenelse(transl_exp cond,
                  event_before ifso (transl_exp ifso),
                  event_before ifnot (transl_exp ifnot))
  | Texp_ifthenelse(cond, ifso, None) ->
      Lifthenelse(transl_exp cond,
                  event_before ifso (transl_exp ifso),
                  lambda_unit)
  | Texp_sequence(expr1, expr2) ->
      Lsequence(transl_exp expr1, event_before expr2 (transl_exp expr2))
  | Texp_while(cond, body) ->
      Lwhile(transl_exp cond, event_before body (transl_exp body))
  | Texp_for(param, low, high, dir, body) ->
      Lfor(param, transl_exp low, transl_exp high, dir,
           event_before body (transl_exp body))
  | Texp_when(cond, body) ->
      event_before cond
        (Lifthenelse(transl_exp cond, event_before body (transl_exp body),
                     Lstaticfail))
  | _ ->
      fatal_error "Translcore.transl"

and transl_list expr_list =
  List.map transl_exp expr_list

and transl_cases pat_expr_list =
  List.map
    (fun (pat, expr) -> (pat, event_before expr (transl_exp expr)))
    pat_expr_list

and transl_tupled_cases patl_expr_list =
  List.map (fun (patl, expr) -> (patl, transl_exp expr)) patl_expr_list

and transl_function loc untuplify_fn repr pat_expr_list =
  match pat_expr_list with
    [pat, ({exp_desc = Texp_function pl} as exp)] ->
      let param = name_pattern "param" pat_expr_list in
      let ((_, params), body) = transl_function exp.exp_loc false repr pl in
      ((Curried, param :: params),
       Matching.for_function loc None (Lvar param) [pat, body])
  | ({pat_desc = Tpat_tuple pl}, _) :: _ when untuplify_fn ->
      begin try
        let size = List.length pl in
        let pats_expr_list =
          List.map
            (fun (pat, expr) -> (Matching.flatten_pattern size pat, expr))
            pat_expr_list in
        let params = List.map (fun p -> Ident.create "param") pl in
        ((Tupled, params),
         Matching.for_tupled_function loc params
                                      (transl_tupled_cases pats_expr_list))
      with Matching.Cannot_flatten ->
        let param = name_pattern "param" pat_expr_list in
        ((Curried, [param]),
         Matching.for_function loc repr (Lvar param)
           (transl_cases pat_expr_list))
      end
  | _ ->
      let param = name_pattern "param" pat_expr_list in
      ((Curried, [param]),
       Matching.for_function loc repr (Lvar param)
         (transl_cases pat_expr_list))

and transl_let rec_flag pat_expr_list body =
  match rec_flag with
    Nonrecursive ->
      let rec transl = function
        [] ->
          body
      | (pat, expr) :: rem ->
          Matching.for_let pat.pat_loc (transl_exp expr) pat (transl rem)
      in transl pat_expr_list
  | Recursive ->
      let idlist =
        List.map
          (fun (pat, expr) -> 
            match pat.pat_desc with
              Tpat_var id -> id
            | _ -> raise(Error(pat.pat_loc, Illegal_letrec_pat)))
        pat_expr_list in
      let transl_case (pat, expr) id =
        let lam = transl_exp expr in
        if not (check_recursive_lambda idlist lam) then
          raise(Error(expr.exp_loc, Illegal_letrec_expr));
        (id, lam) in
      Lletrec(List.map2 transl_case pat_expr_list idlist, body)

<<function Translcore.transl_exception>>

(* Error report *)

open Format

<<constant Translcore.report_error>>
@


\subsection*{[[./bytecomp/bytegen.mli]]}


<<signature Bytegen.compile_phrase>>=
val compile_phrase: lambda -> instruction list * instruction list
@


%-------------------------------------------------------------

<<./bytecomp/bytegen.mli>>=
<<copyright header>>

(* Generation of bytecode from lambda terms *)

open Lambda
open Instruct

<<signature Bytegen.compile_implementation>>
<<signature Bytegen.compile_phrase>>
@


\subsection*{[[./bytecomp/bytegen.ml]]}

<<constant Bytegen.label_counter>>=
(**** Label generation ****)

let label_counter = ref 0
@

<<function Bytegen.new_label>>=
let new_label () =
  incr label_counter; !label_counter
@

<<constant Bytegen.empty_env>>=
(**** Operations on compilation environments. ****)

let empty_env =
  { ce_stack = Ident.empty; ce_heap = Ident.empty }
@

<<function Bytegen.add_var>>=
(* Add a stack-allocated variable *)

let add_var id pos env =
  { ce_stack = Ident.add id pos env.ce_stack;
    ce_heap = env.ce_heap }
@

<<constant Bytegen.label_code>>=
(* Return a label to the beginning of the given continuation.
   If the sequence starts with a branch, use the target of that branch
   as the label, thus avoiding a jump to a jump. *)

let label_code = function
    Kbranch lbl :: _ as cont -> (lbl, cont)
  | Klabel lbl :: _ as cont -> (lbl, cont)
  | cont -> let lbl = new_label() in (lbl, Klabel lbl :: cont)
@

<<function Bytegen.make_branch>>=
(* Return a branch to the continuation. That is, an instruction that,
   when executed, branches to the continuation or performs what the
   continuation performs. We avoid generating branches to branches and
   branches to returns. *)

let make_branch cont =
  match cont with
    (Kbranch _ as branch) :: _ -> (branch, cont)
  | (Kreturn _ as return) :: _ -> (return, cont)
  | Kraise :: _ -> (Kraise, cont)
  | Klabel lbl :: _ -> (Kbranch lbl, cont)
  | _ -> let lbl = new_label() in (Kbranch lbl, Klabel lbl :: cont)
@

<<constant Bytegen.discard_dead_code>>=
(* Discard all instructions up to the next label.
   This function is to be applied to the continuation before adding a
   non-terminating instruction (branch, raise, return) in front of it. *)

let rec discard_dead_code = function
    [] -> []
  | (Klabel _ | Krestart | Ksetglobal _) :: _ as cont -> cont
  | _ :: cont -> discard_dead_code cont
@

<<constant Bytegen.is_tailcall>>=
(* Check if we're in tailcall position *)

let rec is_tailcall = function
    Kreturn _ :: _ -> true
  | Klabel _ :: c -> is_tailcall c
  | Kpop _ :: c -> is_tailcall c
  | _ -> false
@

<<function Bytegen.add_pop>>=
(* Add a Kpop N instruction in front of a continuation *)

let rec add_pop n cont =
  if n = 0 then cont else
    match cont with
      Kpop m :: cont -> add_pop (n + m) cont
    | Kreturn m :: cont -> Kreturn(n + m) :: cont
    | Kraise :: _ -> cont
    | _ -> Kpop n :: cont
@

<<constant Bytegen.add_const_unit>>=
(* Add the constant "unit" in front of a continuation *)

let add_const_unit = function
    (Kacc _ | Kconst _ | Kgetglobal _ | Kpush_retaddr _) :: _ as cont -> cont
  | cont -> Kconst const_unit :: cont
@

<<constant Bytegen.size_of_lambda>>=
let rec size_of_lambda = function
  | Lfunction(kind, params, body) as funct ->
      1 + IdentSet.cardinal(free_variables funct)
  | Lprim(Pmakeblock(tag, mut), args) -> List.length args
  | Lprim(Pmakearray kind, args) -> List.length args
  | Llet(str, id, arg, body) -> size_of_lambda body
  | Lletrec(bindings, body) -> size_of_lambda body
  | Levent (lam, _) -> size_of_lambda lam
  | _ -> fatal_error "Bytegen.size_of_lambda"
@

<<function Bytegen.copy_event>>=
(**** Merging consecutive events ****)

let copy_event ev kind info repr =
  { ev_pos = 0;                   (* patched in emitcode *)
    ev_module = ev.ev_module;
    ev_char = ev.ev_char;
    ev_kind = kind;
    ev_info = info;
    ev_typenv = ev.ev_typenv;
    ev_compenv = ev.ev_compenv;
    ev_stacksize = ev.ev_stacksize;
    ev_repr = repr }
@

<<function Bytegen.merge_infos>>=
let merge_infos ev ev' =
  match ev.ev_info, ev'.ev_info with
    Event_other, info -> info
  | info, Event_other -> info
  | _                 -> fatal_error "Bytegen.merge_infos"
@

<<function Bytegen.merge_repr>>=
let merge_repr ev ev' =
  match ev.ev_repr, ev'.ev_repr with
    Event_none, x -> x
  | x, Event_none -> x
  | Event_parent r, Event_child r' when r == r' && !r = 1 -> Event_none
  | _, _          -> fatal_error "Bytegen.merge_repr"
@

<<function Bytegen.merge_events>>=
let merge_events ev ev' =
  let (maj, min) =
    match ev.ev_kind, ev'.ev_kind with
    (* Discard pseudo-events *)    
      Event_pseudo,  _                              -> ev', ev
    | _,             Event_pseudo                   -> ev,  ev'
    (* Keep following event, supposedly more informative *)
    | Event_before,  (Event_after _ | Event_before) -> ev',  ev
    (* Discard following events, supposedly less informative *)
    | Event_after _, (Event_after _ | Event_before) -> ev, ev'
  in
  copy_event maj maj.ev_kind (merge_infos maj min) (merge_repr maj min)
@

<<function Bytegen.weaken_event>>=
let weaken_event ev cont =
  match ev.ev_kind with
    Event_after _ ->
      begin match cont with
        Kpush :: Kevent ({ev_repr = Event_none} as ev') :: c ->
          begin match ev.ev_info with
            Event_return _ ->
              (* Weaken event *)
              let repr = ref 1 in
              let ev =
                copy_event ev Event_pseudo ev.ev_info (Event_parent repr)
              and ev' =
                copy_event ev' ev'.ev_kind ev'.ev_info (Event_child repr)
              in
              Kevent ev :: Kpush :: Kevent ev' :: c
          | _ ->
              (* Only keep following event, equivalent *)
              cont
          end
      | _ ->
          Kevent ev :: cont
      end
  | _ ->
      Kevent ev :: cont
@

<<function Bytegen.add_event>>=
let add_event ev =
  function
    Kevent ev' :: cont -> weaken_event (merge_events ev ev') cont
  | cont               -> weaken_event ev cont
@

<<constant Bytegen.functions_to_compile>>=
(* Function bodies that remain to be compiled *)

let functions_to_compile  =
@

<<constant Bytegen.compunit_name>>=
(* Name of current compilation unit (for debugging events) *)

let compunit_name = ref ""
@

<<function Bytegen.comp_function>>=
(**** Compilation of functions ****)

let comp_function (params, fun_body, entry_lbl, free_vars) cont =
  let arity = List.length params in
  let rec pos_args pos delta = function
      [] -> Ident.empty
    | id :: rem -> Ident.add id pos (pos_args (pos+delta) delta rem) in
  let env =
    { ce_stack = pos_args arity (-1) params;
      ce_heap = pos_args 0 1 free_vars } in
  let cont1 =
    comp_expr env fun_body arity (Kreturn arity :: cont) in
  if arity > 1 then
    Krestart :: Klabel entry_lbl :: Kgrab(arity - 1) :: cont1
  else
    Klabel entry_lbl :: cont1
@

<<function Bytegen.comp_remainder>>=
let comp_remainder cont =
  let c = ref cont in
  begin try
    while true do
      c := comp_function (Stack.pop functions_to_compile) !c
    done
  with Stack.Empty ->
    ()
  end;
  !c
@

<<function Bytegen.compile_implementation>>=
(**** Compilation of a lambda phrase ****)

let compile_implementation modulename expr =
  Stack.clear functions_to_compile;
  label_counter := 0;
  lbl_staticfail := 0;
  sz_staticfail := 0;
  compunit_name := modulename;
  let init_code = comp_expr empty_env expr 0 [] in
  if Stack.length functions_to_compile > 0 then begin
    let lbl_init = new_label() in
    Kbranch lbl_init :: comp_remainder (Klabel lbl_init :: init_code)
  end else
    init_code
@

<<function Bytegen.compile_phrase>>=
let compile_phrase expr =
  Stack.clear functions_to_compile;
  label_counter := 0;
  lbl_staticfail := 0;
  sz_staticfail := 0;
  let init_code = comp_expr empty_env expr 1 [Kreturn 1] in
  let fun_code = comp_remainder [] in
  (init_code, fun_code)
@


%-------------------------------------------------------------

<<./bytecomp/bytegen.ml>>=
<<copyright header>>

(*  bytegen.ml : translation of lambda terms to lists of instructions. *)

open Misc
open Asttypes
open Primitive
open Types
open Lambda
open Instruct

<<constant Bytegen.label_counter>>

<<function Bytegen.new_label>>

<<constant Bytegen.empty_env>>

<<function Bytegen.add_var>>

(**** Examination of the continuation ****)

<<constant Bytegen.label_code>>

<<function Bytegen.make_branch>>

<<constant Bytegen.discard_dead_code>>

<<constant Bytegen.is_tailcall>>

<<function Bytegen.add_pop>>

<<constant Bytegen.add_const_unit>>

(**** Auxiliary for compiling "let rec" ****)

module IdentSet = Set

<<constant Bytegen.size_of_lambda>>

<<function Bytegen.copy_event>>

<<function Bytegen.merge_infos>>

<<function Bytegen.merge_repr>>

<<function Bytegen.merge_events>>

<<function Bytegen.weaken_event>>
  
<<function Bytegen.add_event>>

(**** Compilation of a lambda expression ****)

(* The label to which Lstaticfail branches, and the stack size at that point.*)

let lbl_staticfail = ref 0
and sz_staticfail = ref 0

<<constant Bytegen.functions_to_compile>>
  (Stack.create () : (Ident.t list * lambda * label * Ident.t list) Stack.t)

<<constant Bytegen.compunit_name>>

(* Compile an expression.
   The value of the expression is left in the accumulator.
   env = compilation environment
   exp = the lambda expression to compile
   sz = current size of the stack frame
   cont = list of instructions to execute afterwards
   Result = list of instructions that evaluate exp, then perform cont. *)

let rec comp_expr env exp sz cont =
  match exp with
    Lvar id ->
      begin try
        let pos = Ident.find_same id env.ce_stack in
        Kacc(sz - pos) :: cont
      with Not_found ->
      try
        let pos = Ident.find_same id env.ce_heap in
        Kenvacc(pos) :: cont
      with Not_found ->
        Ident.print id; print_newline();
        fatal_error "Bytegen.comp_expr: var"
      end
  | Lconst cst ->
      Kconst cst :: cont
  | Lapply(func, args) ->
      let nargs = List.length args in
      if is_tailcall cont then
        comp_args env args sz
          (Kpush :: comp_expr env func (sz + nargs)
            (Kappterm(nargs, sz + nargs) :: discard_dead_code cont))
      else
        if nargs < 4 then
          comp_args env args sz
            (Kpush :: comp_expr env func (sz + nargs) (Kapply nargs :: cont))
        else begin
          let (lbl, cont1) = label_code cont in
          Kpush_retaddr lbl ::
          comp_args env args (sz + 3)
            (Kpush :: comp_expr env func (sz + 3 + nargs)
                      (Kapply nargs :: cont1))
        end
  | Lfunction(kind, params, body) -> (* assume kind = Curried *)
      let lbl = new_label() in
      let fv = IdentSet.elements(free_variables exp) in
      Stack.push (params, body, lbl, fv) functions_to_compile;
      comp_args env (List.map (fun n -> Lvar n) fv) sz
        (Kclosure(lbl, List.length fv) :: cont)
  | Llet(str, id, arg, body) ->
      comp_expr env arg sz
        (Kpush :: comp_expr (add_var id (sz+1) env) body (sz+1)
          (add_pop 1 cont))
  | Lletrec(([id, Lfunction(kind, params, funct_body)] as decl), let_body) ->
      let lbl = new_label() in
      let fv =
        IdentSet.elements (free_variables (Lletrec(decl, lambda_unit))) in
      Stack.push (params, funct_body, lbl, id :: fv) functions_to_compile;
      comp_args env (List.map (fun n -> Lvar n) fv) sz
        (Kclosurerec(lbl, List.length fv) :: Kpush ::
          (comp_expr (add_var id (sz+1) env) let_body (sz+1)
                     (add_pop 1 cont)))
  | Lletrec(decl, body) ->
      let ndecl = List.length decl in
      let decl_size =
        List.map (fun (id, exp) -> (id, exp, size_of_lambda exp)) decl in
      let rec comp_decl new_env sz i = function
          [] ->
            comp_expr new_env body sz (add_pop ndecl cont)
        | (id, exp, blocksize) :: rem ->
            comp_expr new_env exp sz
              (Kpush :: Kacc i :: Kupdate blocksize ::
               comp_decl new_env sz (i-1) rem) in
      let rec comp_init new_env sz = function
          [] ->
            comp_decl new_env sz ndecl decl_size
        | (id, exp, blocksize) :: rem ->
            Kdummy blocksize :: Kpush ::
            comp_init (add_var id (sz+1) new_env) (sz+1) rem in
      comp_init env sz decl_size
  | Lprim(Pidentity, [arg]) ->
      comp_expr env arg sz cont
  | Lprim(Pnot, [arg]) ->
      let newcont =
        match cont with
          Kbranchif lbl :: cont1 -> Kbranchifnot lbl :: cont1
        | Kbranchifnot lbl :: cont1 -> Kbranchif lbl :: cont1
        | _ -> Kboolnot :: cont in
      comp_expr env arg sz newcont
  | Lprim(Psequand, [exp1; exp2]) ->
      begin match cont with
        Kbranchifnot lbl :: _ ->
          comp_expr env exp1 sz (Kbranchifnot lbl ::
            comp_expr env exp2 sz cont)
      | Kbranchif lbl :: cont1 ->
          let (lbl2, cont2) = label_code cont1 in
          comp_expr env exp1 sz (Kbranchifnot lbl2 ::
            comp_expr env exp2 sz (Kbranchif lbl :: cont2))
      | _ ->
          let (lbl, cont1) = label_code cont in
          comp_expr env exp1 sz (Kstrictbranchifnot lbl ::
            comp_expr env exp2 sz cont1)
      end
  | Lprim(Psequor, [exp1; exp2]) ->
      begin match cont with
        Kbranchif lbl :: _ ->
          comp_expr env exp1 sz (Kbranchif lbl ::
            comp_expr env exp2 sz cont)
      | Kbranchifnot lbl :: cont1 ->
          let (lbl2, cont2) = label_code cont1 in
          comp_expr env exp1 sz (Kbranchif lbl2 ::
            comp_expr env exp2 sz (Kbranchifnot lbl :: cont2))
      | _ ->
          let (lbl, cont1) = label_code cont in
          comp_expr env exp1 sz (Kstrictbranchif lbl ::
            comp_expr env exp2 sz cont1)
      end
  | Lprim(Praise, [arg]) ->
      comp_expr env arg sz (Kraise :: discard_dead_code cont)
  | Lprim((Paddint | Psubint as prim), [arg; Lconst(Const_base(Const_int n))])
    when n >= immed_min & n <= immed_max ->
      let ofs = if prim == Paddint then n else -n in
      comp_expr env arg sz (Koffsetint ofs :: cont)
  | Lprim(p, args) ->
      let instr =
        match p with
          Pgetglobal id -> Kgetglobal id
        | Psetglobal id -> Ksetglobal id
        | Pintcomp cmp -> Kintcomp cmp
        | Pmakeblock(tag, mut) -> Kmakeblock(List.length args, tag)
        | Pfield n -> Kgetfield n
        | Psetfield(n, ptr) -> Ksetfield n
        | Pfloatfield n -> Kgetfield n
        | Psetfloatfield n -> Ksetfield n
        | Pccall p -> Kccall(p.prim_name, p.prim_arity)
        | Pnegint -> Knegint
        | Paddint -> Kaddint
        | Psubint -> Ksubint
        | Pmulint -> Kmulint
        | Pdivint -> Kdivint
        | Pmodint -> Kmodint
        | Pandint -> Kandint
        | Porint -> Korint
        | Pxorint -> Kxorint
        | Plslint -> Klslint
        | Plsrint -> Klsrint
        | Pasrint -> Kasrint
        | Poffsetint n -> Koffsetint n
        | Poffsetref n -> Koffsetref n
        | Pintoffloat -> Kccall("int_of_float", 1)
        | Pfloatofint -> Kccall("float_of_int", 1)
        | Pnegfloat -> Kccall("neg_float", 1)
        | Pabsfloat -> Kccall("abs_float", 1)
        | Paddfloat -> Kccall("add_float", 2)
        | Psubfloat -> Kccall("sub_float", 2)
        | Pmulfloat -> Kccall("mul_float", 2)
        | Pdivfloat -> Kccall("div_float", 2)
        | Pfloatcomp Ceq -> Kccall("eq_float", 2)
        | Pfloatcomp Cneq -> Kccall("neq_float", 2)
        | Pfloatcomp Clt -> Kccall("lt_float", 2)
        | Pfloatcomp Cgt -> Kccall("gt_float", 2)
        | Pfloatcomp Cle -> Kccall("le_float", 2)
        | Pfloatcomp Cge -> Kccall("ge_float", 2)
        | Pstringlength -> Kccall("ml_string_length", 1)
        | Pstringrefs -> Kccall("string_get", 2)
        | Pstringsets -> Kccall("string_set", 3)
        | Pstringrefu -> Kgetstringchar
        | Pstringsetu -> Ksetstringchar
        | Pmakearray kind -> Kmakeblock(List.length args, 0)
        | Parraylength kind -> Kvectlength
        | Parrayrefs kind -> Kccall("array_get", 2)
        | Parraysets kind -> Kccall("array_set", 3)
        | Parrayrefu kind -> Kgetvectitem
        | Parraysetu kind -> Ksetvectitem
        | Pbittest -> Kccall("bitvect_test", 2)
        | _ -> fatal_error "Bytegen.comp_expr: prim" in
      comp_args env args sz (instr :: cont)
  | Lcatch(body, Lstaticfail) ->
      comp_expr env body sz cont
  | Lcatch(body, handler) ->
      let (branch1, cont1) = make_branch cont in
      let (lbl_handler, cont2) = label_code (comp_expr env handler sz cont1) in
      let saved_lbl_staticfail = !lbl_staticfail
      and saved_sz_staticfail = !sz_staticfail in
      lbl_staticfail := lbl_handler;
      sz_staticfail := sz;
      let cont3 = comp_expr env body sz (branch1 :: cont2) in
      lbl_staticfail := saved_lbl_staticfail;
      sz_staticfail := saved_sz_staticfail;
      cont3
  | Lstaticfail ->
      add_pop (sz - !sz_staticfail)
              (Kbranch !lbl_staticfail :: discard_dead_code cont)
  | Ltrywith(body, id, handler) ->
      let (branch1, cont1) = make_branch cont in
      let lbl_handler = new_label() in
      Kpushtrap lbl_handler :: 
        comp_expr env body (sz+4) (Kpoptrap :: branch1 :: 
          Klabel lbl_handler :: Kpush ::
            comp_expr (add_var id (sz+1) env) handler (sz+1) (add_pop 1 cont1))
  | Lifthenelse(cond, ifso, ifnot) ->
      comp_binary_test env cond ifso ifnot sz cont
  | Lsequence(exp1, exp2) ->
      comp_expr env exp1 sz (comp_expr env exp2 sz cont)
  | Lwhile(cond, body) ->
      let lbl_loop = new_label() in
      let lbl_test = new_label() in
      Kbranch lbl_test :: Klabel lbl_loop :: Kcheck_signals ::
        comp_expr env body sz
          (Klabel lbl_test ::
            comp_expr env cond sz (Kbranchif lbl_loop :: add_const_unit cont))
  | Lfor(param, start, stop, dir, body) ->
      let lbl_loop = new_label() in
      let lbl_test = new_label() in
      let offset = match dir with Upto -> 1 | Downto -> -1 in
      let comp = match dir with Upto -> Cle | Downto -> Cge in
      comp_expr env start sz
        (Kpush :: comp_expr env stop (sz+1)
          (Kpush :: Kbranch lbl_test ::
           Klabel lbl_loop :: Kcheck_signals ::
           comp_expr (add_var param (sz+1) env) body (sz+2)
             (Kacc 1 :: Koffsetint offset :: Kassign 1 ::
              Klabel lbl_test ::
              Kacc 0 :: Kpush :: Kacc 2 :: Kintcomp comp ::
              Kbranchif lbl_loop ::
              add_const_unit (add_pop 2 cont))))
  | Lswitch(arg, sw) ->
      let (branch, cont1) = make_branch cont in
      let c = ref (discard_dead_code cont1) in
      let act_consts = Array.create sw.sw_numconsts Lstaticfail in
      List.iter (fun (n, act) -> act_consts.(n) <- act) sw.sw_consts;
      let act_blocks = Array.create sw.sw_numblocks Lstaticfail in
      List.iter (fun (n, act) -> act_blocks.(n) <- act) sw.sw_blocks;
      let lbl_consts = Array.create sw.sw_numconsts 0 in
      let lbl_blocks = Array.create sw.sw_numblocks 0 in
      for i = sw.sw_numblocks - 1 downto 0 do
        let (lbl, c1) =
          label_code(comp_expr env act_blocks.(i) sz (branch :: !c)) in
        lbl_blocks.(i) <- lbl;
        c := discard_dead_code c1
      done;
      for i = sw.sw_numconsts - 1 downto 0 do
        let (lbl, c1) =
          label_code(comp_expr env act_consts.(i) sz (branch :: !c)) in
        lbl_consts.(i) <- lbl;
        c := discard_dead_code c1
      done;
      if sw.sw_checked then c := comp_expr env Lstaticfail sz !c;        
      comp_expr env arg sz (Kswitch(lbl_consts, lbl_blocks) :: !c)
  | Lassign(id, expr) ->
      begin try
        let pos = Ident.find_same id env.ce_stack in
        comp_expr env expr sz (Kassign(sz - pos) :: cont)
      with Not_found ->
        fatal_error "Bytegen.comp_expr: assign"
      end
  | Levent(lam, lev) ->
      let event kind info =
        { ev_pos = 0;                   (* patched in emitcode *)
          ev_module = !compunit_name;
          ev_char = lev.lev_loc;
          ev_kind = kind;
          ev_info = info;
          ev_typenv = lev.lev_env;
          ev_compenv = env;
          ev_stacksize = sz;
          ev_repr =
            begin match lev.lev_repr with
              None ->
                Event_none
            | Some ({contents = 1} as repr) when lev.lev_kind = Lev_function ->
                Event_child repr
            | Some ({contents = 1} as repr) ->
                Event_parent repr
            | Some repr when lev.lev_kind = Lev_function ->
                Event_parent repr
            | Some repr ->
                Event_child repr
            end }
      in
      begin match lev.lev_kind with
        Lev_before ->
          let c = comp_expr env lam sz cont in
          let ev = event Event_before Event_other in
          add_event ev c
      | Lev_function ->
          let c = comp_expr env lam sz cont in
          let ev = event Event_pseudo Event_function in
          add_event ev c
      | Lev_after _ when is_tailcall cont -> (* don't destroy tail call opt *)
          comp_expr env lam sz cont
      | Lev_after ty ->
          let info =
            match lam with
              Lapply(_, args)   -> Event_return (List.length args)
            | _                 -> Event_other
          in
          let ev = event (Event_after ty) info in
          let cont1 = add_event ev cont in
          comp_expr env lam sz cont1
      end

(* Compile a list of arguments [e1; ...; eN] to a primitive operation.
   The values of eN ... e2 are pushed on the stack, e2 at top of stack,
   then e3, then ... The value of e1 is left in the accumulator. *)

and comp_args env argl sz cont =
  comp_expr_list env (List.rev argl) sz cont

and comp_expr_list env exprl sz cont =
  match exprl with
    [] -> cont
  | [exp] -> comp_expr env exp sz cont
  | exp :: rem ->
      comp_expr env exp sz (Kpush :: comp_expr_list env rem (sz+1) cont)

(* Compile an if-then-else test. *)

and comp_binary_test env cond ifso ifnot sz cont =
  let cont_cond =
    if ifnot = Lconst const_unit then begin
      let (lbl_end, cont1) = label_code cont in
      Kstrictbranchifnot lbl_end :: comp_expr env ifso sz cont1
    end else
    if ifso = Lstaticfail & sz = !sz_staticfail then
      Kbranchif !lbl_staticfail :: comp_expr env ifnot sz cont
    else
    if ifnot = Lstaticfail & sz = !sz_staticfail then
      Kbranchifnot !lbl_staticfail :: comp_expr env ifso sz cont
    else begin
      let (branch_end, cont1) = make_branch cont in
      let (lbl_not, cont2) = label_code(comp_expr env ifnot sz cont1) in
      Kbranchifnot lbl_not :: comp_expr env ifso sz (branch_end :: cont2)
    end in
  comp_expr env cond sz cont_cond

<<function Bytegen.comp_function>>

<<function Bytegen.comp_remainder>>

<<function Bytegen.compile_implementation>>

<<function Bytegen.compile_phrase>>

@


\subsection*{[[./bytecomp/translmod.mli]]}




%-------------------------------------------------------------

<<./bytecomp/translmod.mli>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Typedtree
open Lambda

<<signature Translmod.transl_implementation>>
<<signature Translmod.transl_store_implementation>>
<<signature Translmod.transl_toplevel_definition>>

<<signature Translmod.primitive_declarations>>
@


\subsection*{[[./bytecomp/translmod.ml]]}

<<function Translmod.reset_labels>>=
let reset_labels () =
 (*  used_methods := [] *)
  ()
@

<<function Translmod.transl_label_init>>=
let transl_label_init expr =
(*
  if !used_methods = [] then
    expr
  else
    let init = Ident.create "new_method" in
    let expr' =
      Llet(StrictOpt, init, oo_prim "new_method",
      List.fold_right
        (fun (lab, id) expr ->
           Llet(StrictOpt, id, Lapply(Lvar init, [string lab]), expr))
        !used_methods
        expr)
    in
    reset_labels ();
    expr'
*)
  expr
@

<<function Translmod.compose_coercions>>=
(* Compose two coercions
   apply_coercion c1 (apply_coercion c2 e) behaves like
   apply_coercion (compose_coercions c1 c2) e. *)

let rec compose_coercions c1 c2 =
  match (c1, c2) with
    (Tcoerce_none, c2) -> c2
  | (c1, Tcoerce_none) -> c1
  | (Tcoerce_structure pc1, Tcoerce_structure pc2) ->
      let v2 = Array.of_list pc2 in
      Tcoerce_structure
        (List.map (fun (p1, c1) ->
                let (p2, c2) = v2.(p1) in (p2, compose_coercions c1 c2))
             pc1)
  | (_, _) ->
      fatal_error "Translmod.compose_coercions"
@

<<constant Translmod.primitive_declarations>>=
(* Record the primitive declarations occuring in the module compiled *)

let primitive_declarations = ref ([] : string list)
@

<<function Translmod.transl_implementation>>=
(* Compile an implementation *)

let transl_implementation module_name str cc =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  Lprim(Psetglobal module_id, [transl_label_init (transl_structure [] cc str)])
@

<<function Translmod.transl_store_structure>>=
(* A variant of transl_structure used to compile toplevel structure definitions
   for the native-code compiler. Store the defined values in the fields
   of the global as soon as they are defined, in order to reduce register
   pressure.
   "map" is a table from idents to (position in global block, coercion).
   "prim" is a list of (position in global block, primitive declaration). *)

let transl_store_structure glob map prims str =
  let rec transl_store = function
    [] ->
      lambda_unit
  | Tstr_eval expr :: rem ->
      Lsequence(transl_exp expr, transl_store rem)
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      transl_let rec_flag pat_expr_list
        (store_idents glob map (let_bound_idents pat_expr_list)
          (transl_store rem))
  | Tstr_primitive(id, descr) :: rem ->
      begin match descr.val_kind with
        Val_prim p -> primitive_declarations :=
                        p.Primitive.prim_name :: !primitive_declarations
      | _ -> ()
      end;
      transl_store rem
  | Tstr_type(decls) :: rem ->
      transl_store rem
  | Tstr_exception(id, decl) :: rem ->
      Llet(Strict, id, transl_exception id decl,
           store_ident glob map id (transl_store rem))
  | Tstr_module(id, modl) :: rem ->
      Llet(Strict, id, transl_module Tcoerce_none modl,
           store_ident glob map id (transl_store rem))
  | Tstr_modtype(id, decl) :: rem ->
      transl_store rem
  | Tstr_open path :: rem ->
      transl_store rem

  and store_ident glob map id cont =
    try
      let (pos, cc) = Ident.find_same id map in
      let init_val = apply_coercion cc (Lvar id) in
      Lsequence
       (Lprim(Psetfield(pos, false), [Lprim(Pgetglobal glob, []); init_val]),
        cont)
    with Not_found ->
      cont

  and store_idents glob map idlist cont =
    List.fold_right (store_ident glob map) idlist cont

  and store_primitive (pos, prim) cont =
    Lsequence(Lprim(Psetfield(pos, false),
                    [Lprim(Pgetglobal glob, []); transl_primitive prim]),
              cont)
  in
    List.fold_right store_primitive prims (transl_store str)
@

<<constant Translmod.defined_idents>>=
(* Build the list of value identifiers defined by a toplevel structure *)

let rec defined_idents = function
    [] -> []
  | Tstr_eval expr :: rem -> defined_idents rem
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      let_bound_idents pat_expr_list @ defined_idents rem
  | Tstr_primitive(id, descr) :: rem -> defined_idents rem
  | Tstr_type decls :: rem -> defined_idents rem
  | Tstr_exception(id, decl) :: rem -> id :: defined_idents rem
  | Tstr_module(id, modl) :: rem -> id :: defined_idents rem
  | Tstr_modtype(id, decl) :: rem -> defined_idents rem
  | Tstr_open path :: rem -> defined_idents rem
@

<<function Translmod.build_ident_map>>=
(* Transform a coercion and the list of value identifiers built above
   into a table id -> (pos, coercion), with [pos] being the position
   in the global block where the value of [id] must be stored,
   and [coercion] the coercion to be applied to it.
   A given identifier may appear several times
   in the coercion (if it occurs several times in the signature); remember
   to assign it the position of its last occurrence.
   Also buid a list of primitives and their positions in the global block,
   and the total size of the global block. *)

let build_ident_map restr idlist =
  match restr with
    Tcoerce_none ->
      let rec build_map pos map = function
        [] ->
          (map, [], pos)
      | id :: rem ->
          build_map (pos+1) (Ident.add id (pos, Tcoerce_none) map) rem
      in build_map 0 Ident.empty idlist
  | Tcoerce_structure pos_cc_list ->
      let idarray = Array.of_list idlist in
      let rec build_map pos map prims = function
        [] ->
          (map, prims, pos)
      | (source_pos, Tcoerce_primitive p) :: rem ->
          build_map (pos+1) map ((pos, p) :: prims) rem
      | (source_pos, cc) :: rem ->
          build_map (pos+1) (Ident.add idarray.(source_pos) (pos, cc) map)
                    prims rem
      in build_map 0 Ident.empty [] pos_cc_list
  | _ ->
      fatal_error "Translmod.build_ident_map"
@

<<function Translmod.transl_store_implementation>>=
(* Compile an implementation using transl_store_structure 
   (for the native-code compiler). *)

let transl_store_implementation module_name str restr =
  reset_labels ();
  primitive_declarations := [];
  let module_id = Ident.create_persistent module_name in
  let (map, prims, size) = build_ident_map restr (defined_idents str) in
  (size, transl_label_init (transl_store_structure module_id map prims str))
@

<<function Translmod.make_sequence>>=
(* Compile a sequence of expressions *)

let rec make_sequence fn = function
    [] -> lambda_unit
  | [x] -> fn x
  | x::rem ->
      let lam = fn x in Lsequence(lam, make_sequence fn rem)
@

<<constant Translmod.transl_toplevel_item>>=
(* Compile a toplevel phrase *)

let transl_toplevel_item = function
    Tstr_eval expr ->
      transl_exp expr
  | Tstr_value(rec_flag, pat_expr_list) ->
      let idents = let_bound_idents pat_expr_list in
      let lam =
        transl_let rec_flag pat_expr_list
          (make_sequence (fun id -> Lprim(Psetglobal id, [Lvar id])) idents) in
      List.iter Ident.make_global idents;
      lam
  | Tstr_primitive(id, descr) ->
      lambda_unit
  | Tstr_type(decls) ->
      lambda_unit
  | Tstr_exception(id, decl) ->
      Ident.make_global id;
      Lprim(Psetglobal id, [transl_exception id decl])
  | Tstr_module(id, modl) ->
      Ident.make_global id;
      Lprim(Psetglobal id, [transl_module Tcoerce_none modl])
  | Tstr_modtype(id, decl) ->
      lambda_unit
  | Tstr_open path ->
      lambda_unit
@

<<function Translmod.transl_toplevel_definition>>=
let transl_toplevel_definition str =
  reset_labels ();
  transl_label_init (make_sequence transl_toplevel_item str)
@


%-------------------------------------------------------------

<<./bytecomp/translmod.ml>>=
<<copyright header>>

(* Translation from typed abstract syntax to lambda terms,
   for the module language *)

open Misc
open Asttypes
open Types
open Typedtree
open Lambda
open Translcore

<<function Translmod.reset_labels>>

<<function Translmod.transl_label_init>>

(* Compile a coercion *)

let rec apply_coercion restr arg =
  match restr with
    Tcoerce_none ->
      arg
  | Tcoerce_structure pos_cc_list ->
      name_lambda arg (fun id ->
        Lprim(Pmakeblock(0, Immutable),
              List.map (apply_coercion_field id) pos_cc_list))
  | Tcoerce_primitive p ->
      fatal_error "Translmod.apply_coercion"

and apply_coercion_field id (pos, cc) =
  match cc with
    Tcoerce_primitive p -> transl_primitive p
  | _ -> apply_coercion cc (Lprim(Pfield pos, [Lvar id]))

<<function Translmod.compose_coercions>>

<<constant Translmod.primitive_declarations>>

(* Compile a module expression *)

let rec transl_module cc mexp =
  match mexp.mod_desc with
    Tmod_ident path ->
      apply_coercion cc (transl_path path)
  | Tmod_structure str ->
      transl_structure [] cc str
  | Tmod_constraint(arg, mty, ccarg) ->
      transl_module (compose_coercions cc ccarg) arg

and transl_structure fields cc = function
    [] ->
      begin match cc with
        Tcoerce_none ->
          Lprim(Pmakeblock(0, Immutable),
                List.map (fun id -> Lvar id) (List.rev fields))
      | Tcoerce_structure pos_cc_list ->
          let v = Array.of_list (List.rev fields) in
          Lprim(Pmakeblock(0, Immutable),
                List.map
                  (fun (pos, cc) ->
                    match cc with
                      Tcoerce_primitive p -> transl_primitive p
                    | _ -> apply_coercion cc (Lvar v.(pos)))
                  pos_cc_list)
      | _ ->
          fatal_error "Translmod.transl_structure"
      end
  | Tstr_eval expr :: rem ->
      Lsequence(transl_exp expr, transl_structure fields cc rem)
  | Tstr_value(rec_flag, pat_expr_list) :: rem ->
      let ext_fields = rev_let_bound_idents pat_expr_list @ fields in
      transl_let rec_flag pat_expr_list (transl_structure ext_fields cc rem)
  | Tstr_primitive(id, descr) :: rem ->
      begin match descr.val_kind with
        Val_prim p -> primitive_declarations :=
                        p.Primitive.prim_name :: !primitive_declarations
      | _ -> ()
      end;
      transl_structure fields cc rem
  | Tstr_type(decls) :: rem ->
      transl_structure fields cc rem
  | Tstr_exception(id, decl) :: rem ->
      Llet(Strict, id, transl_exception id decl,
           transl_structure (id :: fields) cc rem)
  | Tstr_module(id, modl) :: rem ->
      Llet(Strict, id, transl_module Tcoerce_none modl,
           transl_structure (id :: fields) cc rem)
  | Tstr_modtype(id, decl) :: rem ->
      transl_structure fields cc rem
  | Tstr_open path :: rem ->
      transl_structure fields cc rem

<<function Translmod.transl_implementation>>

<<function Translmod.transl_store_structure>>

<<constant Translmod.defined_idents>>

<<function Translmod.build_ident_map>>
        
<<function Translmod.transl_store_implementation>>

<<function Translmod.make_sequence>>

<<constant Translmod.transl_toplevel_item>>

<<function Translmod.transl_toplevel_definition>>
@


\subsection*{[[./bytecomp/emitcode.mli]]}


<<signature Emitcode.to_memory>>=
val to_memory: instruction list -> instruction list ->
                    string * int * (reloc_info * int) list
        (* Arguments:
             initialization code (terminated by STOP)
             function code
           Results:
             block of relocatable bytecode
             size of this block
             relocation information *)
@


%-------------------------------------------------------------

<<./bytecomp/emitcode.mli>>=
<<copyright header>>

(* Generation of bytecode for .cmo files *)

open Lambda
open Instruct

<<type Emitcode.reloc_info>>

<<type Emitcode.compilation_unit>>

<<signature Emitcode.to_file>>
<<signature Emitcode.to_memory>>

@


\subsection*{[[./bytecomp/emitcode.ml]]}



<<function Emitcode.out_word>>=
let out_word b1 b2 b3 b4 =
  let p = !out_position in
  if p >= String.length !out_buffer then begin
    let len = String.length !out_buffer in
    let new_buffer = String.create (2 * len) in
    String.blit !out_buffer 0 new_buffer 0 len;
    out_buffer := new_buffer
  end;
  String.unsafe_set !out_buffer p (Char.unsafe_chr b1);
  String.unsafe_set !out_buffer (p+1) (Char.unsafe_chr b2);
  String.unsafe_set !out_buffer (p+2) (Char.unsafe_chr b3);
  String.unsafe_set !out_buffer (p+3) (Char.unsafe_chr b4);
  out_position := p + 4
@

<<function Emitcode.out>>=
let out opcode =
  out_word opcode 0 0 0
@

<<function Emitcode.out_int>>=
let out_int n =
  out_word n (n asr 8) (n asr 16) (n asr 24)
@

<<type Emitcode.label_definition>>=
(* Handling of local labels and backpatching *)

type label_definition =
    Label_defined of int
  | Label_undefined of (int * int) list
@

<<constant Emitcode.label_table>>=
let label_table  = ref ([| |] : label_definition array)
@

<<function Emitcode.extend_label_table>>=
let extend_label_table needed =
  let new_size = ref(Array.length !label_table) in
  while needed >= !new_size do new_size := 2 * !new_size done;
  let new_table = Array.create !new_size (Label_undefined []) in
  Array.blit !label_table 0 new_table 0 (Array.length !label_table);
  label_table := new_table
@

<<function Emitcode.backpatch>>=
let backpatch (pos, orig) =
  let displ = (!out_position - orig) asr 2 in
  !out_buffer.[pos] <- Char.unsafe_chr displ;
  !out_buffer.[pos+1] <- Char.unsafe_chr (displ asr 8);
  !out_buffer.[pos+2] <- Char.unsafe_chr (displ asr 16);
@

<<function Emitcode.define_label>>=
let define_label lbl =
  if lbl >= Array.length !label_table then extend_label_table lbl;
  match (!label_table).(lbl) with
    Label_defined _ ->
      fatal_error "Emitcode.define_label"
  | Label_undefined patchlist ->
      List.iter backpatch patchlist;
@

<<function Emitcode.out_label_with_orig>>=
let out_label_with_orig orig lbl =
  if lbl >= Array.length !label_table then extend_label_table lbl;
  match (!label_table).(lbl) with
    Label_defined def ->
      out_int((def - orig) asr 2)
  | Label_undefined patchlist ->
      (!label_table).(lbl) <-
         Label_undefined((!out_position, orig) :: patchlist);
      out_int 0
@

<<function Emitcode.out_label>>=
let out_label l = out_label_with_orig !out_position l
@

<<constant Emitcode.reloc_info>>=
(* Relocation information *)

let reloc_info = ref ([] : (reloc_info * int) list)
@

<<function Emitcode.enter>>=
let enter info =
  reloc_info := (info, !out_position) :: !reloc_info
@

<<constant Emitcode.events>>=
(* Debugging events *)

let events = ref ([] : debug_event list)
@

<<function Emitcode.record_event>>=
let record_event ev =
  ev.ev_pos <- !out_position;
  events := ev :: !events
@

<<function Emitcode.init>>=
(* Initialization *)

let init () =
  out_position := 0;
  label_table := Array.create 16 (Label_undefined []);
  reloc_info := [];
  events := []
@

<<constant Emitcode.emit_instr>>=
(* Emission of one instruction *)

let emit_instr = function
    Klabel lbl -> define_label lbl
  | Kacc n ->
      if n < 8 then out(opACC0 + n) else (out opACC; out_int n)
  | Kenvacc n ->
      if n < 4 then out(opENVACC1 + n) else (out opENVACC; out_int (n+1))
  | Kpush ->
      out opPUSH
  | Kpop n ->
      out opPOP; out_int n
  | Kassign n ->
      out opASSIGN; out_int n
  | Kpush_retaddr lbl -> out opPUSH_RETADDR; out_label lbl
  | Kapply n ->
      if n < 4 then out(opAPPLY1 + n - 1) else (out opAPPLY; out_int n)
  | Kappterm(n, sz) ->
      if n < 4 then (out(opAPPTERM1 + n - 1); out_int sz)
               else (out opAPPTERM; out_int n; out_int sz)
  | Kreturn n -> out opRETURN; out_int n
  | Krestart -> out opRESTART
  | Kgrab n -> out opGRAB; out_int n
  | Kclosure(lbl, n) -> out opCLOSURE; out_int n; out_label lbl
  | Kclosurerec(lbl, n) -> out opCLOSUREREC; out_int n; out_label lbl
  | Kgetglobal q -> out opGETGLOBAL; slot_for_getglobal q
  | Ksetglobal q -> out opSETGLOBAL; slot_for_setglobal q
  | Kconst sc ->
      begin match sc with
        Const_base(Const_int i) when i >= immed_min & i <= immed_max ->
          if i >= 0 & i <= 3
          then out (opCONST0 + i)
          else (out opCONSTINT; out_int i)
      | Const_base(Const_char c) ->
          out opCONSTINT; out_int (Char.code c)
      | Const_pointer i ->
          if i >= 0 & i <= 3
          then out (opCONST0 + i)
          else (out opCONSTINT; out_int i)
      | Const_block(t, []) ->
          if t = 0 then out opATOM0 else (out opATOM; out_int t)
      | _ ->
          out opGETGLOBAL; slot_for_literal sc
      end
  | Kmakeblock(n, t) ->
      if n = 0 then
        if t < 4 then out (opATOM0 + t) else (out opATOM; out_int t)
      else if n < 4 then (out(opMAKEBLOCK1 + n - 1); out_int t)
      else (out opMAKEBLOCK; out_int n; out_int t)
  | Kgetfield n ->
      if n < 4 then out(opGETFIELD0 + n) else (out opGETFIELD; out_int n)
  | Ksetfield n ->
      if n < 4 then out(opSETFIELD0 + n) else (out opSETFIELD; out_int n)
  | Kdummy n ->
      if n = 0 then out opATOM0 else (out opDUMMY; out_int n)
  | Kupdate n -> out opUPDATE
  | Kvectlength -> out opVECTLENGTH
  | Kgetvectitem -> out opGETVECTITEM
  | Ksetvectitem -> out opSETVECTITEM
  | Kgetstringchar -> out opGETSTRINGCHAR
  | Ksetstringchar -> out opSETSTRINGCHAR
  | Kbranch lbl -> out opBRANCH; out_label lbl
  | Kbranchif lbl -> out opBRANCHIF; out_label lbl
  | Kbranchifnot lbl -> out opBRANCHIFNOT; out_label lbl
  | Kstrictbranchif lbl -> out opBRANCHIF; out_label lbl
  | Kstrictbranchifnot lbl -> out opBRANCHIFNOT; out_label lbl
  | Kswitch(tbl_const, tbl_block) ->
      out opSWITCH;
      out_int (Array.length tbl_const + (Array.length tbl_block lsl 16));
      let org = !out_position in
      Array.iter (out_label_with_orig org) tbl_const;
      Array.iter (out_label_with_orig org) tbl_block
  | Kboolnot -> out opBOOLNOT
  | Kpushtrap lbl -> out opPUSHTRAP; out_label lbl
  | Kpoptrap -> out opPOPTRAP
  | Kraise -> out opRAISE
  | Kcheck_signals -> out opCHECK_SIGNALS
  | Kccall(name, n) ->
      if n <= 5
      then (out (opC_CALL1 + n - 1); slot_for_c_prim name)
      else (out opC_CALLN; out_int n; slot_for_c_prim name)
  | Knegint -> out opNEGINT  | Kaddint -> out opADDINT
  | Ksubint -> out opSUBINT  | Kmulint -> out opMULINT
  | Kdivint -> out opDIVINT  | Kmodint -> out opMODINT
  | Kandint -> out opANDINT  | Korint -> out opORINT
  | Kxorint -> out opXORINT  | Klslint -> out opLSLINT
  | Klsrint -> out opLSRINT  | Kasrint -> out opASRINT
  | Kintcomp Ceq -> out opEQ         | Kintcomp Cneq -> out opNEQ
  | Kintcomp Clt -> out opLTINT      | Kintcomp Cle -> out opLEINT
  | Kintcomp Cgt -> out opGTINT      | Kintcomp Cge -> out opGEINT
  | Koffsetint n -> out opOFFSETINT; out_int n
  | Koffsetref n -> out opOFFSETREF; out_int n
  | Kevent ev -> record_event ev
  | Kstop -> out opSTOP
@

<<constant Emitcode.emit>>=
(* Emission of a list of instructions. Include some peephole optimization. *)

let rec emit = function
    [] -> ()
  (* Peephole optimizations *)
  | Kpush :: Kacc n :: c ->
      if n < 8 then out(opPUSHACC0 + n) else (out opPUSHACC; out_int n);
      emit c
  | Kpush :: Kenvacc n :: c ->
      if n < 4 then out(opPUSHENVACC1 + n)
               else (out opPUSHENVACC; out_int (n+1));
      emit c
  | Kpush :: Kgetglobal id :: Kgetfield n :: c ->
      out opPUSHGETGLOBALFIELD; slot_for_getglobal id; out_int n; emit c
  | Kpush :: Kgetglobal id :: c ->
      out opPUSHGETGLOBAL; slot_for_getglobal id; emit c
  | Kpush :: Kconst sc :: c ->
      begin match sc with
        Const_base(Const_int i) when i >= immed_min & i <= immed_max ->
          if i >= 0 & i <= 3
          then out (opPUSHCONST0 + i)
          else (out opPUSHCONSTINT; out_int i)
      | Const_base(Const_char c) ->
          out opPUSHCONSTINT; out_int(Char.code c)
      | Const_pointer i ->
          if i >= 0 & i <= 3
          then out (opPUSHCONST0 + i)
          else (out opPUSHCONSTINT; out_int i)
      | Const_block(t, []) ->
          if t = 0 then out opPUSHATOM0 else (out opPUSHATOM; out_int t)
      | _ ->
          out opPUSHGETGLOBAL; slot_for_literal sc
      end;
      emit c
  | Kpush :: (Kevent {ev_kind = Event_before} as ev) ::
    (Kgetglobal _ as instr1) :: (Kgetfield _ as instr2) :: c ->
      emit (Kpush :: instr1 :: instr2 :: ev :: c)
  | Kpush :: (Kevent {ev_kind = Event_before} as ev) ::
    (Kacc _ | Kenvacc _ | Kgetglobal _ | Kconst _ as instr) :: c ->
      emit (Kpush :: instr :: ev :: c)
  | Kgetglobal id :: Kgetfield n :: c ->
      out opGETGLOBALFIELD; slot_for_getglobal id; out_int n; emit c
  (* Default case *)
  | instr :: c ->
      emit_instr instr; emit c
@


<<function Emitcode.to_memory>>=
(* Emission to a memory block *)

let to_memory init_code fun_code =
  init();
  emit init_code;
  emit fun_code;
  let code = Meta.static_alloc !out_position in
  String.unsafe_blit !out_buffer 0 code 0 !out_position;
  let reloc = List.rev !reloc_info
  and code_size = !out_position in
  init();
  (code, code_size, reloc)
@


%-------------------------------------------------------------

<<./bytecomp/emitcode.ml>>=
<<copyright header>>

(* Generation of bytecode + relocation information *)

open Config
open Misc
open Asttypes
open Lambda
open Instruct
open Opcodes


<<type Emitcode.reloc_info>>

<<type Emitcode.compilation_unit>>

(* Format of a .cmo file:
     magic number (Config.cmo_magic_number)
     absolute offset of compilation unit descriptor
     block of relocatable bytecode
     compilation unit descriptor *)

(* Buffering of bytecode *)

let out_buffer = ref(String.create 1024)
and out_position = ref 0

<<function Emitcode.out_word>>

<<function Emitcode.out>>

<<function Emitcode.out_int>>

<<type Emitcode.label_definition>>

<<constant Emitcode.label_table>>

<<function Emitcode.extend_label_table>>

<<function Emitcode.backpatch>>
  !out_buffer.[pos+3] <- Char.unsafe_chr (displ asr 24)

<<function Emitcode.define_label>>
      (!label_table).(lbl) <- Label_defined !out_position

<<function Emitcode.out_label_with_orig>>

<<function Emitcode.out_label>>

<<constant Emitcode.reloc_info>>

<<function Emitcode.enter>>

let slot_for_literal sc =
  enter (Reloc_literal sc);
  out_int 0
and slot_for_getglobal id =
  enter (Reloc_getglobal id);
  out_int 0
and slot_for_setglobal id =
  enter (Reloc_setglobal id);
  out_int 0
and slot_for_c_prim name =
  enter (Reloc_primitive name);
  out_int 0

<<constant Emitcode.events>>

<<function Emitcode.record_event>>

<<function Emitcode.init>>

<<constant Emitcode.emit_instr>>

<<constant Emitcode.emit>>

<<function Emitcode.to_file>>

<<function Emitcode.to_memory>>
@


\subsection*{[[./bytecomp/bytelibrarian.mli]]}




%-------------------------------------------------------------

<<./bytecomp/bytelibrarian.mli>>=
<<copyright header>>

(* Build libraries of .cmo files *)

<<signature Bytelibrarian.create_archive>>

<<type Bytelibrarian.error>>

<<exception Bytelibrarian.Error>>

<<signature Bytelibrarian.report_error>>
@


\subsection*{[[./bytecomp/bytelibrarian.ml]]}

<<function Bytelibrarian.copy_compunit>>=
let copy_compunit ic oc compunit =
  seek_in ic compunit.cu_pos;
  compunit.cu_pos <- pos_out oc;
  compunit.cu_force_link <- !Clflags.link_everything;
  copy_file_chunk ic oc compunit.cu_codesize;
  if compunit.cu_debug > 0 then begin
    seek_in ic compunit.cu_debug;
    compunit.cu_debug <- pos_out oc;
    copy_file_chunk ic oc compunit.cu_debugsize
  end
@

<<function Bytelibrarian.copy_object_file>>=
let copy_object_file oc name =
  let file_name =
    try
      find_in_path !load_path name
    with Not_found ->
      raise(Error(File_not_found name)) in
  let ic = open_in_bin file_name in
  try
    let buffer = String.create (String.length cmo_magic_number) in
    really_input ic buffer 0 (String.length cmo_magic_number);
    if buffer = cmo_magic_number then begin
      let compunit_pos = input_binary_int ic in
      seek_in ic compunit_pos;
      let compunit = (input_value ic : compilation_unit) in
      copy_compunit ic oc compunit;
      close_in ic;
      [compunit]
    end else
    if buffer = cma_magic_number then begin
      let toc_pos = input_binary_int ic in
      seek_in ic toc_pos;
      let toc = (input_value ic : compilation_unit list) in
      List.iter (copy_compunit ic oc) toc;
      close_in ic;
      toc
    end else
      raise(Error(Not_an_object_file file_name))
  with x ->
    close_in ic;
    raise x
@

<<function Bytelibrarian.create_archive>>=
let create_archive file_list lib_name =
  let outchan = open_out_bin lib_name in
  try
    output_string outchan cma_magic_number;
    let ofs_pos_toc = pos_out outchan in
    output_binary_int outchan 0;
    let toc = List.flatten(List.map (copy_object_file outchan) file_list) in
    let pos_toc = pos_out outchan in
    output_value outchan toc;
    seek_out outchan ofs_pos_toc;
    output_binary_int outchan pos_toc;
    close_out outchan
  with x ->
    close_out outchan;
    remove_file lib_name;
    raise x
@


%-------------------------------------------------------------

<<./bytecomp/bytelibrarian.ml>>=
<<copyright header>>

(* Build libraries of .cmo files *)

open Misc
open Config
open Emitcode

<<type Bytelibrarian.error>>

<<exception Bytelibrarian.Error>>

<<function Bytelibrarian.copy_compunit>>

<<function Bytelibrarian.copy_object_file>>

<<function Bytelibrarian.create_archive>>

open Format

<<constant Bytelibrarian.report_error>>

@


\subsection*{[[./bytecomp/symtable.mli]]}

<<signature Symtable.init>>=
(* Functions for batch linking *)

val init: unit -> unit
@

<<signature Symtable.patch_object>>=
val patch_object: string -> (reloc_info * int) list -> unit
@

<<signature Symtable.require_primitive>>=
val require_primitive: string -> unit
@

<<signature Symtable.initial_global_table>>=
val initial_global_table: unit -> Obj.t array
@

<<signature Symtable.output_global_map>>=
val output_global_map: out_channel -> unit
@

<<signature Symtable.output_primitive_names>>=
val output_primitive_names: out_channel -> unit
@

<<signature Symtable.output_primitive_table>>=
val output_primitive_table: out_channel -> unit
@

<<signature Symtable.init_toplevel>>=
(* Functions for the toplevel *)

val init_toplevel: unit -> unit
@

<<signature Symtable.update_global_table>>=
val update_global_table: unit -> unit
@

<<signature Symtable.get_global_value>>=
val get_global_value: Ident.t -> Obj.t
@

<<signature Symtable.get_global_position>>=
val get_global_position: Ident.t -> int
@

<<signature Symtable.current_state>>=
val current_state: unit -> global_map
@

<<signature Symtable.restore_state>>=
val restore_state: global_map -> unit
@

<<signature Symtable.hide_additions>>=
val hide_additions: global_map -> unit
@

<<signature Symtable.filter_global_map>>=
val filter_global_map: (Ident.t -> bool) -> global_map -> global_map
@

<<type Symtable.error>>=
(* Error report *)

type error =
    Undefined_global of string
  | Unavailable_primitive of string
@

<<exception Symtable.Error>>=
exception Error of error
@

<<signature Symtable.report_error>>=
val report_error: error -> unit
@


%-------------------------------------------------------------

<<./bytecomp/symtable.mli>>=
<<copyright header>>

(* Assign locations and numbers to globals and primitives *)

open Emitcode

<<signature Symtable.init>>
<<signature Symtable.patch_object>>
<<signature Symtable.require_primitive>>
<<signature Symtable.initial_global_table>>
<<signature Symtable.output_global_map>>
<<signature Symtable.output_primitive_names>>
<<signature Symtable.output_primitive_table>>

<<signature Symtable.init_toplevel>>
<<signature Symtable.update_global_table>>
<<signature Symtable.get_global_value>>
<<signature Symtable.get_global_position>>

type global_map

<<signature Symtable.current_state>>
<<signature Symtable.restore_state>>
<<signature Symtable.hide_additions>>
<<signature Symtable.filter_global_map>>

<<type Symtable.error>>

<<exception Symtable.Error>>

<<signature Symtable.report_error>>
@


\subsection*{[[./bytecomp/symtable.ml]]}

<<type Symtable.numtable>>=
(* Tables for numbering objects *)

type 'a numtable =
  { num_cnt: int;               (* The next number *)
    num_tbl: ('a, int) Tbl.t } (* The table of already numbered objects *)
@

<<constant Symtable.empty_numtable>>=
let empty_numtable = { num_cnt = 0; num_tbl = Tbl.empty }
@

<<function Symtable.find_numtable>>=
let find_numtable nt key =
  Tbl.find key nt.num_tbl
@

<<function Symtable.enter_numtable>>=
let enter_numtable nt key =
  let n = !nt.num_cnt in
  nt := { num_cnt = n + 1; num_tbl = Tbl.add key n !nt.num_tbl };
  n
@

<<function Symtable.incr_numtable>>=
let incr_numtable nt =
  let n = !nt.num_cnt in
  nt := { num_cnt = n + 1; num_tbl = !nt.num_tbl };
  n
@

<<function Symtable.slot_for_getglobal>>=
let slot_for_getglobal id =
  try
    find_numtable !global_table id
  with Not_found ->
    raise(Error(Undefined_global(Ident.name id)))
@

<<function Symtable.slot_for_setglobal>>=
let slot_for_setglobal id =
  enter_numtable global_table id
@

<<function Symtable.slot_for_literal>>=
let slot_for_literal cst =
  let n = incr_numtable global_table in
  literal_table := (n, cst) :: !literal_table;
  n
@

<<constant Symtable.c_prim_table>>=
(* The C primitives *)

let c_prim_table = ref(empty_numtable : string numtable)
@

<<function Symtable.num_of_prim>>=
let num_of_prim name =
  try
    find_numtable !c_prim_table name
  with Not_found ->
    if !Clflags.custom_runtime
    then enter_numtable c_prim_table name
    else raise(Error(Unavailable_primitive name))
@

<<function Symtable.require_primitive>>=
let require_primitive name =
  if name.[0] <> '%' then begin num_of_prim name; () end
@

<<function Symtable.all_primitives>>=
let all_primitives () =
  let prim = Array.create !c_prim_table.num_cnt "" in
  Tbl.iter (fun name number -> prim.(number) <- name) !c_prim_table.num_tbl;
  prim
@

<<function Symtable.output_primitive_names>>=
let output_primitive_names outchan =
  let prim = all_primitives() in
  for i = 0 to Array.length prim - 1 do
    output_string outchan prim.(i); output_char outchan '\000'
  done
@

<<function Symtable.output_primitive_table>>=
let output_primitive_table outchan =
  let prim = all_primitives() in
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "extern long %s();\n" prim.(i)
  done;
  fprintf outchan "typedef long (*primitive)();\n";
  fprintf outchan "primitive cprim[] = {\n";
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "  %s,\n" prim.(i)
  done;
  fprintf outchan "  (primitive) 0 };\n";
  fprintf outchan "char * names_of_cprim[] = {\n";
  for i = 0 to Array.length prim - 1 do
    fprintf outchan "  \"%s\",\n" prim.(i)
  done;
  fprintf outchan "  (char *) 0 };\n"
@

<<function Symtable.init>>=
(* Initialization for batch linking *)

let init () =
  (* Enter the predefined exceptions *)
  Array.iter 
    (fun name -> 
      let id =
        try List.assoc name Predef.builtin_values
        with Not_found -> fatal_error "Symtable.init" in
      let c = slot_for_setglobal id in
      let cst = Const_block(0, [Const_base(Const_string name)]) in
      literal_table := (c, cst) :: !literal_table)
    Runtimedef.builtin_exceptions;
  (* Enter the known C primitives *)
  Array.iter (fun x -> enter_numtable c_prim_table x; ())
             Runtimedef.builtin_primitives
@

<<function Symtable.patch_int>>=
(* Must use the unsafe String.set here because the block may be
   a "fake" string as returned by Meta.static_alloc. *)

let patch_int buff pos n =
  String.unsafe_set buff pos (Char.unsafe_chr n);
  String.unsafe_set buff (pos + 1) (Char.unsafe_chr (n asr 8));
  String.unsafe_set buff (pos + 2) (Char.unsafe_chr (n asr 16));
  String.unsafe_set buff (pos + 3) (Char.unsafe_chr (n asr 24))
@

<<function Symtable.patch_object>>=
let patch_object buff patchlist = 
  List.iter
    (function
        (Reloc_literal sc, pos) ->
          patch_int buff pos (slot_for_literal sc)
      | (Reloc_getglobal id, pos) ->
          patch_int buff pos (slot_for_getglobal id)
      | (Reloc_setglobal id, pos) ->
          patch_int buff pos (slot_for_setglobal id)
      | (Reloc_primitive name, pos) ->
          patch_int buff pos (num_of_prim name))
    patchlist
@

<<constant Symtable.transl_const>>=
(* Translate structured constants *)

let rec transl_const = function
    Const_base(Const_int i) -> Obj.repr i
  | Const_base(Const_char c) -> Obj.repr c
  | Const_base(Const_string s) -> Obj.repr s
  | Const_base(Const_float f) -> Obj.repr(float_of_string f)
  | Const_pointer i -> Obj.repr i
  | Const_block(tag, fields) ->
      let block = Obj.new_block tag (List.length fields) in
      let pos = ref 0 in
      List.iter
        (fun c -> Obj.set_field block !pos (transl_const c); incr pos)
        fields;
      block
  | Const_float_array fields ->
      transl_const
        (Const_block(0, List.map (fun f -> Const_base(Const_float f)) fields))
@

<<function Symtable.initial_global_table>>=
(* Build the initial table of globals *)

let initial_global_table () =
  let glob = Array.create !global_table.num_cnt (Obj.repr 0) in
  List.iter
    (fun (slot, cst) -> glob.(slot) <- transl_const cst)
    !literal_table;
  literal_table := [];
  glob
@

<<function Symtable.output_global_map>>=
(* Save the table of globals *)

let output_global_map oc =
  output_value oc !global_table
@

<<function Symtable.update_global_table>>=
(* Update the in-core table of globals *)

let update_global_table () =
  let ng = !global_table.num_cnt in
  if ng > Array.length(Meta.global_data()) then Meta.realloc_global_data ng;
  let glob = Meta.global_data() in
  List.iter
    (fun (slot, cst) -> glob.(slot) <- transl_const cst)
    !literal_table;
  literal_table := []
@

<<function Symtable.init_toplevel>>=
(* Initialize the linker for toplevel use *)

let init_toplevel () =
  (* Read back the known global symbols from the executable file *)
  let ic = open_in_bin Sys.argv.(0) in
  let pos_trailer =
    in_channel_length ic - 20 - String.length Config.exec_magic_number in
  seek_in ic pos_trailer;
  let code_size = input_binary_int ic in
  let prim_size = input_binary_int ic in
  let data_size = input_binary_int ic in
  let symbol_size = input_binary_int ic in
  let debug_size = input_binary_int ic in
  seek_in ic (pos_trailer - debug_size - symbol_size);
  global_table := (input_value ic : Ident.t numtable);
  close_in ic;
  (* Enter the known C primitives *)
  Array.iter (fun x -> enter_numtable c_prim_table x; ())
             (Meta.available_primitives())
@

<<function Symtable.get_global_position>>=
(* @Scheck: used by the debugger *)
let get_global_position id = slot_for_getglobal id
@

<<function Symtable.get_global_value>>=
let get_global_value id =
@

<<type Symtable.global_map>>=
(* Save and restore the current state *)

type global_map = Ident.t numtable
@

<<function Symtable.current_state>>=
let current_state () = !global_table
@

<<function Symtable.restore_state>>=
let restore_state st = global_table := st
@

<<function Symtable.hide_additions>>=
(* @Scheck: used by dynlink *)
let hide_additions st =
  if st.num_cnt > !global_table.num_cnt then
    fatal_error "Symtable.hide_additions";
  global_table :=
    { num_cnt = !global_table.num_cnt;
      num_tbl = st.num_tbl }
@

<<function Symtable.filter_global_map>>=
(* "Filter" the global map according to some predicate.
   Used to expunge the global map for the toplevel. *)

let filter_global_map p gmap =
  let newtbl = ref Tbl.empty in
  Tbl.iter
    (fun id num -> if p id then newtbl := Tbl.add id num !newtbl)
    gmap.num_tbl;
  {num_cnt = gmap.num_cnt; num_tbl = !newtbl}
@

<<constant Symtable.report_error>>=
let report_error = function
    Undefined_global s ->
      print_string "Reference to undefined global `"; print_string s;
      print_string "'"
  | Unavailable_primitive s ->
      print_string "The external function `"; print_string s;
      print_string "' is not available"
@


%-------------------------------------------------------------

<<./bytecomp/symtable.ml>>=
<<copyright header>>

(* To assign numbers to globals and primitives *)

open Misc
open Asttypes
open Lambda
open Emitcode


<<type Symtable.error>>

<<exception Symtable.Error>>

<<type Symtable.numtable>>

<<constant Symtable.empty_numtable>>

<<function Symtable.find_numtable>>

<<function Symtable.enter_numtable>>

<<function Symtable.incr_numtable>>

(* Global variables *)

let global_table = ref(empty_numtable : Ident.t numtable)
and literal_table = ref([] : (int * structured_constant) list)

<<function Symtable.slot_for_getglobal>>

<<function Symtable.slot_for_setglobal>>

<<function Symtable.slot_for_literal>>

<<constant Symtable.c_prim_table>>

<<function Symtable.num_of_prim>>

<<function Symtable.require_primitive>>

<<function Symtable.all_primitives>>

<<function Symtable.output_primitive_names>>

open Printf

<<function Symtable.output_primitive_table>>

<<function Symtable.init>>

(* Relocate a block of object bytecode *)

<<function Symtable.patch_int>>

<<function Symtable.patch_object>>

<<constant Symtable.transl_const>>

<<function Symtable.initial_global_table>>

<<function Symtable.output_global_map>>

(* Functions for toplevel use *)

<<function Symtable.update_global_table>>

<<function Symtable.init_toplevel>>

(* Find the value of a global identifier *)

<<function Symtable.get_global_position>>

<<function Symtable.get_global_value>>
  (Meta.global_data()).(slot_for_getglobal id)

<<type Symtable.global_map>>

<<function Symtable.current_state>>

<<function Symtable.restore_state>>

<<function Symtable.hide_additions>>

<<function Symtable.filter_global_map>>

(* Error report *)

open Format

<<constant Symtable.report_error>>
@


\subsection*{[[./bytecomp/bytelink.mli]]}





%-------------------------------------------------------------

<<./bytecomp/bytelink.mli>>=
<<copyright header>>

<<signature Bytelink.link>>

<<signature Bytelink.check_consistency>>

<<type Bytelink.error>>

<<exception Bytelink.Error>>

<<signature Bytelink.report_error>>
@


\subsection*{[[./bytecomp/bytelink.ml]]}

<<type Bytelink.link_action>>=
type link_action =
    Link_object of string * compilation_unit
      (* Name of .cmo file and descriptor of the unit *)
  | Link_archive of string * compilation_unit list
      (* Name of .cma file and descriptors of the units to be linked. *)
@

<<constant Bytelink.missing_globals>>=
let missing_globals = ref IdentSet.empty
@

<<function Bytelink.is_required>>=
let is_required (rel, pos) =
  match rel with
    Reloc_setglobal id ->
      IdentSet.mem id !missing_globals
  | _ -> false
@

<<function Bytelink.add_required>>=
let add_required (rel, pos) =
  match rel with
    Reloc_getglobal id ->
      missing_globals := IdentSet.add id !missing_globals
  | _ -> ()
@

<<function Bytelink.remove_required>>=
let remove_required (rel, pos) =
  match rel with
    Reloc_setglobal id ->
      missing_globals := IdentSet.remove id !missing_globals
  | _ -> ()
@

<<function Bytelink.scan_file>>=
let scan_file obj_name tolink =
  let file_name =
    try
      find_in_path !load_path obj_name
    with Not_found ->
      raise(Error(File_not_found obj_name)) in
  let ic = open_in_bin file_name in
  try
    let buffer = String.create (String.length cmo_magic_number) in
    really_input ic buffer 0 (String.length cmo_magic_number);
    if buffer = cmo_magic_number then begin
      (* This is a .cmo file. It must be linked in any case.
         Read the relocation information to see which modules it
         requires. *)
      let compunit_pos = input_binary_int ic in  (* Go to descriptor *)
      seek_in ic compunit_pos;
      let compunit = (input_value ic : compilation_unit) in
      close_in ic;
      List.iter add_required compunit.cu_reloc;
      Link_object(file_name, compunit) :: tolink
    end
    else if buffer = cma_magic_number then begin
      (* This is an archive file. Each unit contained in it will be linked
         in only if needed. *)
      let pos_toc = input_binary_int ic in    (* Go to table of contents *)
      seek_in ic pos_toc;
      let toc = (input_value ic : compilation_unit list) in
      close_in ic;
      let required =
        List.fold_right
          (fun compunit reqd ->
            if compunit.cu_force_link
            or !Clflags.link_everything
            or List.exists is_required compunit.cu_reloc
            then begin
              List.iter remove_required compunit.cu_reloc;
              List.iter add_required compunit.cu_reloc;
              compunit :: reqd
            end else
              reqd)
          toc [] in
      Link_archive(file_name, required) :: tolink
    end
    else raise(Error(Not_an_object_file file_name))
  with x ->
    close_in ic; raise x
@

<<constant Bytelink.debug_info>>=
(* Second pass: link in the required units *)

let debug_info = ref ([] : debug_event list list)
@

<<constant Bytelink.crc_interfaces>>=
(* Consistency check between interfaces *)

let crc_interfaces =
  (Hashtbl.create 17 : (string, string * Digest.t) Hashtbl.t)
@

<<function Bytelink.check_consistency>>=
let check_consistency file_name cu =
  List.iter
    (fun (name, crc) ->
      if name = cu.cu_name then begin
        Hashtbl.add crc_interfaces name (file_name, crc)
      end else begin
        try
          let (auth_name, auth_crc) = Hashtbl.find crc_interfaces name in
          if crc <> auth_crc then
            raise(Error(Inconsistent_import(name, file_name, auth_name)))
        with Not_found ->
          (* Can only happen for unit for which only a .cmi file was used,
             but no .cmo is provided *)
          Hashtbl.add crc_interfaces name (file_name, crc)
      end)
    cu.cu_imports
@

<<constant Bytelink.debug_info (./bytecomp/bytelink.ml)>>=
(* Relocate and record compilation events *)

let debug_info = ref ([] : debug_event list list)
@

<<function Bytelink.record_events>>=
let record_events orig evl =
  if evl <> [] then begin
    List.iter
      (fun ev ->
         ev.ev_pos <- orig + ev.ev_pos;
         begin match ev.ev_repr with
           Event_parent repr -> repr := ev.ev_pos
         | _                 -> ()
         end)
      evl;
    debug_info := evl :: !debug_info
  end
@

<<function Bytelink.link_compunit>>=
(* Link in a compilation unit *)

let link_compunit output_fun currpos_fun inchan file_name compunit =
  check_consistency file_name compunit;
  seek_in inchan compunit.cu_pos;
  let code_block = String.create compunit.cu_codesize in
  really_input inchan code_block 0 compunit.cu_codesize;
  Symtable.patch_object code_block compunit.cu_reloc;
  if !Clflags.debug && compunit.cu_debug > 0 then begin
    seek_in inchan compunit.cu_debug;
    record_events (currpos_fun()) (input_value inchan : debug_event list)
  end;
  output_fun code_block;
  if !Clflags.link_everything then
    List.iter Symtable.require_primitive compunit.cu_primitives
@

<<function Bytelink.link_object>>=
(* Link in a .cmo file *)

let link_object output_fun currpos_fun file_name compunit =
  let inchan = open_in_bin file_name in
  try
    link_compunit output_fun currpos_fun inchan file_name compunit;
    close_in inchan
  with
    Symtable.Error msg ->
      close_in inchan; raise(Error(Symbol_error(file_name, msg)))
  | x ->
      close_in inchan; raise x
@

<<function Bytelink.link_archive>>=
(* Link in a .cma file *)

let link_archive output_fun currpos_fun file_name units_required =
  let inchan = open_in_bin file_name in
  try
    List.iter
      (fun cu ->
         let name = file_name ^ "(" ^ cu.cu_name ^ ")" in
         try
           link_compunit output_fun currpos_fun inchan name cu
         with Symtable.Error msg ->
           raise(Error(Symbol_error(name, msg))))
      units_required;
    close_in inchan
  with x -> close_in inchan; raise x
@

<<function Bytelink.link_file>>=
(* Link in a .cmo or .cma file *)

let link_file output_fun currpos_fun = function
    Link_object(file_name, unit) ->
      link_object output_fun currpos_fun file_name unit
  | Link_archive(file_name, units) ->
      link_archive output_fun currpos_fun file_name units
@

<<function Bytelink.link_bytecode>>=
(* Create a bytecode executable file *)

let link_bytecode objfiles exec_name copy_header =
  let tolink = List.fold_right scan_file objfiles [] in
  if Sys.os_type = "MacOS" then begin
    (* Create it as a text file for bytecode scripts *)
    let c = open_out_gen [Open_wronly; Open_creat] 0o777 exec_name in
    close_out c
  end;
  let outchan = open_out_gen [Open_wronly; Open_trunc; Open_creat; Open_binary]
                             0o777 exec_name in
  try
    (* Copy the header *)
    if copy_header then begin
      try
        let inchan = open_in_bin (find_in_path !load_path "camlheader") in
        copy_file inchan outchan;
        close_in inchan
      with Not_found | Sys_error _ -> ()
    end;
    (* The bytecode *)
    let pos1 = pos_out outchan in
    Symtable.init();
    Hashtbl.clear crc_interfaces;
    let output_fun = output_string outchan
    and currpos_fun () = pos_out outchan - pos1 in
    List.iter (link_file output_fun currpos_fun) tolink;
    (* The final STOP instruction *)
    output_byte outchan Opcodes.opSTOP;
    output_byte outchan 0; output_byte outchan 0; output_byte outchan 0;
    (* The names of all primitives *)
    let pos2 = pos_out outchan in
    Symtable.output_primitive_names outchan;
    (* The table of global data *)
    let pos3 = pos_out outchan in
    output_value outchan (Symtable.initial_global_table());
    (* The map of global identifiers *)
    let pos4 = pos_out outchan in
    Symtable.output_global_map outchan;
    (* Debug info *)
    let pos5 = pos_out outchan in
    if !Clflags.debug then output_value outchan !debug_info;
    (* The trailer *)
    let pos6 = pos_out outchan in
    output_binary_int outchan (pos2 - pos1);
    output_binary_int outchan (pos3 - pos2);
    output_binary_int outchan (pos4 - pos3);
    output_binary_int outchan (pos5 - pos4);
    output_binary_int outchan (pos6 - pos5);
    output_string outchan exec_magic_number;
    close_out outchan
  with x ->
    close_out outchan;
    remove_file exec_name;
    raise x
@

<<constant Bytelink.output_code_string_counter>>=
(* Output a string as a C array of unsigned ints *)

let output_code_string_counter = ref 0
@

<<function Bytelink.output_code_string>>=
let output_code_string outchan code =
  let pos = ref 0 in
  let len = String.length code in
  while !pos < len do
    let c1 = Char.code(code.[!pos]) in
    let c2 = Char.code(code.[!pos + 1]) in
    let c3 = Char.code(code.[!pos + 2]) in
    let c4 = Char.code(code.[!pos + 3]) in
    pos := !pos + 4;
    Printf.fprintf outchan "0x%02x%02x%02x%02x, " c4 c3 c2 c1;
    incr output_code_string_counter;
    if !output_code_string_counter >= 6 then begin
      output_char outchan '\n';
      output_code_string_counter := 0
    end
  done
@

<<function Bytelink.output_data_string>>=
(* Output a string as a C string *)

let output_data_string outchan data =
  let counter = ref 0 in
  output_string outchan "\"";
  for i = 0 to String.length data - 1 do
    Printf.fprintf outchan "\\%03o" (Char.code(data.[i]));
    incr counter;
    if !counter >= 16 then begin
      output_string outchan "\\\n";
      counter := 0
    end
  done;
  output_string outchan "\";\n\n"
@

<<function Bytelink.link_bytecode_as_c>>=
(* Output a bytecode executable as a C file *)

let link_bytecode_as_c objfiles outfile =
  let tolink = List.fold_right scan_file objfiles [] in
  let outchan = open_out outfile in
  try
    (* The bytecode *)
    output_string outchan "static int caml_code[] = {\n";
    Symtable.init();
    Hashtbl.clear crc_interfaces;
    let output_fun = output_code_string outchan
    and currpos_fun () = fatal_error "Bytelink.link_bytecode_as_c" in
    List.iter (link_file output_fun currpos_fun) tolink;
    (* The final STOP instruction *)
    Printf.fprintf outchan "\n0x%x};\n\n" Opcodes.opSTOP;
    (* The table of global data *)
    output_string outchan "static char * caml_data =\n";
    output_data_string outchan
      (Marshal.to_string (Symtable.initial_global_table()) []);
    (* The table of primitives *)
    Symtable.output_primitive_table outchan;
    (* The entry point *)
    output_string outchan "\n
void caml_startup(argv)
        char ** argv;
{
  caml_startup_code(caml_code, sizeof(caml_code), caml_data, argv);
}\n";
    close_out outchan
  with x ->
    close_out outchan;
    raise x
@

<<function Bytelink.extract>>=
(* Build a custom runtime *)

let rec extract suffix l =
  match l with
  | [] -> []
  | h::t when Filename.check_suffix h suffix -> h :: (extract suffix t)
  | h::t -> extract suffix t
@

<<function Bytelink.build_custom_runtime>>=
let build_custom_runtime prim_name exec_name =
  let libname = "libcamlrun" ^ ext_lib in
  let runtime_lib =
    try
      find_in_path !load_path libname
    with Not_found ->
      raise(Error(File_not_found libname)) in
  match Sys.os_type with
    "Unix" ->
      Ccomp.command
       (Printf.sprintf
          "%s -o %s -I%s %s %s -L%s %s %s %s"
          Config.bytecomp_c_compiler
          exec_name
          Config.standard_library
          (String.concat " " (List.rev !Clflags.ccopts))
          prim_name
          Config.standard_library
          (String.concat " " (List.rev !Clflags.ccobjs))
          runtime_lib
          Config.c_libraries)
  | _ ->
    fatal_error "Bytelink.build_custom_runtime"
@

<<function Bytelink.append_bytecode_and_cleanup>>=
let append_bytecode_and_cleanup bytecode_name exec_name prim_name =
  match Sys.os_type with
  | _ ->
      let oc =
        open_out_gen [Open_wronly; Open_append; Open_binary] 0
                                 !Clflags.exec_name in
      let ic = open_in_bin bytecode_name in
      copy_file ic oc;
      close_in ic;
      close_out oc;
      remove_file bytecode_name;
      remove_file prim_name
@

<<function Bytelink.fix_exec_name>>=
(* Fix the name of the output file, if the C compiler changes it behind
   our back. *)

let fix_exec_name name =
  match Sys.os_type with
  | _ -> name
@

<<function Bytelink.link>>=
(* Main entry point (build a custom runtime if needed) *)

let link objfiles =
  let objfiles = "stdlib.cma" :: (objfiles @ ["std_exit.cmo"]) in
  if not !Clflags.custom_runtime then
    link_bytecode objfiles !Clflags.exec_name true
  else if not !Clflags.output_c_object then begin
    let bytecode_name = Filename.temp_file "camlcode" "" in
    let prim_name = Filename.temp_file "camlprim" ".c" in
    try
      link_bytecode objfiles bytecode_name false;
      let poc = open_out prim_name in
      Symtable.output_primitive_table poc;
      close_out poc;
      let exec_name = fix_exec_name !Clflags.exec_name in
      if build_custom_runtime prim_name exec_name <> 0
      then raise(Error Custom_runtime);
      append_bytecode_and_cleanup bytecode_name exec_name prim_name
    with x ->
      remove_file bytecode_name;
      remove_file prim_name;
      raise x
  end else begin
    let c_file =
      Filename.chop_suffix !Clflags.object_name Config.ext_obj ^ ".c" in
    if Sys.file_exists c_file then raise(Error(File_exists c_file));
    try
      link_bytecode_as_c objfiles c_file;
      if Ccomp.compile_file_bytecode c_file <> 0
      then raise(Error Custom_runtime);
      remove_file c_file
    with x ->
      remove_file c_file;
      remove_file !Clflags.object_name;
      raise x
  end
@


%-------------------------------------------------------------

<<./bytecomp/bytelink.ml>>=
<<copyright header>>

(* Link a set of .cmo files and produce a bytecode executable. *)

open Sys
open Misc
open Config
open Instruct
open Emitcode

<<type Bytelink.error>>

<<exception Bytelink.Error>>

<<type Bytelink.link_action>>

(* First pass: determine which units are needed *)

module IdentSet = Set

<<constant Bytelink.missing_globals>>

<<function Bytelink.is_required>>

<<function Bytelink.add_required>>

<<function Bytelink.remove_required>>

<<function Bytelink.scan_file>>

<<constant Bytelink.debug_info>>

<<constant Bytelink.crc_interfaces>>

<<function Bytelink.check_consistency>>

<<constant Bytelink.debug_info (./bytecomp/bytelink.ml)>>

<<function Bytelink.record_events>>

<<function Bytelink.link_compunit>>

<<function Bytelink.link_object>>

<<function Bytelink.link_archive>>

<<function Bytelink.link_file>>

<<function Bytelink.link_bytecode>>

<<constant Bytelink.output_code_string_counter>>

<<function Bytelink.output_code_string>>

<<function Bytelink.output_data_string>>

<<function Bytelink.link_bytecode_as_c>>

<<function Bytelink.extract>>
;;

<<function Bytelink.build_custom_runtime>>

<<function Bytelink.append_bytecode_and_cleanup>>

<<function Bytelink.fix_exec_name>>

<<function Bytelink.link>>

(* Error report *)

open Format

<<constant Bytelink.report_error>>
@


\section{[[./driver/]]}

\subsection*{[[./driver/compile.mli]]}


%-------------------------------------------------------------

<<./driver/compile.mli>>=
<<copyright header>>

(* Compile a .ml or .mli file *)

<<signature Compile.interface>>
<<signature Compile.implementation>>
<<signature Compile.c_file>>

<<signature Compile.initial_env>>
<<signature Compile.init_path>>
@


\subsection*{[[./driver/compile.ml]]}

<<function Compile.init_path>>=
(* Initialize the search path.
   The current directory is always searched first,
   then the directories specified with the -I option (in command-line order),
   then the standard library directory. *)

let init_path () =
  let dirs =
    if !Clflags.thread_safe then
     Filename.concat Config.standard_library "threads" :: !Clflags.include_dirs
    else
     !Clflags.include_dirs in
  load_path := "" :: List.rev (Config.standard_library :: dirs);
  Env.reset_cache()
@

<<function Compile.initial_env>>=
(* Return the initial environment in which compilation proceeds. *)

let initial_env () =
  try
    if !Clflags.nopervasives
    then Env.initial
    else Env.open_pers_signature "Pervasives" Env.initial
  with Not_found ->
    fatal_error "cannot open Pervasives.cmi"
@

<<function Compile.preprocess>>=
(* Optionally preprocess a source file *)

let preprocess sourcefile tmpfile =
  match !Clflags.preprocessor with
    None -> sourcefile
  | Some pp ->
      let comm = pp ^ " " ^ sourcefile ^ " > " ^ tmpfile in
      if Ccomp.command comm <> 0 then begin
        Printf.eprintf "Preprocessing error\n";
        flush stderr;
        exit 2
      end;
      tmpfile
@

<<function Compile.remove_preprocessed>>=
let remove_preprocessed inputfile =
  match !Clflags.preprocessor with
    None -> ()
  | Some _ -> remove_file inputfile
@

<<exception Compile.Outdated_version>>=
(* Parse a file or get a dumped syntax tree in it *)

exception Outdated_version
@

<<function Compile.parse_file>>=
let parse_file inputfile parse_fun ast_magic =
  let ic = open_in_bin inputfile in
  let is_ast_file =
    try
      let buffer = String.create (String.length ast_magic) in
      really_input ic buffer 0 (String.length ast_magic);
      if buffer = ast_magic then true
      else if String.sub buffer 0 9 = String.sub ast_magic 0 9 then
        raise Outdated_version
      else false
    with
      Outdated_version ->
        fatal_error "Ocaml and preprocessor have incompatible versions"
    | _ -> false
  in
  let ast =
    try
      if is_ast_file then begin
        Location.input_name := input_value ic;
        input_value ic
      end else begin
        seek_in ic 0;
        Location.input_name := inputfile;
        parse_fun (Lexing.from_channel ic)
      end
    with x -> close_in ic; raise x
  in
  close_in ic;
  ast
@


<<function Compile.print_if>>=
(* Compile a .ml file *)

let print_if flag printer arg =
  if !flag then begin printer arg; print_newline() end;
  arg
@


<<function Compile.c_file>>=
let c_file name =
  if Ccomp.compile_file_bytecode name <> 0 then exit 2
@


%-------------------------------------------------------------

<<./driver/compile.ml>>=
<<copyright header>>

(* The batch compiler *)

open Misc
open Config
open Format
open Typedtree

<<function Compile.init_path>>

<<function Compile.initial_env>>

<<function Compile.preprocess>>

<<function Compile.remove_preprocessed>>

<<exception Compile.Outdated_version>>

<<function Compile.parse_file>>

<<function Compile.interface>>

<<function Compile.print_if>>

<<function Compile.implementation>>

<<function Compile.c_file>>
@


\subsection*{[[./driver/errors.mli]]}



%-------------------------------------------------------------

<<./driver/errors.mli>>=
<<copyright header>>

<<signature Errors.report_error>>
@


\subsection*{[[./driver/errors.ml]]}

%-------------------------------------------------------------

<<./driver/errors.ml>>=
<<copyright header>>

(* Error report *)

open Format
open Location

<<function Errors.report_error>>
@


\subsection*{[[./driver/main.ml]]}


%-------------------------------------------------------------

<<./driver/main.ml>>=
<<copyright header>>

open Config
open Clflags

<<function Main.process_interface_file>>

<<function Main.process_implementation_file>>

<<function Main.process_file>>

<<function Main.print_version_number>>

<<constant Main.usage>>

<<function Main.main>>

<<toplevel Main._1>>
@
